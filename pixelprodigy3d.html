<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PixelProdigy Universe - Multi-Workspace Studio</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      height: 100vh;
    }

    #container {
      display: grid;
      grid-template-columns: 250px 1fr;
      grid-template-rows: 60px 1fr 40px;
      height: 100vh;
    }

    #header {
      grid-column: 1 / -1;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 20px;
    }

    #header h1 {
      font-size: 24px;
      font-weight: 600;
    }

    .workspace-tabs {
      display: flex;
      gap: 4px;
      flex: 1;
    }

    .workspace-tab {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: rgba(255, 255, 255, 0.7);
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 6px 6px 0 0;
      transition: all 0.2s;
      font-size: 13px;
      font-weight: 500;
    }

    .workspace-tab:hover {
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
    }

    .workspace-tab.active {
      background: #1a1a1a;
      color: #fff;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
    }
    
    /* Dropdown Menu for SkyRelics */
    .tab-dropdown {
      position: relative;
      display: inline-block;
    }
    
    .dropdown-trigger {
      cursor: pointer;
    }
    
    .dropdown-content {
      display: none;
      position: absolute;
      background: #1a1a1a;
      min-width: 200px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      border-radius: 4px;
      margin-top: 2px;
      max-height: 500px;
      overflow-y: auto;
    }
    
    .dropdown-content button {
      background: transparent;
      color: rgba(255, 255, 255, 0.8);
      padding: 10px 16px;
      text-align: left;
      border: none;
      width: 100%;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.2s;
      border-radius: 0;
    }
    
    .dropdown-content button:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }
    
    .dropdown-content button:first-child {
      border-radius: 4px 4px 0 0;
    }
    
    .dropdown-content button:last-child {
      border-radius: 0 0 4px 4px;
    }
    
    .tab-dropdown:hover .dropdown-content {
      display: block;
    }

    #sidebar {
      background: #1a1a1a;
      padding: 20px;
      overflow-y: auto;
      border-right: 2px solid #333;
      position: relative;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    /* Collapsed state - show only edge */
    #sidebar.collapsed {
      transform: translateX(-280px);
      opacity: 0.3;
    }
    
    /* Hover effect when collapsed */
    #sidebar.collapsed:hover {
      transform: translateX(0);
      opacity: 1;
    }
    
    /* Toggle button for sidebar */
    .sidebar-toggle {
      position: absolute;
      right: -40px;
      top: 50%;
      transform: translateY(-50%);
      width: 40px;
      height: 80px;
      background: linear-gradient(90deg, #1a1a1a 0%, rgba(26,26,26,0.95) 100%);
      border: 2px solid #333;
      border-left: none;
      border-radius: 0 8px 8px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: #667eea;
      transition: all 0.3s ease;
      z-index: 10;
    }
    
    .sidebar-toggle:hover {
      background: linear-gradient(90deg, #2a2a2a 0%, rgba(42,42,42,0.95) 100%);
      right: -42px;
      color: #fff;
    }
    
    #sidebar.collapsed .sidebar-toggle {
      transform: translateY(-50%) rotate(180deg);
    }

    #viewport {
      background: #0f0f0f;
      position: relative;
      overflow: hidden;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
    }

    #footer {
      grid-column: 1 / -1;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      border-top: 2px solid #333;
      font-size: 13px;
      color: #888;
    }

    .section {
      margin-bottom: 25px;
    }

    .section-title {
      font-size: 12px;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 12px;
      font-weight: 600;
      letter-spacing: 1px;
    }

    .tool-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .tool-btn {
      background: #2a2a2a;
      border: 2px solid #3a3a3a;
      color: #fff;
      padding: 12px 8px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
      font-size: 13px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .tool-btn:hover {
      background: #3a3a3a;
      border-color: #667eea;
    }

    .tool-btn.active {
      background: #667eea;
      border-color: #764ba2;
      box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
    }

    .tool-icon {
      font-size: 24px;
    }

    .slider-control {
      margin-bottom: 15px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 12px;
      color: #aaa;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      background: #2a2a2a;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #667eea;
      cursor: pointer;
      border-radius: 50%;
      transition: all 0.2s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #764ba2;
      transform: scale(1.2);
    }

    .primitive-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #667eea;
    }
    
    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      }
      50% {
        box-shadow: 0 0 40px rgba(0, 255, 255, 0.8), 0 0 60px rgba(138, 43, 226, 0.6);
      }
    }
    
    /* WordWeaver Document Canvas Styles */
    .doc-mode-selector {
      transition: all 0.3s ease;
    }
    
    .doc-mode-selector:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    .shape-selector, .material-selector, .font-selector, .doc-template-btn,
    .weight-selector, .style-selector, .align-selector {
      transition: all 0.2s ease;
    }
    
    .shape-selector:hover, .material-selector:hover, .font-selector:hover,
    .doc-template-btn:hover, .weight-selector:hover, .style-selector:hover,
    .align-selector:hover {
      transform: translateY(-2px);
      box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
    }
    
    #blog-content::-webkit-scrollbar,
    #pdf-paragraph::-webkit-scrollbar,
    #saved-docs-list::-webkit-scrollbar {
      width: 8px;
    }
    
    #blog-content::-webkit-scrollbar-track,
    #pdf-paragraph::-webkit-scrollbar-track,
    #saved-docs-list::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }
    
    #blog-content::-webkit-scrollbar-thumb,
    #pdf-paragraph::-webkit-scrollbar-thumb,
    #saved-docs-list::-webkit-scrollbar-thumb {
      background: rgba(102, 126, 234, 0.5);
      border-radius: 4px;
    }
    
    #blog-content::-webkit-scrollbar-thumb:hover,
    #pdf-paragraph::-webkit-scrollbar-thumb:hover,
    #saved-docs-list::-webkit-scrollbar-thumb:hover {
      background: rgba(102, 126, 234, 0.7);
    }
    
    /* Saved documents list items */
    .saved-doc-item {
      padding: 8px;
      background: rgba(102, 126, 234, 0.1);
      border-radius: 4px;
      font-size: 11px;
      color: #e0e0e0;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .saved-doc-item:hover {
      background: rgba(102, 126, 234, 0.2);
      transform: translateX(4px);
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="header">
      <h1>‚ö° PixelProdigy Universe</h1>
      <div class="workspace-tabs">
        <button class="workspace-tab" onclick="switchDimensionUI('navigator', this)" data-dimension="navigator" title="3D Dimension Navigator">üéØ Navigator</button>
        
        <!-- SkyRelics Dropdown Menu -->
        <div class="tab-dropdown">
          <button class="workspace-tab active dropdown-trigger" data-dimension="skyrelics">üè∞ SkyRelics ‚ñº</button>
          <div class="dropdown-content">
            <button onclick="switchDimensionUI('skyrelics', this)" data-dimension="skyrelics">üè∞ Main Plaza</button>
            <button onclick="switchDimensionUI('skyrelics_forge', this)" data-dimension="skyrelics_forge">üî• The Forge</button>
            <button onclick="switchDimensionUI('skyrelics_sanctuary', this)" data-dimension="skyrelics_sanctuary">üíé Crystal Sanctuary</button>
            <button onclick="switchDimensionUI('skyrelics_observatory', this)" data-dimension="skyrelics_observatory">ÔøΩ Sky Observatory</button>
            <hr style="border-color: rgba(255,255,255,0.2); margin: 4px 0;">
            <button onclick="switchDimensionUI('skyrelics_mirror', this)" data-dimension="skyrelics_mirror">ü™û Mirror Dimension</button>
            <button onclick="switchDimensionUI('skyrelics_desert', this)" data-dimension="skyrelics_desert">üèúÔ∏è Desert Oasis</button>
            <button onclick="switchDimensionUI('skyrelics_tundra', this)" data-dimension="skyrelics_tundra">‚ùÑÔ∏è Frozen Tundra</button>
            <button onclick="switchDimensionUI('skyrelics_monsoon', this)" data-dimension="skyrelics_monsoon">üåßÔ∏è Monsoon Temple</button>
            <button onclick="switchDimensionUI('skyrelics_mountain', this)" data-dimension="skyrelics_mountain">‚õ∞Ô∏è Mountain Peak</button>
            <button onclick="switchDimensionUI('skyrelics_space', this)" data-dimension="skyrelics_space">üåå Deep Space</button>
            <button onclick="switchDimensionUI('skyrelics_underwater', this)" data-dimension="skyrelics_underwater">üê† Coral Reef</button>
            <button onclick="switchDimensionUI('skyrelics_volcanic', this)" data-dimension="skyrelics_volcanic">üåã Volcanic Forge</button>
            <button onclick="switchDimensionUI('skyrelics_crystal_cave', this)" data-dimension="skyrelics_crystal_cave">ÔøΩ Crystal Cavern</button>
            <button onclick="switchDimensionUI('skyrelics_cyberpunk', this)" data-dimension="skyrelics_cyberpunk">üåÉ Neon Nexus</button>
          </div>
        </div>
        
        <button class="workspace-tab" onclick="switchDimensionUI('wordweaver', this)" data-dimension="wordweaver">‚úçÔ∏è WordWeaver</button>
        <button class="workspace-tab" onclick="switchDimensionUI('anatomy', this)" data-dimension="anatomy">ü¶¥ Anatomy</button>
        <button class="workspace-tab" onclick="switchDimensionUI('perfect', this)" data-dimension="perfect">‚ú® Perfect</button>
        <button class="workspace-tab" onclick="switchDimensionUI('venuespro', this)" data-dimension="venuespro" title="Interactive Event Showcases">üé™ VenuesPro</button>
        <button class="workspace-tab" onclick="switchDimensionUI('skeletor_land', this)" data-dimension="skeletor_land" title="Chase Skeletor!">üíÄ Skeletor Land</button>
      </div>
      <div style="color: rgba(255,255,255,0.8); font-size: 14px;">
        üåå Dimensional Workspace System
        <span id="current-dimension-display" style="margin-left: 10px; padding: 4px 8px; background: rgba(255,255,255,0.1); border-radius: 4px; font-size: 11px;">üè∞ SkyRelics Universe</span>
      </div>
      
      <!-- Camera Controls -->
      <div style="display: flex; gap: 8px; margin-left: auto;">
        <button onclick="window.location.href='pixelprodigy_blog.html'" style="padding: 8px 16px; background: rgba(102,126,234,0.15); border: 2px solid rgba(102,126,234,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          ÔøΩ WordWeaver
        </button>
        <button id="orbitToggle" onclick="toggleOrbitControls()" style="padding: 8px 16px; background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          üé• Orbit: ON
        </button>
        <button id="walkModeToggle" onclick="toggleWalkMode()" style="padding: 8px 16px; background: rgba(255,165,0,0.15); border: 2px solid rgba(255,165,0,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          üö∂ Walk Mode: OFF
        </button>
        <button id="thirdPersonToggle" onclick="toggle3rdPersonCamera()" style="padding: 8px 16px; background: rgba(33,150,243,0.15); border: 2px solid rgba(33,150,243,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          üéÆ 3rd Person: AUTO
        </button>
        <button id="vrIKToggle" onclick="toggleVRIK()" style="padding: 8px 16px; background: rgba(156,39,176,0.15); border: 2px solid rgba(156,39,176,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          ü¶æ VR IK: ON
        </button>
      </div>
      
      <!-- Movement Info -->
      <div style="position: absolute; top: 70px; left: 20px; background: rgba(0,0,0,0.7); padding: 12px; border-radius: 8px; font-size: 12px; color: #fff; font-family: monospace;">
        <div style="margin-bottom: 4px;">üéÆ <strong>CONTROLS:</strong></div>
        <div>W/S - Walk Forward/Back</div>
        <div>A/D - Turn Left/Right</div>
        <div><strong>SHIFT - Run (hold)</strong></div>
        <div>SPACE - Jump</div>
        <div>F - Flight Mode (Superman)</div>
        <div><strong>H - Hide/Show Panel</strong></div>
        <div style="margin-top: 4px; font-size: 11px; opacity: 0.7;">Flight: SHIFT=Up, CTRL=Down</div>
      </div>
    </div>

    <div id="sidebar">
      <!-- Collapse/Expand Toggle Button -->
      <div class="sidebar-toggle" onclick="toggleSidebar()" title="Toggle control panel">
        ‚óÄ
      </div>
      
      <!-- Sculpt Workspace -->
      <div id="workspace-sculpt" class="workspace-content">
        <div class="section">
          <div class="section-title">üîß Mode</div>
          <div class="tool-grid">
            <button class="tool-btn active" onclick="setMode('add', this)">
              <span class="tool-icon">‚ûï</span>
              <span>Add</span>
            </button>
            <button class="tool-btn" onclick="setMode('subtract', this)">
              <span class="tool-icon">‚ûñ</span>
              <span>Subtract</span>
            </button>
          </div>
        </div>

        <div class="section">
          <div class="section-title">‚úã Manipulate</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="setTransformMode('translate')">
              <span class="tool-icon">‚ÜîÔ∏è</span>
              <span>Move (W)</span>
            </button>
            <button class="tool-btn" onclick="setTransformMode('rotate')">
              <span class="tool-icon">üîÑ</span>
              <span>Rotate (E)</span>
            </button>
            <button class="tool-btn" onclick="setTransformMode('scale')">
              <span class="tool-icon">üìè</span>
              <span>Scale (R)</span>
            </button>
          </div>
        </div>

        <div class="section">
          <div class="section-title">üé® Primitives</div>
          <div class="primitive-grid">
            <button class="tool-btn active" onclick="setPrimitive('sphere', this)">
              <span class="tool-icon">‚ö™</span>
              <span>Sphere</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cube', this)">
              <span class="tool-icon">‚¨õ</span>
              <span>Cube</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cylinder', this)">
              <span class="tool-icon">üîµ</span>
              <span>Cylinder</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cone', this)">
              <span class="tool-icon">üîª</span>
              <span>Cone</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('torus', this)">
              <span class="tool-icon">üç©</span>
              <span>Torus</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('pyramid', this)">
              <span class="tool-icon">üî∫</span>
              <span>Pyramid</span>
            </button>
            <button class="tool-btn" onclick="loadHumanAnatomy(this)" style="grid-column: 1 / -1; background: rgba(102, 126, 234, 0.2);">
              <span class="tool-icon">ü¶æ</span>
              <span>Load Arm (86V)</span>
            </button>
            <button class="tool-btn" onclick="loadBothArms(this)" style="grid-column: 1 / -1; background: rgba(63, 81, 181, 0.25); border: 2px solid rgba(63, 81, 181, 0.5);">
              <span class="tool-icon">ü¶æü¶æ</span>
              <span>Both Arms (172V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanLeg(this)" style="grid-column: 1 / -1; background: rgba(76, 175, 80, 0.2); border: 2px solid rgba(76, 175, 80, 0.4);">
              <span class="tool-icon">ü¶µ</span>
              <span>Load Leg (86V)</span>
            </button>
            <button class="tool-btn" onclick="loadBothLegs(this)" style="grid-column: 1 / -1; background: rgba(46, 125, 50, 0.25); border: 2px solid rgba(46, 125, 50, 0.5);">
              <span class="tool-icon">ü¶µü¶µ</span>
              <span>Both Legs (172V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanTorso(this)" style="grid-column: 1 / -1; background: rgba(255, 193, 7, 0.2); border: 2px solid rgba(255, 193, 7, 0.4);">
              <span class="tool-icon">ü¶¥</span>
              <span>Load Torso (120V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanHead(this)" style="grid-column: 1 / -1; background: rgba(156, 39, 176, 0.2); border: 2px solid rgba(156, 39, 176, 0.4);">
              <span class="tool-icon">üß†</span>
              <span>Load Head (100V)</span>
            </button>
            <button class="tool-btn" onclick="loadFullBody(this)" style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(255, 64, 129, 0.3), rgba(63, 81, 181, 0.3)); border: 3px solid rgba(255, 255, 255, 0.6); box-shadow: 0 0 15px rgba(255, 64, 129, 0.4); font-weight: bold; font-size: 1.1em;">
              <span class="tool-icon">üßç</span>
              <span>FULL BODY (564V)</span>
            </button>
            <button class="tool-btn" onclick="loadSkeletonBody(this)" style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(200, 200, 200, 0.3), rgba(100, 100, 100, 0.3)); border: 3px solid rgba(200, 200, 200, 0.6); box-shadow: 0 0 15px rgba(200, 200, 200, 0.4); font-weight: bold; font-size: 1.1em;">
              <span class="tool-icon">üíÄ</span>
              <span>BONES BODY (564V)</span>
            </button>
            <button class="tool-btn" onclick="loadDetailedSkeleton(this)" style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(180, 180, 255, 0.4)); border: 3px solid rgba(255, 255, 255, 0.8); box-shadow: 0 0 20px rgba(180, 180, 255, 0.6); font-weight: bold; font-size: 1.1em;">
              <span class="tool-icon">ü¶¥</span>
              <span>DETAILED SKELETON (1200V+)</span>
            </button>
            
            <!-- VR Room Entrance -->
            <button class="tool-btn" onclick="enterVRRoom()" style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(138, 43, 226, 0.3)); border: 3px solid rgba(0, 255, 255, 0.6); box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); font-weight: bold; font-size: 1.1em; animation: pulse 2s ease-in-out infinite;">
              <span class="tool-icon">ü•Ω</span>
              <span>ENTER VR ROOM</span>
            </button>
            
            <button class="tool-btn" onclick="openAnatomyEditor()" style="grid-column: 1 / -1; background: rgba(255, 165, 0, 0.2); border: 2px solid rgba(255, 165, 0, 0.4);">
              <span class="tool-icon">‚úèÔ∏è</span>
              <span>Edit Anatomy (Advanced)</span>
            </button>
            <button class="tool-btn" onclick="toggleVertexEngine()" style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(138, 43, 226, 0.3)); border: 3px solid rgba(0, 255, 255, 0.6); box-shadow: 0 0 15px rgba(138, 43, 226, 0.4); font-weight: bold; font-size: 1.1em;">
              <span class="tool-icon">üî¨</span>
              <span>VERTEX ENGINE</span>
            </button>
          </div>
        </div>

        <!-- VERTEX ENGINE PANEL -->
        <div class="section" id="vertexEnginePanel" style="display: none;">
          <div class="section-title">üî¨ Vertex Engine - Microscopic Detail</div>
          
          <div style="background: rgba(0, 255, 255, 0.1); padding: 10px; border-radius: 5px; margin-bottom: 10px;">
            <div style="font-size: 0.9em; color: #0ff; margin-bottom: 5px;">
              <strong>Selected Object:</strong> <span id="vertexObjectName">None</span>
            </div>
            <div style="font-size: 0.9em; color: #0ff;">
              <strong>Total Vertices:</strong> <span id="vertexTotalCount">0</span>
            </div>
            <div style="font-size: 0.9em; color: #0ff;">
              <strong>Selected Vertex:</strong> <span id="vertexSelectedIndex">None</span>
            </div>
          </div>

          <!-- Quick Actions for Bodies -->
          <div style="margin-bottom: 15px;">
            <button onclick="analyzeFullBody()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, rgba(255, 64, 129, 0.3), rgba(63, 81, 181, 0.3)); border: 2px solid rgba(255, 64, 129, 0.5); border-radius: 5px; color: #fff; cursor: pointer; margin-bottom: 8px; font-weight: bold;">
              üßç Analyze Full Body
            </button>
            <button onclick="analyzeSkeletonBody()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, rgba(200, 200, 200, 0.3), rgba(100, 100, 100, 0.3)); border: 2px solid rgba(200, 200, 200, 0.5); border-radius: 5px; color: #fff; cursor: pointer; font-weight: bold;">
              üíÄ Analyze Skeleton Body
            </button>
          </div>

          <!-- Vertex Visualization -->
          <div style="margin-bottom: 15px;">
            <label style="display: flex; align-items: center; gap: 10px; color: #fff; margin-bottom: 8px;">
              <input type="checkbox" id="showVertexPoints" onchange="toggleVertexVisualization(this.checked)" style="width: 18px; height: 18px;">
              <span>Show All Vertices (as points)</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; color: #fff; margin-bottom: 8px;">
              <input type="checkbox" id="showVertexNumbers" onchange="toggleVertexNumbers(this.checked)" style="width: 18px; height: 18px;">
              <span>Show Vertex Numbers</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; color: #fff;">
              <input type="checkbox" id="showWireframe" onchange="toggleWireframe(this.checked)" style="width: 18px; height: 18px;">
              <span>Wireframe Mode</span>
            </label>
          </div>

          <!-- Vertex Position Editor -->
          <div style="background: rgba(138, 43, 226, 0.2); padding: 12px; border-radius: 5px; margin-bottom: 10px;">
            <div style="color: #fff; font-weight: bold; margin-bottom: 8px;">üìç Vertex Position (XYZ)</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
              <div>
                <label style="color: #f00; font-size: 0.85em;">X</label>
                <input type="number" id="vertexPosX" step="0.01" onchange="updateVertexPosition()" 
                       style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); color: #f00; border: 1px solid #f00; border-radius: 3px;">
              </div>
              <div>
                <label style="color: #0f0; font-size: 0.85em;">Y</label>
                <input type="number" id="vertexPosY" step="0.01" onchange="updateVertexPosition()" 
                       style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); color: #0f0; border: 1px solid #0f0; border-radius: 3px;">
              </div>
              <div>
                <label style="color: #00f; font-size: 0.85em;">Z</label>
                <input type="number" id="vertexPosZ" step="0.01" onchange="updateVertexPosition()" 
                       style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); color: #00f; border: 1px solid #00f; border-radius: 3px;">
              </div>
            </div>
          </div>

          <!-- Sculpting Tools -->
          <div style="margin-bottom: 10px;">
            <div style="color: #fff; font-weight: bold; margin-bottom: 8px;">üé® Sculpt Mode</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <button onclick="setSculptMode('push')" style="padding: 8px; background: rgba(255, 100, 100, 0.3); border: 2px solid rgba(255, 100, 100, 0.5); border-radius: 5px; color: #fff; cursor: pointer;">
                ‚¨ÜÔ∏è Push
              </button>
              <button onclick="setSculptMode('pull')" style="padding: 8px; background: rgba(100, 100, 255, 0.3); border: 2px solid rgba(100, 100, 255, 0.5); border-radius: 5px; color: #fff; cursor: pointer;">
                ‚¨áÔ∏è Pull
              </button>
              <button onclick="setSculptMode('smooth')" style="padding: 8px; background: rgba(255, 255, 100, 0.3); border: 2px solid rgba(255, 255, 100, 0.5); border-radius: 5px; color: #fff; cursor: pointer;">
                ‚ú® Smooth
              </button>
              <button onclick="setSculptMode('inflate')" style="padding: 8px; background: rgba(100, 255, 100, 0.3); border: 2px solid rgba(100, 255, 100, 0.5); border-radius: 5px; color: #fff; cursor: pointer;">
                üí® Inflate
              </button>
            </div>
          </div>

          <!-- Brush Settings -->
          <div style="margin-bottom: 10px;">
            <label style="color: #fff; font-size: 0.9em; display: block; margin-bottom: 5px;">
              üñåÔ∏è Brush Size: <span id="brushSizeValue">1.0</span>
            </label>
            <input type="range" id="brushSize" min="0.1" max="5.0" step="0.1" value="1.0" 
                   oninput="document.getElementById('brushSizeValue').textContent = this.value; updateBrushSize(this.value)"
                   style="width: 100%;">
            
            <label style="color: #fff; font-size: 0.9em; display: block; margin-bottom: 5px; margin-top: 8px;">
              üí™ Strength: <span id="sculptStrengthValue">0.5</span>
            </label>
            <input type="range" id="sculptStrength" min="0.1" max="2.0" step="0.1" value="0.5" 
                   oninput="document.getElementById('sculptStrengthValue').textContent = this.value; updateSculptStrength(this.value)"
                   style="width: 100%;">
          </div>

          <!-- Export Vertex Data -->
          <button onclick="smartExportVertices()" style="width: 100%; padding: 10px; background: rgba(0, 200, 0, 0.3); border: 2px solid rgba(0, 200, 0, 0.5); border-radius: 5px; color: #fff; cursor: pointer; margin-bottom: 8px;">
            üíæ Export Vertex Coordinates (JSON)
          </button>
          
          <div style="font-size: 0.8em; color: #888; margin-bottom: 8px; text-align: center;">
            Exports selected object or entire body if body is loaded
          </div>

          <!-- Vertex Info Display -->
          <div id="vertexInfoDisplay" style="background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; font-family: monospace; font-size: 0.75em; color: #0ff; max-height: 200px; overflow-y: auto; display: none;">
            <!-- Vertex data will be displayed here -->
          </div>
        </div>

        <!-- ARM ARTICULATION -->
        <div class="section" id="armArticulation" style="display: none;">
          <div class="section-title">üí™ Arm Articulation</div>
          <div style="margin-bottom: 15px;">
            <label style="font-size: 12px; color: #888; display: flex; justify-content: space-between; margin-bottom: 5px;">
              <span>Elbow Angle</span>
              <span id="elbowAngleValue" style="color: #00ff88;">180¬∞</span>
            </label>
            <input type="range" id="elbowAngle" min="180" max="340" value="180" step="1" 
                   oninput="updateElbowAngle(parseInt(this.value))"
                   style="width: 100%; cursor: pointer;">
            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;">
              <span>180¬∞ (straight)</span>
              <span>340¬∞ (bent)</span>
            </div>
          </div>
        </div>

        <!-- NECK SWIVEL -->
        <div class="section" id="neckSwivel" style="display: none;">
          <div class="section-title">üîÑ Neck Swivel</div>
          <div style="margin-bottom: 15px;">
            <label style="font-size: 12px; color: #888; display: flex; justify-content: space-between; margin-bottom: 5px;">
              <span>Head Rotation</span>
              <span id="neckSwivelValue" style="color: #00ff88;">0¬∞</span>
            </label>
            <input type="range" id="neckSwivelAngle" min="-180" max="180" value="0" step="1" 
                   oninput="updateNeckSwivel(parseInt(this.value))"
                   style="width: 100%; cursor: pointer;">
            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;">
              <span>-180¬∞ (left)</span>
              <span>0¬∞ (center)</span>
              <span>180¬∞ (right)</span>
            </div>
          </div>
        </div>

        <!-- LEARN MODE TOGGLE -->
        <div class="section">
          <div class="section-title">üìö Learn Mode</div>
          <button class="tool-btn" id="learnModeToggle" onclick="toggleLearnMode(this)" style="width: 100%; background: rgba(0, 255, 136, 0.1); border: 2px solid rgba(0, 255, 136, 0.3);">
            <span class="tool-icon">üë®‚Äçüè´</span>
            <span>Enable Story Mode</span>
          </button>
          <div id="learnModeInfo" style="display: none; margin-top: 10px; padding: 12px; background: rgba(0, 255, 136, 0.1); border-radius: 8px; font-size: 11px; line-height: 1.5; color: rgba(255, 255, 255, 0.9);">
            <strong>Learn Mode Active!</strong><br>
            Click any Mathematical Method below to see the mathematician's story and how their discovery powers your creations! üèÜ
          </div>
        </div>

        <!-- MATHEMATICAL METHODS -->
        <div class="section">
          <div class="section-title">üèÜ Mathematical Methods</div>
          <div class="tool-grid">
            <button class="tool-btn active" onclick="selectMethod('fibonacci', this)">
              <span class="tool-icon">üáÆüáπ</span>
              <span>Fibonacci</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('catmull', this)">
              <span class="tool-icon">üá∫üá∏</span>
              <span>Catmull-Rom</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('bezier', this)">
              <span class="tool-icon">üá´üá∑</span>
              <span>B√©zier</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('perlin', this)">
              <span class="tool-icon">üéÆ</span>
              <span>Perlin Noise</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('quaternion', this)">
              <span class="tool-icon">üáÆüá™</span>
              <span>Quaternion</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('lsystem', this)">
              <span class="tool-icon">üá≠üá∫</span>
              <span>L-System</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('voronoi', this)">
              <span class="tool-icon">üá∫üá¶</span>
              <span>Voronoi</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('phong', this)">
              <span class="tool-icon">üáªüá≥</span>
              <span>Phong</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('delaunay', this)">
              <span class="tool-icon">üá∑üá∫</span>
              <span>Delaunay</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('subdivision', this)">
              <span class="tool-icon">üíé</span>
              <span>Subdivision</span>
            </button>
          </div>
        </div>

        <!-- MATHEMATICIAN STORY PANEL -->
        <div id="mathematicianStory" class="section" style="display: none;">
          <div class="section-title" id="storyTitle">üèÜ Mathematician Story</div>
          <div style="padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 2px solid rgba(102, 126, 234, 0.3);">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
              <span id="storyFlag" style="font-size: 24px;">üáÆüáπ</span>
              <div>
                <div id="storyName" style="font-weight: 700; font-size: 14px; color: #00ff88;">Leonardo Fibonacci</div>
                <div id="storyDates" style="font-size: 11px; opacity: 0.8;">1170-1250</div>
              </div>
            </div>
            <div id="storyDiscovery" style="font-size: 12px; font-weight: 600; color: #667eea; margin-bottom: 8px;">
              Discovery: Fibonacci Sequence
            </div>
            <div id="storyText" style="font-size: 11px; line-height: 1.6; margin-bottom: 10px; color: rgba(255, 255, 255, 0.9);">
              Italian mathematician who discovered the famous sequence (0,1,1,2,3,5,8...) while studying rabbit populations.
            </div>
            <div style="background: rgba(0, 255, 136, 0.1); padding: 8px; border-radius: 6px; border-left: 3px solid #00ff88;">
              <div style="font-size: 10px; font-weight: 700; color: #00ff88; margin-bottom: 4px;">üí° KID FACT:</div>
              <div id="storyKidFact" style="font-size: 11px; line-height: 1.5;">
                He introduced Arabic numerals (0-9) to Europe! Before him, Europeans used Roman numerals.
              </div>
            </div>
          </div>
        </div>

        <div class="section">
          <div class="section-title">‚öôÔ∏è Settings</div>
          <div class="slider-control">
            <div class="slider-label">
              <span>Size</span>
              <span id="sizeValue">0.5</span>
            </div>
            <input type="range" min="0.1" max="2" step="0.1" value="0.5" oninput="updateSize(this.value)">
          </div>
          <div class="slider-control">
            <div class="slider-label">
              <span>Angle</span>
              <span id="angleValue">0¬∞</span>
            </div>
            <input type="range" min="0" max="360" step="15" value="0" oninput="updateAngle(this.value)">
          </div>
        </div>

        <div class="section">
          <div class="section-title">üéØ Actions</div>
          <button class="tool-btn" onclick="clearScene()" style="width: 100%; grid-column: 1 / -1;">
            <span class="tool-icon">üóëÔ∏è</span>
            <span>Clear All</span>
          </button>
        </div>
      </div>

      <!-- CSS Designer Workspace -->
      <div id="workspace-css" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">üíÖ CSS Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Gradient generator coming soon!')">
              <span class="tool-icon">üåà</span>
              <span>Gradient</span>
            </button>
            <button class="tool-btn" onclick="alert('Shadow generator coming soon!')">
              <span class="tool-icon">üå´Ô∏è</span>
              <span>Shadow</span>
            </button>
            <button class="tool-btn" onclick="alert('Border designer coming soon!')">
              <span class="tool-icon">üî≤</span>
              <span>Border</span>
            </button>
            <button class="tool-btn" onclick="alert('Animation builder coming soon!')">
              <span class="tool-icon">üé¨</span>
              <span>Animate</span>
            </button>
          </div>
        </div>
      </div>

      <!-- WordWeaver Workspace -->
      <div id="workspace-word" class="workspace-content" style="display: none; overflow-y: auto; max-height: calc(100vh - 100px);">
        
        <!-- WordWeaver Control Panel Header -->
        <div style="position: sticky; top: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px; border-radius: 8px; margin-bottom: 15px; z-index: 10;">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <h3 style="margin: 0; font-size: 18px; font-weight: 700;">üß¨ WordWeaver 3D Document Studio</h3>
              <p style="margin: 5px 0 0 0; font-size: 11px; opacity: 0.9;">Create 3D text art with individual letter geometries</p>
            </div>
            <button onclick="toggleWordWeaverPanel()" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 6px; color: white; font-weight: 600; cursor: pointer;">
              ‚öôÔ∏è Settings
            </button>
          </div>
        </div>
        
        <div class="section">
          <div class="section-title">üß¨ WordWeaver Canvas</div>
          
          <!-- Document Format Selector -->
          <div class="section" style="margin-bottom: 15px;">
            <div class="section-title">üìã Document Format</div>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
              <button id="doc-mode-blog" class="tool-btn doc-mode-selector active" onclick="selectDocumentMode('blog')" style="flex: 1; background: rgba(102, 126, 234, 0.3); border: 2px solid rgba(102, 126, 234, 0.5);">
                <span class="tool-icon">üìù</span>
                <span>Blog Post</span>
              </button>
              <button id="doc-mode-pdf" class="tool-btn doc-mode-selector" onclick="selectDocumentMode('pdf')" style="flex: 1; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3);">
                <span class="tool-icon">üìÑ</span>
                <span>PDF Document</span>
              </button>
            </div>
          </div>
          
          <!-- Text Input Area -->
          <div class="section">
            <div class="section-title">‚úçÔ∏è Content Input</div>
            
            <!-- Blog Mode Fields -->
            <div id="blog-mode-fields" style="display: block;">
              <div style="margin-bottom: 12px;">
                <label style="display: block; margin-bottom: 5px; color: #999; font-size: 12px;">Blog Title:</label>
                <input type="text" id="blog-title" placeholder="Enter your blog title..." style="width: 100%; padding: 10px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; color: #e0e0e0; font-family: inherit; font-size: 14px;">
              </div>
              <div style="margin-bottom: 12px;">
                <label style="display: block; margin-bottom: 5px; color: #999; font-size: 12px;">Blog Content:</label>
                <textarea id="blog-content" placeholder="Write your blog post... Press 'Materialize' to see words appear in 3D!" style="width: 100%; min-height: 150px; padding: 12px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; color: #e0e0e0; font-family: 'Courier New', monospace; font-size: 13px; resize: vertical;"></textarea>
              </div>
            </div>
            
            <!-- PDF Mode Fields -->
            <div id="pdf-mode-fields" style="display: none;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <div>
                  <label style="display: block; margin-bottom: 5px; color: #999; font-size: 11px;">Name:</label>
                  <input type="text" id="pdf-name" placeholder="John Doe" style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: #e0e0e0; font-size: 12px;">
                </div>
                <div>
                  <label style="display: block; margin-bottom: 5px; color: #999; font-size: 11px;">City:</label>
                  <input type="text" id="pdf-city" placeholder="City" style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: #e0e0e0; font-size: 12px;">
                </div>
                <div>
                  <label style="display: block; margin-bottom: 5px; color: #999; font-size: 11px;">State:</label>
                  <input type="text" id="pdf-state" placeholder="ST" style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: #e0e0e0; font-size: 12px;">
                </div>
                <div>
                  <label style="display: block; margin-bottom: 5px; color: #999; font-size: 11px;">Zip:</label>
                  <input type="text" id="pdf-zip" placeholder="00000" style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: #e0e0e0; font-size: 12px;">
                </div>
              </div>
              <div style="margin-bottom: 10px;">
                <label style="display: block; margin-bottom: 5px; color: #999; font-size: 11px;">Document Title:</label>
                <input type="text" id="pdf-title" placeholder="Enter document title..." style="width: 100%; padding: 10px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; color: #e0e0e0; font-size: 14px;">
              </div>
              <div style="margin-bottom: 10px;">
                <label style="display: block; margin-bottom: 5px; color: #999; font-size: 11px;">Paragraph Content:</label>
                <textarea id="pdf-paragraph" placeholder="Enter paragraph text..." style="width: 100%; min-height: 120px; padding: 12px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; color: #e0e0e0; font-family: 'Courier New', monospace; font-size: 12px; resize: vertical;"></textarea>
              </div>
            </div>
            
            <!-- Materialize Button -->
            <button onclick="materializeDocument()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 8px; color: white; font-weight: 700; font-size: 15px; cursor: pointer; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); transition: all 0.3s;">
              ‚ú® Materialize in 3D Space
            </button>
          </div>
          
          <!-- Visual Controls -->
          <div class="section" style="margin-top: 15px;">
            <div class="section-title">üé® Word Appearance</div>
            
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Shape Distribution:</label>
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                <button class="shape-selector" data-shape="linear" onclick="selectDocShape('linear')" style="padding: 8px 6px; background: rgba(102, 126, 234, 0.3); border: 2px solid rgba(102, 126, 234, 0.5); border-radius: 6px; color: #fff; font-size: 10px; cursor: pointer; transition: all 0.2s;">
                  üìÑ Linear
                </button>
                <button class="shape-selector" data-shape="sphere" onclick="selectDocShape('sphere')" style="padding: 8px 6px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer; transition: all 0.2s;">
                  üîÆ Sphere
                </button>
                <button class="shape-selector" data-shape="cube" onclick="selectDocShape('cube')" style="padding: 8px 6px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer; transition: all 0.2s;">
                  üì¶ Cube
                </button>
                <button class="shape-selector" data-shape="pyramid" onclick="selectDocShape('pyramid')" style="padding: 8px 6px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer; transition: all 0.2s;">
                  üî∫ Pyramid
                </button>
                <button class="shape-selector" data-shape="sine" onclick="selectDocShape('sine')" style="padding: 8px 6px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer; transition: all 0.2s;">
                  „Ä∞Ô∏è Wave
                </button>
                <button class="shape-selector" data-shape="helix" onclick="selectDocShape('helix')" style="padding: 8px 6px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer; transition: all 0.2s;">
                  üß¨ Helix
                </button>
              </div>
            </div>
            
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Material:</label>
              
              <!-- Auto-Correlation Toggle -->
              <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                  <input type="checkbox" id="enable-matrix-correlation" checked onchange="toggleMatrixCorrelation()" style="width: 16px; height: 16px; cursor: pointer;">
                  <span style="color: #e0e0e0; font-size: 11px;">üîÑ Auto-correlate Matrix Background</span>
                </label>
                <div style="margin-top: 2px; padding-left: 24px; font-size: 9px; color: rgba(255,255,255,0.5);">
                  Matrix wall automatically matches material type
                </div>
              </div>
              
              <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px;">
                <button class="material-selector" data-material="biblical" onclick="selectDocMaterial('biblical')" style="padding: 8px; background: rgba(212, 165, 116, 0.3); border: 2px solid rgba(212, 165, 116, 0.5); border-radius: 6px; color: #fff; font-size: 10px; cursor: pointer;">
                  üìñ Biblical
                </button>
                <button class="material-selector" data-material="chrome" onclick="selectDocMaterial('chrome')" style="padding: 8px; background: rgba(224, 224, 224, 0.1); border: 2px solid rgba(224, 224, 224, 0.3); border-radius: 6px; color: #e0e0e0; font-size: 10px; cursor: pointer;">
                  ‚öôÔ∏è Chrome
                </button>
                <button class="material-selector" data-material="holographic" onclick="selectDocMaterial('holographic')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer;">
                  ‚ú® Holo
                </button>
                <button class="material-selector" data-material="metallic" onclick="selectDocMaterial('metallic')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer;">
                  üîß Metal
                </button>
                <button class="material-selector" data-material="glass" onclick="selectDocMaterial('glass')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer;">
                  üîÆ Glass
                </button>
                <button class="material-selector" data-material="magnetic" onclick="selectDocMaterial('magnetic')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer;">
                  üß≤ Magnetic
                </button>
              </div>
              
              <!-- Material Correlation Display -->
              <div id="material-correlation-info" style="margin-top: 6px; padding: 6px; background: rgba(102, 126, 234, 0.1); border-radius: 4px; font-size: 9px; color: rgba(255,255,255,0.7); line-height: 1.4;">
                üìÑ Biblical ‚Üí Solid Grid (Ancient parchment texture)
              </div>
            </div>
            
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Font Style:</label>
              <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px;">
                <button class="font-selector" data-font="helvetiker" onclick="selectDocFont('helvetiker')" style="padding: 8px; background: rgba(102, 126, 234, 0.3); border: 2px solid rgba(102, 126, 234, 0.5); border-radius: 6px; color: #fff; font-size: 10px; cursor: pointer; font-family: Arial, sans-serif;">
                  Aa Modern
                </button>
                <button class="font-selector" data-font="optimer" onclick="selectDocFont('optimer')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer; font-family: 'Times New Roman', serif;">
                  Aa Classic
                </button>
                <button class="font-selector" data-font="gentilis" onclick="selectDocFont('gentilis')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer; font-family: Georgia, serif;">
                  Aa Elegant
                </button>
                <button class="font-selector" data-font="droid" onclick="selectDocFont('droid')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer; font-family: 'Courier New', monospace;">
                  Aa Tech
                </button>
              </div>
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Word Color:</label>
              <input type="color" id="doc-color" value="#667eea" onchange="updateDocColor(this.value)" style="width: 100%; height: 36px; border-radius: 6px; border: 2px solid rgba(255, 255, 255, 0.1); background: transparent; cursor: pointer;">
            </div>
          </div>
          
          <!-- Export & Clear -->
          <div class="section" style="margin-top: 15px;">
            <div style="display: flex; gap: 8px;">
              <button onclick="exportDocument()" style="flex: 1; padding: 12px; background: rgba(34, 197, 94, 0.2); border: 2px solid rgba(34, 197, 94, 0.4); border-radius: 8px; color: #22c55e; font-weight: 600; font-size: 13px; cursor: pointer;">
                üì• Export
              </button>
              <button onclick="clearDocument()" style="flex: 1; padding: 12px; background: rgba(239, 68, 68, 0.2); border: 2px solid rgba(239, 68, 68, 0.4); border-radius: 8px; color: #ef4444; font-weight: 600; font-size: 13px; cursor: pointer;">
                üóëÔ∏è Clear
              </button>
            </div>
            
            <!-- Word Count -->
            <div style="margin-top: 12px; padding: 10px; background: rgba(102, 126, 234, 0.1); border-radius: 6px; text-align: center;">
              <span style="color: #999; font-size: 12px;">Word Count: </span>
              <span id="doc-word-count" style="color: #667eea; font-size: 16px; font-weight: 700;">0</span>
            </div>
          </div>
          
          <!-- ========================================
               ADVANCED WORDWEAVER CONTROL PANEL
               ======================================== -->
          
          <!-- Document Type Templates -->
          <div class="section" style="margin-top: 20px;">
            <div class="section-title">üìÑ Document Templates</div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
              <button class="doc-template-btn" onclick="loadDocTemplate('essay')" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer; transition: all 0.2s;">
                üìù Essay
              </button>
              <button class="doc-template-btn" onclick="loadDocTemplate('letter')" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer; transition: all 0.2s;">
                ‚úâÔ∏è Letter
              </button>
              <button class="doc-template-btn" onclick="loadDocTemplate('report')" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer; transition: all 0.2s;">
                üìä Report
              </button>
              <button class="doc-template-btn" onclick="loadDocTemplate('poem')" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer; transition: all 0.2s;">
                üé≠ Poem
              </button>
              <button class="doc-template-btn" onclick="loadDocTemplate('resume')" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer; transition: all 0.2s;">
                üíº Resume
              </button>
              <button class="doc-template-btn" onclick="loadDocTemplate('script')" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer; transition: all 0.2s;">
                üé¨ Script
              </button>
            </div>
          </div>
          
          <!-- Text Formatting Controls -->
          <div class="section" style="margin-top: 15px;">
            <div class="section-title">‚úèÔ∏è Text Formatting</div>
            
            <!-- Font Weight & Style -->
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Font Weight:</label>
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                <button class="weight-selector active" data-weight="normal" onclick="selectFontWeight('normal')" style="padding: 8px; background: rgba(102, 126, 234, 0.3); border: 2px solid rgba(102, 126, 234, 0.5); border-radius: 6px; color: #fff; font-size: 10px; cursor: pointer;">
                  Regular
                </button>
                <button class="weight-selector" data-weight="bold" onclick="selectFontWeight('bold')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; font-weight: bold; cursor: pointer;">
                  Bold
                </button>
                <button class="weight-selector" data-weight="bolder" onclick="selectFontWeight('bolder')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; font-weight: 900; cursor: pointer;">
                  Extra Bold
                </button>
              </div>
            </div>
            
            <!-- Text Decoration -->
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Text Style:</label>
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                <button class="style-selector" data-style="none" onclick="toggleTextDecoration('none')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer;">
                  Normal
                </button>
                <button class="style-selector" data-style="underline" onclick="toggleTextDecoration('underline')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; text-decoration: underline; cursor: pointer;">
                  Underline
                </button>
                <button class="style-selector" data-style="italic" onclick="toggleTextDecoration('italic')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; font-style: italic; cursor: pointer;">
                  Italic
                </button>
              </div>
            </div>
            
            <!-- Letter Size Control -->
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Letter Size:</label>
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="letter-size-slider" min="0.2" max="2.0" step="0.1" value="0.4" oninput="updateLetterSize(this.value)" style="flex: 1;">
                <span id="letter-size-value" style="min-width: 45px; text-align: right; color: #667eea; font-weight: 600; font-size: 13px;">0.4</span>
              </div>
              <div style="display: flex; justify-content: space-between; margin-top: 4px; font-size: 9px; color: #666;">
                <span>Tiny</span>
                <span>Normal</span>
                <span>Huge</span>
              </div>
            </div>
            
            <!-- Letter Spacing -->
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Letter Spacing:</label>
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="letter-spacing-slider" min="0.3" max="1.5" step="0.1" value="0.6" oninput="updateLetterSpacing(this.value)" style="flex: 1;">
                <span id="letter-spacing-value" style="min-width: 45px; text-align: right; color: #667eea; font-weight: 600; font-size: 13px;">0.6</span>
              </div>
            </div>
            
            <!-- 3D Extrusion Depth -->
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">3D Depth:</label>
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="extrusion-depth-slider" min="0.05" max="0.5" step=" 0.05" value="0.15" oninput="updateExtrusionDepth(this.value)" style="flex: 1;">
                <span id="extrusion-depth-value" style="min-width: 45px; text-align: right; color: #667eea; font-weight: 600; font-size: 13px;">0.15</span>
              </div>
              <div style="display: flex; justify-content: space-between; margin-top: 4px; font-size: 9px; color: #666;">
                <span>Flat</span>
                <span>3D</span>
                <span>Deep</span>
              </div>
            </div>
          </div>
          
          <!-- Word Placement Controls -->
          <div class="section" style="margin-top: 15px;">
            <div class="section-title">üìç Word Placement</div>
            
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Alignment:</label>
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                <button class="align-selector active" data-align="left" onclick="selectAlignment('left')" style="padding: 8px; background: rgba(102, 126, 234, 0.3); border: 2px solid rgba(102, 126, 234, 0.5); border-radius: 6px; color: #fff; font-size: 10px; cursor: pointer;">
                  ‚Üê Left
                </button>
                <button class="align-selector" data-align="center" onclick="selectAlignment('center')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer;">
                  ‚Üî Center
                </button>
                <button class="align-selector" data-align="right" onclick="selectAlignment('right')" style="padding: 8px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer;">
                  Right ‚Üí
                </button>
              </div>
            </div>
            
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Line Spacing:</label>
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="line-spacing-slider" min="0.5" max="2.0" step="0.1" value="0.8" oninput="updateLineSpacing(this.value)" style="flex: 1;">
                <span id="line-spacing-value" style="min-width: 45px; text-align: right; color: #667eea; font-weight: 600; font-size: 13px;">0.8</span>
              </div>
            </div>
            
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Words Per Line:</label>
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="words-per-line-slider" min="4" max="16" step="1" value="8" oninput="updateWordsPerLine(this.value)" style="flex: 1;">
                <span id="words-per-line-value" style="min-width: 45px; text-align: right; color: #667eea; font-weight: 600; font-size: 13px;">8</span>
              </div>
            </div>
          </div>
          
          <!-- Save & Load System -->
          <div class="section" style="margin-top: 15px;">
            <div class="section-title">üíæ Save & Load</div>
            
            <div style="margin-bottom: 10px;">
              <label style="display: block; margin-bottom: 5px; color: #999; font-size: 11px;">Document Name:</label>
              <input type="text" id="doc-save-name" placeholder="My 3D Document" style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; color: #e0e0e0; font-size: 12px;">
            </div>
            
            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
              <button onclick="saveDocument()" style="flex: 1; padding: 10px; background: rgba(59, 130, 246, 0.2); border: 2px solid rgba(59, 130, 246, 0.4); border-radius: 6px; color: #3b82f6; font-weight: 600; font-size: 12px; cursor: pointer;">
                üíæ Save
              </button>
              <button onclick="showLoadDialog()" style="flex: 1; padding: 10px; background: rgba(168, 85, 247, 0.2); border: 2px solid rgba(168, 85, 247, 0.4); border-radius: 6px; color: #a855f7; font-weight: 600; font-size: 12px; cursor: pointer;">
                üìÇ Load
              </button>
            </div>
            
            <div style="display: flex; gap: 8px;">
              <button onclick="newDocument()" style="flex: 1; padding: 10px; background: rgba(34, 197, 94, 0.2); border: 2px solid rgba(34, 197, 94, 0.4); border-radius: 6px; color: #22c55e; font-weight: 600; font-size: 12px; cursor: pointer;">
                ‚ûï New
              </button>
              <button onclick="duplicateDocument()" style="flex: 1; padding: 10px; background: rgba(251, 146, 60, 0.2); border: 2px solid rgba(251, 146, 60, 0.4); border-radius: 6px; color: #fb923c; font-weight: 600; font-size: 12px; cursor: pointer;">
                üìã Duplicate
              </button>
            </div>
            
            <!-- Saved Documents List -->
            <div style="margin-top: 12px; max-height: 150px; overflow-y: auto; background: rgba(0, 0, 0, 0.3); border-radius: 6px; padding: 8px;">
              <div style="font-size: 10px; color: #999; margin-bottom: 6px; font-weight: 600;">SAVED DOCUMENTS:</div>
              <div id="saved-docs-list" style="display: flex; flex-direction: column; gap: 4px;">
                <div style="font-size: 10px; color: #666; font-style: italic; padding: 8px;">No saved documents yet...</div>
              </div>
            </div>
          </div>
          
          <!-- Animation Controls -->
          <div class="section" style="margin-top: 15px;">
            <div class="section-title">üé¨ Animation Settings</div>
            
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Materialization Speed:</label>
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="animation-speed-slider" min="500" max="2000" step="100" value="1200" oninput="updateAnimationSpeed(this.value)" style="flex: 1;">
                <span id="animation-speed-value" style="min-width: 60px; text-align: right; color: #667eea; font-weight: 600; font-size: 13px;">1200ms</span>
              </div>
              <div style="display: flex; justify-content: space-between; margin-top: 4px; font-size: 9px; color: #666;">
                <span>Fast</span>
                <span>Normal</span>
                <span>Slow</span>
              </div>
            </div>
            
            <div style="margin-bottom: 12px;">
              <label style="display: block; margin-bottom: 6px; color: #999; font-size: 11px; font-weight: 600;">Letter Stagger Delay:</label>
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="stagger-delay-slider" min="0" max="150" step="10" value="50" oninput="updateStaggerDelay(this.value)" style="flex: 1;">
                <span id="stagger-delay-value" style="min-width: 50px; text-align: right; color: #667eea; font-weight: 600; font-size: 13px;">50ms</span>
              </div>
            </div>
            
            <div>
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="enable-rotation" checked onchange="toggleRotationAnimation()" style="width: 16px; height: 16px; cursor: pointer;">
                <span style="color: #e0e0e0; font-size: 12px;">Enable Rotation Animation</span>
              </label>
            </div>
            
            <div style="margin-top: 12px;">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="enable-matrix-grid" checked onchange="toggleMatrixGrid()" style="width: 16px; height: 16px; cursor: pointer;">
                <span style="color: #e0e0e0; font-size: 12px;">üåê Show Matrix Grid Backwall</span>
              </label>
              <div style="margin-top: 4px; padding-left: 24px; font-size: 10px; color: rgba(255,255,255,0.5);">
                Spatial reference grid behind text
              </div>
              
              <!-- Matrix Wall Mode Selector -->
              <div style="margin-top: 10px; padding-left: 0px;">
                <div style="font-size: 11px; color: rgba(255,255,255,0.7); margin-bottom: 6px; font-weight: 600;">
                  üé® Matrix Wall Style:
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px;">
                  <button 
                    id="mode-paperback" 
                    onclick="switchMatrixMode('paperback')" 
                    class="matrix-mode-btn active-mode"
                    style="padding: 8px 4px; background: rgba(102, 126, 234, 0.3); border: 2px solid rgba(102, 126, 234, 0.6); border-radius: 6px; color: #fff; font-size: 10px; cursor: pointer; transition: all 0.3s; font-weight: 600;">
                    üìÑ Solid
                  </button>
                  <button 
                    id="mode-magnetic" 
                    onclick="switchMatrixMode('magnetic')" 
                    class="matrix-mode-btn"
                    style="padding: 8px 4px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer; transition: all 0.3s; font-weight: 600;">
                    üß≤ Field
                  </button>
                  <button 
                    id="mode-holographic" 
                    onclick="switchMatrixMode('holographic')" 
                    class="matrix-mode-btn"
                    style="padding: 8px 4px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 10px; cursor: pointer; transition: all 0.3s; font-weight: 600;">
                    üîÆ Holo
                  </button>
                </div>
                <div id="matrix-mode-description" style="margin-top: 6px; font-size: 9px; color: rgba(255,255,255,0.5); line-height: 1.4;">
                  üìÑ Solid grid structure with clean lines
                </div>
              </div>
            </div>
          </div>
          
          <!-- Quick Actions -->
          <div class="section" style="margin-top: 15px; margin-bottom: 20px;">
            <div class="section-title">‚ö° Quick Actions</div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <button onclick="selectAllLetters()" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer;">
                üîò Select All
              </button>
              <button onclick="deselectAllLetters()" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer;">
                ‚≠ï Deselect All
              </button>
              <button onclick="randomizeColors()" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer;">
                üåà Random Colors
              </button>
              <button onclick="resetToDefaults()" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer;">
                üîÑ Reset Defaults
              </button>
              <button onclick="arrangeInCircle()" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer;">
                ‚≠ï Circle Layout
              </button>
              <button onclick="arrangeInSpiral()" style="padding: 10px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 6px; color: #667eea; font-size: 11px; cursor: pointer;">
                üåÄ Spiral Layout
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Campus Workspace -->
      <div id="workspace-campus" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">üè´ Campus Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Building designer coming soon!')">
              <span class="tool-icon">üè¢</span>
              <span>Buildings</span>
            </button>
            <button class="tool-btn" onclick="alert('Layout planner coming soon!')">
              <span class="tool-icon">üó∫Ô∏è</span>
              <span>Layout</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Perfect Workspace -->
      <div id="workspace-perfect" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">‚ú® Perfect Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Perfect system coming soon!')">
              <span class="tool-icon">‚≠ê</span>
              <span>Optimize</span>
            </button>
          </div>
        </div>
      </div>

      <!-- ü¶¥ ANATOMY WORKSPACE -->
      <div id="workspace-anatomy" class="workspace-content" style="display: none; overflow-y: auto; max-height: calc(100vh - 100px);">
        <!-- Anatomical Search Bar -->
        <div class="section">
          <div class="section-title">üîç Anatomical Search</div>
          <div style="padding: 10px;">
            <input 
              type="text" 
              id="anatomy-search" 
              placeholder="Search bones, muscles, organs... (e.g., 'femur', 'bicep', 'heart')"
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(102, 126, 234, 0.3); border-radius: 4px; color: #fff; font-size: 14px;"
              oninput="anatomySearch(this.value)"
              onkeydown="if(event.key==='Enter') anatomySearchEnter()"
            />
            <div id="search-suggestions" style="margin-top: 5px; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.5); border-radius: 4px; display: none;"></div>
            <div id="search-results-count" style="margin-top: 5px; color: rgba(255,255,255,0.6); font-size: 12px;"></div>
          </div>
        </div>

        <!-- System Filters -->
        <div class="section">
          <div class="section-title">üéØ Filter by System</div>
          <div style="padding: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
            <button class="filter-btn active" data-system="all" onclick="filterBySystem('all', this)" style="background: rgba(102, 126, 234, 0.3); border: 1px solid rgba(102, 126, 234, 0.5); border-radius: 4px; padding: 8px 15px; color: #fff; cursor: pointer; font-size: 13px;">
              üåü All Systems
            </button>
            <button class="filter-btn" data-system="skeletal" onclick="filterBySystem('skeletal', this)" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 8px 15px; color: #fff; cursor: pointer; font-size: 13px;">
              ü¶¥ Skeletal
            </button>
            <button class="filter-btn" data-system="muscular" onclick="filterBySystem('muscular', this)" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 8px 15px; color: #fff; cursor: pointer; font-size: 13px;">
              üí™ Muscular
            </button>
            <button class="filter-btn" data-system="nervous" onclick="filterBySystem('nervous', this)" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 8px 15px; color: #fff; cursor: pointer; font-size: 13px;">
              üß† Nervous
            </button>
            <button class="filter-btn" data-system="circulatory" onclick="filterBySystem('circulatory', this)" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 8px 15px; color: #fff; cursor: pointer; font-size: 13px;">
              ‚ù§Ô∏è Circulatory
            </button>
            <button class="filter-btn" data-system="respiratory" onclick="filterBySystem('respiratory', this)" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 8px 15px; color: #fff; cursor: pointer; font-size: 13px;">
              ü´Å Respiratory
            </button>
            <button class="filter-btn" data-system="digestive" onclick="filterBySystem('digestive', this)" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 8px 15px; color: #fff; cursor: pointer; font-size: 13px;">
              ü´É Digestive
            </button>
          </div>
        </div>

        <!-- Highlighted Structures List -->
        <div class="section">
          <div class="section-title">‚ú® Found Structures</div>
          <div id="found-structures-list" style="padding: 10px; color: rgba(255,255,255,0.7); font-size: 13px;">
            <div style="color: rgba(255,255,255,0.4);">Search or filter to find anatomical structures...</div>
          </div>
        </div>

        <!-- Quick Actions -->
        <div class="section">
          <div class="section-title">‚ö° Quick Actions</div>
          <div style="padding: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <button onclick="showAllAnatomy()" style="background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); border-radius: 4px; padding: 10px; color: #fff; cursor: pointer; font-size: 13px;">
              üëÅÔ∏è Show All
            </button>
            <button onclick="hideAllAnatomy()" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 10px; color: #fff; cursor: pointer; font-size: 13px;">
              üôà Hide All
            </button>
            <button onclick="resetAnatomyView()" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 10px; color: #fff; cursor: pointer; font-size: 13px;">
              üîÑ Reset View
            </button>
            <button onclick="focusOnSelected()" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 10px; color: #fff; cursor: pointer; font-size: 13px;">
              üéØ Focus Selected
            </button>
          </div>
        </div>

        <!-- Layer Visibility Toggle -->
        <div class="section">
          <div class="section-title">üëÅÔ∏è Layer Visibility</div>
          <div style="padding: 10px;">
            <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer; color: rgba(255,255,255,0.8);">
              <input type="checkbox" id="layer-skeleton" checked onchange="toggleLayer('skeleton', this.checked)" style="margin-right: 10px; cursor: pointer;">
              ü¶¥ Skeleton
            </label>
            <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer; color: rgba(255,255,255,0.8);">
              <input type="checkbox" id="layer-muscles" onchange="toggleLayer('muscles', this.checked)" style="margin-right: 10px; cursor: pointer;">
              üí™ Muscles
            </label>
            <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer; color: rgba(255,255,255,0.8);">
              <input type="checkbox" id="layer-organs" onchange="toggleLayer('organs', this.checked)" style="margin-right: 10px; cursor: pointer;">
              ü´Ä Organs
            </label>
            <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer; color: rgba(255,255,255,0.8);">
              <input type="checkbox" id="layer-skin" onchange="toggleLayer('skin', this.checked)" style="margin-right: 10px; cursor: pointer;">
              üë§ Skin
            </label>
            <div style="margin-top: 15px;">
              <label style="color: rgba(255,255,255,0.7); font-size: 13px; display: block; margin-bottom: 5px;">
                Layer Transparency: <span id="layer-opacity-value">100</span>%
              </label>
              <input type="range" id="layer-opacity" min="0" max="100" value="100" oninput="updateLayerOpacity(this.value)" style="width: 100%; cursor: pointer;">
            </div>
          </div>
        </div>

        <!-- Voice Search (VR Mode) -->
        <div class="section">
          <div class="section-title">üé§ Voice Search (VR)</div>
          <div style="padding: 10px;">
            <button id="voice-search-btn" onclick="startVoiceSearch()" style="width: 100%; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); border-radius: 4px; padding: 12px; color: #fff; cursor: pointer; font-size: 14px;">
              üé§ Start Voice Search
            </button>
            <div id="voice-search-status" style="margin-top: 8px; color: rgba(255,255,255,0.5); font-size: 12px; text-align: center;"></div>
          </div>
        </div>

        <!-- Educational Info Panel -->
        <div class="section">
          <div class="section-title">üìö Selected Structure Info</div>
          <div id="anatomy-info-panel" style="padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px; min-height: 100px;">
            <div style="color: rgba(255,255,255,0.4); font-size: 13px;">
              Click on a bone or structure in the 3D view to see details...
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="viewport">
      <canvas id="canvas"></canvas>
      <div class="loading" id="loading">Initializing 3D Engine...</div>
    </div>

    <div id="footer">
      <div>Workspace: <strong id="workspaceDisplay">3D SCULPT</strong> | Mode: <strong id="modeDisplay">ADD</strong> | Primitive: <strong id="primitiveDisplay">SPHERE</strong></div>
      <div>Click viewport to place objects | Drag to rotate view</div>
      <div>Objects: <strong id="objectCount">0</strong> | Vertices: <strong id="vertexCount">0</strong></div>
    </div>
  </div>

  <script src="lib/three.min.js"></script>
  <script src="lib/OrbitControls.js"></script>
  <script src="lib/TransformControls.js"></script>
  <script src="document3d_canvas.js"></script>
  
  <!-- VRButton Implementation -->
  <script>
    // VRButton fallback for CDN issues
    if (typeof THREE !== 'undefined' && !window.VRButton) {
      const VRButton = {
        createButton: function(renderer) {
          const button = document.createElement('button');
          
          function showEnterVR() {
            button.style.display = '';
            button.style.cursor = 'pointer';
            button.style.left = 'calc(50% - 50px)';
            button.style.width = '100px';
            button.textContent = 'ENTER VR';
            
            button.onmouseenter = function() {
              button.style.opacity = '1.0';
            };
            
            button.onmouseleave = function() {
              button.style.opacity = '0.5';
            };
            
            button.onclick = function() {
              if (renderer.xr.isPresenting === false) {
                renderer.xr.getSession().then(() => {});
              } else {
                renderer.xr.getSession().end();
              }
            };
          }
          
          function disableButton() {
            button.style.display = '';
            button.style.cursor = 'auto';
            button.style.left = 'calc(50% - 75px)';
            button.style.width = '150px';
            button.onmouseenter = null;
            button.onmouseleave = null;
            button.onclick = null;
          }
          
          function showWebXRNotFound() {
            disableButton();
            button.textContent = 'VR NOT SUPPORTED';
          }
          
          function showVRNotAllowed(exception) {
            disableButton();
            console.warn('Exception when trying to call xr.isSessionSupported', exception);
            button.textContent = 'VR NOT ALLOWED';
          }
          
          function stylizeElement(element) {
            element.style.position = 'absolute';
            element.style.bottom = '20px';
            element.style.padding = '12px 6px';
            element.style.border = '1px solid #fff';
            element.style.borderRadius = '4px';
            element.style.background = 'rgba(0,0,0,0.1)';
            element.style.color = '#fff';
            element.style.font = 'normal 13px sans-serif';
            element.style.textAlign = 'center';
            element.style.opacity = '0.5';
            element.style.outline = 'none';
            element.style.zIndex = '999';
          }
          
          if ('xr' in navigator) {
            button.id = 'VRButton';
            button.style.display = 'none';
            
            stylizeElement(button);
            
            navigator.xr.isSessionSupported('immersive-vr').then(function(supported) {
              supported ? showEnterVR() : showWebXRNotFound();
              
              if (supported && renderer.xr.isPresenting) {
                button.textContent = 'EXIT VR';
              }
            }).catch(showVRNotAllowed);
            
            return button;
          } else {
            const message = document.createElement('a');
            
            if (window.isSecureContext === false) {
              message.href = document.location.href.replace(/^http:/, 'https:');
              message.innerHTML = 'WEBXR NEEDS HTTPS';
            } else {
              message.href = 'https://immersiveweb.dev/';
              message.innerHTML = 'WEBXR NOT AVAILABLE';
            }
            
            message.style.left = 'calc(50% - 90px)';
            message.style.width = '180px';
            message.style.textDecoration = 'none';
            
            stylizeElement(message);
            
            return message;
          }
        }
      };
      
      window.VRButton = VRButton;
    }
  </script>
  
  <!-- Load FontLoader and TextGeometry for WordWeaver -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
  
  <script>
    // State
    let scene, camera, renderer, controls, transformControl;
    let currentMode = 'add';
    let currentPrimitive = 'sphere';
    let primitiveSize = 0.5;
    let rotationAngle = 0;
    let objects = [];
    let selectedObject = null;
    let selectionBox = null; // Visual selection indicator
    let orbitEnabled = true; // Camera orbit control state
    let currentArmGroup = null; // Reference to loaded arm for articulation
    let armForearmPart = null; // Reference to forearm+hand section
    let currentHeadGroup = null; // Reference to loaded head
    let headNeckSwivel = null; // Reference to neck swivel group
    
    // Full body part references (for hierarchical selection)
    let fullBodyGroup = null;
    let bodyPartMap = new Map(); // Maps mesh objects to their body part names and control groups
    let selectedBodyPart = null; // Currently selected body part
    let bodyPartControlMode = null; // 'shoulder', 'elbow', 'wrist', 'hip', 'knee', 'ankle', 'neck'
    
    // Walking/Running animation state
    let walkModeEnabled = false; // Toggle between stationary animation and forward movement
    let thirdPersonCamera = 'auto'; // 'auto', 'always', 'never' - 3rd person camera mode
    let walkCycleSpeed = 0; // 0 = stopped, 1-3 = walking, 4+ = running
    let walkCyclePhase = 0; // Current phase in walk cycle (0 to 2*PI)
    let lastWheelTime = 0;
    let walkDecayRate = 0.95; // How quickly walking slows down
    let leftLegGroup = null; // Reference to left leg for animation
    let rightLegGroup = null; // Reference to right leg for animation
    let leftArmGroupRef = null; // Reference to left arm for swing
    let rightArmGroupRef = null; // Reference to right arm for swing
    let leftForearmGroup = null; // Reference to left forearm for elbow bend
    let rightForearmGroup = null; // Reference to right forearm for elbow bend
    let leftKneeGroup = null; // Reference to left lower leg (for knee flexion)
    let rightKneeGroup = null; // Reference to right lower leg (for knee flexion)
    let leftFootGroup = null; // Reference to left foot (for heel-toe placement)
    let rightFootGroup = null; // Reference to right foot (for heel-toe placement)
    
    // Advanced movement state
    let isJumping = false;
    let jumpVelocity = 0;
    let gravity = -0.02;
    let groundLevel = 0;
    let flightModeEnabled = false;
    let verticalVelocity = 0;
    
    // Movement input state (for smooth controls)
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let moveUp = false;
    let moveDown = false;
    let isRunning = false; // Shift key for running
    
    // VR State
    let vrEnabled = false;
    let vrIKEnabled = true; // Use IK solver for arm tracking
    let vrControllers = [];
    let controllerGrips = [];
    let leftController = null;
    let rightController = null;
    let leftHand = null;  // Reference to left arm/hand body part
    let rightHand = null; // Reference to right arm/hand body part
    let vrBodyOffset = new THREE.Vector3(0, -1.5, 0); // Body position relative to headset
    
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();

    // =====================================
    // üåå DIMENSIONAL WORKSPACE SYSTEM
    // Multi-Environment Manager with Isolated 3D Spaces
    // =====================================
    
    let currentDimension = 'skyrelics'; // Active workspace/dimension
    let dimensionalSpaces = {}; // Stores all workspace configurations
    let masterMatrixGrid = null; // Universal boundary grid
    
    /**
     * üéØ Dimensional Workspace Configuration
     * Each workspace is an isolated 3D universe with custom settings
     */
    const DIMENSIONAL_CONFIGS = {
      // ========================================
      // üè∞ SKYRELICS DIMENSIONS
      // ========================================
      
      skyrelics: {
        name: 'SkyRelics Main Plaza',
        icon: 'üè∞',
        description: 'Main hub - primitive 3D object creation',
        backgroundColor: 0x0a0a0a,
        fogColor: 0x0a0a0a,
        fogNear: 10,
        fogFar: 50,
        cameraPosition: { x: 5, y: 5, z: 5 },
        cameraTarget: { x: 0, y: 2, z: 0 },
        gridConfig: {
          size: 40,
          divisions: 40,
          centerColor: 0x667eea,
          gridColor: 0x334477,
          wallColor: 0x1a1a2e,
          showWalls: true,
          wallHeight: 20,
          wallOpacity: 0.3
        },
        lighting: {
          ambient: { color: 0x404040, intensity: 0.5 },
          directional: { color: 0xffffff, intensity: 0.8, position: { x: 10, y: 20, z: 10 } },
          point: { color: 0x667eea, intensity: 0.5, position: { x: 0, y: 10, z: 0 } }
        },
        previewText: 'Main creative workspace for building 3D primitives and structures'
      },
      
      skyrelics_forge: {
        name: 'The Forge',
        icon: 'üî•',
        description: 'Advanced object manipulation and material crafting',
        backgroundColor: 0x1a0a00,
        fogColor: 0x1a0a00,
        fogNear: 8,
        fogFar: 40,
        cameraPosition: { x: 6, y: 4, z: 6 },
        cameraTarget: { x: 0, y: 2, z: 0 },
        gridConfig: {
          size: 30,
          divisions: 30,
          centerColor: 0xff6600,
          gridColor: 0x884422,
          wallColor: 0x2a1a0e,
          showWalls: true,
          wallHeight: 18,
          wallOpacity: 0.4
        },
        lighting: {
          ambient: { color: 0x603020, intensity: 0.6 },
          directional: { color: 0xffaa66, intensity: 0.9, position: { x: 8, y: 15, z: 8 } },
          point: [
            { color: 0xff6600, intensity: 0.8, position: { x: 0, y: 5, z: 0 } },
            { color: 0xff3300, intensity: 0.5, position: { x: -5, y: 3, z: -5 } }
          ]
        },
        previewText: 'Craft and refine materials with intense focused lighting'
      },
      
      skyrelics_sanctuary: {
        name: 'Crystal Sanctuary',
        icon: 'üíé',
        description: 'Precision modeling with crystalline grid structure',
        backgroundColor: 0x0a1a2a,
        fogColor: 0x0a1a2a,
        fogNear: 12,
        fogFar: 55,
        cameraPosition: { x: 7, y: 6, z: 7 },
        cameraTarget: { x: 0, y: 3, z: 0 },
        gridConfig: {
          size: 35,
          divisions: 45,
          centerColor: 0x00ffff,
          gridColor: 0x4488cc,
          wallColor: 0x0a1a2a,
          showWalls: true,
          wallHeight: 22,
          wallOpacity: 0.5,
          crystalline: true
        },
        lighting: {
          ambient: { color: 0x304050, intensity: 0.7 },
          directional: { color: 0xccffff, intensity: 0.7, position: { x: 12, y: 18, z: 12 } },
          point: [
            { color: 0x00ffff, intensity: 0.6, position: { x: 0, y: 8, z: 0 } },
            { color: 0x4488cc, intensity: 0.4, position: { x: 5, y: 6, z: 5 } }
          ]
        },
        previewText: 'High-precision workspace with crystalline reference grid'
      },
      
      skyrelics_observatory: {
        name: 'Sky Observatory',
        icon: 'üî≠',
        description: 'Large-scale construction with elevated perspective',
        backgroundColor: 0x0a0a1a,
        fogColor: 0x0a0a1a,
        fogNear: 20,
        fogFar: 100,
        cameraPosition: { x: 15, y: 15, z: 15 },
        cameraTarget: { x: 0, y: 5, z: 0 },
        gridConfig: {
          size: 60,
          divisions: 60,
          centerColor: 0xffdd66,
          gridColor: 0x4466aa,
          wallColor: 0x0a0a1a,
          showWalls: true,
          wallHeight: 30,
          wallOpacity: 0.2
        },
        lighting: {
          ambient: { color: 0x303050, intensity: 0.4 },
          directional: { color: 0xffffee, intensity: 1.0, position: { x: 20, y: 30, z: 20 } },
          point: { color: 0xffdd66, intensity: 0.7, position: { x: 0, y: 20, z: 0 } }
        },
        previewText: 'Massive workspace for large-scale architectural projects'
      },
      
      // ========================================
      // ‚úçÔ∏è WORDWEAVER DIMENSIONS
      // ========================================
      
      wordweaver: {
        name: 'WordWeaver Studio',
        icon: '‚úçÔ∏è',
        description: '3D text materialization and document creation',
        backgroundColor: 0x0a0a1a,
        fogColor: 0x0a0a1a,
        fogNear: 15,
        fogFar: 60,
        cameraPosition: { x: 0, y: 8, z: 15 },
        cameraTarget: { x: 0, y: 8, z: 0 },
        gridConfig: {
          size: 50,
          divisions: 40,
          centerColor: 0x00ff00,
          gridColor: 0x667eea,
          wallColor: 0x0a0a1a,
          showWalls: true,
          wallHeight: 30,
          wallOpacity: 0.6,
          backwallZ: -8 // Special backwall for text reference
        },
        lighting: {
          ambient: { color: 0x606060, intensity: 0.7 },
          directional: { color: 0xffffff, intensity: 0.6, position: { x: 5, y: 15, z: 10 } },
          point: { color: 0x667eea, intensity: 0.3, position: { x: 0, y: 8, z: -5 } }
        },
        previewText: 'Letters materialize from center outward. Matrix walls adapt to material type.'
      },
      
      // ========================================
      // ü¶¥ ANATOMY DIMENSIONS
      // ========================================
      
      anatomy: {
        name: 'Anatomical Explorer',
        icon: 'ü¶¥',
        description: 'Human anatomy visualization and medical education',
        backgroundColor: 0x1a1a1a,
        fogColor: 0x1a1a1a,
        fogNear: 20,
        fogFar: 80,
        cameraPosition: { x: 8, y: 3, z: 8 },
        cameraTarget: { x: 0, y: 2, z: 0 },
        gridConfig: {
          size: 30,
          divisions: 30,
          centerColor: 0xff6b6b,
          gridColor: 0x4a4a4a,
          wallColor: 0x1a1a1a,
          showWalls: true,
          wallHeight: 15,
          wallOpacity: 0.4,
          circular: true // Circular grid for 360¬∞ viewing
        },
        lighting: {
          ambient: { color: 0x505050, intensity: 0.6 },
          directional: { color: 0xffffff, intensity: 1.0, position: { x: 10, y: 10, z: 10 } },
          point: [
            { color: 0xff6b6b, intensity: 0.4, position: { x: -5, y: 5, z: 5 } },
            { color: 0x6bcfff, intensity: 0.4, position: { x: 5, y: 5, z: -5 } }
          ]
        },
        previewText: 'Explore skeletal system, muscles, organs. Search anatomical structures.'
      },
      
      // ========================================
      // ‚ú® PERFECT & SPECIAL DIMENSIONS
      // ========================================
      
      perfect: {
        name: 'Perfect Universe',
        icon: '‚ú®',
        description: 'Ideal world creation and procedural generation',
        backgroundColor: 0x1a0a2e,
        fogColor: 0x1a0a2e,
        fogNear: 10,
        fogFar: 50,
        cameraPosition: { x: 10, y: 5, z: 10 },
        cameraTarget: { x: 0, y: 0, z: 0 },
        gridConfig: {
          size: 50,
          divisions: 50,
          centerColor: 0xffd700,
          gridColor: 0x8b00ff,
          wallColor: 0x1a0a2e,
          showWalls: true,
          wallHeight: 25,
          wallOpacity: 0.5
        },
        lighting: {
          ambient: { color: 0x404040, intensity: 0.5 },
          directional: { color: 0xffd700, intensity: 0.7, position: { x: 15, y: 20, z: 15 } },
          point: { color: 0x8b00ff, intensity: 0.6, position: { x: 0, y: 15, z: 0 } }
        },
        previewText: 'Procedural world generation. Golden ratio proportions. Purple-gold aesthetic.'
      },
      
      // ========================================
      // üåç SKYRELICS ENVIRONMENTAL VARIANTS
      // ========================================
      
      skyrelics_mirror: {
        name: 'Mirror Dimension',
        icon: 'ü™û',
        description: 'Reflective kaleidoscope reality - symmetry exploration',
        backgroundColor: 0x0f0f1f,
        fogColor: 0x1a1a2e,
        fogNear: 5,
        fogFar: 45,
        cameraPosition: { x: 6, y: 6, z: 6 },
        cameraTarget: { x: 0, y: 2, z: 0 },
        gridConfig: {
          size: 40,
          divisions: 40,
          centerColor: 0xccffff,
          gridColor: 0x4488ff,
          wallColor: 0x1a1a3e,
          showWalls: true,
          wallHeight: 20,
          wallOpacity: 0.7,
          reflective: true
        },
        lighting: {
          ambient: { color: 0x606080, intensity: 0.8 },
          directional: { color: 0xffffff, intensity: 1.2, position: { x: 10, y: 20, z: 10 } },
          point: [
            { color: 0xccffff, intensity: 0.9, position: { x: 0, y: 10, z: 0 } },
            { color: 0xff88ff, intensity: 0.6, position: { x: -8, y: 5, z: -8 } }
          ]
        },
        previewText: 'Everything reflects. Create symmetrical designs with kaleidoscope effects.'
      },
      
      skyrelics_desert: {
        name: 'Desert Oasis',
        icon: 'üèúÔ∏è',
        description: 'Vast sandy expanse with heat shimmer effects',
        backgroundColor: 0x2a1a0a,
        fogColor: 0x4a3a2a,
        fogNear: 15,
        fogFar: 70,
        cameraPosition: { x: 8, y: 5, z: 8 },
        cameraTarget: { x: 0, y: 0, z: 0 },
        gridConfig: {
          size: 50,
          divisions: 50,
          centerColor: 0xffdd88,
          gridColor: 0xaa8844,
          wallColor: 0x3a2a1a,
          showWalls: false,
          wallHeight: 0,
          wallOpacity: 0
        },
        lighting: {
          ambient: { color: 0x8a6a4a, intensity: 0.9 },
          directional: { color: 0xffffcc, intensity: 1.5, position: { x: 20, y: 40, z: 10 } },
          point: { color: 0xffaa44, intensity: 0.7, position: { x: 0, y: 2, z: 0 } }
        },
        previewText: 'Build sand castles, pyramids, and desert monuments under harsh sun.'
      },
      
      skyrelics_tundra: {
        name: 'Frozen Tundra',
        icon: '‚ùÑÔ∏è',
        description: 'Icy wasteland with aurora borealis and crystalline structures',
        backgroundColor: 0x0a1a2a,
        fogColor: 0x1a2a3a,
        fogNear: 10,
        fogFar: 80,
        cameraPosition: { x: 7, y: 6, z: 7 },
        cameraTarget: { x: 0, y: 1, z: 0 },
        gridConfig: {
          size: 45,
          divisions: 45,
          centerColor: 0xaaffff,
          gridColor: 0x4488cc,
          wallColor: 0x1a2a3a,
          showWalls: true,
          wallHeight: 18,
          wallOpacity: 0.5,
          icy: true
        },
        lighting: {
          ambient: { color: 0x4a6a8a, intensity: 0.6 },
          directional: { color: 0xeeffff, intensity: 0.8, position: { x: 15, y: 25, z: 15 } },
          point: [
            { color: 0x00ffaa, intensity: 0.7, position: { x: -10, y: 15, z: 0 } }, // Aurora green
            { color: 0xff00ff, intensity: 0.5, position: { x: 10, y: 15, z: 0 } }  // Aurora magenta
          ]
        },
        previewText: 'Sculpt ice formations and igloos. Watch aurora lights dance overhead.'
      },
      
      skyrelics_monsoon: {
        name: 'Monsoon Temple',
        icon: 'üåßÔ∏è',
        description: 'Ancient ruins in perpetual rainfall with thunder effects',
        backgroundColor: 0x1a1a2a,
        fogColor: 0x2a2a3a,
        fogNear: 8,
        fogFar: 50,
        cameraPosition: { x: 6, y: 5, z: 6 },
        cameraTarget: { x: 0, y: 2, z: 0 },
        gridConfig: {
          size: 35,
          divisions: 35,
          centerColor: 0x6699ff,
          gridColor: 0x334466,
          wallColor: 0x1a1a2a,
          showWalls: true,
          wallHeight: 20,
          wallOpacity: 0.6,
          wet: true
        },
        lighting: {
          ambient: { color: 0x404060, intensity: 0.5 },
          directional: { color: 0x8899cc, intensity: 0.7, position: { x: 10, y: 20, z: 10 } },
          point: { color: 0x6699ff, intensity: 0.8, position: { x: 0, y: 12, z: 0 } }
        },
        previewText: 'Build in the rain. Wet surfaces glisten. Thunder rumbles in distance.'
      },
      
      skyrelics_mountain: {
        name: 'Mountain Peak',
        icon: '‚õ∞Ô∏è',
        description: 'High-altitude construction above the clouds',
        backgroundColor: 0x1a2a3a,
        fogColor: 0x3a4a5a,
        fogNear: 20,
        fogFar: 90,
        cameraPosition: { x: 12, y: 12, z: 12 },
        cameraTarget: { x: 0, y: 3, z: 0 },
        gridConfig: {
          size: 50,
          divisions: 50,
          centerColor: 0xccddff,
          gridColor: 0x778899,
          wallColor: 0x2a3a4a,
          showWalls: true,
          wallHeight: 25,
          wallOpacity: 0.4
        },
        lighting: {
          ambient: { color: 0x7788aa, intensity: 0.7 },
          directional: { color: 0xffffee, intensity: 1.3, position: { x: 25, y: 40, z: 15 } },
          point: { color: 0xccddff, intensity: 0.5, position: { x: 0, y: 20, z: 0 } }
        },
        previewText: 'Build mountain temples. Thin air, crisp lighting, clouds below you.'
      },
      
      skyrelics_space: {
        name: 'Deep Space Station',
        icon: 'üåå',
        description: 'Zero-gravity construction in the void between stars',
        backgroundColor: 0x000005,
        fogColor: 0x000000,
        fogNear: 30,
        fogFar: 150,
        cameraPosition: { x: 10, y: 8, z: 10 },
        cameraTarget: { x: 0, y: 0, z: 0 },
        gridConfig: {
          size: 60,
          divisions: 60,
          centerColor: 0x6666ff,
          gridColor: 0x222244,
          wallColor: 0x000011,
          showWalls: false,
          wallHeight: 0,
          wallOpacity: 0
        },
        lighting: {
          ambient: { color: 0x0a0a1a, intensity: 0.2 },
          directional: { color: 0xffffff, intensity: 0.6, position: { x: 30, y: 20, z: 30 } },
          point: [
            { color: 0x6666ff, intensity: 1.0, position: { x: 0, y: 0, z: 0 } }, // Star nearby
            { color: 0xff6666, intensity: 0.4, position: { x: -20, y: 10, z: -20 } } // Distant star
          ]
        },
        previewText: 'Construct space stations. Stars twinkle. Nebula clouds drift past.'
      },
      
      skyrelics_underwater: {
        name: 'Coral Reef Cathedral',
        icon: 'üê†',
        description: 'Sunken world with caustic light rays and aquatic life',
        backgroundColor: 0x0a1a2a,
        fogColor: 0x1a3a5a,
        fogNear: 5,
        fogFar: 40,
        cameraPosition: { x: 6, y: 5, z: 6 },
        cameraTarget: { x: 0, y: 2, z: 0 },
        gridConfig: {
          size: 35,
          divisions: 35,
          centerColor: 0x00ffdd,
          gridColor: 0x4488aa,
          wallColor: 0x1a2a3a,
          showWalls: true,
          wallHeight: 18,
          wallOpacity: 0.7,
          underwater: true
        },
        lighting: {
          ambient: { color: 0x2a4a6a, intensity: 0.8 },
          directional: { color: 0x88ccff, intensity: 0.9, position: { x: 10, y: 25, z: 10 } }, // Sunlight from above
          point: [
            { color: 0x00ffdd, intensity: 0.6, position: { x: 0, y: 8, z: 0 } },
            { color: 0xff6699, intensity: 0.4, position: { x: -6, y: 4, z: -6 } } // Bioluminescence
          ]
        },
        previewText: 'Build coral structures. Caustic light dances. Bubbles float upward.'
      },
      
      skyrelics_volcanic: {
        name: 'Volcanic Forge',
        icon: 'üåã',
        description: 'Active lava flows and intense heat - extreme crafting',
        backgroundColor: 0x2a0a0a,
        fogColor: 0x4a1a0a,
        fogNear: 5,
        fogFar: 35,
        cameraPosition: { x: 7, y: 6, z: 7 },
        cameraTarget: { x: 0, y: 2, z: 0 },
        gridConfig: {
          size: 32,
          divisions: 32,
          centerColor: 0xff3300,
          gridColor: 0x883311,
          wallColor: 0x331100,
          showWalls: true,
          wallHeight: 16,
          wallOpacity: 0.5,
          molten: true
        },
        lighting: {
          ambient: { color: 0x6a2a1a, intensity: 0.7 },
          directional: { color: 0xffaa44, intensity: 0.8, position: { x: 12, y: 18, z: 12 } },
          point: [
            { color: 0xff3300, intensity: 1.2, position: { x: 0, y: 0, z: 0 } }, // Lava pool center
            { color: 0xff6600, intensity: 0.9, position: { x: 5, y: 2, z: 5 } },
            { color: 0xff9933, intensity: 0.7, position: { x: -5, y: 3, z: -5 } }
          ]
        },
        previewText: 'Forge in extreme heat. Lava glows, embers float, obsidian forms.'
      },
      
      skyrelics_crystal_cave: {
        name: 'Bioluminescent Cavern',
        icon: 'üí†',
        description: 'Underground crystal cave with glowing minerals',
        backgroundColor: 0x0a0a1a,
        fogColor: 0x1a1a2a,
        fogNear: 8,
        fogFar: 45,
        cameraPosition: { x: 8, y: 5, z: 8 },
        cameraTarget: { x: 0, y: 2, z: 0 },
        gridConfig: {
          size: 38,
          divisions: 38,
          centerColor: 0x00ff88,
          gridColor: 0x4488cc,
          wallColor: 0x1a1a2a,
          showWalls: true,
          wallHeight: 20,
          wallOpacity: 0.6,
          bioluminescent: true
        },
        lighting: {
          ambient: { color: 0x2a3a4a, intensity: 0.4 },
          directional: { color: 0x6688aa, intensity: 0.3, position: { x: 8, y: 12, z: 8 } },
          point: [
            { color: 0x00ff88, intensity: 0.8, position: { x: 0, y: 5, z: 0 } },    // Green glow
            { color: 0xff00ff, intensity: 0.6, position: { x: 6, y: 4, z: 6 } },    // Magenta crystal
            { color: 0x00ffff, intensity: 0.7, position: { x: -6, y: 6, z: -6 } }   // Cyan mineral
          ]
        },
        previewText: 'Deep underground. Crystals glow with inner light. Minerals shimmer.'
      },
      
      skyrelics_cyberpunk: {
        name: 'Neon Nexus',
        icon: 'üåÉ',
        description: 'Futuristic cityscape with holographic advertisements',
        backgroundColor: 0x0a0a1a,
        fogColor: 0x1a1a3a,
        fogNear: 10,
        fogFar: 60,
        cameraPosition: { x: 8, y: 7, z: 8 },
        cameraTarget: { x: 0, y: 3, z: 0 },
        gridConfig: {
          size: 42,
          divisions: 42,
          centerColor: 0xff00ff,
          gridColor: 0x00ffff,
          wallColor: 0x1a1a3a,
          showWalls: true,
          wallHeight: 24,
          wallOpacity: 0.5,
          neon: true
        },
        lighting: {
          ambient: { color: 0x3a2a4a, intensity: 0.6 },
          directional: { color: 0x8888ff, intensity: 0.5, position: { x: 10, y: 20, z: 10 } },
          point: [
            { color: 0xff00ff, intensity: 0.9, position: { x: -5, y: 8, z: 0 } },  // Magenta neon
            { color: 0x00ffff, intensity: 0.9, position: { x: 5, y: 6, z: 0 } },   // Cyan neon
            { color: 0xffff00, intensity: 0.7, position: { x: 0, y: 10, z: -5 } }  // Yellow holo
          ]
        },
        previewText: 'High-tech urban jungle. Neon lights pulse. Holograms flicker.'
      },
      
      // ========================================
      // üíÄ SKELETOR LAND (Special Game Dimension)
      // ========================================
      
      skeletor_land: {
        name: 'Skeletor\'s Domain',
        icon: 'üíÄ',
        description: 'Chase Skeletor for rewards! Comedy gold mine with AI banter',
        backgroundColor: 0x1a0a2a,
        fogColor: 0x2a1a3a,
        fogNear: 10,
        fogFar: 60,
        cameraPosition: { x: 8, y: 4, z: 8 },
        cameraTarget: { x: 0, y: 2, z: 0 },
        gridConfig: {
          size: 50,
          divisions: 50,
          centerColor: 0xaa00ff,
          gridColor: 0x440066,
          wallColor: 0x1a0a2a,
          showWalls: true,
          wallHeight: 22,
          wallOpacity: 0.4,
          haunted: true
        },
        lighting: {
          ambient: { color: 0x3a2a4a, intensity: 0.5 },
          directional: { color: 0xaa88ff, intensity: 0.7, position: { x: 12, y: 18, z: 12 } },
          point: [
            { color: 0xaa00ff, intensity: 0.9, position: { x: 0, y: 5, z: 0 } },   // Purple evil glow
            { color: 0xff0066, intensity: 0.6, position: { x: -8, y: 4, z: 8 } },  // Magenta mystery
            { color: 0x00ff00, intensity: 0.4, position: { x: 8, y: 3, z: -8 } }   // Toxic green
          ]
        },
        previewText: 'NYAH! Catch me for rewards! Blockchain tokenomics, legendary loot drops!',
        isGameMode: true,
        gameConfig: {
          type: 'chase',
          target: 'skeletor',
          aiPersonality: 'skeletor_comedian',
          rewards: {
            tokens: true,
            health: true,
            powerups: true,
            skins: true,
            rarities: ['common', 'rare', 'epic', 'legendary']
          }
        }
      },
      
      // ========================================
      // üé™ VENUESPRO SHOWCASE DIMENSION
      // ========================================
      
      venuespro: {
        name: 'VenuesPro Showcase',
        icon: 'üé™',
        description: '3D webpage gallery - interactive iframe displays for events & celebrations',
        backgroundColor: 0x0f0f1a,
        fogColor: 0x1a1a2a,
        fogNear: 15,
        fogFar: 80,
        cameraPosition: { x: 0, y: 6, z: 25 },
        cameraTarget: { x: 0, y: 4, z: 0 },
        gridConfig: {
          size: 70,
          divisions: 70,
          centerColor: 0x4a90e2,
          gridColor: 0x2a4a6a,
          wallColor: 0x1a2a3a,
          showWalls: true,
          wallHeight: 26,
          wallOpacity: 0.3,
          gallery: true
        },
        lighting: {
          ambient: { color: 0x3a3a4a, intensity: 0.7 },
          directional: { color: 0xffffff, intensity: 0.8, position: { x: 0, y: 20, z: 10 } },
          point: [
            { color: 0x4a90e2, intensity: 1.0, position: { x: 0, y: 10, z: 0 } },   // Spotlight center
            { color: 0xffffff, intensity: 0.6, position: { x: -12, y: 8, z: 0 } },  // Left gallery light
            { color: 0xffffff, intensity: 0.6, position: { x: 12, y: 8, z: 0 } }    // Right gallery light
          ]
        },
        previewText: 'Interactive webpage gallery. Scroll iframe displays. Event marketing showcase.',
        isGalleryMode: true,
        venueConfig: {
          layouts: [
            {
              name: 'Corporate Professional',
              category: 'business',
              style: 'minimalist_corporate',
              keywords: ['business', 'professional', 'corporate', 'enterprise', 'B2B', 'consulting', 'finance'],
              position: { x: -15, y: 4, z: 0 },
              color: 0x2a4a8a,
              targetAudience: 'Business conferences, corporate events, professional networking'
            },
            {
              name: 'Modern Startup',
              category: 'business',
              style: 'tech_startup',
              keywords: ['startup', 'tech', 'innovation', 'SaaS', 'modern', 'agile', 'disruptive'],
              position: { x: -8, y: 4, z: 0 },
              color: 0x6a4ac2,
              targetAudience: 'Product launches, pitch events, hackathons, tech conferences'
            },
            {
              name: 'Cyberpunk Edge',
              category: 'creative',
              style: 'cyberpunk_neon',
              keywords: ['cyberpunk', 'futuristic', 'neon', 'edgy', 'gaming', 'esports', 'metaverse'],
              position: { x: -1, y: 4, z: 0 },
              color: 0xff00ff,
              targetAudience: 'Gaming tournaments, VR events, NFT showcases, crypto conferences'
            },
            {
              name: 'Elegant Wedding',
              category: 'celebration',
              style: 'wedding_elegant',
              keywords: ['wedding', 'marriage', 'elegant', 'romantic', 'ceremony', 'reception', 'bridal'],
              position: { x: 6, y: 4, z: 0 },
              color: 0xffd4e5,
              targetAudience: 'Weddings, engagement parties, vow renewals, bridal showers'
            },
            {
              name: 'Birthday Bash',
              category: 'celebration',
              style: 'birthday_festive',
              keywords: ['birthday', 'party', 'celebration', 'festive', 'milestone', 'anniversary'],
              position: { x: 13, y: 4, z: 0 },
              color: 0xffaa00,
              targetAudience: 'Birthday parties, milestone celebrations, surprise parties'
            },
            {
              name: 'Family Reunion',
              category: 'celebration',
              style: 'reunion_warm',
              keywords: ['reunion', 'family', 'gathering', 'homecoming', 'heritage', 'legacy'],
              position: { x: 20, y: 4, z: 0 },
              color: 0x66aa44,
              targetAudience: 'Family reunions, homecomings, memorial services, heritage events'
            },
            {
              name: 'Career Milestone',
              category: 'professional',
              style: 'career_achievement',
              keywords: ['promotion', 'job', 'career', 'achievement', 'LinkedIn', 'professional', 'raise'],
              position: { x: -15, y: 4, z: -8 },
              color: 0x0077b5,
              targetAudience: 'Promotions, job placements, career fairs, LinkedIn events, salary negotiations'
            },
            {
              name: 'Retirement Gala',
              category: 'professional',
              style: 'retirement_honor',
              keywords: ['retirement', 'honor', 'legacy', 'farewell', 'milestone', 'career'],
              position: { x: -8, y: 4, z: -8 },
              color: 0xaa8844,
              targetAudience: 'Retirement parties, farewell events, career retrospectives'
            },
            {
              name: 'Graduation Ceremony',
              category: 'celebration',
              style: 'graduation_academic',
              keywords: ['graduation', 'commencement', 'academic', 'achievement', 'diploma', 'degree'],
              position: { x: -1, y: 4, z: -8 },
              color: 0x4444aa,
              targetAudience: 'Graduations, commencements, academic achievements, scholarships'
            },
            {
              name: 'Holiday Festival',
              category: 'celebration',
              style: 'holiday_seasonal',
              keywords: ['holiday', 'festival', 'seasonal', 'Christmas', 'Thanksgiving', 'celebration'],
              position: { x: 6, y: 4, z: -8 },
              color: 0xdd4444,
              targetAudience: 'Holiday parties, seasonal celebrations, festival gatherings'
            },
            {
              name: 'Charity Fundraiser',
              category: 'professional',
              style: 'charity_nonprofit',
              keywords: ['charity', 'fundraiser', 'nonprofit', 'philanthropy', 'donation', 'cause'],
              position: { x: 13, y: 4, z: -8 },
              color: 0x44aa88,
              targetAudience: 'Fundraising galas, charity auctions, nonprofit events'
            },
            {
              name: 'Trade Show Booth',
              category: 'business',
              style: 'tradeshow_expo',
              keywords: ['trade show', 'expo', 'exhibition', 'booth', 'B2B', 'vendor', 'showcase'],
              position: { x: 20, y: 4, z: -8 },
              color: 0xaa6644,
              targetAudience: 'Trade shows, expos, vendor showcases, B2B exhibitions'
            }
          ],
          interactionConfig: {
            iframeEnabled: true,
            scrollEnabled: true,
            clickThrough: true,
            proximityActivation: 3.5,  // Units from camera to activate iframe
            displaySize: { width: 6, height: 4.5 },  // 3D plane size
            resolution: { width: 1920, height: 1080 }  // Iframe resolution
          },
          partnershipOpportunities: [
            {
              name: 'LinkedIn Integration',
              description: 'Career milestone celebrations, job placement announcements, professional networking events',
              potential: 'Partner for professional event marketing, job fair showcases, career advancement tracking',
              apis: ['LinkedIn API', 'Job Boards', 'Professional Networks']
            },
            {
              name: 'Wedding Industry',
              description: 'Bridal showcases, venue tours, vendor coordination, guest management',
              potential: 'Partner with wedding planners, venues, photographers, caterers',
              apis: ['Wedding Wire', 'The Knot', 'Eventbrite']
            },
            {
              name: 'Corporate Events',
              description: 'Conference planning, team building, product launches, shareholder meetings',
              potential: 'Partner with event management companies, corporate venues, AV providers',
              apis: ['Cvent', 'Bizzabo', 'Hopin']
            },
            {
              name: 'Blockchain Ticketing',
              description: 'NFT tickets, tokenized event access, proof of attendance, loyalty rewards',
              potential: 'Integrate with ticket marketplaces, create exclusive digital collectibles',
              apis: ['Polygon', 'Ethereum', 'IPFS']
            }
          ]
        }
      },
      
      navigator: {
        name: 'Spherical Navigator',
        icon: 'üéØ',
        description: 'Multi-layered spherical navigation - scroll to rotate layers, hover segments',
        backgroundColor: 0x000000,
        fogColor: 0x000000,
        fogNear: 5,
        fogFar: 40,
        cameraPosition: { x: 0, y: 0, z: 18 },
        cameraTarget: { x: 0, y: 0, z: 0 },
        gridConfig: {
          size: 60,
          divisions: 60,
          centerColor: 0x00ffff,
          gridColor: 0x00aaaa,
          wallColor: 0x001a1a,
          showWalls: false,
          wallHeight: 0,
          wallOpacity: 0
        },
        lighting: {
          ambient: { color: 0x202020, intensity: 0.4 },
          directional: { color: 0xffffff, intensity: 0.6, position: { x: 10, y: 20, z: 10 } },
          point: [
            { color: 0x00ffff, intensity: 1.0, position: { x: 0, y: 0, z: 0 } },
            { color: 0xff00ff, intensity: 0.8, position: { x: 10, y: 5, z: 10 } },
            { color: 0xffff00, intensity: 0.7, position: { x: -10, y: -5, z: -10 } }
          ]
        },
        previewText: 'Spherical dimension navigator. Scroll to rotate layers. Hover segments to explore.',
        isNavigator: true,
        sphericalNav: {
          enabled: true,
          radius: 8,
          layers: [
            {
              name: 'SkyRelics Core',
              category: 'skyrelics_core',
              angle: 0,
              dimensions: ['skyrelics', 'skyrelics_forge', 'skyrelics_sanctuary', 'skyrelics_observatory'],
              color: 0x667eea,
              icon: 'üè∞'
            },
            {
              name: 'Environmental Worlds',
              category: 'environments',
              angle: 60,
              dimensions: ['skyrelics_mirror', 'skyrelics_desert', 'skyrelics_tundra', 'skyrelics_monsoon'],
              color: 0x4a90e2,
              icon: 'üåç'
            },
            {
              name: 'Extreme Environments',
              category: 'extreme',
              angle: 120,
              dimensions: ['skyrelics_mountain', 'skyrelics_space', 'skyrelics_underwater', 'skyrelics_volcanic'],
              color: 0xe24a90,
              icon: '‚ö°'
            },
            {
              name: 'Tech & Crystal',
              category: 'tech',
              angle: 180,
              dimensions: ['skyrelics_crystal_cave', 'skyrelics_cyberpunk'],
              color: 0x9a4ae2,
              icon: 'üí†'
            },
            {
              name: 'Creative Tools',
              category: 'creative',
              angle: 240,
              dimensions: ['wordweaver', 'anatomy', 'perfect'],
              color: 0x4ae290,
              icon: '‚ú®'
            },
            {
              name: 'Business & Events',
              category: 'business',
              angle: 300,
              dimensions: ['venuespro'],
              color: 0xe2904a,
              icon: 'üé™'
            },
            {
              name: 'Game Worlds',
              category: 'games',
              angle: 360,
              dimensions: ['skeletor_land'],
              color: 0xaa00ff,
              icon: 'üíÄ'
            }
          ],
          segmentConfig: {
            segmentsPerLayer: 8,
            segmentHeight: 2.5,
            segmentThickness: 0.3,
            hoverScale: 1.3,
            hoverGlow: 2.0,
            rotationSpeed: 0.5,  // Degrees per scroll tick
            transitionTime: 0.5  // Seconds for smooth rotation
          }
        }
      }
    };

    // Initialize
    function init() {
      const canvas = document.getElementById('canvas');
      
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);
      scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);

      // Camera
      camera = new THREE.PerspectiveCamera(
        75,
        canvas.parentElement.offsetWidth / canvas.parentElement.offsetHeight,
        0.1,
        1000
      );
      camera.position.set(5, 5, 5);

      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.parentElement.offsetWidth, canvas.parentElement.offsetHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      
      // Enable VR support
      renderer.xr.enabled = true;
      
      // Add VR button to the page
      const vrButton = VRButton.createButton(renderer);
      document.body.appendChild(vrButton);
      vrButton.style.position = 'absolute';
      vrButton.style.bottom = '20px';
      vrButton.style.left = '50%';
      vrButton.style.transform = 'translateX(-50%)';
      vrButton.style.zIndex = '1000';
      
      // Setup VR controllers
      setupVRControllers();

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 2;
      controls.maxDistance = 50;

      // Transform Controls for object manipulation
      transformControl = new THREE.TransformControls(camera, renderer.domElement);
      transformControl.addEventListener('dragging-changed', function(event) {
        controls.enabled = !event.value;
      });
      scene.add(transformControl);
      
      // Keyboard: W=move, E=rotate, R=scale, Delete=remove, H=toggle sidebar
      window.addEventListener('keydown', function(event) {
        switch(event.key.toLowerCase()) {
          case 'h':
            // Toggle sidebar (H for Hide/Show)
            toggleSidebar();
            break;
          case 'w': 
            if (selectedObject) setTransformMode('translate');
            break;
          case 'e': 
            if (selectedObject) setTransformMode('rotate');
            break;
          case 'r': 
            if (selectedObject) setTransformMode('scale');
            break;
          case 'delete':
          case 'backspace':
            if (selectedObject) {
              scene.remove(selectedObject);
              objects = objects.filter(obj => obj !== selectedObject);
              transformControl.detach();
              selectedObject = null;
              
              // Remove selection box
              if (selectionBox) {
                scene.remove(selectionBox);
                selectionBox = null;
              }
              
              updateObjectCount();
            }
            break;
        }
      });

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 10, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0x667eea, 1, 100);
      pointLight.position.set(-5, 5, -5);
      scene.add(pointLight);

      // Ground plane
      const groundGeometry = new THREE.PlaneGeometry(50, 50);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a,
        roughness: 0.8,
        metalness: 0.2
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid
      const gridHelper = new THREE.GridHelper(50, 50, 0x667eea, 0x2a2a2a);
      scene.add(gridHelper);

      // Events
      canvas.addEventListener('click', onCanvasClick);
      canvas.addEventListener('mousemove', onCanvasMouseMove);
      canvas.addEventListener('wheel', onMouseWheel, { passive: false });
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);

      // Hide loading
      document.getElementById('loading').style.display = 'none';

      // Start animation
      animate();
    }
    
    // Keyboard controls for body movement
    function onKeyDown(event) {
      if (!window.fullBodyGroup) return;
      
      // Disable body controls when OrbitControls are active
      if (orbitEnabled) {
        return; // OrbitControls take priority
      }
      
      // Prevent default for space (no page scroll)
      if (event.key === ' ') {
        event.preventDefault();
      }
      
      switch(event.key.toLowerCase()) {
        case 'w':
        case 'arrowup':
          moveForward = true;
          if (!walkModeEnabled) {
            walkModeEnabled = true;
            controls.enabled = false;
            console.log('üö∂ Walk Mode: ENABLED');
          }
          break;
        case 's':
        case 'arrowdown':
          moveBackward = true;
          if (!walkModeEnabled) {
            walkModeEnabled = true;
            controls.enabled = false;
            console.log('üö∂ Walk Mode: ENABLED');
          }
          break;
        case 'a':
        case 'arrowleft':
          moveLeft = true;
          break;
        case 'd':
        case 'arrowright':
          moveRight = true;
          break;
        case ' ':
          // Jump (only if not in flight mode and on ground)
          if (!flightModeEnabled && !isJumping && Math.abs(window.fullBodyGroup.position.y - groundLevel) < 0.1) {
            isJumping = true;
            jumpVelocity = 0.3;
            console.log('‚¨ÜÔ∏è JUMP!');
          }
          break;
        case 'f':
          // Toggle flight mode
          flightModeEnabled = !flightModeEnabled;
          if (flightModeEnabled) {
            console.log('‚úàÔ∏è FLIGHT MODE: ENABLED (Superman pose)');
            isJumping = false;
            jumpVelocity = 0;
          } else {
            console.log('‚úàÔ∏è FLIGHT MODE: DISABLED');
          }
          break;
        case 'shift':
          // Hold shift for running OR ascend in flight mode
          isRunning = true;
          if (flightModeEnabled) {
            moveUp = true;
          }
          break;
        case 'control':
          // Hold ctrl for descend in flight mode
          if (flightModeEnabled) {
            moveDown = true;
          }
          break;
      }
    }
    
    function onKeyUp(event) {
      switch(event.key.toLowerCase()) {
        case 'w':
        case 'arrowup':
          moveForward = false;
          break;
        case 's':
        case 'arrowdown':
          moveBackward = false;
          break;
        case 'a':
        case 'arrowleft':
          moveLeft = false;
          break;
        case 'd':
        case 'arrowright':
          moveRight = false;
          break;
        case 'shift':
          isRunning = false;
          moveUp = false;
          break;
        case 'control':
          moveDown = false;
          break;
      }
    }

    // ========================================
    // VR CONTROLLER SETUP & BODY ATTACHMENT
    // ========================================
    
    function setupVRControllers() {
      console.log('ü•Ω Setting up VR controllers...');
      
      // Controller 0 (typically left hand)
      leftController = renderer.xr.getController(0);
      leftController.addEventListener('selectstart', onControllerSelectStart);
      leftController.addEventListener('selectend', onControllerSelectEnd);
      leftController.addEventListener('connected', function(event) {
        console.log('üéÆ Left controller connected:', event.data);
        this.add(buildControllerModel(event.data));
      });
      leftController.addEventListener('disconnected', function() {
        console.log('üéÆ Left controller disconnected');
        this.remove(this.children[0]);
      });
      scene.add(leftController);
      vrControllers.push(leftController);
      
      // Controller 1 (typically right hand)
      rightController = renderer.xr.getController(1);
      rightController.addEventListener('selectstart', onControllerSelectStart);
      rightController.addEventListener('selectend', onControllerSelectEnd);
      rightController.addEventListener('connected', function(event) {
        console.log('üéÆ Right controller connected:', event.data);
        this.add(buildControllerModel(event.data));
      });
      rightController.addEventListener('disconnected', function() {
        console.log('üéÆ Right controller disconnected');
        this.remove(this.children[0]);
      });
      scene.add(rightController);
      vrControllers.push(rightController);
      
      // Controller grips (for hand models)
      const leftGrip = renderer.xr.getControllerGrip(0);
      leftGrip.add(createHandModel('left'));
      scene.add(leftGrip);
      controllerGrips.push(leftGrip);
      
      const rightGrip = renderer.xr.getControllerGrip(1);
      rightGrip.add(createHandModel('right'));
      scene.add(rightGrip);
      controllerGrips.push(rightGrip);
      
      // Listen for VR session start/end
      renderer.xr.addEventListener('sessionstart', onVRSessionStart);
      renderer.xr.addEventListener('sessionend', onVRSessionEnd);
      
      console.log('‚úÖ VR controllers ready!');
    }
    
    function buildControllerModel(data) {
      // Simple line pointing forward from controller
      const geometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, -1)
      ]);
      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        linewidth: 2
      });
      return new THREE.Line(geometry, material);
    }
    
    function createHandModel(hand) {
      // Create a simple hand representation
      const handGroup = new THREE.Group();
      handGroup.name = `${hand}_hand_model`;
      
      // Palm
      const palmGeom = new THREE.BoxGeometry(0.08, 0.03, 0.12);
      const palmMat = new THREE.MeshStandardMaterial({ 
        color: 0xffdbac,
        roughness: 0.8,
        metalness: 0.1
      });
      const palm = new THREE.Mesh(palmGeom, palmMat);
      palm.name = `${hand}_palm`;
      handGroup.add(palm);
      
      // Fingers (simplified)
      for (let i = 0; i < 5; i++) {
        const fingerGeom = new THREE.CylinderGeometry(0.008, 0.008, 0.06, 8);
        const finger = new THREE.Mesh(fingerGeom, palmMat);
        finger.name = `${hand}_finger_${i}`;
        
        const xOffset = hand === 'left' ? 
          (0.03 - i * 0.015) : 
          (-0.03 + i * 0.015);
        
        finger.position.set(xOffset, 0, 0.06);
        finger.rotation.x = Math.PI / 2;
        handGroup.add(finger);
      }
      
      return handGroup;
    }
    
    function onControllerSelectStart(event) {
      const controller = event.target;
      console.log('üéÆ Controller select start', controller === leftController ? 'LEFT' : 'RIGHT');
      
      // Could implement grabbing objects here
      // For now, just log
    }
    
    function onControllerSelectEnd(event) {
      const controller = event.target;
      console.log('üéÆ Controller select end', controller === leftController ? 'LEFT' : 'RIGHT');
    }
    
    function onVRSessionStart() {
      console.log('ü•Ω ===== VR SESSION STARTED =====');
      vrEnabled = true;
      
      // Disable OrbitControls in VR
      if (orbitEnabled) {
        controls.enabled = false;
      }
      
      // Attach body to VR space if it exists
      if (window.fullBodyGroup) {
        attachBodyToVR();
      }
      
      console.log('‚úÖ VR mode active! Body will follow headset position.');
    }
    
    function onVRSessionEnd() {
      console.log('ü•Ω ===== VR SESSION ENDED =====');
      vrEnabled = false;
      
      // Re-enable OrbitControls
      if (orbitEnabled) {
        controls.enabled = true;
      }
      
      // Detach body from VR
      if (window.fullBodyGroup) {
        detachBodyFromVR();
      }
      
      console.log('‚úÖ Desktop mode restored.');
    }
    
    function attachBodyToVR() {
      console.log('ü¶¥ Attaching body to VR controllers...');
      
      if (!window.fullBodyGroup) {
        console.warn('‚ö†Ô∏è No body loaded to attach to VR!');
        return;
      }
      
      // Find arm references in the body
      window.fullBodyGroup.traverse(child => {
        if (child.name && child.name.toLowerCase().includes('left') && 
            (child.name.toLowerCase().includes('hand') || child.name.toLowerCase().includes('arm'))) {
          if (!leftHand && child.isMesh) {
            leftHand = child;
            console.log('  ‚Üí Found left hand/arm:', child.name);
          }
        }
        if (child.name && child.name.toLowerCase().includes('right') && 
            (child.name.toLowerCase().includes('hand') || child.name.toLowerCase().includes('arm'))) {
          if (!rightHand && child.isMesh) {
            rightHand = child;
            console.log('  ‚Üí Found right hand/arm:', child.name);
          }
        }
      });
      
      // Position body relative to headset
      // Body will be positioned below the camera (headset)
      window.fullBodyGroup.userData.vrMode = true;
      
      console.log('‚úÖ Body attached to VR! Arms will follow controllers.');
      console.log('   ‚Üí Left controller ‚Üí Left arm');
      console.log('   ‚Üí Right controller ‚Üí Right arm');
      console.log('   ‚Üí Headset ‚Üí Body position (offset below)');
    }
    
    function detachBodyFromVR() {
      console.log('ü¶¥ Detaching body from VR...');
      
      if (window.fullBodyGroup) {
        window.fullBodyGroup.userData.vrMode = false;
        leftHand = null;
        rightHand = null;
      }
      
      console.log('‚úÖ Body detached from VR.');
    }
    
    function updateVRBodyTracking() {
      if (!vrEnabled || !window.fullBodyGroup || !window.fullBodyGroup.userData.vrMode) {
        return;
      }
      
      // Use IK solver if enabled, otherwise use simple tracking
      if (vrIKEnabled) {
        updateVRBodyTrackingWithIK();
      } else {
        // Simple tracking (original method)
        updateVRBodyTrackingSimple();
      }
    }
    
    function updateVRBodyTrackingSimple() {
      // Get headset position (camera position in VR)
      const headsetPosition = new THREE.Vector3();
      camera.getWorldPosition(headsetPosition);
      
      // Position body below headset
      window.fullBodyGroup.position.copy(headsetPosition);
      window.fullBodyGroup.position.add(vrBodyOffset);
      
      // Track controller positions for IK (Inverse Kinematics)
      if (leftController && leftHand) {
        // Get controller world position
        const leftControllerPos = new THREE.Vector3();
        leftController.getWorldPosition(leftControllerPos);
        
        // Simple position matching (later we'll add proper IK)
        const leftArmGroup = leftHand.parent;
        if (leftArmGroup) {
          // Point arm toward controller position
          leftArmGroup.lookAt(leftControllerPos);
          
          // Optional: Move hand toward controller
          // This is simplified - proper IK would calculate elbow position
          const handTarget = leftControllerPos.clone().sub(window.fullBodyGroup.position);
          if (handTarget.length() < 1.5) { // Within arm reach
            leftHand.position.lerp(handTarget, 0.1);
          }
        }
      }
      
      if (rightController && rightHand) {
        // Get controller world position
        const rightControllerPos = new THREE.Vector3();
        rightController.getWorldPosition(rightControllerPos);
        
        // Simple position matching
        const rightArmGroup = rightHand.parent;
        if (rightArmGroup) {
          // Point arm toward controller position
          rightArmGroup.lookAt(rightControllerPos);
          
          // Optional: Move hand toward controller
          const handTarget = rightControllerPos.clone().sub(window.fullBodyGroup.position);
          if (handTarget.length() < 1.5) { // Within arm reach
            rightHand.position.lerp(handTarget, 0.1);
          }
        }
      }
      
      // Rotate body to face forward (based on headset orientation)
      const cameraDirection = new THREE.Vector3();
      camera.getWorldDirection(cameraDirection);
      cameraDirection.y = 0; // Keep on horizontal plane
      cameraDirection.normalize();
      
      // Calculate target rotation
      const targetRotation = Math.atan2(cameraDirection.x, cameraDirection.z);
      
      // Smooth rotation
      const currentRotation = window.fullBodyGroup.rotation.y;
      window.fullBodyGroup.rotation.y = THREE.MathUtils.lerp(
        currentRotation,
        targetRotation,
        0.1
      );
    }
    
    // ========================================
    // INVERSE KINEMATICS (IK) SYSTEM
    // ========================================
    
    /**
     * Two-bone IK solver for arm (shoulder ‚Üí elbow ‚Üí wrist)
     * Based on law of cosines
     */
    function solveArmIK(shoulderPos, targetPos, upperArmLength, forearmLength, side) {
      // Calculate distance to target
      const toTarget = targetPos.clone().sub(shoulderPos);
      const distance = toTarget.length();
      
      // Clamp to reachable distance
      const maxReach = upperArmLength + forearmLength;
      const minReach = Math.abs(upperArmLength - forearmLength);
      const clampedDistance = Math.max(minReach, Math.min(maxReach, distance));
      
      // If target is too far, reach as far as possible
      if (distance > maxReach) {
        toTarget.normalize().multiplyScalar(maxReach);
      }
      
      // Law of cosines to find elbow angle
      const a = upperArmLength;
      const b = forearmLength;
      const c = clampedDistance;
      
      // Angle at elbow joint
      const elbowAngle = Math.acos(
        (a * a + b * b - c * c) / (2 * a * b)
      );
      
      // Angle at shoulder (to point toward target)
      const shoulderToTarget = Math.acos(
        (a * a + c * c - b * b) / (2 * a * c)
      );
      
      return {
        shoulderAngle: shoulderToTarget,
        elbowAngle: Math.PI - elbowAngle, // Bend inward
        reachable: distance <= maxReach
      };
    }
    
    /**
     * Apply IK to body arm based on controller position
     */
    function applyIKToArm(controllerPos, side) {
      if (!window.fullBodyGroup) return;
      
      // Find arm components
      let shoulder, upperArm, forearm, hand;
      
      window.fullBodyGroup.traverse(child => {
        const name = child.name ? child.name.toLowerCase() : '';
        const matchesSide = name.includes(side);
        
        if (matchesSide) {
          if (name.includes('shoulder') || name.includes('humerus')) {
            shoulder = child;
          } else if (name.includes('upper') && name.includes('arm')) {
            upperArm = child;
          } else if (name.includes('forearm') || name.includes('radius') || name.includes('ulna')) {
            forearm = child;
          } else if (name.includes('hand') || name.includes('wrist')) {
            hand = child;
          }
        }
      });
      
      if (!shoulder || !upperArm) {
        console.warn(`‚ö†Ô∏è Could not find ${side} arm components for IK`);
        return;
      }
      
      // Get shoulder world position
      const shoulderPos = new THREE.Vector3();
      shoulder.getWorldPosition(shoulderPos);
      
      // Calculate IK
      const upperArmLength = 1.4; // Approximate upper arm length
      const forearmLength = 1.3;  // Approximate forearm length
      
      const ik = solveArmIK(shoulderPos, controllerPos, upperArmLength, forearmLength, side);
      
      if (ik.reachable) {
        // Apply shoulder rotation
        const toTarget = controllerPos.clone().sub(shoulderPos).normalize();
        const targetQuat = new THREE.Quaternion().setFromUnitVectors(
          new THREE.Vector3(0, -1, 0), // Default arm direction
          toTarget
        );
        
        // Smooth rotation
        if (shoulder.quaternion) {
          shoulder.quaternion.slerp(targetQuat, 0.2);
        }
        
        // Apply elbow bend
        if (forearm) {
          forearm.rotation.x = THREE.MathUtils.lerp(
            forearm.rotation.x,
            ik.elbowAngle,
            0.2
          );
        }
        
        console.log(`ü¶æ ${side} arm IK: shoulder=${(ik.shoulderAngle * 180 / Math.PI).toFixed(1)}¬∞ elbow=${(ik.elbowAngle * 180 / Math.PI).toFixed(1)}¬∞`);
      } else {
        console.warn(`‚ö†Ô∏è ${side} controller out of reach`);
      }
    }
    
    /**
     * Enhanced VR body tracking with proper IK
     */
    function updateVRBodyTrackingWithIK() {
      if (!vrEnabled || !window.fullBodyGroup || !window.fullBodyGroup.userData.vrMode) {
        return;
      }
      
      // Get headset position (camera position in VR)
      const headsetPosition = new THREE.Vector3();
      camera.getWorldPosition(headsetPosition);
      
      // Position body below headset
      window.fullBodyGroup.position.copy(headsetPosition);
      window.fullBodyGroup.position.add(vrBodyOffset);
      
      // Apply IK to left arm
      if (leftController) {
        const leftControllerPos = new THREE.Vector3();
        leftController.getWorldPosition(leftControllerPos);
        applyIKToArm(leftControllerPos, 'left');
      }
      
      // Apply IK to right arm
      if (rightController) {
        const rightControllerPos = new THREE.Vector3();
        rightController.getWorldPosition(rightControllerPos);
        applyIKToArm(rightControllerPos, 'right');
      }
      
      // Rotate body to face forward (based on headset orientation)
      const cameraDirection = new THREE.Vector3();
      camera.getWorldDirection(cameraDirection);
      cameraDirection.y = 0; // Keep on horizontal plane
      cameraDirection.normalize();
      
      // Calculate target rotation
      const targetRotation = Math.atan2(cameraDirection.x, cameraDirection.z);
      
      // Smooth rotation
      const currentRotation = window.fullBodyGroup.rotation.y;
      window.fullBodyGroup.rotation.y = THREE.MathUtils.lerp(
        currentRotation,
        targetRotation,
        0.1
      );
    }

    // =====================================
    // üéõÔ∏è SIDEBAR TOGGLE
    // =====================================
    
    let sidebarCollapsed = false;
    
    // =====================================
    // üéØ NAVIGATOR CUBE HOVER STATE
    // =====================================
    
    let hoveredNavigatorCube = null;
    
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const toggleBtn = sidebar.querySelector('.sidebar-toggle');
      
      sidebarCollapsed = !sidebarCollapsed;
      
      if (sidebarCollapsed) {
        sidebar.classList.add('collapsed');
        toggleBtn.innerHTML = '‚ñ∂';
        toggleBtn.title = 'Show control panel';
        console.log('üìê Sidebar collapsed - hover to show controls');
      } else {
        sidebar.classList.remove('collapsed');
        toggleBtn.innerHTML = '‚óÄ';
        toggleBtn.title = 'Hide control panel';
        console.log('üìê Sidebar expanded');
      }
    }
    
    // Toggle orbit controls on/off
    function toggleOrbitControls() {
      orbitEnabled = !orbitEnabled;
      controls.enabled = orbitEnabled;
      
      const btn = document.getElementById('orbitToggle');
      if (orbitEnabled) {
        btn.textContent = 'üé• Orbit: ON';
        btn.style.background = 'rgba(76, 175, 80, 0.3)';
        btn.style.borderColor = 'rgba(76, 175, 80, 0.6)';
        console.log('üé• Orbit controls: ENABLED');
        console.log('   ‚Üí WASD body movement DISABLED (use mouse to orbit camera)');
      } else {
        btn.textContent = 'üé• Orbit: OFF';
        btn.style.background = 'rgba(244, 67, 54, 0.3)';
        btn.style.borderColor = 'rgba(244, 67, 54, 0.6)';
        console.log('üé• Orbit controls: DISABLED');
        console.log('   ‚Üí WASD body movement ENABLED');
      }
    }
    
    // Toggle Walk Mode (stationary animation vs. forward movement)
    function toggleWalkMode() {
      walkModeEnabled = !walkModeEnabled;
      
      const btn = document.getElementById('walkModeToggle');
      if (walkModeEnabled) {
        btn.textContent = 'üö∂ Walk Mode: ON';
        btn.style.background = 'rgba(255, 165, 0, 0.3)';
        btn.style.borderColor = 'rgba(255, 165, 0, 0.6)';
        console.log('üö∂ WALK MODE ENABLED: Body will move forward when scrolling!');
        console.log('   ‚Üí Scroll mouse wheel to walk/run through the scene');
        console.log('   ‚Üí Camera follows body automatically');
        
        // Disable orbit controls in walk mode
        if (orbitEnabled) {
          toggleOrbitControls();
        }
      } else {
        btn.textContent = 'üö∂ Walk Mode: OFF';
        btn.style.background = 'rgba(255,165,0,0.15)';
        btn.style.borderColor = 'rgba(255,165,0,0.3)';
        console.log('üö∂ Walk Mode DISABLED: Body stays in place (stationary animation)');
        
        // Re-enable orbit controls
        if (!orbitEnabled) {
          toggleOrbitControls();
        }
      }
    }
    
    // Toggle 3rd person camera mode
    function toggle3rdPersonCamera() {
      const modes = ['auto', 'always', 'never'];
      const currentIndex = modes.indexOf(thirdPersonCamera);
      thirdPersonCamera = modes[(currentIndex + 1) % modes.length];
      
      const btn = document.getElementById('thirdPersonToggle');
      if (thirdPersonCamera === 'auto') {
        btn.textContent = 'üéÆ 3rd Person: AUTO';
        btn.style.background = 'rgba(33,150,243,0.15)';
        btn.style.borderColor = 'rgba(33,150,243,0.3)';
        console.log('üéÆ 3rd Person: AUTO - Activates in Walk/Flight Mode');
      } else if (thirdPersonCamera === 'always') {
        btn.textContent = 'üéÆ 3rd Person: ALWAYS';
        btn.style.background = 'rgba(76,175,80,0.3)';
        btn.style.borderColor = 'rgba(76,175,80,0.6)';
        console.log('üéÆ 3rd Person: ALWAYS ON - Game camera always active');
        controls.enabled = false; // Disable orbit when always on
      } else {
        btn.textContent = 'üéÆ 3rd Person: NEVER';
        btn.style.background = 'rgba(244,67,54,0.3)';
        btn.style.borderColor = 'rgba(244,67,54,0.6)';
        console.log('üéÆ 3rd Person: NEVER - Free camera only');
      }
    }
    
    // Toggle VR IK (Inverse Kinematics for arm tracking)
    function toggleVRIK() {
      vrIKEnabled = !vrIKEnabled;
      
      const btn = document.getElementById('vrIKToggle');
      if (vrIKEnabled) {
        btn.textContent = 'ü¶æ VR IK: ON';
        btn.style.background = 'rgba(156, 39, 176, 0.3)';
        btn.style.borderColor = 'rgba(156, 39, 176, 0.6)';
        console.log('ü¶æ VR IK: ENABLED - Using mechanical arm IK solver');
        console.log('   ‚Üí Arms will bend realistically at elbow joints');
        console.log('   ‚Üí Hands track VR controllers with proper kinematics');
      } else {
        btn.textContent = 'ü¶æ VR IK: OFF';
        btn.style.background = 'rgba(156, 39, 176, 0.15)';
        btn.style.borderColor = 'rgba(156, 39, 176, 0.3)';
        console.log('ü¶æ VR IK: DISABLED - Using simple tracking');
        console.log('   ‚Üí Arms point toward controllers (no elbow bend)');
      }
    }
    
    // ========================================
    // VR ROOM ENTRANCE & SKYRELICS INTEGRATION
    // ========================================
    
    function enterVRRoom() {
      console.log('ü•Ω ===== ENTERING VR ROOM =====');
      
      if (!renderer.xr.isPresenting) {
        console.log('‚ö†Ô∏è VR headset not detected. Please click "ENTER VR" button in viewport.');
        console.log('üì± If you don\'t have a VR headset, the button will enable VR mode for testing.');
        
        // Create VR environment preview
        createVREnvironment();
        
        console.log('\nüèõÔ∏è VR ROOM FEATURES:');
        console.log('  ‚Üí SkyBox with procedural clouds');
        console.log('  ‚Üí Ground plane with grid');
        console.log('  ‚Üí Ambient lighting (sunset theme)');
        console.log('  ‚Üí Body spawns in center of room');
        console.log('  ‚Üí Controllers visualized with hand models');
        console.log('\nüéÆ SKYRELICS INTEGRATION READY:');
        console.log('  ‚Üí Ancient artifacts placeable in VR space');
        console.log('  ‚Üí Interactive relic pedestals');
        console.log('  ‚Üí Holographic information panels');
        console.log('  ‚Üí Teleportation system between relics');
        
        return;
      }
      
      // VR session is active
      createVREnvironment();
      
      // Spawn body if loaded
      if (window.fullBodyGroup) {
        attachBodyToVR();
        console.log('‚úÖ Body spawned in VR room!');
      } else {
        console.log('üí° TIP: Load a body (FULL BODY or DETAILED SKELETON) before entering VR!');
      }
      
      console.log('‚úÖ VR Room active! Look around and use controllers to interact.');
    }
    
    function createVREnvironment() {
      console.log('üèóÔ∏è Creating VR environment...');
      
      // Check if environment already exists
      if (scene.getObjectByName('VR_Environment')) {
        console.log('‚ö†Ô∏è VR environment already exists');
        return;
      }
      
      const vrEnv = new THREE.Group();
      vrEnv.name = 'VR_Environment';
      
      // === SKY BOX ===
      const skyGeom = new THREE.SphereGeometry(500, 32, 32);
      const skyMat = new THREE.MeshBasicMaterial({
        color: 0x87CEEB,
        side: THREE.BackSide,
        fog: false
      });
      const sky = new THREE.Mesh(skyGeom, skyMat);
      sky.name = 'SkyBox';
      vrEnv.add(sky);
      
      // === PROCEDURAL CLOUDS ===
      const cloudMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide
      });
      
      for (let i = 0; i < 20; i++) {
        const cloudGeom = new THREE.SphereGeometry(
          15 + Math.random() * 10,
          8,
          8
        );
        const cloud = new THREE.Mesh(cloudGeom, cloudMat);
        cloud.name = `Cloud_${i}`;
        
        // Random position in sky
        const angle = (i / 20) * Math.PI * 2;
        const radius = 200 + Math.random() * 100;
        cloud.position.set(
          Math.cos(angle) * radius,
          50 + Math.random() * 100,
          Math.sin(angle) * radius
        );
        
        cloud.scale.set(
          1 + Math.random() * 0.5,
          0.4 + Math.random() * 0.3,
          1 + Math.random() * 0.5
        );
        
        vrEnv.add(cloud);
      }
      
      // === GROUND PLANE ===
      const groundGeom = new THREE.PlaneGeometry(100, 100, 50, 50);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x4a5f3a,
        roughness: 0.9,
        metalness: 0.1,
        wireframe: false
      });
      const ground = new THREE.Mesh(groundGeom, groundMat);
      ground.name = 'Ground';
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      vrEnv.add(ground);
      
      // === GRID OVERLAY ===
      const gridHelper = new THREE.GridHelper(100, 50, 0x888888, 0x444444);
      gridHelper.name = 'Grid';
      gridHelper.position.y = 0.01;
      vrEnv.add(gridHelper);
      
      // === LIGHTING (SUNSET THEME) ===
      // Sun (directional light)
      const sun = new THREE.DirectionalLight(0xffa500, 1.2);
      sun.name = 'Sun';
      sun.position.set(50, 80, 30);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 2048;
      sun.shadow.mapSize.height = 2048;
      sun.shadow.camera.near = 1;
      sun.shadow.camera.far = 500;
      sun.shadow.camera.left = -50;
      sun.shadow.camera.right = 50;
      sun.shadow.camera.top = 50;
      sun.shadow.camera.bottom = -50;
      vrEnv.add(sun);
      
      // Ambient fill light
      const ambient = new THREE.AmbientLight(0xffeedd, 0.4);
      ambient.name = 'Ambient';
      vrEnv.add(ambient);
      
      // Hemisphere light (sky color)
      const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x4a5f3a, 0.6);
      hemiLight.name = 'Hemisphere';
      vrEnv.add(hemiLight);
      
      // === SKYRELICS PEDESTALS ===
      createSkyRelicsPedestals(vrEnv);
      
      scene.add(vrEnv);
      
      // Update scene fog for VR
      scene.fog = new THREE.Fog(0x87CEEB, 50, 300);
      
      console.log('‚úÖ VR environment created:');
      console.log('  ‚Üí SkyBox with 20 procedural clouds');
      console.log('  ‚Üí 100√ó100m ground plane with grid');
      console.log('  ‚Üí 3-point lighting (sun, ambient, hemisphere)');
      console.log('  ‚Üí SkyRelics pedestals ready');
    }
    
    function createSkyRelicsPedestals(parent) {
      console.log('üèõÔ∏è Creating SkyRelics pedestals...');
      
      const pedestalMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.3,
        metalness: 0.7
      });
      
      const relicMat = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        roughness: 0.2,
        metalness: 0.8,
        emissive: 0xffd700,
        emissiveIntensity: 0.3
      });
      
      // Create 5 pedestals in a circle
      const pedestalRadius = 8;
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const x = Math.cos(angle) * pedestalRadius;
        const z = Math.sin(angle) * pedestalRadius;
        
        // Pedestal base
        const baseGeom = new THREE.CylinderGeometry(0.8, 1.0, 0.3, 16);
        const base = new THREE.Mesh(baseGeom, pedestalMat);
        base.position.set(x, 0.15, z);
        base.castShadow = true;
        parent.add(base);
        
        // Pedestal column
        const columnGeom = new THREE.CylinderGeometry(0.4, 0.5, 2.0, 12);
        const column = new THREE.Mesh(columnGeom, pedestalMat);
        column.position.set(x, 1.3, z);
        column.castShadow = true;
        parent.add(column);
        
        // Pedestal top
        const topGeom = new THREE.CylinderGeometry(0.7, 0.5, 0.2, 16);
        const top = new THREE.Mesh(topGeom, pedestalMat);
        top.position.set(x, 2.4, z);
        top.castShadow = true;
        parent.add(top);
        
        // Ancient relic (placeholder - will be replaced with actual artifacts)
        let relicGeom;
        switch(i) {
          case 0: // Crystal
            relicGeom = new THREE.OctahedronGeometry(0.4, 0);
            break;
          case 1: // Orb
            relicGeom = new THREE.SphereGeometry(0.35, 16, 16);
            break;
          case 2: // Cube
            relicGeom = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            break;
          case 3: // Torus
            relicGeom = new THREE.TorusGeometry(0.3, 0.1, 12, 24);
            break;
          case 4: // Pyramid
            relicGeom = new THREE.TetrahedronGeometry(0.4, 0);
            break;
        }
        
        const relic = new THREE.Mesh(relicGeom, relicMat);
        relic.name = `SkyRelic_${i + 1}`;
        relic.position.set(x, 2.8, z);
        relic.castShadow = true;
        relic.userData.isRelic = true;
        relic.userData.relicId = i + 1;
        
        // Animate relics (rotate and hover)
        relic.userData.rotationSpeed = 0.01 + Math.random() * 0.01;
        relic.userData.hoverOffset = Math.random() * Math.PI * 2;
        
        parent.add(relic);
        
        // Holographic label (text will be added later)
        const labelGeom = new THREE.PlaneGeometry(1.5, 0.4);
        const labelMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
        const label = new THREE.Mesh(labelGeom, labelMat);
        label.name = `Relic_Label_${i + 1}`;
        label.position.set(x, 3.5, z);
        label.lookAt(0, 3.5, 0); // Face center
        parent.add(label);
      }
      
      console.log('‚úÖ Created 5 SkyRelics pedestals with ancient artifacts');
      console.log('  ‚Üí Crystal, Orb, Cube, Torus, Pyramid');
      console.log('  ‚Üí Animated rotation and hover effects');
      console.log('  ‚Üí Holographic information panels');
    }
    
    // Animate SkyRelics (call in animation loop)
    function animateSkyRelics() {
      if (!scene.getObjectByName('VR_Environment')) return;
      
      const time = Date.now() * 0.001;
      
      scene.traverse(child => {
        if (child.userData.isRelic) {
          // Rotate relic
          child.rotation.y += child.userData.rotationSpeed;
          
          // Hover effect
          const hoverAmount = Math.sin(time * 2 + child.userData.hoverOffset) * 0.05;
          child.position.y = 2.8 + hoverAmount;
        }
      });
    }
    
    // Procedural walking/running animation with realistic biomechanics + WASD movement + Jump + Flight
    function updateWalkingAnimation() {
      if (!window.fullBodyGroup) return;
      
      // Disable body movement when OrbitControls are active
      if (orbitEnabled) {
        return; // Let OrbitControls handle camera movement
      }
      
      // === MOVEMENT PROCESSING ===
      const moveSpeed = 0.1;
      const turnSpeed = 0.03;
      let isMoving = moveForward || moveBackward || moveLeft || moveRight;
      
      // Update rotation based on left/right
      if (moveLeft) {
        window.fullBodyGroup.rotation.y += turnSpeed;
      }
      if (moveRight) {
        window.fullBodyGroup.rotation.y -= turnSpeed;
      }
      
      // === FLIGHT MODE ===
      if (flightModeEnabled) {
        // Superman pose: Arms extended forward, legs straight back
        if (leftArmGroupRef && rightArmGroupRef) {
          leftArmGroupRef.rotation.x = -Math.PI / 2; // Forward
          rightArmGroupRef.rotation.x = -Math.PI / 2;
          
          // Straighten elbows
          if (leftForearmGroup) leftForearmGroup.rotation.x = 0;
          if (rightForearmGroup) rightForearmGroup.rotation.x = 0;
        }
        
        // Legs straight back
        if (leftLegGroup && rightLegGroup) {
          leftLegGroup.rotation.x = Math.PI / 6; // Slight back angle
          rightLegGroup.rotation.x = Math.PI / 6;
          
          // Straight knees
          if (leftKneeGroup) leftKneeGroup.rotation.x = 0;
          if (rightKneeGroup) rightKneeGroup.rotation.x = 0;
          
          // Point toes
          if (leftFootGroup) leftFootGroup.rotation.x = -0.3;
          if (rightFootGroup) rightFootGroup.rotation.x = -0.3;
        }
        
        // Flight movement
        const bodyRotation = window.fullBodyGroup.rotation.y;
        if (moveForward) {
          window.fullBodyGroup.position.x += Math.sin(bodyRotation) * moveSpeed;
          window.fullBodyGroup.position.z += Math.cos(bodyRotation) * moveSpeed;
        }
        if (moveBackward) {
          window.fullBodyGroup.position.x -= Math.sin(bodyRotation) * moveSpeed * 0.5;
          window.fullBodyGroup.position.z -= Math.cos(bodyRotation) * moveSpeed * 0.5;
        }
        if (moveUp) {
          window.fullBodyGroup.position.y += moveSpeed * 0.5;
        }
        if (moveDown) {
          window.fullBodyGroup.position.y -= moveSpeed * 0.5;
          if (window.fullBodyGroup.position.y < groundLevel) {
            window.fullBodyGroup.position.y = groundLevel;
          }
        }
        
        // 3rd person camera for flight (behind and slightly above)
        const bodyPos = window.fullBodyGroup.position.clone();
        const cameraDistance = 10;
        const cameraHeight = 3;
        
        const cameraOffset = new THREE.Vector3(
          -Math.sin(bodyRotation) * cameraDistance,
          cameraHeight,
          -Math.cos(bodyRotation) * cameraDistance
        );
        
        const targetCameraPos = bodyPos.clone().add(cameraOffset);
        camera.position.lerp(targetCameraPos, 0.08);
        camera.lookAt(bodyPos);
        
        return; // Skip walking animation
      }
      
      // === JUMP PHYSICS ===
      if (isJumping) {
        // Squat pose before/during jump
        if (leftLegGroup && rightLegGroup && leftKneeGroup && rightKneeGroup) {
          const squatAmount = Math.max(0, 1 - jumpVelocity * 3); // Squat more at start
          leftKneeGroup.rotation.x = squatAmount * 1.2; // Bend knees back
          rightKneeGroup.rotation.x = squatAmount * 1.2;
          leftLegGroup.rotation.x = -squatAmount * 0.3; // Lean forward slightly
          rightLegGroup.rotation.x = -squatAmount * 0.3;
        }
        
        // Arms swing up during jump
        if (leftArmGroupRef && rightArmGroupRef) {
          const armSwing = -jumpVelocity * 2;
          leftArmGroupRef.rotation.x = armSwing;
          rightArmGroupRef.rotation.x = armSwing;
        }
        
        // Apply jump physics
        window.fullBodyGroup.position.y += jumpVelocity;
        jumpVelocity += gravity;
        
        // Land
        if (window.fullBodyGroup.position.y <= groundLevel) {
          window.fullBodyGroup.position.y = groundLevel;
          isJumping = false;
          jumpVelocity = 0;
          console.log('üéØ Landed!');
        }
      }
      
      // === WALKING/RUNNING ANIMATION ===
      if (isMoving && !isJumping && !flightModeEnabled) {
        // Gradual acceleration: Start with paced walk, Shift for run
        const targetSpeed = isRunning ? 8 : 3; // Walk: 3, Run: 8
        const acceleration = isRunning ? 0.3 : 0.2; // Run accelerates faster
        
        if (moveForward) {
          walkCycleSpeed = Math.min(walkCycleSpeed + acceleration, targetSpeed);
        } else if (moveBackward) {
          walkCycleSpeed = Math.min(walkCycleSpeed + 0.15, 2); // Slower backward
        }
        lastWheelTime = Date.now();
      }
      
      // Decay walk speed when not moving
      if (!isMoving || isJumping) {
        walkCycleSpeed *= 0.85; // Slower deceleration for smoother stop
        if (walkCycleSpeed < 0.01) {
          walkCycleSpeed = 0;
          walkCyclePhase = 0;
        }
      }
      
      // Only animate walking if speed > 0
      if (walkCycleSpeed > 0 && leftLegGroup && rightLegGroup && leftKneeGroup && rightKneeGroup) {
        // Determine animation speed based on current walk speed
        const isRunningAnim = walkCycleSpeed > 5;
        const cycleSpeedMultiplier = isRunningAnim ? 0.15 : 0.08;
        walkCyclePhase += walkCycleSpeed * cycleSpeedMultiplier;
        
        // === BIOMECHANICAL WALKING CYCLE ===
        const legSwingAmplitude = isRunningAnim ? 0.6 : 0.4;
        const kneeFlexionMax = isRunningAnim ? 1.2 : 0.8;
        const armSwingAmplitude = isRunningAnim ? 0.5 : 0.3;
        
        // === RIGHT LEG CYCLE ===
        const rightPhase = walkCyclePhase % (Math.PI * 2);
        const rightHipSwing = Math.sin(rightPhase) * legSwingAmplitude;
        rightLegGroup.rotation.x = rightHipSwing;
        
        // Right knee flexion
        if (rightPhase < Math.PI) {
          const flexProgress = Math.sin(rightPhase);
          rightKneeGroup.rotation.x = flexProgress * kneeFlexionMax;
        } else {
          const stanceProgress = Math.sin(rightPhase - Math.PI);
          rightKneeGroup.rotation.x = stanceProgress * 0.2;
        }
        
        // Right foot heel-toe (FORWARD) or ball-pivot (BACKWARD)
        if (moveBackward) {
          // BACKWARD WALKING: Ball of foot pivots first, toe stays down, swing back in arc
          if (rightPhase < Math.PI * 0.2) {
            // Initial pivot on ball of foot (toe down, heel starting to lift)
            rightFootGroup.rotation.x = -0.5; // Plantarflexion - toe down
          } else if (rightPhase < Math.PI * 0.5) {
            // Swing phase: foot arcs back with toe pointed
            const swingProgress = (rightPhase - Math.PI * 0.2) / (Math.PI * 0.3);
            rightFootGroup.rotation.x = -0.5 + (swingProgress * 0.3); // Toe gradually comes up
          } else if (rightPhase < Math.PI) {
            // Landing: foot comes down flat for stance
            rightFootGroup.rotation.x = -0.1; // Nearly flat
          } else {
            // Stance phase: foot flat on ground
            rightFootGroup.rotation.x = 0;
          }
        } else {
          // FORWARD WALKING: Normal heel-toe pattern
          if (rightPhase < Math.PI * 0.3) {
            rightFootGroup.rotation.x = 0.3;
          } else if (rightPhase < Math.PI * 0.7) {
            rightFootGroup.rotation.x = 0;
          } else if (rightPhase < Math.PI) {
            rightFootGroup.rotation.x = -0.4;
          } else {
            rightFootGroup.rotation.x = 0.1;
          }
        }
        
        // === LEFT LEG CYCLE ===
        const leftPhase = (walkCyclePhase + Math.PI) % (Math.PI * 2);
        const leftHipSwing = Math.sin(leftPhase) * legSwingAmplitude;
        leftLegGroup.rotation.x = leftHipSwing;
        
        // Left knee flexion
        if (leftPhase < Math.PI) {
          const flexProgress = Math.sin(leftPhase);
          leftKneeGroup.rotation.x = flexProgress * kneeFlexionMax;
        } else {
          const stanceProgress = Math.sin(leftPhase - Math.PI);
          leftKneeGroup.rotation.x = stanceProgress * 0.2;
        }
        
        // Left foot heel-toe (FORWARD) or ball-pivot (BACKWARD)
        if (moveBackward) {
          // BACKWARD WALKING: Ball of foot pivots first, toe stays down, swing back in arc
          if (leftPhase < Math.PI * 0.2) {
            // Initial pivot on ball of foot (toe down, heel starting to lift)
            leftFootGroup.rotation.x = -0.5; // Plantarflexion - toe down
          } else if (leftPhase < Math.PI * 0.5) {
            // Swing phase: foot arcs back with toe pointed
            const swingProgress = (leftPhase - Math.PI * 0.2) / (Math.PI * 0.3);
            leftFootGroup.rotation.x = -0.5 + (swingProgress * 0.3); // Toe gradually comes up
          } else if (leftPhase < Math.PI) {
            // Landing: foot comes down flat for stance
            leftFootGroup.rotation.x = -0.1; // Nearly flat
          } else {
            // Stance phase: foot flat on ground
            leftFootGroup.rotation.x = 0;
          }
        } else {
          // FORWARD WALKING: Normal heel-toe pattern
          if (leftPhase < Math.PI * 0.3) {
            leftFootGroup.rotation.x = 0.3;
          } else if (leftPhase < Math.PI * 0.7) {
            leftFootGroup.rotation.x = 0;
          } else if (leftPhase < Math.PI) {
            leftFootGroup.rotation.x = -0.4;
          } else {
            leftFootGroup.rotation.x = 0.1;
          }
        }
        
        // === ARM SWING ===
        const leftArmSwing = Math.sin(leftPhase) * armSwingAmplitude;
        const rightArmSwing = Math.sin(rightPhase) * armSwingAmplitude;
        
        if (leftArmGroupRef) {
          leftArmGroupRef.rotation.x = leftArmSwing;
          if (leftForearmGroup) {
            const elbowBendAmplitude = isRunningAnim ? 0.4 : 0.25;
            const elbowBend = Math.max(0, -leftArmSwing) * elbowBendAmplitude;
            leftForearmGroup.rotation.x = elbowBend;
          }
        }
        if (rightArmGroupRef) {
          rightArmGroupRef.rotation.x = rightArmSwing;
          if (rightForearmGroup) {
            const elbowBendAmplitude = isRunningAnim ? 0.4 : 0.25;
            const elbowBend = Math.max(0, -rightArmSwing) * elbowBendAmplitude;
            rightForearmGroup.rotation.x = elbowBend;
          }
        }
        
        // === BODY BOB ===
        const bobAmount = isRunningAnim ? 0.15 : 0.08;
        const bodyBob = Math.abs(Math.sin(walkCyclePhase * 2)) * bobAmount;
        window.fullBodyGroup.position.y = groundLevel + bodyBob;
        
        // === FORWARD/BACKWARD MOVEMENT ===
        const bodyRotation = window.fullBodyGroup.rotation.y;
        if (moveForward) {
          const forwardSpeed = isRunningAnim ? 0.08 : 0.04;
          window.fullBodyGroup.position.x += Math.sin(bodyRotation) * walkCycleSpeed * forwardSpeed;
          window.fullBodyGroup.position.z += Math.cos(bodyRotation) * walkCycleSpeed * forwardSpeed;
        }
        if (moveBackward) {
          const backwardSpeed = 0.02; // Slower backward walk
          window.fullBodyGroup.position.x -= Math.sin(bodyRotation) * walkCycleSpeed * backwardSpeed;
          window.fullBodyGroup.position.z -= Math.cos(bodyRotation) * walkCycleSpeed * backwardSpeed;
        }
        
        // === 3RD PERSON CAMERA (Game-style) ===
        const shouldUse3rdPerson = thirdPersonCamera === 'always' || 
                                   (thirdPersonCamera === 'auto' && (walkModeEnabled || flightModeEnabled));
        
        if (shouldUse3rdPerson) {
          const bodyRotation = window.fullBodyGroup.rotation.y;
          const bodyPos = window.fullBodyGroup.position.clone();
          
          // Camera positioned behind and HIGH above character (bird's eye view)
          const cameraDistance = 8; // Distance behind character
          const cameraHeight = 27; // Height above character (MUCH higher - no more staring at ass!)
          const lookAtHeight = 5; // Look at character's head/upper body
          
          // Calculate camera position behind character (rotates with character)
          const cameraOffset = new THREE.Vector3(
            -Math.sin(bodyRotation) * cameraDistance, // Behind (negative forward)
            cameraHeight,
            -Math.cos(bodyRotation) * cameraDistance
          );
          
          const targetCameraPos = bodyPos.clone().add(cameraOffset);
          const lookAtTarget = bodyPos.clone().add(new THREE.Vector3(0, lookAtHeight, 0));
          
          // Smooth camera movement (lerp for cinematic feel)
          camera.position.lerp(targetCameraPos, 0.1);
          camera.lookAt(lookAtTarget);
        }
      }
    }

    // =====================================
    // üîç ANATOMICAL SEARCH/FILTER SYSTEM
    // =====================================

    // Comprehensive anatomical database
    const anatomicalDatabase = {
      skeletal: [
        // AXIAL SKELETON
        { name: 'Skull', keywords: ['cranium', 'head', 'skull', 'brain case'], system: 'skeletal', region: 'head' },
        { name: 'Mandible', keywords: ['jaw', 'lower jaw', 'mandible', 'jawbone'], system: 'skeletal', region: 'head' },
        { name: 'Maxilla', keywords: ['upper jaw', 'maxilla'], system: 'skeletal', region: 'head' },
        { name: 'Zygomatic', keywords: ['cheekbone', 'zygomatic', 'cheek'], system: 'skeletal', region: 'head' },
        { name: 'Temporal', keywords: ['temporal', 'temple'], system: 'skeletal', region: 'head' },
        { name: 'Occipital', keywords: ['occipital', 'back skull'], system: 'skeletal', region: 'head' },
        
        // SPINE
        { name: 'Cervical Vertebrae', keywords: ['cervical', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'neck vertebrae', 'atlas', 'axis'], system: 'skeletal', region: 'spine' },
        { name: 'Thoracic Vertebrae', keywords: ['thoracic', 't1', 't2', 't3', 't4', 't5', 't6', 't7', 't8', 't9', 't10', 't11', 't12', 'upper back'], system: 'skeletal', region: 'spine' },
        { name: 'Lumbar Vertebrae', keywords: ['lumbar', 'l1', 'l2', 'l3', 'l4', 'l5', 'lower back'], system: 'skeletal', region: 'spine' },
        { name: 'Sacrum', keywords: ['sacrum', 'tailbone base'], system: 'skeletal', region: 'spine' },
        { name: 'Coccyx', keywords: ['coccyx', 'tailbone'], system: 'skeletal', region: 'spine' },
        
        // THORAX
        { name: 'Ribs', keywords: ['rib', 'ribs', 'ribcage', 'costal'], system: 'skeletal', region: 'thorax' },
        { name: 'Sternum', keywords: ['sternum', 'breastbone', 'manubrium', 'xiphoid'], system: 'skeletal', region: 'thorax' },
        
        // PELVIS
        { name: 'Pelvis', keywords: ['pelvis', 'hip', 'ilium', 'ischium', 'pubis'], system: 'skeletal', region: 'pelvis' },
        
        // UPPER LIMBS
        { name: 'Clavicle', keywords: ['clavicle', 'collarbone'], system: 'skeletal', region: 'shoulder' },
        { name: 'Scapula', keywords: ['scapula', 'shoulder blade'], system: 'skeletal', region: 'shoulder' },
        { name: 'Humerus', keywords: ['humerus', 'upper arm'], system: 'skeletal', region: 'arm' },
        { name: 'Radius', keywords: ['radius', 'forearm lateral'], system: 'skeletal', region: 'forearm' },
        { name: 'Ulna', keywords: ['ulna', 'forearm medial', 'elbow bone'], system: 'skeletal', region: 'forearm' },
        { name: 'Carpals', keywords: ['carpals', 'wrist', 'scaphoid', 'lunate', 'triquetrum', 'pisiform', 'trapezium', 'trapezoid', 'capitate', 'hamate'], system: 'skeletal', region: 'hand' },
        { name: 'Metacarpals', keywords: ['metacarpals', 'hand bones', 'palm'], system: 'skeletal', region: 'hand' },
        { name: 'Phalanges (Hand)', keywords: ['phalanges', 'fingers', 'thumb', 'finger bones'], system: 'skeletal', region: 'hand' },
        
        // LOWER LIMBS
        { name: 'Femur', keywords: ['femur', 'thigh bone', 'thighbone'], system: 'skeletal', region: 'leg' },
        { name: 'Patella', keywords: ['patella', 'kneecap', 'knee cap'], system: 'skeletal', region: 'leg' },
        { name: 'Tibia', keywords: ['tibia', 'shin bone', 'shinbone'], system: 'skeletal', region: 'leg' },
        { name: 'Fibula', keywords: ['fibula', 'calf bone'], system: 'skeletal', region: 'leg' },
        { name: 'Tarsals', keywords: ['tarsals', 'ankle', 'talus', 'calcaneus', 'heel'], system: 'skeletal', region: 'foot' },
        { name: 'Metatarsals', keywords: ['metatarsals', 'foot bones'], system: 'skeletal', region: 'foot' },
        { name: 'Phalanges (Foot)', keywords: ['toe', 'toes', 'toe bones', 'hallux', 'big toe'], system: 'skeletal', region: 'foot' }
      ],
      muscular: [
        { name: 'Biceps Brachii', keywords: ['biceps', 'bicep'], system: 'muscular', region: 'arm' },
        { name: 'Triceps Brachii', keywords: ['triceps', 'tricep'], system: 'muscular', region: 'arm' },
        { name: 'Deltoid', keywords: ['deltoid', 'shoulder muscle'], system: 'muscular', region: 'shoulder' },
        { name: 'Pectoralis Major', keywords: ['pectoralis', 'pecs', 'chest'], system: 'muscular', region: 'chest' },
        { name: 'Latissimus Dorsi', keywords: ['latissimus', 'lats', 'back'], system: 'muscular', region: 'back' },
        { name: 'Trapezius', keywords: ['trapezius', 'traps'], system: 'muscular', region: 'back' },
        { name: 'Rectus Abdominis', keywords: ['rectus abdominis', 'abs', 'six pack'], system: 'muscular', region: 'abdomen' },
        { name: 'External Obliques', keywords: ['obliques', 'side abs'], system: 'muscular', region: 'abdomen' },
        { name: 'Quadriceps', keywords: ['quadriceps', 'quads', 'thigh front'], system: 'muscular', region: 'leg' },
        { name: 'Hamstrings', keywords: ['hamstrings', 'thigh back'], system: 'muscular', region: 'leg' },
        { name: 'Gastrocnemius', keywords: ['gastrocnemius', 'calf'], system: 'muscular', region: 'leg' },
        { name: 'Gluteus Maximus', keywords: ['gluteus', 'glutes', 'butt'], system: 'muscular', region: 'pelvis' }
      ],
      nervous: [
        { name: 'Brain', keywords: ['brain', 'cerebrum', 'cerebellum'], system: 'nervous', region: 'head' },
        { name: 'Spinal Cord', keywords: ['spinal cord', 'spine cord'], system: 'nervous', region: 'spine' },
        { name: 'Nerves', keywords: ['nerve', 'nerves', 'neural'], system: 'nervous', region: 'all' }
      ],
      circulatory: [
        { name: 'Heart', keywords: ['heart', 'cardiac'], system: 'circulatory', region: 'chest' },
        { name: 'Arteries', keywords: ['artery', 'arteries', 'aorta'], system: 'circulatory', region: 'all' },
        { name: 'Veins', keywords: ['vein', 'veins'], system: 'circulatory', region: 'all' }
      ],
      respiratory: [
        { name: 'Lungs', keywords: ['lung', 'lungs', 'pulmonary'], system: 'respiratory', region: 'chest' },
        { name: 'Trachea', keywords: ['trachea', 'windpipe'], system: 'respiratory', region: 'neck' },
        { name: 'Bronchi', keywords: ['bronchi', 'bronchus'], system: 'respiratory', region: 'chest' }
      ],
      digestive: [
        { name: 'Stomach', keywords: ['stomach'], system: 'digestive', region: 'abdomen' },
        { name: 'Liver', keywords: ['liver'], system: 'digestive', region: 'abdomen' },
        { name: 'Intestines', keywords: ['intestine', 'intestines', 'bowel'], system: 'digestive', region: 'abdomen' }
      ]
    };

    // Flatten database for search
    let allAnatomicalStructures = [];
    Object.keys(anatomicalDatabase).forEach(system => {
      allAnatomicalStructures = allAnatomicalStructures.concat(anatomicalDatabase[system]);
    });

    let currentAnatomyFilter = 'all';
    let highlightedStructures = [];

    // Search function with autocomplete
    function anatomySearch(query) {
      const searchBox = document.getElementById('anatomy-search');
      const suggestionsDiv = document.getElementById('search-suggestions');
      const resultsCount = document.getElementById('search-results-count');
      
      if (!query || query.length < 2) {
        suggestionsDiv.style.display = 'none';
        resultsCount.textContent = '';
        return;
      }
      
      const lowerQuery = query.toLowerCase();
      const matches = [];
      
      // Search through all structures
      allAnatomicalStructures.forEach(structure => {
        // Check if query matches name or any keyword
        if (structure.name.toLowerCase().includes(lowerQuery) || 
            structure.keywords.some(keyword => keyword.includes(lowerQuery))) {
          // Apply system filter if active
          if (currentAnatomyFilter === 'all' || structure.system === currentAnatomyFilter) {
            matches.push(structure);
          }
        }
      });
      
      // Show suggestions
      if (matches.length > 0) {
        suggestionsDiv.innerHTML = matches.slice(0, 8).map(structure => 
          `<div style="padding: 8px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.1);" 
                onmouseover="this.style.background='rgba(102,126,234,0.2)'" 
                onmouseout="this.style.background='transparent'"
                onclick="selectAnatomicalStructure('${structure.name}')">
            ${getSystemIcon(structure.system)} <strong>${structure.name}</strong> 
            <span style="color: rgba(255,255,255,0.5); font-size: 11px;">${structure.region}</span>
          </div>`
        ).join('');
        suggestionsDiv.style.display = 'block';
        resultsCount.textContent = `Found ${matches.length} structure${matches.length !== 1 ? 's' : ''}`;
      } else {
        suggestionsDiv.innerHTML = '<div style="padding: 8px; color: rgba(255,255,255,0.5);">No results found</div>';
        suggestionsDiv.style.display = 'block';
        resultsCount.textContent = 'No matches';
      }
    }

    // Handle Enter key in search
    function anatomySearchEnter() {
      const query = document.getElementById('anatomy-search').value;
      if (!query) return;
      
      // Find first match and select it
      const lowerQuery = query.toLowerCase();
      const firstMatch = allAnatomicalStructures.find(structure => 
        (structure.name.toLowerCase().includes(lowerQuery) || 
         structure.keywords.some(keyword => keyword.includes(lowerQuery))) &&
        (currentAnatomyFilter === 'all' || structure.system === currentAnatomyFilter)
      );
      
      if (firstMatch) {
        selectAnatomicalStructure(firstMatch.name);
      }
    }

    // Select and highlight a specific anatomical structure
    function selectAnatomicalStructure(structureName) {
      console.log(`üîç Searching for: ${structureName}`);
      
      // Clear previous highlights
      clearAnatomyHighlights();
      
      // Find all meshes matching this structure name
      const matches = [];
      scene.traverse(obj => {
        if (obj.isMesh && obj.name) {
          const objName = obj.name.toLowerCase();
          const searchName = structureName.toLowerCase();
          
          // Check if object name contains the search term
          if (objName.includes(searchName) || searchName.includes(objName.split(' ')[0])) {
            matches.push(obj);
          }
        }
      });
      
      console.log(`  ‚úÖ Found ${matches.length} matching structures`);
      
      // Highlight found structures
      matches.forEach(obj => {
        highlightStructure(obj);
        highlightedStructures.push(obj);
      });
      
      // Update found structures list
      updateFoundStructuresList();
      
      // Focus camera on first match if exists
      if (matches.length > 0) {
        focusOnStructure(matches[0]);
      }
      
      // Hide suggestions
      document.getElementById('search-suggestions').style.display = 'none';
    }

    // Highlight a structure
    function highlightStructure(obj) {
      if (obj.material) {
        // Store original material properties
        if (!obj.userData.originalMaterial) {
          obj.userData.originalMaterial = {
            emissive: obj.material.emissive ? obj.material.emissive.clone() : new THREE.Color(0x000000),
            emissiveIntensity: obj.material.emissiveIntensity || 0
          };
        }
        
        // Apply highlight
        obj.material.emissive = new THREE.Color(0x00ff00); // Green glow
        obj.material.emissiveIntensity = 0.5;
      }
    }

    // Clear all highlights
    function clearAnatomyHighlights() {
      highlightedStructures.forEach(obj => {
        if (obj.material && obj.userData.originalMaterial) {
          obj.material.emissive = obj.userData.originalMaterial.emissive;
          obj.material.emissiveIntensity = obj.userData.originalMaterial.emissiveIntensity;
        }
      });
      highlightedStructures = [];
      updateFoundStructuresList();
    }

    // Update found structures list UI
    function updateFoundStructuresList() {
      const listDiv = document.getElementById('found-structures-list');
      
      if (highlightedStructures.length === 0) {
        listDiv.innerHTML = '<div style="color: rgba(255,255,255,0.4);">Search or filter to find anatomical structures...</div>';
        return;
      }
      
      const uniqueNames = [...new Set(highlightedStructures.map(obj => obj.name))];
      listDiv.innerHTML = uniqueNames.map((name, index) => 
        `<div style="padding: 6px; margin-bottom: 4px; background: rgba(0,255,0,0.1); border-left: 3px solid #00ff00; border-radius: 2px; cursor: pointer;"
              onclick="focusOnStructureByName('${name}')">
          ‚úÖ <strong>${name}</strong>
          <button onclick="event.stopPropagation(); unhighlightByName('${name}')" 
                  style="float: right; background: rgba(255,0,0,0.3); border: none; padding: 2px 8px; cursor: pointer; border-radius: 2px; color: #fff;">
            ‚úï
          </button>
        </div>`
      ).join('');
    }

    // Filter by system
    function filterBySystem(system, buttonElement) {
      currentAnatomyFilter = system;
      
      // Update button styling
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'rgba(0,0,0,0.3)';
        btn.style.borderColor = 'rgba(255,255,255,0.2)';
      });
      
      buttonElement.classList.add('active');
      buttonElement.style.background = 'rgba(102, 126, 234, 0.3)';
      buttonElement.style.borderColor = 'rgba(102, 126, 234, 0.5)';
      
      console.log(`üéØ Filter set to: ${system}`);
      
      // Re-run current search if exists
      const currentSearch = document.getElementById('anatomy-search').value;
      if (currentSearch) {
        anatomySearch(currentSearch);
      }
    }

    // Get system icon
    function getSystemIcon(system) {
      const icons = {
        skeletal: 'ü¶¥',
        muscular: 'üí™',
        nervous: 'üß†',
        circulatory: '‚ù§Ô∏è',
        respiratory: 'ü´Å',
        digestive: 'ü´É'
      };
      return icons[system] || 'üîπ';
    }

    // Focus camera on structure
    function focusOnStructure(obj) {
      if (!obj) return;
      
      // Get world position
      const worldPos = new THREE.Vector3();
      obj.getWorldPosition(worldPos);
      
      // Move camera to look at this structure
      const distance = 5;
      const targetPos = new THREE.Vector3(
        worldPos.x + distance,
        worldPos.y + distance / 2,
        worldPos.z + distance
      );
      
      // Animate camera (simple lerp in animate loop would be smoother)
      camera.position.copy(targetPos);
      camera.lookAt(worldPos);
      controls.target.copy(worldPos);
      controls.update();
      
      console.log(`üì∑ Camera focused on ${obj.name}`);
    }

    // Focus on structure by name
    function focusOnStructureByName(name) {
      const structure = highlightedStructures.find(obj => obj.name === name);
      if (structure) {
        focusOnStructure(structure);
      }
    }

    // Unhighlight by name
    function unhighlightByName(name) {
      highlightedStructures = highlightedStructures.filter(obj => {
        if (obj.name === name) {
          if (obj.material && obj.userData.originalMaterial) {
            obj.material.emissive = obj.userData.originalMaterial.emissive;
            obj.material.emissiveIntensity = obj.userData.originalMaterial.emissiveIntensity;
          }
          return false;
        }
        return true;
      });
      updateFoundStructuresList();
    }

    // Show all anatomy
    function showAllAnatomy() {
      scene.traverse(obj => {
        if (obj.isMesh) {
          obj.visible = true;
        }
      });
      console.log('üëÅÔ∏è All anatomy visible');
    }

    // Hide all anatomy
    function hideAllAnatomy() {
      scene.traverse(obj => {
        if (obj.isMesh && obj.name && 
            (obj.name.includes('Bone') || obj.name.includes('Vertebra') || obj.name.includes('Rib'))) {
          obj.visible = false;
        }
      });
      console.log('üôà Anatomy hidden');
    }

    // Reset anatomy view
    function resetAnatomyView() {
      clearAnatomyHighlights();
      showAllAnatomy();
      camera.position.set(10, 5, 10);
      camera.lookAt(0, 2, 0);
      controls.target.set(0, 2, 0);
      controls.update();
      document.getElementById('anatomy-search').value = '';
      document.getElementById('search-suggestions').style.display = 'none';
      document.getElementById('search-results-count').textContent = '';
      console.log('üîÑ Anatomy view reset');
    }

    // Focus on selected
    function focusOnSelected() {
      if (highlightedStructures.length > 0) {
        focusOnStructure(highlightedStructures[0]);
      } else {
        alert('No structures selected. Use search to find and highlight structures first.');
      }
    }

    // Toggle layer visibility
    function toggleLayer(layer, visible) {
      scene.traverse(obj => {
        if (obj.isMesh && obj.userData.layer === layer) {
          obj.visible = visible;
        }
      });
      console.log(`üëÅÔ∏è Layer '${layer}' ${visible ? 'shown' : 'hidden'}`);
    }

    // Update layer opacity
    function updateLayerOpacity(value) {
      const opacity = parseInt(value) / 100;
      document.getElementById('layer-opacity-value').textContent = value;
      
      scene.traverse(obj => {
        if (obj.isMesh && obj.material) {
          obj.material.opacity = opacity;
          obj.material.transparent = opacity < 1.0;
        }
      });
    }

    // Voice search (VR mode)
    let recognition = null;
    function startVoiceSearch() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        alert('Voice search not supported in this browser. Try Chrome or Edge.');
        return;
      }
      
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';
      
      const btn = document.getElementById('voice-search-btn');
      btn.textContent = 'üé§ Listening...';
      btn.style.background = 'rgba(255, 0, 0, 0.3)';
      
      recognition.onresult = function(event) {
        const transcript = event.results[0][0].transcript.toLowerCase();
        console.log(`üé§ Voice input: "${transcript}"`);
        
        document.getElementById('anatomy-search').value = transcript;
        anatomySearch(transcript);
        anatomySearchEnter();
      };
      
      recognition.onerror = function(event) {
        console.error('Voice recognition error:', event.error);
        btn.textContent = 'üé§ Start Voice Search';
        btn.style.background = 'rgba(102, 126, 234, 0.2)';
      };
      
      recognition.onend = function() {
        btn.textContent = 'üé§ Start Voice Search';
        btn.style.background = 'rgba(102, 126, 234, 0.2)';
      };
      
      recognition.start();
    }

    function animate() {
      // Use renderer.setAnimationLoop for VR compatibility
      renderer.setAnimationLoop(function() {
        controls.update();
        
        // Update VR body tracking (if in VR mode)
        updateVRBodyTracking();
        
        // Update walking/running animation (disabled in VR)
        updateWalkingAnimation();
        
        // Animate SkyRelics (rotation and hover)
        animateSkyRelics();
        
        // Update matrix grid backwall animation (WordWeaver)
        if (documentCanvas && typeof documentCanvas.updateMatrixGridBackwall === 'function') {
          documentCanvas.updateMatrixGridBackwall();
        }
        
        // Update dimensional animations (pulsing grids, markers)
        updateDimensionalAnimations();
        
        // Update selection box to follow selected object
        if (selectionBox && selectedObject) {
          selectionBox.update();
        }
        
        renderer.render(scene, camera);
      });
    }

    function onWindowResize() {
      const canvas = document.getElementById('canvas');
      camera.aspect = canvas.parentElement.offsetWidth / canvas.parentElement.offsetHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.parentElement.offsetWidth, canvas.parentElement.offsetHeight);
    }

    function onCanvasClick(event) {
      const canvas = document.getElementById('canvas');
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      // üéØ Matrix Prism Navigator: Check if clicking preview cube to switch dimensions
      if (currentDimension === 'navigator') {
        const navigatorGroup = dimensionalSpaces['navigator'].objects.find(
          obj => obj.name === 'MatrixPrismNavigator'
        );
        
        if (navigatorGroup) {
          const navigatorIntersects = raycaster.intersectObjects(navigatorGroup.children, true);
          
          if (navigatorIntersects.length > 0) {
            // Find the cube group (traverse up from intersected mesh)
            let cubeGroup = navigatorIntersects[0].object;
            while (cubeGroup && !cubeGroup.userData.isNavigatorCube) {
              cubeGroup = cubeGroup.parent;
            }
            
            if (cubeGroup && cubeGroup.userData.dimensionKey) {
              const targetDimension = cubeGroup.userData.dimensionKey;
              console.log(`üéØ Navigator: Entering ${DIMENSIONAL_CONFIGS[targetDimension].name}`);
              
              // Switch to target dimension
              switchDimension(targetDimension);
              
              // Update UI tabs
              const targetTab = document.querySelector(
                `.workspace-tab[data-dimension="${targetDimension}"]`
              );
              if (targetTab) {
                switchDimensionUI(targetDimension, targetTab);
              }
              
              return; // Don't process regular object clicks
            }
          }
        }
        
        // üåê Spherical Navigator: Check if clicking segment
        const sphereGroup = dimensionalSpaces['navigator'].objects.find(
          obj => obj.name === 'SphericalNavigator'
        );
        
        if (sphereGroup) {
          const sphereIntersects = raycaster.intersectObjects(sphereGroup.children, true);
          
          if (sphereIntersects.length > 0) {
            // Find the segment group (traverse up from intersected mesh)
            let segmentGroup = sphereIntersects[0].object;
            while (segmentGroup && !segmentGroup.userData.isNavigatorSegment) {
              segmentGroup = segmentGroup.parent;
            }
            
            if (segmentGroup && segmentGroup.userData.dimensionKey) {
              const targetDimension = segmentGroup.userData.dimensionKey;
              const dimConfig = segmentGroup.userData.dimensionConfig;
              console.log(`üåê Spherical Navigator: Entering ${dimConfig.icon} ${dimConfig.name}`);
              
              // Switch to target dimension
              switchDimension(targetDimension);
              
              // Update UI tabs
              const targetTab = document.querySelector(
                `.workspace-tab[data-dimension="${targetDimension}"]`
              );
              if (targetTab) {
                switchDimensionUI(targetDimension, targetTab);
              }
              
              return; // Don't process regular object clicks
            }
          }
        }
      }
      
      // Check if clicking existing object to select it
      const intersects = raycaster.intersectObjects(objects, true);
      
      if (intersects.length > 0) {
        // Check if this is a body part (for hierarchical control)
        const clickedMesh = intersects[0].object;
        const bodyPartInfo = getBodyPartFromMesh(clickedMesh);
        
        if (bodyPartInfo) {
          handleBodyPartSelection(bodyPartInfo, clickedMesh);
          return;
        }
        
        // Find the root object (in case of groups like anatomical arm)
        let clickedObject = intersects[0].object;
        while (clickedObject.parent && !objects.includes(clickedObject)) {
          clickedObject = clickedObject.parent;
        }
        
        selectedObject = clickedObject;
        selectedBodyPart = null; // Clear body part selection when selecting whole object
        bodyPartControlMode = null;
        
        // If Vertex Engine is active, analyze this object's vertices
        if (vertexEngineActive) {
          analyzeObjectVertices(clickedObject);
        }
        
        // Don't auto-attach transform, just select
        console.log('‚úÖ Object selected - Click Move/Rotate/Scale or press W/E/R');
        return;
      }
      
      // Otherwise place new object on ground
      if (currentMode === 'add') {
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(groundPlane, intersectPoint);

        if (intersectPoint) {
          placePrimitive(intersectPoint);
        }
      }
    }
    
    // üéØ Matrix Prism Navigator: Handle mouse hover over preview cubes
    function onCanvasMouseMove(event) {
      if (currentDimension !== 'navigator') {
        // Reset hover state if not in navigator
        if (hoveredNavigatorCube) {
          hoveredNavigatorCube.scale.set(1, 1, 1);
          const glow = hoveredNavigatorCube.getObjectByName('dimensionGlow');
          if (glow) glow.material.opacity = 0.1;
          hoveredNavigatorCube = null;
          canvas.style.cursor = 'default';
        }
        return;
      }
      
      const canvas = document.getElementById('canvas');
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      // üåê Check Spherical Navigator segments first (priority)
      const sphereGroup = dimensionalSpaces['navigator'].objects.find(
        obj => obj.name === 'SphericalNavigator'
      );
      
      if (sphereGroup) {
        const sphereIntersects = raycaster.intersectObjects(sphereGroup.children, true);
        
        // Reset all previous segment hovers
        sphereGroup.userData.layers.forEach(layerGroup => {
          layerGroup.userData.segments.forEach(segment => {
            if (segment.userData.isHovered) {
              segment.scale.copy(segment.userData.baseScale);
              const glow = segment.getObjectByName('segmentGlow');
              if (glow) glow.material.opacity = 0;
              segment.userData.isHovered = false;
            }
          });
        });
        
        if (sphereIntersects.length > 0) {
          // Find the segment group (traverse up from intersected mesh)
          let segmentGroup = sphereIntersects[0].object;
          while (segmentGroup && !segmentGroup.userData.isNavigatorSegment) {
            segmentGroup = segmentGroup.parent;
          }
          
          if (segmentGroup) {
            const navConfig = DIMENSIONAL_CONFIGS['navigator'];
            const hoverScale = navConfig.sphericalNav.segmentConfig.hoverScale || 1.3;
            const hoverGlow = navConfig.sphericalNav.segmentConfig.hoverGlow || 2.0;
            
            segmentGroup.scale.set(hoverScale, hoverScale, hoverScale);
            const glow = segmentGroup.getObjectByName('segmentGlow');
            if (glow) {
              glow.material.opacity = 0.4;
              glow.scale.set(hoverGlow, hoverGlow, hoverGlow);
            }
            segmentGroup.userData.isHovered = true;
            canvas.style.cursor = 'pointer';
            
            // Show tooltip with dimension name and category
            const dimConfig = segmentGroup.userData.dimensionConfig;
            canvas.title = `${dimConfig.icon} ${dimConfig.name}\n${segmentGroup.userData.layerCategory}`;
            return;
          }
        }
        
        canvas.style.cursor = 'default';
        canvas.title = 'Scroll to rotate layers';
        return;
      }
      
      // Fallback: Check Matrix Prism Navigator (legacy cube grid)
      const navigatorGroup = dimensionalSpaces['navigator'].objects.find(
        obj => obj.name === 'MatrixPrismNavigator'
      );
      
      if (navigatorGroup) {
        const intersects = raycaster.intersectObjects(navigatorGroup.children, true);
        
        // Reset previous hover
        if (hoveredNavigatorCube) {
          hoveredNavigatorCube.scale.set(1, 1, 1);
          const glow = hoveredNavigatorCube.getObjectByName('dimensionGlow');
          if (glow) glow.material.opacity = 0.1;
          hoveredNavigatorCube = null;
          canvas.style.cursor = 'default';
        }
        
        if (intersects.length > 0) {
          // Find the cube group (traverse up from intersected mesh)
          let cubeGroup = intersects[0].object;
          while (cubeGroup && !cubeGroup.userData.isNavigatorCube) {
            cubeGroup = cubeGroup.parent;
          }
          
          if (cubeGroup) {
            hoveredNavigatorCube = cubeGroup;
            cubeGroup.scale.set(1.2, 1.2, 1.2);
            const glow = cubeGroup.getObjectByName('dimensionGlow');
            if (glow) glow.material.opacity = 0.3;
            canvas.style.cursor = 'pointer';
            
            // Optional: Show tooltip with dimension name
            canvas.title = cubeGroup.userData.config.name;
          }
        }
      }
    }
    
    // Detect which body part was clicked
    function getBodyPartFromMesh(mesh) {
      // Traverse up to find labeled groups
      let current = mesh;
      while (current) {
        if (current.userData && current.userData.bodyPart) {
          return {
            part: current.userData.bodyPart,
            group: current.userData.controlGroup || current,
            name: current.userData.partName || current.userData.bodyPart
          };
        }
        current = current.parent;
      }
      return null;
    }
    
    // Handle body part selection and enable specific controls
    function handleBodyPartSelection(bodyPartInfo, mesh) {
      selectedBodyPart = bodyPartInfo.group;
      bodyPartControlMode = bodyPartInfo.part;
      
      console.log(`üéØ Selected: ${bodyPartInfo.name}`);
      
      // Enable specific controls based on body part
      switch(bodyPartInfo.part) {
        case 'leftArm':
        case 'rightArm':
          console.log('üí™ ARM CONTROL: Click and drag to rotate at shoulder');
          console.log('   Hold SHIFT + drag for elbow bend');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'leftHand':
        case 'rightHand':
          console.log('‚úã HAND CONTROL: Mouse wheel to rotate wrist');
          console.log('   Click and drag to move hand position');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'head':
          console.log('üß† HEAD CONTROL: Click and drag to swivel neck');
          console.log('   Or use neck swivel slider');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          document.getElementById('neckSwivelControls').style.display = 'block';
          break;
          
        case 'leftLeg':
        case 'rightLeg':
          console.log('ü¶µ LEG CONTROL: Click and drag to rotate at hip');
          console.log('   Hold SHIFT + drag for knee bend');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'torso':
          console.log('ü¶¥ TORSO CONTROL: Click and drag to bend/twist spine');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'leftFoot':
        case 'rightFoot':
          console.log('üëü FOOT CONTROL: Click and drag to rotate ankle');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        default:
          console.log('‚úÖ Body part selected');
          break;
      }
      
      // Select the root object for whole-body movement
      selectedObject = fullBodyGroup || objects.find(obj => obj.children.length > 0);
    }
    
    // Mouse wheel handler for wrist/hand rotation OR walking animation
    function onMouseWheel(event) {
      // üåê Spherical Navigator: Rotate layers with scroll wheel
      if (currentDimension === 'navigator' && dimensionalSpaces['navigator']) {
        const sphereGroup = dimensionalSpaces['navigator'].objects.find(
          obj => obj.name === 'SphericalNavigator'
        );
        
        if (sphereGroup) {
          event.preventDefault();
          
          const navConfig = DIMENSIONAL_CONFIGS['navigator'];
          const rotationSpeed = navConfig.sphericalNav.segmentConfig.rotationSpeed || 0.5;
          
          // Scroll down = rotate clockwise (positive), scroll up = counter-clockwise (negative)
          const delta = event.deltaY > 0 ? rotationSpeed : -rotationSpeed;
          sphereGroup.userData.targetRotation += delta * (Math.PI / 180); // Convert degrees to radians
          
          console.log(`üåê Spherical Navigator rotating ${delta > 0 ? 'clockwise ‚Üª' : 'counter-clockwise ‚Ü∫'} ${Math.abs(delta)}¬∞`);
          return;
        }
      }
      
      // If hand is selected, rotate wrist
      if (selectedBodyPart && (bodyPartControlMode === 'leftHand' || bodyPartControlMode === 'rightHand')) {
        event.preventDefault();
        const rotationSpeed = 0.002;
        const delta = event.deltaY * rotationSpeed;
        selectedBodyPart.rotation.z += delta;
        console.log(`‚úã Wrist rotation: ${(selectedBodyPart.rotation.z * 180 / Math.PI).toFixed(1)}¬∞`);
        return;
      }
      
      // If whole body is selected OR clicking on body triggers walking/running
      // Check if fullBodyGroup exists and either selected or we're in the scene
      if (window.fullBodyGroup && !selectedBodyPart) {
        event.preventDefault();
        
        // Update walk speed based on wheel delta
        const wheelSpeed = Math.abs(event.deltaY) / 100;
        walkCycleSpeed = Math.min(walkCycleSpeed + wheelSpeed, 10); // Cap at 10 (full sprint)
        lastWheelTime = Date.now();
        
        // Log state changes
        if (walkCycleSpeed < 1 && walkCycleSpeed > 0) {
          console.log('üö∂ Starting to walk...');
        } else if (walkCycleSpeed > 4 && walkCycleSpeed < 5) {
          console.log('üèÉ Breaking into a run!');
        } else if (walkCycleSpeed > 7) {
          console.log('üí® Full sprint!');
        }
        
        return;
      }
    }

    function placePrimitive(position) {
      let geometry;
      
      switch(currentPrimitive) {
        case 'sphere':
          geometry = new THREE.SphereGeometry(primitiveSize, 32, 32);
          break;
        case 'cube':
          geometry = new THREE.BoxGeometry(primitiveSize, primitiveSize, primitiveSize);
          break;
        case 'cylinder':
          geometry = new THREE.CylinderGeometry(primitiveSize, primitiveSize, primitiveSize * 2, 32);
          break;
        case 'cone':
          geometry = new THREE.ConeGeometry(primitiveSize, primitiveSize * 2, 32);
          break;
        case 'torus':
          geometry = new THREE.TorusGeometry(primitiveSize, primitiveSize * 0.3, 16, 32);
          break;
        case 'pyramid':
          geometry = new THREE.ConeGeometry(primitiveSize, primitiveSize * 1.5, 4);
          break;
      }

      const material = new THREE.MeshStandardMaterial({
        color: currentMode === 'add' ? 0x00ff88 : 0xff3366,
        roughness: 0.7,
        metalness: 0.3,
        transparent: true,
        opacity: 0.9
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.position.y = primitiveSize / 2;
      mesh.rotation.y = (rotationAngle * Math.PI) / 180;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData.mode = currentMode;

      scene.add(mesh);
      objects.push(mesh);
      
      updateObjectCount();
      console.log(`Placed ${currentPrimitive} at`, position);
    }

    function setMode(mode, btn) {
      currentMode = mode;
      document.querySelectorAll('#sidebar .tool-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('modeDisplay').textContent = mode.toUpperCase();
      
      // Detach transform and remove selection box when switching to add mode
      if (mode === 'add' && selectedObject) {
        transformControl.detach();
        selectedObject = null;
        
        if (selectionBox) {
          scene.remove(selectionBox);
          selectionBox = null;
        }
      }
    }

    function setTransformMode(mode) {
      if (!selectedObject) {
        alert('‚ö†Ô∏è Click an object first to select it!\n\n1. Click any object in the scene\n2. Then use Move/Rotate/Scale buttons\n3. Or press W/E/R keys');
        return;
      }
      
      // Disable orbit controls when using transform
      if (orbitEnabled) {
        orbitEnabled = false;
        controls.enabled = false;
        const btn = document.getElementById('orbitToggle');
        btn.textContent = 'üé• Orbit: OFF';
        btn.style.background = 'rgba(244, 67, 54, 0.3)';
        btn.style.borderColor = 'rgba(244, 67, 54, 0.6)';
      }
      
      transformControl.setMode(mode);
      
      // Show selection box when entering transform mode
      if (!selectionBox && selectedObject) {
        selectionBox = new THREE.BoxHelper(selectedObject, 0x00ff88);
        scene.add(selectionBox);
      }
      console.log(`üé® Transform mode: ${mode.toUpperCase()}`);
    }

    function setPrimitive(primitive, btn) {
      currentPrimitive = primitive;
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('primitiveDisplay').textContent = primitive.toUpperCase();
    }

    // ü¶æ HUMAN ANATOMY LOADER (86-Vertex System)
    function loadHumanAnatomy(btn) {
      console.log('ü¶æ Loading 86-vertex human anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical arm with 86 vertices
      const armGroup = new THREE.Group();
      const vertexCount = 86;
      
      // Shoulder (origin point)
      const shoulderGeom = new THREE.SphereGeometry(0.3, 8, 8);
      const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
      armGroup.add(shoulder);
      
      // Upper arm (14" / 35cm extended cylinder)
      const upperArmGeom = new THREE.CylinderGeometry(0.2, 0.18, 3.5, 16);
      const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
      upperArm.position.y = -1.75;
      armGroup.add(upperArm);
      
      // Elbow joint (180¬∞ pivot capability)
      const elbowGeom = new THREE.SphereGeometry(0.22, 8, 8);
      const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const elbow = new THREE.Mesh(elbowGeom, elbowMat);
      elbow.position.y = -3.5;
      armGroup.add(elbow);
      
      // Create forearm group for articulation (rotates at elbow)
      const forearmGroup = new THREE.Group();
      forearmGroup.position.y = -3.5; // At elbow position
      armGroup.add(forearmGroup);
      
      // Forearm (14" / 35cm) - relative to elbow
      const forearmGeom = new THREE.CylinderGeometry(0.18, 0.15, 3.5, 16);
      const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const forearm = new THREE.Mesh(forearmGeom, forearmMat);
      forearm.position.y = -1.75; // Relative to elbow
      forearmGroup.add(forearm);
      
      // Wrist joint
      const wristGeom = new THREE.SphereGeometry(0.16, 8, 8);
      const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const wrist = new THREE.Mesh(wristGeom, wristMat);
      wrist.position.y = -3.5; // Relative to elbow
      forearmGroup.add(wrist);
      
      // Wrist bone protrusion (270-300¬∞ styloid process)
      const wristBoneGeom = new THREE.SphereGeometry(0.01, 8, 8);
      const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
      wristBone.position.set(0.15, -3.5, 0); // Relative to elbow
      forearmGroup.add(wristBone);
      
      // Hand (oval with 40% growth + curl)
      const handGeom = new THREE.BoxGeometry(0.4, 0.6, 0.15);
      const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const hand = new THREE.Mesh(handGeom, handMat);
      hand.position.y = -4.3; // Relative to elbow
      hand.rotation.x = Math.PI / 8; // 45¬∞ curl
      forearmGroup.add(hand);
      
      // Thumb (190¬∞ hump alignment)
      const thumbGeom = new THREE.CylinderGeometry(0.08, 0.06, 0.5, 8);
      const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const thumb = new THREE.Mesh(thumbGeom, thumbMat);
      thumb.position.set(-0.25, -4.1, 0.1); // Relative to elbow
      thumb.rotation.z = -Math.PI / 3;
      forearmGroup.add(thumb);
      
      // 4 Fingers (progressive sizing: 3.5" base, -10% per finger)
      const fingerLengths = [0.875, 0.7875, 0.7, 0.6125];
      for (let i = 0; i < 4; i++) {
        const fingerGeom = new THREE.CylinderGeometry(0.06 * (1 - i * 0.1), 0.04 * (1 - i * 0.1), fingerLengths[i], 8);
        const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const finger = new THREE.Mesh(fingerGeom, fingerMat);
        finger.position.set(-0.15 + (i * 0.1), -4.8, 0); // Relative to elbow
        finger.rotation.x = Math.PI / 12;
        forearmGroup.add(finger);
        
        // Fingertip (spherical)
        const tipGeom = new THREE.SphereGeometry(0.05 * (1 - i * 0.1), 8, 8);
        const tipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const tip = new THREE.Mesh(tipGeom, tipMat);
        tip.position.set(-0.15 + (i * 0.1), -4.8 - fingerLengths[i] / 2, 0); // Relative to elbow
        forearmGroup.add(tip);
      }
      
      // Store references for articulation
      currentArmGroup = armGroup;
      armForearmPart = forearmGroup;
      
      // Position the arm group so hand rests on ground
      armGroup.position.set(0, 8.75, 0);
      scene.add(armGroup);
      objects.push(armGroup);
      
      // Show articulation controls
      document.getElementById('armArticulation').style.display = 'block';
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HUMAN ARM (${vertexCount}V)`;
      
      console.log(`‚úÖ Anatomical arm loaded: ${vertexCount} vertices - shoulder, upper arm, elbow, forearm, wrist, hand, thumb, 4 fingers - ARTICULATION ENABLED`);
    }
    
    // ü¶æü¶æ DUAL ARMS LOADER (172 Vertices Total)
    function loadBothArms(btn) {
      console.log('ü¶æü¶æ Loading both arms (left + right)...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      const bothArmsGroup = new THREE.Group();
      const totalVertexCount = 172;
      
      // Helper function to create a single arm
      function createArm(xOffset, isRight = false) {
        const armGroup = new THREE.Group();
        
        // Shoulder
        const shoulderGeom = new THREE.SphereGeometry(0.3, 8, 8);
        const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
        armGroup.add(shoulder);
        
        // Upper arm
        const upperArmGeom = new THREE.CylinderGeometry(0.2, 0.18, 3.5, 16);
        const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
        upperArm.position.y = -1.75;
        armGroup.add(upperArm);
        
        // Elbow joint
        const elbowGeom = new THREE.SphereGeometry(0.22, 8, 8);
        const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const elbow = new THREE.Mesh(elbowGeom, elbowMat);
        elbow.position.y = -3.5;
        armGroup.add(elbow);
        
        // Forearm group for articulation
        const forearmGroup = new THREE.Group();
        forearmGroup.position.y = -3.5;
        armGroup.add(forearmGroup);
        
        // Forearm
        const forearmGeom = new THREE.CylinderGeometry(0.18, 0.15, 3.5, 16);
        const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const forearm = new THREE.Mesh(forearmGeom, forearmMat);
        forearm.position.y = -1.75;
        forearmGroup.add(forearm);
        
        // Wrist
        const wristGeom = new THREE.SphereGeometry(0.16, 8, 8);
        const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const wrist = new THREE.Mesh(wristGeom, wristMat);
        wrist.position.y = -3.5;
        forearmGroup.add(wrist);
        
        // Wrist bone (mirror for right arm)
        const wristBoneGeom = new THREE.SphereGeometry(0.01, 8, 8);
        const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
        wristBone.position.set(isRight ? -0.15 : 0.15, -3.5, 0);
        forearmGroup.add(wristBone);
        
        // Hand
        const handGeom = new THREE.BoxGeometry(0.4, 0.6, 0.15);
        const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hand = new THREE.Mesh(handGeom, handMat);
        hand.position.y = -4.3;
        hand.rotation.x = Math.PI / 8;
        forearmGroup.add(hand);
        
        // Thumb (mirror position for right arm)
        const thumbGeom = new THREE.CylinderGeometry(0.08, 0.06, 0.5, 8);
        const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thumb = new THREE.Mesh(thumbGeom, thumbMat);
        thumb.position.set(isRight ? 0.25 : -0.25, -4.1, 0.1);
        thumb.rotation.z = isRight ? Math.PI / 3 : -Math.PI / 3;
        forearmGroup.add(thumb);
        
        // 4 Fingers
        const fingerLengths = [0.875, 0.7875, 0.7, 0.6125];
        for (let i = 0; i < 4; i++) {
          const fingerGeom = new THREE.CylinderGeometry(0.06 * (1 - i * 0.1), 0.04 * (1 - i * 0.1), fingerLengths[i], 8);
          const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const finger = new THREE.Mesh(fingerGeom, fingerMat);
          const xPos = isRight ? 0.15 - (i * 0.1) : -0.15 + (i * 0.1);
          finger.position.set(xPos, -4.8, 0);
          finger.rotation.x = Math.PI / 12;
          forearmGroup.add(finger);
          
          // Fingertip
          const tipGeom = new THREE.SphereGeometry(0.05 * (1 - i * 0.1), 8, 8);
          const tipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const tip = new THREE.Mesh(tipGeom, tipMat);
          tip.position.set(xPos, -4.8 - fingerLengths[i] / 2, 0);
          forearmGroup.add(tip);
        }
        
        // Position arm at shoulder offset
        armGroup.position.set(xOffset, 0, 0);
        
        return { armGroup, forearmGroup };
      }
      
      // Create left arm (negative X)
      const leftArm = createArm(-1.2, false);
      bothArmsGroup.add(leftArm.armGroup);
      
      // Create right arm (positive X)
      const rightArm = createArm(1.2, true);
      bothArmsGroup.add(rightArm.armGroup);
      
      // Position both arms at shoulder height
      bothArmsGroup.position.set(0, 8.75, 0);
      scene.add(bothArmsGroup);
      objects.push(bothArmsGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `BOTH ARMS (${totalVertexCount}V)`;
      
      console.log(`‚úÖ Both arms loaded: ${totalVertexCount} vertices (86V √ó 2) - left shoulder at X=-1.2, right shoulder at X=1.2`);
    }
    
    // Update elbow angle (180¬∞ = straight, 340¬∞ = fully bent)
    function updateElbowAngle(angle) {
      if (!armForearmPart) {
        console.warn('‚ö†Ô∏è No arm loaded for articulation');
        return;
      }
      
      // Convert angle to radians (180¬∞ = 0 rad, 340¬∞ = bent forward)
      // Rotate around X axis to bend elbow
      const bendAngle = (angle - 180) * (Math.PI / 180);
      armForearmPart.rotation.x = bendAngle;
      
      // Update display
      document.getElementById('elbowAngleValue').textContent = angle + '¬∞';
      
      console.log(`üí™ Elbow angle: ${angle}¬∞ (${bendAngle.toFixed(2)} rad)`);
    }

    // ü¶µ HUMAN LEG LOADER (86-Vertex System)
    function loadHumanLeg(btn) {
      console.log('ü¶µ Loading 86-vertex leg anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical leg with 86 vertices
      const legGroup = new THREE.Group();
      const vertexCount = 86;
      
      // Hip joint (origin point)
      const hipGeom = new THREE.SphereGeometry(0.35, 8, 8);
      const hipMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const hip = new THREE.Mesh(hipGeom, hipMat);
      legGroup.add(hip);
      
      // Thigh (14" / 35cm extended cylinder)
      const thighGeom = new THREE.CylinderGeometry(0.25, 0.22, 3.5, 16);
      const thighMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const thigh = new THREE.Mesh(thighGeom, thighMat);
      thigh.position.y = -1.75;
      legGroup.add(thigh);
      
      // Knee joint (180¬∞ pivot capability)
      const kneeGeom = new THREE.SphereGeometry(0.24, 8, 8);
      const kneeMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const knee = new THREE.Mesh(kneeGeom, kneeMat);
      knee.position.y = -3.5;
      legGroup.add(knee);
      
      // Calf (14" / 35cm)
      const calfGeom = new THREE.CylinderGeometry(0.22, 0.18, 3.5, 16);
      const calfMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const calf = new THREE.Mesh(calfGeom, calfMat);
      calf.position.y = -5.25;
      legGroup.add(calf);
      
      // Ankle joint
      const ankleGeom = new THREE.SphereGeometry(0.18, 8, 8);
      const ankleMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const ankle = new THREE.Mesh(ankleGeom, ankleMat);
      ankle.position.y = -7;
      legGroup.add(ankle);
      
      // Ankle bone protrusion (malleolus)
      const ankleBoneGeom = new THREE.SphereGeometry(0.012, 8, 8);
      const ankleBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const ankleBone = new THREE.Mesh(ankleBoneGeom, ankleBoneMat);
      ankleBone.position.set(0.18, -7, 0);
      legGroup.add(ankleBone);
      
      // Foot (elongated with 40% growth)
      const footGeom = new THREE.BoxGeometry(0.35, 0.25, 0.8);
      const footMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const foot = new THREE.Mesh(footGeom, footMat);
      foot.position.set(0, -7.3, 0.3);
      foot.rotation.x = -Math.PI / 16; // Slight arch
      legGroup.add(foot);
      
      // Big toe (larger and separate)
      const bigToeGeom = new THREE.CylinderGeometry(0.07, 0.05, 0.35, 8);
      const bigToeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const bigToe = new THREE.Mesh(bigToeGeom, bigToeMat);
      bigToe.position.set(-0.12, -7.5, 0.65);
      bigToe.rotation.x = Math.PI / 2;
      legGroup.add(bigToe);
      
      // 4 Toes (progressive sizing: smaller than big toe, decreasing)
      const toeLengths = [0.28, 0.26, 0.24, 0.22]; // Progressive reduction
      for (let i = 0; i < 4; i++) {
        const toeGeom = new THREE.CylinderGeometry(0.045 * (1 - i * 0.08), 0.03 * (1 - i * 0.08), toeLengths[i], 8);
        const toeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const toe = new THREE.Mesh(toeGeom, toeMat);
        toe.position.set(-0.05 + (i * 0.08), -7.5, 0.65);
        toe.rotation.x = Math.PI / 2;
        legGroup.add(toe);
        
        // Toe tip (spherical)
        const toeTipGeom = new THREE.SphereGeometry(0.035 * (1 - i * 0.08), 8, 8);
        const toeTipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const toeTip = new THREE.Mesh(toeTipGeom, toeTipMat);
        toeTip.position.set(-0.05 + (i * 0.08), -7.5, 0.65 + toeLengths[i] / 2);
        legGroup.add(toeTip);
      }
      
      // Position the leg group so foot rests on ground (foot bottom is at ~Y=-7.5, so lift by 7.5)
      legGroup.position.set(0, 7.5, 0);
      scene.add(legGroup);
      objects.push(legGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HUMAN LEG (${vertexCount}V)`;
      
      console.log(`‚úÖ Anatomical leg loaded: ${vertexCount} vertices - hip, thigh, knee, calf, ankle, foot, big toe, 4 toes`);
    }

    // ÔøΩü¶µ BOTH LEGS LOADER (172 Vertices Total - 86V each)
    function loadBothLegs(btn) {
      console.log('ü¶µü¶µ Loading both legs with symmetry...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Helper function to create a single leg with mirroring
      function createLeg(xOffset, isRight) {
        const legGroup = new THREE.Group();
        
        // Hip joint (origin point)
        const hipGeom = new THREE.SphereGeometry(0.35, 8, 8);
        const hipMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hip = new THREE.Mesh(hipGeom, hipMat);
        legGroup.add(hip);
        
        // Thigh (14" / 35cm extended cylinder)
        const thighGeom = new THREE.CylinderGeometry(0.25, 0.22, 3.5, 16);
        const thighMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thigh = new THREE.Mesh(thighGeom, thighMat);
        thigh.position.y = -1.75;
        legGroup.add(thigh);
        
        // Knee joint (180¬∞ pivot capability)
        const kneeGeom = new THREE.SphereGeometry(0.24, 8, 8);
        const kneeMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const knee = new THREE.Mesh(kneeGeom, kneeMat);
        knee.position.y = -3.5;
        legGroup.add(knee);
        
        // Calf (14" / 35cm)
        const calfGeom = new THREE.CylinderGeometry(0.22, 0.18, 3.5, 16);
        const calfMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const calf = new THREE.Mesh(calfGeom, calfMat);
        calf.position.y = -5.25;
        legGroup.add(calf);
        
        // Ankle joint
        const ankleGeom = new THREE.SphereGeometry(0.18, 8, 8);
        const ankleMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const ankle = new THREE.Mesh(ankleGeom, ankleMat);
        ankle.position.y = -7;
        legGroup.add(ankle);
        
        // Ankle bone protrusion (malleolus) - MIRRORED
        const ankleBoneGeom = new THREE.SphereGeometry(0.012, 8, 8);
        const ankleBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const ankleBone = new THREE.Mesh(ankleBoneGeom, ankleBoneMat);
        ankleBone.position.set(isRight ? 0.18 : -0.18, -7, 0); // Mirror X position
        legGroup.add(ankleBone);
        
        // Foot (elongated with 40% growth)
        const footGeom = new THREE.BoxGeometry(0.35, 0.25, 0.8);
        const footMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const foot = new THREE.Mesh(footGeom, footMat);
        foot.position.set(0, -7.3, 0.3);
        foot.rotation.x = -Math.PI / 16; // Slight arch
        legGroup.add(foot);
        
        // Big toe (larger and separate) - MIRRORED
        const bigToeGeom = new THREE.CylinderGeometry(0.07, 0.05, 0.35, 8);
        const bigToeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const bigToe = new THREE.Mesh(bigToeGeom, bigToeMat);
        bigToe.position.set(isRight ? -0.12 : 0.12, -7.5, 0.65); // Mirror X (big toe on inside)
        bigToe.rotation.x = Math.PI / 2;
        legGroup.add(bigToe);
        
        // 4 Toes (progressive sizing) - MIRRORED X positions
        const toeLengths = [0.28, 0.26, 0.24, 0.22]; // Progressive reduction
        for (let i = 0; i < 4; i++) {
          const toeGeom = new THREE.CylinderGeometry(0.045 * (1 - i * 0.08), 0.03 * (1 - i * 0.08), toeLengths[i], 8);
          const toeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const toe = new THREE.Mesh(toeGeom, toeMat);
          const toeXBase = isRight ? -0.05 : 0.05;
          const toeXOffset = isRight ? (i * 0.08) : -(i * 0.08);
          toe.position.set(toeXBase + toeXOffset, -7.5, 0.65);
          toe.rotation.x = Math.PI / 2;
          legGroup.add(toe);
          
          // Toe tip (spherical)
          const toeTipGeom = new THREE.SphereGeometry(0.035 * (1 - i * 0.08), 8, 8);
          const toeTipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const toeTip = new THREE.Mesh(toeTipGeom, toeTipMat);
          toeTip.position.set(toeXBase + toeXOffset, -7.5, 0.65 + toeLengths[i] / 2);
          legGroup.add(toeTip);
        }
        
        // Position leg at specified X offset
        legGroup.position.set(xOffset, 0, 0);
        return legGroup;
      }
      
      // Create container group for both legs
      const bothLegsGroup = new THREE.Group();
      
      // Create left leg (X = -0.4, at left hip)
      const leftLeg = createLeg(-0.4, false);
      bothLegsGroup.add(leftLeg);
      
      // Create right leg (X = 0.4, at right hip)
      const rightLeg = createLeg(0.4, true);
      bothLegsGroup.add(rightLeg);
      
      // Position both legs so feet rest on ground (foot bottom is at ~Y=-7.5, so lift by 7.5)
      bothLegsGroup.position.set(0, 7.5, 0);
      
      scene.add(bothLegsGroup);
      objects.push(bothLegsGroup);
      
      // Update UI
      const totalVertexCount = 172; // 86V √ó 2 legs
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `BOTH LEGS (${totalVertexCount}V)`;
      
      console.log(`‚úÖ Both legs loaded: ${totalVertexCount} vertices (86V each) - left at X=-0.4, right at X=0.4`);
    }

    // ÔøΩü¶¥ HUMAN TORSO LOADER (120+ Vertices)
    function loadHumanTorso(btn) {
      console.log('ü¶¥ Loading torso anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical torso
      const torsoGroup = new THREE.Group();
      let vertexCount = 120;
      
      // Pelvis base (hip connector)
      const pelvisGeom = new THREE.CylinderGeometry(0.45, 0.5, 0.6, 16);
      const pelvisMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const pelvis = new THREE.Mesh(pelvisGeom, pelvisMat);
      pelvis.position.y = 0;
      torsoGroup.add(pelvis);
      
      // Lower spine (L1-L5 lumbar vertebrae)
      const lowerSpineGeom = new THREE.CylinderGeometry(0.12, 0.12, 1.2, 12);
      const spineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const lowerSpine = new THREE.Mesh(lowerSpineGeom, spineMat);
      lowerSpine.position.y = 0.9;
      torsoGroup.add(lowerSpine);
      
      // Mid spine (T7-T12 thoracic vertebrae)
      const midSpineGeom = new THREE.CylinderGeometry(0.13, 0.12, 1.5, 12);
      const midSpine = new THREE.Mesh(midSpineGeom, spineMat);
      midSpine.position.y = 2.25;
      torsoGroup.add(midSpine);
      
      // Upper spine (T1-T6 thoracic vertebrae)
      const upperSpineGeom = new THREE.CylinderGeometry(0.14, 0.13, 1.2, 12);
      const upperSpine = new THREE.Mesh(upperSpineGeom, spineMat);
      upperSpine.position.y = 3.6;
      torsoGroup.add(upperSpine);
      
      // Ribcage (12 ribs on each side)
      for (let i = 0; i < 12; i++) {
        const ribHeight = 2.0 + (i * 0.15);
        const ribWidth = 0.35 + (i * 0.04);
        const ribDepth = 0.25 + (i * 0.03);
        
        // Left rib
        const leftRibGeom = new THREE.TorusGeometry(ribWidth, 0.02, 8, 16, Math.PI);
        const ribMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const leftRib = new THREE.Mesh(leftRibGeom, ribMat);
        leftRib.position.set(-0.15, ribHeight, 0);
        leftRib.rotation.y = Math.PI / 2;
        leftRib.rotation.z = -Math.PI / 12;
        torsoGroup.add(leftRib);
        
        // Right rib
        const rightRib = new THREE.Mesh(leftRibGeom.clone(), ribMat);
        rightRib.position.set(0.15, ribHeight, 0);
        rightRib.rotation.y = -Math.PI / 2;
        rightRib.rotation.z = Math.PI / 12;
        torsoGroup.add(rightRib);
      }
      
      // Chest/sternum
      const chestGeom = new THREE.BoxGeometry(0.4, 1.8, 0.2);
      const chestMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.7 });
      const chest = new THREE.Mesh(chestGeom, chestMat);
      chest.position.set(0, 3.0, 0.35);
      torsoGroup.add(chest);
      
      // Left shoulder socket
      const leftShoulderGeom = new THREE.SphereGeometry(0.25, 8, 8);
      const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.6 });
      const leftShoulder = new THREE.Mesh(leftShoulderGeom, shoulderMat);
      leftShoulder.position.set(-0.6, 4.0, 0);
      torsoGroup.add(leftShoulder);
      
      // Right shoulder socket
      const rightShoulder = new THREE.Mesh(leftShoulderGeom, shoulderMat);
      rightShoulder.position.set(0.6, 4.0, 0);
      torsoGroup.add(rightShoulder);
      
      // Clavicles (collar bones)
      const clavicleGeom = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8);
      const clavicleMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      
      const leftClavicle = new THREE.Mesh(clavicleGeom, clavicleMat);
      leftClavicle.position.set(-0.35, 4.0, 0.1);
      leftClavicle.rotation.z = Math.PI / 6;
      torsoGroup.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(clavicleGeom, clavicleMat);
      rightClavicle.position.set(0.35, 4.0, 0.1);
      rightClavicle.rotation.z = -Math.PI / 6;
      torsoGroup.add(rightClavicle);
      
      // Position torso at ground level (pelvis at Y=0, lift to ground)
      torsoGroup.position.set(0, 0.3, 0);
      scene.add(torsoGroup);
      objects.push(torsoGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `TORSO (${vertexCount}V)`;
      
      console.log(`‚úÖ Anatomical torso loaded: ${vertexCount}+ vertices - pelvis, spine, 24 ribs, chest, shoulders, clavicles`);
    }

    // üß† HUMAN HEAD & NECK LOADER (100+ Vertices)
    function loadHumanHead(btn) {
      console.log('üß† Loading head and neck anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical head & neck group
      const headGroup = new THREE.Group();
      let vertexCount = 100;
      
      // Neck base (C7 vertebra)
      const neckBaseGeom = new THREE.CylinderGeometry(0.14, 0.12, 0.4, 12);
      const neckMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const neckBase = new THREE.Mesh(neckBaseGeom, neckMat);
      neckBase.position.y = 0.2;
      headGroup.add(neckBase);
      
      // Create neck swivel group (rotates for head turning)
      const neckSwivelGroup = new THREE.Group();
      neckSwivelGroup.position.y = 0.4;
      headGroup.add(neckSwivelGroup);
      
      // Neck cylinder (C1-C6 cervical vertebrae)
      const neckGeom = new THREE.CylinderGeometry(0.12, 0.14, 1.0, 12);
      const neck = new THREE.Mesh(neckGeom, neckMat);
      neck.position.y = 0.5;
      neckSwivelGroup.add(neck);
      
      // Skull base (foramen magnum)
      const skullBaseGeom = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 12);
      const boneMat = new THREE.MeshStandardMaterial({ color: 0xfff8e7, roughness: 0.4 });
      const skullBase = new THREE.Mesh(skullBaseGeom, boneMat);
      skullBase.position.y = 1.1;
      neckSwivelGroup.add(skullBase);
      
      // Cranium (main skull sphere)
      const craniumGeom = new THREE.SphereGeometry(0.65, 16, 16);
      const cranium = new THREE.Mesh(craniumGeom, boneMat);
      cranium.position.y = 1.6;
      cranium.scale.set(1, 1.1, 1); // Slightly taller
      neckSwivelGroup.add(cranium);
      
      // Jaw (mandible)
      const jawGeom = new THREE.BoxGeometry(0.5, 0.3, 0.4);
      const skinMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const jaw = new THREE.Mesh(jawGeom, skinMat);
      jaw.position.set(0, 1.0, 0.25);
      neckSwivelGroup.add(jaw);
      
      // Face plane (for features)
      const faceGeom = new THREE.CircleGeometry(0.55, 16);
      const faceMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.6, side: THREE.DoubleSide });
      const face = new THREE.Mesh(faceGeom, faceMat);
      face.position.set(0, 1.6, 0.6);
      neckSwivelGroup.add(face);
      
      // Left eye
      const eyeGeom = new THREE.SphereGeometry(0.08, 12, 12);
      const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const leftEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
      leftEye.position.set(-0.18, 1.7, 0.58);
      neckSwivelGroup.add(leftEye);
      
      // Left pupil
      const pupilGeom = new THREE.SphereGeometry(0.04, 12, 12);
      const pupilMat = new THREE.MeshStandardMaterial({ color: 0x2a4d69, roughness: 0.2 });
      const leftPupil = new THREE.Mesh(pupilGeom, pupilMat);
      leftPupil.position.set(-0.18, 1.7, 0.63);
      neckSwivelGroup.add(leftPupil);
      
      // Right eye
      const rightEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
      rightEye.position.set(0.18, 1.7, 0.58);
      neckSwivelGroup.add(rightEye);
      
      // Right pupil
      const rightPupil = new THREE.Mesh(pupilGeom, pupilMat);
      rightPupil.position.set(0.18, 1.7, 0.63);
      neckSwivelGroup.add(rightPupil);
      
      // Nose
      const noseGeom = new THREE.ConeGeometry(0.08, 0.2, 8);
      const nose = new THREE.Mesh(noseGeom, skinMat);
      nose.position.set(0, 1.5, 0.62);
      nose.rotation.x = Math.PI / 2;
      neckSwivelGroup.add(nose);
      
      // Mouth
      const mouthGeom = new THREE.BoxGeometry(0.25, 0.05, 0.1);
      const mouthMat = new THREE.MeshStandardMaterial({ color: 0xff6b8a, roughness: 0.5 });
      const mouth = new THREE.Mesh(mouthGeom, mouthMat);
      mouth.position.set(0, 1.25, 0.6);
      neckSwivelGroup.add(mouth);
      
      // Left ear
      const earGeom = new THREE.SphereGeometry(0.12, 12, 12);
      const leftEar = new THREE.Mesh(earGeom, skinMat);
      leftEar.position.set(-0.6, 1.6, 0.1);
      leftEar.scale.set(0.5, 1, 0.8);
      neckSwivelGroup.add(leftEar);
      
      // Right ear
      const rightEar = new THREE.Mesh(earGeom, skinMat);
      rightEar.position.set(0.6, 1.6, 0.1);
      rightEar.scale.set(0.5, 1, 0.8);
      neckSwivelGroup.add(rightEar);
      
      // Store reference for neck swivel
      currentHeadGroup = headGroup;
      headNeckSwivel = neckSwivelGroup;
      
      // Position head at appropriate height
      headGroup.position.set(0, 4.5, 0);
      scene.add(headGroup);
      objects.push(headGroup);
      
      // Show neck swivel controls
      document.getElementById('neckSwivel').style.display = 'block';
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HEAD (${vertexCount}V)`;
      
      console.log(`‚úÖ Anatomical head loaded: ${vertexCount}+ vertices - neck, skull, jaw, eyes, nose, mouth, ears - NECK SWIVEL ENABLED`);
    }
    
    // ü¶¥ DETAILED FACIAL STRUCTURE with Cheekbones, Proper Jaw, Teeth, Gums
    function createDetailedFace(parent, yOffset = 0) {
      console.log('üòä Creating detailed facial structure...');
      
      const faceGroup = new THREE.Group();
      faceGroup.name = 'Detailed Face';
      faceGroup.position.y = yOffset;
      
      // === SKIN MATERIALS ===
      const skinMat = new THREE.MeshStandardMaterial({ 
        color: 0xffccaa,
        roughness: 0.65,
        metalness: 0.05,
        side: THREE.DoubleSide
      });
      
      const boneMat = new THREE.MeshStandardMaterial({ 
        color: 0xfff8e7,
        roughness: 0.4,
        metalness: 0.1
      });
      
      const gumMat = new THREE.MeshStandardMaterial({ 
        color: 0xffb3ba,
        roughness: 0.7
      });
      
      const toothMat = new THREE.MeshStandardMaterial({ 
        color: 0xfff8f0,
        roughness: 0.2,
        metalness: 0.1
      });
      
      // === SKULL BASE & JAW BONE ===
      // Maxilla (upper jaw bone)
      const maxillaGeom = new THREE.BoxGeometry(0.5, 0.35, 0.45);
      const maxilla = new THREE.Mesh(maxillaGeom, boneMat);
      maxilla.name = 'Maxilla (Upper Jaw)';
      maxilla.position.set(0, 1.5, 0.3);
      maxilla.scale.set(1, 0.7, 1);
      faceGroup.add(maxilla);
      
      // Mandible (lower jaw bone) - anatomically shaped
      const mandibleVertices = [];
      const segments = 20;
      
      // Create U-shaped mandible
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const angle = (t - 0.5) * Math.PI; // -90¬∞ to 90¬∞
        const radius = 0.3;
        const x = Math.sin(angle) * radius;
        const z = Math.cos(angle) * radius * 0.6 + 0.25;
        const y = 0.95 - Math.abs(Math.sin(angle)) * 0.05; // Slight curve
        
        // Top row
        mandibleVertices.push(x, y + 0.08, z);
        // Bottom row
        mandibleVertices.push(x, y - 0.08, z);
      }
      
      const mandibleGeom = new THREE.BufferGeometry();
      mandibleGeom.setAttribute('position', new THREE.Float32BufferAttribute(mandibleVertices, 3));
      
      // Create faces for mandible
      const mandibleIndices = [];
      for (let i = 0; i < segments; i++) {
        const topLeft = i * 2;
        const bottomLeft = i * 2 + 1;
        const topRight = (i + 1) * 2;
        const bottomRight = (i + 1) * 2 + 1;
        
        mandibleIndices.push(topLeft, bottomLeft, topRight);
        mandibleIndices.push(bottomLeft, bottomRight, topRight);
      }
      mandibleGeom.setIndex(mandibleIndices);
      mandibleGeom.computeVertexNormals();
      
      const mandible = new THREE.Mesh(mandibleGeom, boneMat);
      mandible.name = 'Mandible (Lower Jaw)';
      faceGroup.add(mandible);
      
      // === CHEEKBONES (Zygomatic Bones) ===
      const cheekboneGeom = new THREE.SphereGeometry(0.15, 12, 12);
      
      // Left cheekbone
      const leftCheekbone = new THREE.Mesh(cheekboneGeom, boneMat);
      leftCheekbone.name = 'Left Zygomatic (Cheekbone)';
      leftCheekbone.position.set(-0.35, 1.6, 0.45);
      leftCheekbone.scale.set(1, 0.6, 1.2);
      faceGroup.add(leftCheekbone);
      
      // Right cheekbone
      const rightCheekbone = new THREE.Mesh(cheekboneGeom, boneMat);
      rightCheekbone.name = 'Right Zygomatic (Cheekbone)';
      rightCheekbone.position.set(0.35, 1.6, 0.45);
      rightCheekbone.scale.set(1, 0.6, 1.2);
      faceGroup.add(rightCheekbone);
      
      // === UPPER TEETH & GUMS ===
      const upperGumGeom = new THREE.CylinderGeometry(0.28, 0.28, 0.08, 16, 1, false, 0, Math.PI);
      const upperGum = new THREE.Mesh(upperGumGeom, gumMat);
      upperGum.name = 'Upper Gum';
      upperGum.position.set(0, 1.38, 0.42);
      upperGum.rotation.x = -Math.PI / 2;
      faceGroup.add(upperGum);
      
      // Upper teeth (16 teeth - 8 visible from front)
      const toothGeom = new THREE.BoxGeometry(0.04, 0.12, 0.05);
      const upperTeeth = [];
      
      for (let i = 0; i < 8; i++) {
        const tooth = new THREE.Mesh(toothGeom, toothMat);
        tooth.name = `Upper Tooth ${i + 1}`;
        
        const angle = ((i - 3.5) / 8) * Math.PI * 0.6; // Spread across arc
        const radius = 0.27;
        const x = Math.sin(angle) * radius;
        const z = Math.cos(angle) * radius + 0.42;
        
        tooth.position.set(x, 1.36, z);
        tooth.rotation.y = -angle;
        
        // Vary tooth size slightly
        if (i === 0 || i === 7) { // Incisors
          tooth.scale.set(0.9, 1, 0.9);
        } else if (i === 3 || i === 4) { // Canines
          tooth.scale.set(0.85, 1.1, 0.9);
        }
        
        faceGroup.add(tooth);
        upperTeeth.push(tooth);
      }
      
      // === LOWER TEETH & GUMS ===
      const lowerGumGeom = new THREE.CylinderGeometry(0.26, 0.26, 0.08, 16, 1, false, 0, Math.PI);
      const lowerGum = new THREE.Mesh(lowerGumGeom, gumMat);
      lowerGum.name = 'Lower Gum';
      lowerGum.position.set(0, 1.08, 0.38);
      lowerGum.rotation.x = -Math.PI / 2;
      lowerGum.rotation.z = Math.PI;
      faceGroup.add(lowerGum);
      
      // Lower teeth (16 teeth - 8 visible from front)
      const lowerTeeth = [];
      
      for (let i = 0; i < 8; i++) {
        const tooth = new THREE.Mesh(toothGeom, toothMat);
        tooth.name = `Lower Tooth ${i + 1}`;
        
        const angle = ((i - 3.5) / 8) * Math.PI * 0.55; // Slightly narrower arc
        const radius = 0.25;
        const x = Math.sin(angle) * radius;
        const z = Math.cos(angle) * radius + 0.38;
        
        tooth.position.set(x, 1.10, z);
        tooth.rotation.y = -angle;
        tooth.scale.set(0.9, 0.95, 0.9); // Slightly smaller than upper
        
        faceGroup.add(tooth);
        lowerTeeth.push(tooth);
      }
      
      // === TONGUE ===
      const tongueGeom = new THREE.BoxGeometry(0.18, 0.06, 0.28);
      const tongueMat = new THREE.MeshStandardMaterial({ 
        color: 0xff6b8a,
        roughness: 0.8
      });
      const tongue = new THREE.Mesh(tongueGeom, tongueMat);
      tongue.name = 'Tongue';
      tongue.position.set(0, 1.18, 0.32);
      tongue.scale.set(1, 1, 1.2);
      faceGroup.add(tongue);
      
      // === SKIN OVERLAY ===
      // Face skin (covering cheekbones and jaw)
      const faceSkinGeom = new THREE.SphereGeometry(0.58, 24, 24, 0, Math.PI * 2, 0, Math.PI * 0.65);
      const faceSkin = new THREE.Mesh(faceSkinGeom, skinMat);
      faceSkin.name = 'Facial Skin';
      faceSkin.position.set(0, 1.5, 0.35);
      faceSkin.scale.set(1.05, 1, 1.1);
      faceGroup.add(faceSkin);
      
      // Chin skin
      const chinGeom = new THREE.SphereGeometry(0.15, 16, 16);
      const chin = new THREE.Mesh(chinGeom, skinMat);
      chin.name = 'Chin';
      chin.position.set(0, 0.88, 0.42);
      chin.scale.set(1.2, 0.9, 1);
      faceGroup.add(chin);
      
      // Lip overlay (covers tooth gap)
      const upperLipGeom = new THREE.BoxGeometry(0.32, 0.04, 0.08);
      const lipMat = new THREE.MeshStandardMaterial({ 
        color: 0xffaaaa,
        roughness: 0.6
      });
      const upperLip = new THREE.Mesh(upperLipGeom, lipMat);
      upperLip.name = 'Upper Lip';
      upperLip.position.set(0, 1.32, 0.56);
      faceGroup.add(upperLip);
      
      const lowerLipGeom = new THREE.BoxGeometry(0.30, 0.05, 0.08);
      const lowerLip = new THREE.Mesh(lowerLipGeom, lipMat);
      lowerLip.name = 'Lower Lip';
      lowerLip.position.set(0, 1.20, 0.56);
      faceGroup.add(lowerLip);
      
      parent.add(faceGroup);
      
      console.log('‚úÖ Detailed face created:');
      console.log('  ‚Üí Maxilla & Mandible (jaw bones)');
      console.log('  ‚Üí Zygomatic bones (cheekbones)');
      console.log('  ‚Üí 16 upper teeth + gums');
      console.log('  ‚Üí 16 lower teeth + gums');
      console.log('  ‚Üí Tongue');
      console.log('  ‚Üí Facial skin with lips');
      
      return faceGroup;
    }
    
    // Update neck swivel angle (-180¬∞ to 180¬∞)
    function updateNeckSwivel(angle) {
      if (!headNeckSwivel) {
        console.warn('‚ö†Ô∏è No head loaded for neck swivel');
        return;
      }
      
      // Convert angle to radians and rotate around Y axis
      const swivelAngle = angle * (Math.PI / 180);
      headNeckSwivel.rotation.y = swivelAngle;
      
      // Update display
      document.getElementById('neckSwivelValue').textContent = angle + '¬∞';
      
      console.log(`üîÑ Neck swivel: ${angle}¬∞ (${swivelAngle.toFixed(2)} rad)`);
    }

    // üßç FULL BODY LOADER (564+ Vertices Total)
    function loadFullBody(btn) {
      console.log('üßç Loading complete human body with all parts...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create main body container
      const fullBodyGroup = new THREE.Group();
      let totalVertices = 0;
      
      // ===== LEGS (172V) - Ground Level =====
      const legsGroup = new THREE.Group();
      
      function createLeg(xOffset, isRight) {
        const legGroup = new THREE.Group();
        const sideName = isRight ? 'Right' : 'Left';
        
        // Hip joint (Acetabulum - socket in pelvis)
        const hipGeom = new THREE.SphereGeometry(0.35, 8, 8);
        const hipMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hip = new THREE.Mesh(hipGeom, hipMat);
        hip.name = `${sideName} Hip Joint (Acetabulum)`;
        legGroup.add(hip);
        
        // Thigh (Femur - longest bone in body)
        const thighGeom = new THREE.CylinderGeometry(0.25, 0.22, 3.5, 16);
        const thighMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thigh = new THREE.Mesh(thighGeom, thighMat);
        thigh.name = `${sideName} Femur (Thigh Bone)`;
        thigh.position.y = -1.75;
        legGroup.add(thigh);
        
        // === KNEE GROUP (for flexion/bending) ===
        const kneeGroup = new THREE.Group();
        kneeGroup.position.y = -3.5; // Position at knee joint
        
        // Knee joint (Patella - kneecap)
        const kneeGeom = new THREE.SphereGeometry(0.24, 8, 8);
        const kneeMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const knee = new THREE.Mesh(kneeGeom, kneeMat);
        knee.name = `${sideName} Patella (Kneecap)`;
        knee.position.y = 0; // Relative to kneeGroup
        kneeGroup.add(knee);
        
        // Calf (Tibia - shinbone, Fibula - smaller lateral bone) - part of knee group so it bends with knee
        const calfGeom = new THREE.CylinderGeometry(0.22, 0.18, 3.5, 16);
        const calfMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const calf = new THREE.Mesh(calfGeom, calfMat);
        calf.name = `${sideName} Tibia & Fibula (Shin Bones)`;
        calf.position.y = -1.75; // Relative to knee
        kneeGroup.add(calf);
        
        // Ankle joint (Talus - ankle bone)
        const ankleGeom = new THREE.SphereGeometry(0.18, 8, 8);
        const ankleMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const ankle = new THREE.Mesh(ankleGeom, ankleMat);
        ankle.name = `${sideName} Talus (Ankle Joint)`;
        ankle.position.y = -3.5; // Relative to knee
        kneeGroup.add(ankle);
        
        // Ankle bone protrusion (Medial/Lateral Malleolus) - mirrored
        const ankleBoneGeom = new THREE.SphereGeometry(0.012, 8, 8);
        const ankleBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const ankleBone = new THREE.Mesh(ankleBoneGeom, ankleBoneMat);
        ankleBone.name = `${sideName} ${isRight ? 'Lateral' : 'Medial'} Malleolus`;
        ankleBone.position.set(isRight ? 0.18 : -0.18, -3.5, 0);
        kneeGroup.add(ankleBone);
        
        // === FOOT GROUP (for heel-toe placement) ===
        const footGroup = new THREE.Group();
        footGroup.position.y = -3.8; // Relative to knee
        
        // Foot (Metatarsals & Tarsals - foot bones)
        const footGeom = new THREE.BoxGeometry(0.35, 0.25, 0.8);
        const footMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const foot = new THREE.Mesh(footGeom, footMat);
        foot.name = `${sideName} Metatarsals & Tarsals (Foot Bones)`;
        foot.position.set(0, 0, 0.3);
        foot.rotation.x = -Math.PI / 16;
        footGroup.add(foot);
        
        // Big toe (Hallux - 1st Phalanx) - mirrored
        const bigToeGeom = new THREE.CylinderGeometry(0.07, 0.05, 0.35, 8);
        const bigToeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const bigToe = new THREE.Mesh(bigToeGeom, bigToeMat);
        bigToe.name = `${sideName} Hallux (Big Toe - 1st Phalanx)`;
        bigToe.position.set(isRight ? -0.12 : 0.12, -0.2, 0.65);
        bigToe.rotation.x = Math.PI / 2;
        footGroup.add(bigToe);
        
        // 4 Toes (2nd-5th Phalanges) - mirrored
        const toeLengths = [0.28, 0.26, 0.24, 0.22];
        const toeNames = ['2nd', '3rd', '4th', '5th'];
        for (let i = 0; i < 4; i++) {
          const toeGeom = new THREE.CylinderGeometry(0.045 * (1 - i * 0.08), 0.03 * (1 - i * 0.08), toeLengths[i], 8);
          const toeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const toe = new THREE.Mesh(toeGeom, toeMat);
          toe.name = `${sideName} ${toeNames[i]} Phalanx (Toe)`;
          const toeXBase = isRight ? -0.05 : 0.05;
          const toeXOffset = isRight ? (i * 0.08) : -(i * 0.08);
          toe.position.set(toeXBase + toeXOffset, -0.2, 0.65);
          toe.rotation.x = Math.PI / 2;
          footGroup.add(toe);
          
          // Toe tip
          const toeTipGeom = new THREE.SphereGeometry(0.035 * (1 - i * 0.08), 8, 8);
          const toeTipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const toeTip = new THREE.Mesh(toeTipGeom, toeTipMat);
          toeTip.position.set(toeXBase + toeXOffset, -0.2, 0.65 + toeLengths[i] / 2);
          footGroup.add(toeTip);
        }
        
        kneeGroup.add(footGroup);
        legGroup.add(kneeGroup);
        legGroup.position.set(xOffset, 0, 0);
        
        // Tag leg group for selection
        legGroup.userData.bodyPart = isRight ? 'rightLeg' : 'leftLeg';
        legGroup.userData.partName = isRight ? 'Right Leg' : 'Left Leg';
        legGroup.userData.controlGroup = legGroup;
        
        // Tag foot for separate control
        footGroup.userData.bodyPart = isRight ? 'rightFoot' : 'leftFoot';
        footGroup.userData.partName = isRight ? 'Right Foot' : 'Left Foot';
        
        return { legGroup, kneeGroup, footGroup };
      }
      
      // Create both legs
      const leftLegData = createLeg(-0.4, false);
      const rightLegData = createLeg(0.4, true);
      legsGroup.add(leftLegData.legGroup);
      legsGroup.add(rightLegData.legGroup);
      legsGroup.position.set(0, 7.5, 0); // Feet on ground
      fullBodyGroup.add(legsGroup);
      totalVertices += 172; // 86V √ó 2
      
      // Store references for walking animation
      leftLegGroup = leftLegData.legGroup;
      rightLegGroup = rightLegData.legGroup;
      leftKneeGroup = leftLegData.kneeGroup;
      rightKneeGroup = rightLegData.kneeGroup;
      leftFootGroup = leftLegData.footGroup;
      rightFootGroup = rightLegData.footGroup;
      
      // ===== TORSO (120V) - Connects legs to arms =====
      const torsoGroup = new THREE.Group();
      
      // Pelvis base
      const pelvisGeom = new THREE.CylinderGeometry(0.45, 0.5, 0.6, 16);
      const pelvisMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const pelvis = new THREE.Mesh(pelvisGeom, pelvisMat);
      pelvis.position.y = 0;
      torsoGroup.add(pelvis);
      
      // Lower spine (L1-L5 lumbar vertebrae)
      const lowerSpineGeom = new THREE.CylinderGeometry(0.12, 0.12, 1.2, 12);
      const spineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const lowerSpine = new THREE.Mesh(lowerSpineGeom, spineMat);
      lowerSpine.position.y = 0.9;
      torsoGroup.add(lowerSpine);
      
      // Mid spine (T7-T12 thoracic vertebrae)
      const midSpineGeom = new THREE.CylinderGeometry(0.13, 0.12, 1.5, 12);
      const midSpine = new THREE.Mesh(midSpineGeom, spineMat);
      midSpine.position.y = 2.25;
      torsoGroup.add(midSpine);
      
      // Upper spine (T1-T6 thoracic vertebrae)
      const upperSpineGeom = new THREE.CylinderGeometry(0.14, 0.13, 1.2, 12);
      const upperSpine = new THREE.Mesh(upperSpineGeom, spineMat);
      upperSpine.position.y = 3.6;
      torsoGroup.add(upperSpine);
      
      // Ribcage (12 ribs on each side)
      for (let i = 0; i < 12; i++) {
        const ribHeight = 2.0 + (i * 0.15);
        const ribWidth = 0.35 + (i * 0.04);
        
        // Left rib
        const leftRibGeom = new THREE.TorusGeometry(ribWidth, 0.02, 8, 16, Math.PI);
        const ribMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const leftRib = new THREE.Mesh(leftRibGeom, ribMat);
        leftRib.position.set(-0.15, ribHeight, 0);
        leftRib.rotation.y = Math.PI / 2;
        leftRib.rotation.z = -Math.PI / 12;
        torsoGroup.add(leftRib);
        
        // Right rib
        const rightRibGeom = new THREE.TorusGeometry(ribWidth, 0.02, 8, 16, Math.PI);
        const rightRib = new THREE.Mesh(rightRibGeom, ribMat);
        rightRib.position.set(0.15, ribHeight, 0);
        rightRib.rotation.y = -Math.PI / 2;
        rightRib.rotation.z = Math.PI / 12;
        torsoGroup.add(rightRib);
      }
      
      // Chest
      const chestGeom = new THREE.CylinderGeometry(0.55, 0.45, 1.5, 16);
      const chestMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const chest = new THREE.Mesh(chestGeom, chestMat);
      chest.position.y = 3.5;
      torsoGroup.add(chest);
      
      // Shoulders
      const shouldersGeom = new THREE.CylinderGeometry(0.65, 0.55, 0.5, 16);
      const shouldersMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const shoulders = new THREE.Mesh(shouldersGeom, shouldersMat);
      shoulders.position.y = 4.5;
      torsoGroup.add(shoulders);
      
      // Clavicles (collarbones)
      const leftClavicleGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
      const clavicleMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const leftClavicle = new THREE.Mesh(leftClavicleGeom, clavicleMat);
      leftClavicle.position.set(-0.5, 4.6, 0);
      leftClavicle.rotation.z = Math.PI / 6;
      torsoGroup.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(leftClavicleGeom, clavicleMat);
      rightClavicle.position.set(0.5, 4.6, 0);
      rightClavicle.rotation.z = -Math.PI / 6;
      torsoGroup.add(rightClavicle);
      
      // Tag torso for selection
      torsoGroup.userData.bodyPart = 'torso';
      torsoGroup.userData.partName = 'Torso';
      torsoGroup.userData.controlGroup = torsoGroup;
      
      torsoGroup.position.set(0, 7.5, 0); // Align with legs at ground level
      fullBodyGroup.add(torsoGroup);
      totalVertices += 120;
      
      // ===== ARMS (172V) - At shoulder height =====
      const armsGroup = new THREE.Group();
      
      function createArm(xOffset, isRight) {
        const armGroup = new THREE.Group();
        const forearmGroup = new THREE.Group(); // For elbow articulation
        
        // Shoulder joint
        const shoulderGeom = new THREE.SphereGeometry(0.25, 8, 8);
        const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
        armGroup.add(shoulder);
        
        // Upper arm (bicep/tricep area)
        const upperArmGeom = new THREE.CylinderGeometry(0.18, 0.15, 2.5, 16);
        const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
        upperArm.position.y = -1.25;
        armGroup.add(upperArm);
        
        // Elbow joint
        const elbowGeom = new THREE.SphereGeometry(0.16, 8, 8);
        const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const elbow = new THREE.Mesh(elbowGeom, elbowMat);
        elbow.position.y = -2.5;
        armGroup.add(elbow);
        
        // === FOREARM GROUP (for articulation) ===
        forearmGroup.position.y = -2.5; // Position at elbow
        
        // Forearm
        const forearmGeom = new THREE.CylinderGeometry(0.14, 0.12, 2.3, 16);
        const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const forearm = new THREE.Mesh(forearmGeom, forearmMat);
        forearm.position.y = -1.15;
        forearmGroup.add(forearm);
        
        // Wrist joint
        const wristGeom = new THREE.SphereGeometry(0.12, 8, 8);
        const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const wrist = new THREE.Mesh(wristGeom, wristMat);
        wrist.position.y = -2.3;
        forearmGroup.add(wrist);
        
        // Wrist bone (styloid process) - mirrored
        const wristBoneGeom = new THREE.SphereGeometry(0.008, 8, 8);
        const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
        wristBone.position.set(isRight ? -0.15 : 0.15, -2.3, 0);
        forearmGroup.add(wristBone);
        
        // Hand (palm)
        const handGeom = new THREE.BoxGeometry(0.3, 0.12, 0.45);
        const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hand = new THREE.Mesh(handGeom, handMat);
        hand.position.y = -2.65;
        forearmGroup.add(hand);
        
        // Thumb - mirrored rotation
        const thumbGeom = new THREE.CylinderGeometry(0.05, 0.04, 0.35, 8);
        const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thumb = new THREE.Mesh(thumbGeom, thumbMat);
        thumb.position.set(isRight ? 0.25 : -0.25, -2.65, 0);
        thumb.rotation.z = isRight ? Math.PI / 3 : -Math.PI / 3;
        forearmGroup.add(thumb);
        
        // 4 Fingers - mirrored X positions
        const fingerLengths = [0.45, 0.48, 0.46, 0.42];
        for (let i = 0; i < 4; i++) {
          const fingerGeom = new THREE.CylinderGeometry(0.035 * (1 - i * 0.05), 0.025 * (1 - i * 0.05), fingerLengths[i], 8);
          const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const finger = new THREE.Mesh(fingerGeom, fingerMat);
          const fingerXBase = isRight ? -0.12 : 0.12;
          const fingerXOffset = isRight ? (i * 0.08) : -(i * 0.08);
          finger.position.set(fingerXBase + fingerXOffset, -3.1, 0);
          forearmGroup.add(finger);
          
          // Fingertip
          const fingertipGeom = new THREE.SphereGeometry(0.03 * (1 - i * 0.05), 8, 8);
          const fingertipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const fingertip = new THREE.Mesh(fingertipGeom, fingertipMat);
          fingertip.position.set(fingerXBase + fingerXOffset, -3.1 - fingerLengths[i] / 2, 0);
          forearmGroup.add(fingertip);
        }
        
        armGroup.add(forearmGroup);
        armGroup.position.set(xOffset, 0, 0);
        
        // Tag arm group for selection
        armGroup.userData.bodyPart = isRight ? 'rightArm' : 'leftArm';
        armGroup.userData.partName = isRight ? 'Right Arm' : 'Left Arm';
        armGroup.userData.controlGroup = armGroup;
        
        // Tag forearm/hand group for wrist control
        forearmGroup.userData.bodyPart = isRight ? 'rightHand' : 'leftHand';
        forearmGroup.userData.partName = isRight ? 'Right Hand' : 'Left Hand';
        forearmGroup.userData.controlGroup = forearmGroup;
        
        return { armGroup, forearmGroup };
      }
      
      // Create both arms
      const leftArmData = createArm(-1.2, false);
      const rightArmData = createArm(1.2, true);
      armsGroup.add(leftArmData.armGroup);
      armsGroup.add(rightArmData.armGroup);
      armsGroup.position.set(0, 12.25, 0); // At shoulder height (torso top ~4.5 + base 7.5)
      fullBodyGroup.add(armsGroup);
      totalVertices += 172; // 86V √ó 2
      
      // Store references for walking animation (arm swing)
      leftArmGroupRef = leftArmData.armGroup;
      rightArmGroupRef = rightArmData.armGroup;
      leftForearmGroup = leftArmData.forearmGroup;
      rightForearmGroup = rightArmData.forearmGroup;
      
      // ===== HEAD (100V) - Top of torso =====
      const headGroup = new THREE.Group();
      const neckSwivelGroup = new THREE.Group(); // For head rotation
      
      // Cervical spine (C1-C7 vertebrae)
      const cervicalSpineGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 12);
      const cervicalSpineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const cervicalSpine = new THREE.Mesh(cervicalSpineGeom, cervicalSpineMat);
      cervicalSpine.position.y = 0.3;
      headGroup.add(cervicalSpine);
      
      // Neck base
      const neckBaseGeom = new THREE.CylinderGeometry(0.2, 0.18, 0.5, 16);
      const neckBaseMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const neckBase = new THREE.Mesh(neckBaseGeom, neckBaseMat);
      neckBase.position.y = 0.8;
      headGroup.add(neckBase);
      
      // === NECK SWIVEL GROUP (for head rotation) ===
      neckSwivelGroup.position.y = 1.1; // Position at top of neck
      
      // Skull base (occipital bone)
      const skullBaseGeom = new THREE.SphereGeometry(0.25, 12, 12);
      const skullBaseMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const skullBase = new THREE.Mesh(skullBaseGeom, skullBaseMat);
      skullBase.position.y = 0.2;
      neckSwivelGroup.add(skullBase);
      
      // Cranium (skull)
      const craniumGeom = new THREE.SphereGeometry(0.45, 16, 16);
      const craniumMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const cranium = new THREE.Mesh(craniumGeom, craniumMat);
      cranium.position.y = 0.65;
      neckSwivelGroup.add(cranium);
      
      // Jaw (mandible)
      const jawGeom = new THREE.BoxGeometry(0.4, 0.2, 0.35);
      const jawMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const jaw = new THREE.Mesh(jawGeom, jawMat);
      jaw.position.set(0, 0.3, 0.25);
      neckSwivelGroup.add(jaw);
      
      // Eyes
      const eyeGeom = new THREE.SphereGeometry(0.08, 12, 12);
      const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
      leftEye.position.set(-0.15, 0.7, 0.4);
      neckSwivelGroup.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
      rightEye.position.set(0.15, 0.7, 0.4);
      neckSwivelGroup.add(rightEye);
      
      // Pupils
      const pupilGeom = new THREE.SphereGeometry(0.04, 8, 8);
      const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.2 });
      const leftPupil = new THREE.Mesh(pupilGeom, pupilMat);
      leftPupil.position.set(-0.15, 0.7, 0.48);
      neckSwivelGroup.add(leftPupil);
      
      const rightPupil = new THREE.Mesh(pupilGeom, pupilMat);
      rightPupil.position.set(0.15, 0.7, 0.48);
      neckSwivelGroup.add(rightPupil);
      
      // Nose
      const noseGeom = new THREE.ConeGeometry(0.08, 0.15, 8);
      const noseMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const nose = new THREE.Mesh(noseGeom, noseMat);
      nose.position.set(0, 0.55, 0.45);
      nose.rotation.x = Math.PI / 2;
      neckSwivelGroup.add(nose);
      
      // Mouth
      const mouthGeom = new THREE.BoxGeometry(0.25, 0.05, 0.1);
      const mouthMat = new THREE.MeshStandardMaterial({ color: 0xff6666, roughness: 0.4 });
      const mouth = new THREE.Mesh(mouthGeom, mouthMat);
      mouth.position.set(0, 0.4, 0.42);
      neckSwivelGroup.add(mouth);
      
      // Ears
      const earGeom = new THREE.SphereGeometry(0.1, 8, 8);
      const earMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const leftEar = new THREE.Mesh(earGeom, earMat);
      leftEar.position.set(-0.45, 0.65, 0);
      leftEar.scale.set(0.4, 1, 0.6);
      neckSwivelGroup.add(leftEar);
      
      const rightEar = new THREE.Mesh(earGeom, earMat);
      rightEar.position.set(0.45, 0.65, 0);
      rightEar.scale.set(0.4, 1, 0.6);
      neckSwivelGroup.add(rightEar);
      
      // Tag head group for selection
      neckSwivelGroup.userData.bodyPart = 'head';
      neckSwivelGroup.userData.partName = 'Head';
      neckSwivelGroup.userData.controlGroup = neckSwivelGroup;
      
      headGroup.add(neckSwivelGroup);
      headGroup.position.set(0, 12, 0); // At top of torso (4.5 + 7.5)
      fullBodyGroup.add(headGroup);
      totalVertices += 100;
      
      // ===== ADD TO SCENE =====
      fullBodyGroup.position.set(0, 0, 0); // Standing upright at origin
      
      // Store global reference for body part selection
      window.fullBodyGroup = fullBodyGroup;
      
      scene.add(fullBodyGroup);
      objects.push(fullBodyGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `FULL BODY (${totalVertices}V)`;
      
      // Show articulation controls
      document.getElementById('armArticulationControls').style.display = 'block';
      document.getElementById('neckSwivelControls').style.display = 'block';
      
      console.log(`üßç ‚úÖ FULL BODY loaded: ${totalVertices} vertices total`);
      console.log(`  ‚Üí Legs: 172V (86V √ó 2) at ground level`);
      console.log(`  ‚Üí Torso: 120V connecting legs to arms`);
      console.log(`  ‚Üí Arms: 172V (86V √ó 2) at shoulder height`);
      console.log(`  ‚Üí Head: 100V at top of torso`);
      console.log(`  ‚Üí All articulation controls enabled (elbow bend, neck swivel)`);
      console.log(`\nü¶¥ ANATOMICAL BONE STRUCTURE:`);
      console.log(`  LEGS (per side):`);
      console.log(`    ‚Ä¢ Acetabulum (Hip Socket)`);
      console.log(`    ‚Ä¢ Femur (Thigh Bone - longest bone)`);
      console.log(`    ‚Ä¢ Patella (Kneecap)`);
      console.log(`    ‚Ä¢ Tibia & Fibula (Shin Bones)`);
      console.log(`    ‚Ä¢ Talus (Ankle Joint)`);
      console.log(`    ‚Ä¢ Malleolus (Ankle Protrusion)`);
      console.log(`    ‚Ä¢ Metatarsals & Tarsals (Foot Bones)`);
      console.log(`    ‚Ä¢ Hallux (Big Toe - 1st Phalanx)`);
      console.log(`    ‚Ä¢ 2nd-5th Phalanges (Toes)`);
      console.log(`  ARMS (per side):`);
      console.log(`    ‚Ä¢ Humerus (Upper Arm)`);
      console.log(`    ‚Ä¢ Radius & Ulna (Forearm)`);
      console.log(`    ‚Ä¢ Carpals (Wrist)`);
      console.log(`    ‚Ä¢ Metacarpals & Phalanges (Hand & Fingers)`);
      console.log(`  TORSO:`);
      console.log(`    ‚Ä¢ Pelvis (Ilium, Ischium, Pubis)`);
      console.log(`    ‚Ä¢ Lumbar Vertebrae (L1-L5)`);
      console.log(`    ‚Ä¢ Thoracic Vertebrae (T1-T12)`);
      console.log(`    ‚Ä¢ Ribs (1-12 pairs)`);
      console.log(`    ‚Ä¢ Sternum (Breastbone)`);
      console.log(`    ‚Ä¢ Clavicles (Collarbones)`);
      console.log(`  HEAD:`);
      console.log(`    ‚Ä¢ Cervical Vertebrae (C1-C7 - Neck)`);
      console.log(`    ‚Ä¢ Cranium (Skull)`);
      console.log(`    ‚Ä¢ Mandible (Jawbone)`);
      console.log(`  ‚Üí üö∂ WALKING ANIMATION: Click body, then scroll mouse wheel!`);
      console.log(`     ‚Ä¢ Scroll slowly = walking | Scroll faster = running`);
      console.log(`     ‚Ä¢ Stop scrolling to slow down naturally`);
      console.log(`  ‚Üí üö∂ WALK MODE: Enable 'Walk Mode' button to move through scene!`);
      console.log(`     ‚Ä¢ A/D or ‚Üê/‚Üí = Turn body left/right`);
      console.log(`     ‚Ä¢ W/S or ‚Üë/‚Üì = Speed up/slow down`);
      console.log(`     ‚Ä¢ Camera follows body automatically`);
      console.log(`\nüî¨ VERTEX ENGINE: Click üî¨ button, then click any bone to inspect vertices!`);
    }

    // Load skeleton body (bones only - for enemies/friends in Sky Relics)
    function loadSkeletonBody() {
      clearScene();
      
      const skeletonGroup = new THREE.Group();
      let totalVertices = 0;
      
      // === LEGS (172V) - Bone structure only ===
      function createSkeletonLeg(xOffset, isRight) {
        const legGroup = new THREE.Group();
        const sideName = isRight ? 'Right' : 'Left';
        const boneMat = new THREE.MeshStandardMaterial({ 
          color: 0xdddddd, 
          roughness: 0.3,
          metalness: 0.1,
          emissive: 0x222222
        });
        
        // Femur (thigh bone)
        const femurGeom = new THREE.CylinderGeometry(0.08, 0.06, 3.5, 12);
        const femur = new THREE.Mesh(femurGeom, boneMat);
        femur.name = `${sideName} Femur`;
        femur.position.y = -1.75;
        legGroup.add(femur);
        
        // Femur head (ball joint at hip)
        const femurHeadGeom = new THREE.SphereGeometry(0.12, 12, 12);
        const femurHead = new THREE.Mesh(femurHeadGeom, boneMat);
        femurHead.position.y = 0;
        legGroup.add(femurHead);
        
        // Patella (kneecap)
        const patellaGeom = new THREE.SphereGeometry(0.15, 12, 12);
        const patella = new THREE.Mesh(patellaGeom, boneMat);
        patella.name = `${sideName} Patella`;
        patella.position.y = -3.5;
        legGroup.add(patella);
        
        // Knee group for articulation
        const kneeGroup = new THREE.Group();
        kneeGroup.position.y = -3.5;
        
        // Tibia (shin bone - larger)
        const tibiaGeom = new THREE.CylinderGeometry(0.07, 0.055, 3.5, 12);
        const tibia = new THREE.Mesh(tibiaGeom, boneMat);
        tibia.name = `${sideName} Tibia`;
        tibia.position.set(-0.04, -1.75, 0);
        kneeGroup.add(tibia);
        
        // Fibula (smaller lateral bone)
        const fibulaGeom = new THREE.CylinderGeometry(0.035, 0.03, 3.5, 8);
        const fibula = new THREE.Mesh(fibulaGeom, boneMat);
        fibula.name = `${sideName} Fibula`;
        fibula.position.set(0.08, -1.75, 0);
        kneeGroup.add(fibula);
        
        // Malleolus (ankle protrusion)
        const malleolusGeom = new THREE.SphereGeometry(0.06, 8, 8);
        const malleolus = new THREE.Mesh(malleolusGeom, boneMat);
        malleolus.position.set(isRight ? 0.08 : -0.08, -3.5, 0);
        kneeGroup.add(malleolus);
        
        // Foot group for articulation
        const footGroup = new THREE.Group();
        footGroup.position.y = -3.8;
        
        // Tarsals (heel/ankle bones)
        const tarsalsGeom = new THREE.BoxGeometry(0.25, 0.15, 0.4);
        const tarsals = new THREE.Mesh(tarsalsGeom, boneMat);
        tarsals.position.set(0, 0, 0);
        footGroup.add(tarsals);
        
        // Metatarsals (foot bones)
        for (let i = 0; i < 5; i++) {
          const metatarsalGeom = new THREE.CylinderGeometry(0.02, 0.015, 0.5, 8);
          const metatarsal = new THREE.Mesh(metatarsalGeom, boneMat);
          const xPos = isRight ? (-0.1 + i * 0.05) : (0.1 - i * 0.05);
          metatarsal.position.set(xPos, 0, 0.35);
          metatarsal.rotation.x = Math.PI / 2;
          footGroup.add(metatarsal);
          
          // Phalanges (toe bones)
          const phalanxGeom = new THREE.CylinderGeometry(0.015, 0.01, 0.2, 6);
          const phalanx = new THREE.Mesh(phalanxGeom, boneMat);
          phalanx.position.set(xPos, 0, 0.6);
          phalanx.rotation.x = Math.PI / 2;
          footGroup.add(phalanx);
        }
        
        kneeGroup.add(footGroup);
        legGroup.add(kneeGroup);
        
        // Tag groups for animation
        legGroup.userData.bodyPart = isRight ? 'rightLeg' : 'leftLeg';
        legGroup.userData.controlGroup = legGroup;
        
        return { legGroup, kneeGroup, footGroup };
      }
      
      // Create both legs
      const leftLegData = createSkeletonLeg(-0.4, false);
      const rightLegData = createSkeletonLeg(0.4, true);
      skeletonGroup.add(leftLegData.legGroup);
      skeletonGroup.add(rightLegData.legGroup);
      leftLegData.legGroup.position.set(-0.4, 7.5, 0);
      rightLegData.legGroup.position.set(0.4, 7.5, 0);
      totalVertices += 172;
      
      // Store references for animation
      leftLegGroup = leftLegData.legGroup;
      rightLegGroup = rightLegData.legGroup;
      leftKneeGroup = leftLegData.kneeGroup;
      rightKneeGroup = rightLegData.kneeGroup;
      leftFootGroup = leftLegData.footGroup;
      rightFootGroup = rightLegData.footGroup;
      
      // === PELVIS & SPINE (Torso skeleton) ===
      const torsoGroup = new THREE.Group();
      const boneMat = new THREE.MeshStandardMaterial({ 
        color: 0xdddddd, 
        roughness: 0.3,
        metalness: 0.1,
        emissive: 0x222222
      });
      
      // Pelvis (hip bones)
      const pelvisGeom = new THREE.SphereGeometry(0.5, 12, 12);
      const pelvis = new THREE.Mesh(pelvisGeom, boneMat);
      pelvis.position.y = 0.5;
      pelvis.scale.set(1.2, 0.6, 0.8);
      torsoGroup.add(pelvis);
      
      // Lumbar vertebrae (L1-L5)
      for (let i = 0; i < 5; i++) {
        const vertebraGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.2, 8);
        const vertebra = new THREE.Mesh(vertebraGeom, boneMat);
        vertebra.position.y = 1.0 + (i * 0.25);
        torsoGroup.add(vertebra);
      }
      
      // Thoracic vertebrae (T1-T12) + Ribs
      for (let i = 0; i < 12; i++) {
        const vertebraGeom = new THREE.CylinderGeometry(0.07, 0.07, 0.15, 8);
        const vertebra = new THREE.Mesh(vertebraGeom, boneMat);
        vertebra.position.y = 2.25 + (i * 0.18);
        torsoGroup.add(vertebra);
        
        // Ribs (pairs)
        const ribGeom = new THREE.TorusGeometry(0.25 + (i * 0.03), 0.015, 6, 12, Math.PI);
        const leftRib = new THREE.Mesh(ribGeom, boneMat);
        leftRib.position.set(-0.1, 2.25 + (i * 0.18), 0);
        leftRib.rotation.y = Math.PI / 2;
        leftRib.rotation.z = -Math.PI / 12;
        torsoGroup.add(leftRib);
        
        const rightRib = new THREE.Mesh(ribGeom, boneMat);
        rightRib.position.set(0.1, 2.25 + (i * 0.18), 0);
        rightRib.rotation.y = -Math.PI / 2;
        rightRib.rotation.z = Math.PI / 12;
        torsoGroup.add(rightRib);
      }
      
      // Sternum (breastbone)
      const sternumGeom = new THREE.BoxGeometry(0.12, 0.8, 0.08);
      const sternum = new THREE.Mesh(sternumGeom, boneMat);
      sternum.position.set(0, 3.5, 0.3);
      torsoGroup.add(sternum);
      
      // Clavicles (collarbones)
      const clavicleGeom = new THREE.CylinderGeometry(0.025, 0.025, 0.6, 8);
      const leftClavicle = new THREE.Mesh(clavicleGeom, boneMat);
      leftClavicle.position.set(-0.35, 4.5, 0.1);
      leftClavicle.rotation.z = Math.PI / 6;
      torsoGroup.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(clavicleGeom, boneMat);
      rightClavicle.position.set(0.35, 4.5, 0.1);
      rightClavicle.rotation.z = -Math.PI / 6;
      torsoGroup.add(rightClavicle);
      
      // Scapulae (shoulder blades)
      const scapulaGeom = new THREE.BoxGeometry(0.3, 0.4, 0.05);
      const leftScapula = new THREE.Mesh(scapulaGeom, boneMat);
      leftScapula.position.set(-0.5, 4, -0.2);
      torsoGroup.add(leftScapula);
      
      const rightScapula = new THREE.Mesh(scapulaGeom, boneMat);
      rightScapula.position.set(0.5, 4, -0.2);
      torsoGroup.add(rightScapula);
      
      torsoGroup.position.y = 7.5;
      skeletonGroup.add(torsoGroup);
      totalVertices += 120;
      
      // === ARMS (172V) - Bone structure ===
      function createSkeletonArm(xOffset, isRight) {
        const armGroup = new THREE.Group();
        const sideName = isRight ? 'Right' : 'Left';
        
        // Humerus (upper arm bone)
        const humerusGeom = new THREE.CylinderGeometry(0.06, 0.05, 3.5, 12);
        const humerus = new THREE.Mesh(humerusGeom, boneMat);
        humerus.name = `${sideName} Humerus`;
        humerus.position.y = -1.75;
        armGroup.add(humerus);
        
        // Elbow joint
        const elbowGeom = new THREE.SphereGeometry(0.1, 10, 10);
        const elbow = new THREE.Mesh(elbowGeom, boneMat);
        elbow.position.y = -3.5;
        armGroup.add(elbow);
        
        // Forearm group
        const forearmGroup = new THREE.Group();
        forearmGroup.position.y = -3.5;
        
        // Radius (thumb side)
        const radiusGeom = new THREE.CylinderGeometry(0.04, 0.035, 3.5, 10);
        const radius = new THREE.Mesh(radiusGeom, boneMat);
        radius.name = `${sideName} Radius`;
        radius.position.set(isRight ? -0.04 : 0.04, -1.75, 0);
        forearmGroup.add(radius);
        
        // Ulna (pinky side)
        const ulnaGeom = new THREE.CylinderGeometry(0.035, 0.03, 3.5, 10);
        const ulna = new THREE.Mesh(ulnaGeom, boneMat);
        ulna.name = `${sideName} Ulna`;
        ulna.position.set(isRight ? 0.04 : -0.04, -1.75, 0);
        forearmGroup.add(ulna);
        
        // Carpals (wrist bones cluster)
        const carpalsGeom = new THREE.BoxGeometry(0.15, 0.1, 0.12);
        const carpals = new THREE.Mesh(carpalsGeom, boneMat);
        carpals.position.y = -3.5;
        forearmGroup.add(carpals);
        
        // Metacarpals & Phalanges (hand bones)
        for (let i = 0; i < 5; i++) {
          const metacarpalGeom = new THREE.CylinderGeometry(0.015, 0.012, 0.35, 6);
          const metacarpal = new THREE.Mesh(metacarpalGeom, boneMat);
          const xPos = isRight ? (0.06 - i * 0.03) : (-0.06 + i * 0.03);
          metacarpal.position.set(xPos, -4.1, 0);
          forearmGroup.add(metacarpal);
          
          // Finger bones (3 phalanges per finger)
          for (let j = 0; j < 3; j++) {
            const phalanxGeom = new THREE.CylinderGeometry(0.01, 0.008, 0.15, 6);
            const phalanx = new THREE.Mesh(phalanxGeom, boneMat);
            phalanx.position.set(xPos, -4.4 - (j * 0.15), 0);
            forearmGroup.add(phalanx);
          }
        }
        
        armGroup.add(forearmGroup);
        armGroup.position.set(xOffset, 0, 0);
        
        return { armGroup, forearmGroup };
      }
      
      const armsGroup = new THREE.Group();
      const leftArmData = createSkeletonArm(-1.2, false);
      const rightArmData = createSkeletonArm(1.2, true);
      armsGroup.add(leftArmData.armGroup);
      armsGroup.add(rightArmData.armGroup);
      armsGroup.position.set(0, 12.25, 0);
      skeletonGroup.add(armsGroup);
      totalVertices += 172;
      
      // Store arm references for animation
      leftArmGroupRef = leftArmData.armGroup;
      rightArmGroupRef = rightArmData.armGroup;
      leftForearmGroup = leftArmData.forearmGroup;
      rightForearmGroup = rightArmData.forearmGroup;
      
      // === SKULL & SPINE (Head skeleton) ===
      const headGroup = new THREE.Group();
      const neckSwivelGroup = new THREE.Group();
      
      // Cervical vertebrae (C1-C7)
      for (let i = 0; i < 7; i++) {
        const cervicalGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.12, 8);
        const cervical = new THREE.Mesh(cervicalGeom, boneMat);
        cervical.position.y = 0.2 + (i * 0.14);
        headGroup.add(cervical);
      }
      
      // Cranium (skull)
      const craniumGeom = new THREE.SphereGeometry(0.55, 16, 16);
      const cranium = new THREE.Mesh(craniumGeom, boneMat);
      cranium.name = 'Cranium';
      cranium.position.y = 1.8;
      cranium.scale.set(1, 1.1, 1);
      neckSwivelGroup.add(cranium);
      
      // Eye sockets
      const socketGeom = new THREE.SphereGeometry(0.12, 12, 12);
      const socketMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const leftSocket = new THREE.Mesh(socketGeom, socketMat);
      leftSocket.position.set(-0.18, 1.85, 0.45);
      neckSwivelGroup.add(leftSocket);
      
      const rightSocket = new THREE.Mesh(socketGeom, socketMat);
      rightSocket.position.set(0.18, 1.85, 0.45);
      neckSwivelGroup.add(rightSocket);
      
      // Nasal cavity
      const noseGeom = new THREE.BoxGeometry(0.08, 0.15, 0.08);
      const nose = new THREE.Mesh(noseGeom, socketMat);
      nose.position.set(0, 1.7, 0.52);
      neckSwivelGroup.add(nose);
      
      // Mandible (jawbone)
      const mandibleGeom = new THREE.BoxGeometry(0.4, 0.25, 0.3);
      const mandible = new THREE.Mesh(mandibleGeom, boneMat);
      mandible.name = 'Mandible';
      mandible.position.set(0, 1.3, 0.35);
      mandible.scale.set(1, 0.6, 1);
      neckSwivelGroup.add(mandible);
      
      // Teeth (upper)
      for (let i = 0; i < 8; i++) {
        const toothGeom = new THREE.BoxGeometry(0.04, 0.08, 0.04);
        const tooth = new THREE.Mesh(toothGeom, new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
        tooth.position.set(-0.14 + (i * 0.04), 1.5, 0.52);
        neckSwivelGroup.add(tooth);
      }
      
      // Teeth (lower)
      for (let i = 0; i < 8; i++) {
        const toothGeom = new THREE.BoxGeometry(0.04, 0.08, 0.04);
        const tooth = new THREE.Mesh(toothGeom, new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
        tooth.position.set(-0.14 + (i * 0.04), 1.38, 0.52);
        neckSwivelGroup.add(tooth);
      }
      
      headGroup.add(neckSwivelGroup);
      headGroup.position.y = 16.5;
      skeletonGroup.add(headGroup);
      totalVertices += 100;
      
      // Add to scene
      scene.add(skeletonGroup);
      objects.push(skeletonGroup);
      window.fullBodyGroup = skeletonGroup;
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `SKELETON BODY (${totalVertices}V)`;
      
      console.log(`üíÄ ‚úÖ SKELETON BODY loaded: ${totalVertices} vertices total`);
      console.log(`  ‚Üí Perfect for Sky Relics enemies, frenemies, and skeleton friends!`);
      console.log(`  ‚Üí All bones anatomically labeled and ready to animate`);
      console.log(`  ‚Üí Supports full walking/running animation with WASD controls`);
      console.log(`  ‚Üí Press W to walk, SHIFT to run, SPACE to jump, F to fly!`);
      console.log(`\nüíÄ SKELETON ANATOMY:`);
      console.log(`  ‚Üí Femur, Tibia, Fibula (Leg bones)`);
      console.log(`  ‚Üí Humerus, Radius, Ulna (Arm bones)`);
      console.log(`  ‚Üí Pelvis, Vertebrae (L1-L5, T1-T12, C1-C7)`);
      console.log(`  ‚Üí 24 Ribs (12 pairs)`);
      console.log(`  ‚Üí Sternum, Clavicles, Scapulae`);
      console.log(`  ‚Üí Cranium, Mandible with teeth`);
      console.log(`  ‚Üí Carpals, Metacarpals, Phalanges (Hands)`);
      console.log(`  ‚Üí Tarsals, Metatarsals, Phalanges (Feet)`);
      console.log(`\nüî¨ VERTEX ENGINE: Click üî¨ button, then click any bone to inspect vertices!`);
    }

    // Load DETAILED SKELETON with anatomically accurate bones
    function loadDetailedSkeleton() {
      clearScene();
      
      const skeletonGroup = new THREE.Group();
      skeletonGroup.name = 'Detailed Skeleton';
      let totalVertices = 0;
      
      const boneMat = new THREE.MeshStandardMaterial({ 
        color: 0xeeeeee,
        roughness: 0.25,
        metalness: 0.15,
        emissive: 0x333333,
        emissiveIntensity: 0.3
      });
      
      console.log('\nü¶¥ ===== BUILDING HIERARCHICAL ANATOMICAL SKELETON =====\n');
      console.log('üîó Using parent-child bone relationships for realistic movement\n');
      
      // === PELVIS (ROOT OF HIERARCHY) ===
      console.log('ü¶¥ Creating pelvis (root bone)...');
      const pelvisGroup = new THREE.Group();
      pelvisGroup.name = 'Pelvis (Hip Bone)';
      pelvisGroup.userData.description = 'Ring-like bony structure connecting spine to lower limbs';
      pelvisGroup.userData.anatomical = {
        type: 'Composite Structure',
        bones: ['Ilium (2)', 'Ischium (2)', 'Pubis (2)', 'Sacrum', 'Coccyx'],
        function: 'Weight bearing, birth canal, muscle attachment'
      };
      
      // Main pelvis body (representing ilium wings)
      const pelvisGeom = new THREE.SphereGeometry(0.5, 16, 16);
      const pelvisMain = new THREE.Mesh(pelvisGeom, boneMat);
      pelvisMain.name = 'Pelvis Main Body (Ilium)';
      pelvisMain.userData.description = 'Largest part of hip bone, iliac crests';
      pelvisMain.userData.anatomical = {
        type: 'Flat Bone',
        location: 'Hip wings',
        landmarks: ['Iliac Crest', 'ASIS (Anterior Superior Iliac Spine)', 'PSIS (Posterior Superior Iliac Spine)'],
        function: 'Broad surface for muscle attachment'
      };
      pelvisMain.scale.set(1.3, 0.65, 0.9);
      pelvisGroup.add(pelvisMain);
      
      // Sacrum (fused vertebrae)
      const sacrumGeom = new THREE.BoxGeometry(0.35, 0.5, 0.15);
      const sacrum = new THREE.Mesh(sacrumGeom, boneMat);
      sacrum.name = 'Sacrum (Fused S1-S5)';
      sacrum.userData.description = '5 fused vertebrae forming posterior pelvis';
      sacrum.userData.anatomical = {
        type: 'Irregular Bone (Fused)',
        vertebrae: ['S1', 'S2', 'S3', 'S4', 'S5'],
        articulations: ['L5 (lumbar)', 'Ilium (sacroiliac joint)', 'Coccyx'],
        function: 'Connects spine to pelvis, supports upper body weight'
      };
      sacrum.position.set(0, 0, -0.35);
      pelvisGroup.add(sacrum);
      
      // Coccyx (tailbone)
      const coccyxGeom = new THREE.CylinderGeometry(0.03, 0.02, 0.15, 8);
      const coccyx = new THREE.Mesh(coccyxGeom, boneMat);
      coccyx.name = 'Coccyx (Tailbone)';
      coccyx.userData.description = '3-5 fused vertebrae, vestigial tail';
      coccyx.userData.anatomical = {
        type: 'Irregular Bone (Fused)',
        location: 'Inferior to sacrum',
        articulations: ['Sacrum'],
        function: 'Attachment for pelvic floor muscles, ligaments'
      };
      coccyx.position.set(0, -0.35, -0.45);
      coccyx.rotation.x = Math.PI / 8;
      pelvisGroup.add(coccyx);
      
      // Ischium (sitting bones)
      const ischiumGeom = new THREE.SphereGeometry(0.12, 10, 10);
      const leftIschium = new THREE.Mesh(ischiumGeom, boneMat);
      leftIschium.name = 'Left Ischium (Sitting Bone)';
      leftIschium.userData.description = 'Inferior posterior hip bone, bears weight when sitting';
      leftIschium.position.set(-0.35, -0.25, 0.1);
      pelvisGroup.add(leftIschium);
      
      const rightIschium = new THREE.Mesh(ischiumGeom, boneMat);
      rightIschium.name = 'Right Ischium (Sitting Bone)';
      rightIschium.userData.description = 'Inferior posterior hip bone, bears weight when sitting';
      rightIschium.position.set(0.35, -0.25, 0.1);
      pelvisGroup.add(rightIschium);
      
      // Pubis (pubic bones)
      const pubisGeom = new THREE.TorusGeometry(0.25, 0.03, 8, 16, Math.PI);
      const pubis = new THREE.Mesh(pubisGeom, boneMat);
      pubis.name = 'Pubis (Pubic Arch)';
      pubis.userData.description = 'Anterior hip bones forming pubic symphysis';
      pubis.userData.anatomical = {
        type: 'Flat Bone',
        location: 'Anterior pelvis',
        articulations: ['Opposite pubis at symphysis'],
        function: 'Forms anterior pelvic ring, protects pelvic organs'
      };
      pubis.position.set(0, -0.25, 0.45);
      pubis.rotation.x = Math.PI / 2;
      pelvisGroup.add(pubis);
      
      // Position pelvis at hip height (absolute world position)
      pelvisGroup.position.y = 8.2;
      skeletonGroup.add(pelvisGroup);
      totalVertices += 16 * 16 + 8 + 8 + 10 * 10 * 2 + 8 * 16;
      console.log(`  ‚úì Pelvis: 1 structure (Ilium, Ischium, Pubis, Sacrum, Coccyx)`);
      
      // === DETAILED FEMURS (Thigh Bones) - Parented to pelvis ===
      console.log('ü¶¥ Creating detailed femurs...');
      const leftFemur = createDetailedFemur('Left', boneMat);
      leftFemur.position.set(-0.4, -0.3, 0); // Relative to pelvis
      leftFemur.userData.jointType = 'hip';
      leftFemur.userData.side = 'Left';
      pelvisGroup.add(leftFemur); // ‚úÖ HIERARCHY: Pelvis ‚Üí Femur
      
      const rightFemur = createDetailedFemur('Right', boneMat);
      rightFemur.position.set(0.4, -0.3, 0); // Relative to pelvis
      rightFemur.userData.jointType = 'hip';
      rightFemur.userData.side = 'Right';
      pelvisGroup.add(rightFemur); // ‚úÖ HIERARCHY: Pelvis ‚Üí Femur
      
      // Count femur vertices
      let femurVertices = 0;
      leftFemur.traverse(child => {
        if (child.geometry) femurVertices += child.geometry.getAttribute('position').count;
      });
      totalVertices += femurVertices * 2; // Both femurs
      console.log(`  ‚úì Both Femurs: ${femurVertices * 2} vertices`);
      
      // === DETAILED TIBIAS & FIBULAS (Shin Bones) ===
      console.log('ü¶¥ Creating detailed tibias & fibulas...');
      
      function createDetailedTibiaFibula(side) {
        const group = new THREE.Group();
        group.name = `${side} Tibia & Fibula`;
        
        // Tibia (larger, medial)
        const tibiaVertices = [];
        const segments = 25;
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const y = 3.5 - (t * 3.5);
          const radius = side === 'Right' ? 
            0.075 - (t * 0.02) : // Slight taper
            0.075 - (t * 0.02);
          
          for (let j = 0; j < 16; j++) {
            const angle = (j / 16) * Math.PI * 2;
            tibiaVertices.push(
              Math.cos(angle) * radius - 0.04,
              y,
              Math.sin(angle) * radius
            );
          }
        }
        
        const tibiaGeom = new THREE.BufferGeometry();
        tibiaGeom.setAttribute('position', new THREE.Float32BufferAttribute(tibiaVertices, 3));
        const tibiaIndices = [];
        for (let i = 0; i < segments; i++) {
          for (let j = 0; j < 16; j++) {
            const curr = i * 16 + j;
            const next = i * 16 + ((j + 1) % 16);
            const nextRow = (i + 1) * 16 + j;
            const nextRowNext = (i + 1) * 16 + ((j + 1) % 16);
            tibiaIndices.push(curr, next, nextRow, next, nextRowNext, nextRow);
          }
        }
        tibiaGeom.setIndex(tibiaIndices);
        tibiaGeom.computeVertexNormals();
        
        const tibia = new THREE.Mesh(tibiaGeom, boneMat);
        tibia.name = `${side} Tibia (Shin Bone)`;
        group.add(tibia);
        
        // Fibula (smaller, lateral)
        const fibulaGeom = new THREE.CylinderGeometry(0.03, 0.025, 3.3, 12);
        const fibula = new THREE.Mesh(fibulaGeom, boneMat);
        fibula.name = `${side} Fibula`;
        fibula.position.set(0.08, 1.65, 0);
        group.add(fibula);
        
        // Lateral Malleolus (ankle bump on fibula side)
        const malleolus = new THREE.SphereGeometry(0.06, 10, 10);
        const malleoMesh = new THREE.Mesh(malleolus, boneMat);
        malleoMesh.name = `${side} Lateral Malleolus`;
        malleoMesh.position.set(0.08, 0.1, 0);
        group.add(malleoMesh);
        
        return group;
      }
      
      // Create tibia/fibula groups (will be parented to femurs)
      const leftTibFib = createDetailedTibiaFibula('Left');
      leftTibFib.position.set(0, -4.0, 0); // Relative to femur (knee position)
      leftTibFib.userData.jointType = 'knee';
      leftTibFib.userData.side = 'Left';
      // Parent to femur to create hierarchy
      leftFemur.add(leftTibFib); // ‚úÖ HIERARCHY: Femur ‚Üí Tibia/Fibula
      
      const rightTibFib = createDetailedTibiaFibula('Right');
      rightTibFib.position.set(0, -4.0, 0); // Relative to femur (knee position)
      rightTibFib.userData.jointType = 'knee';
      rightTibFib.userData.side = 'Right';
      // Parent to femur to create hierarchy
      rightFemur.add(rightTibFib); // ‚úÖ HIERARCHY: Femur ‚Üí Tibia/Fibula
      
      // Store joint references in userData for easy animation access
      leftFemur.userData.knee = leftTibFib;
      rightFemur.userData.knee = rightTibFib;
      
      let tibFibVertices = 0;
      leftTibFib.traverse(child => {
        if (child.geometry) tibFibVertices += child.geometry.getAttribute('position').count;
      });
      totalVertices += tibFibVertices * 2;
      console.log(`  ‚úì Both Tibias & Fibulas: ${tibFibVertices * 2} vertices`);
      
      // === DETAILED SKULL ===
      console.log('ü¶¥ Creating detailed skull...');
      const skull = createDetailedSkull(boneMat);
      skull.position.set(0, 17.5, 0);
      skeletonGroup.add(skull);
      
      let skullVertices = 0;
      skull.traverse(child => {
        if (child.geometry) skullVertices += child.geometry.getAttribute('position').count;
      });
      totalVertices += skullVertices;
      console.log(`  ‚úì Skull: ${skullVertices} vertices`);
      
      // === DETAILED VERTEBRAE ===
      console.log('ü¶¥ Creating detailed vertebrae...');
      
      function createVertebra(name, size) {
        const group = new THREE.Group();
        group.name = name;
        
        // Add anatomical description
        const descriptions = {
          'C1': 'Atlas - First Cervical Vertebra (supports skull)',
          'C2': 'Axis - Second Cervical Vertebra (allows head rotation)',
          'C3': 'Third Cervical Vertebra',
          'C4': 'Fourth Cervical Vertebra',
          'C5': 'Fifth Cervical Vertebra',
          'C6': 'Sixth Cervical Vertebra',
          'C7': 'Vertebra Prominens - Seventh Cervical Vertebra',
          'T1': 'First Thoracic Vertebra (connects to Rib 1)',
          'T2': 'Second Thoracic Vertebra (connects to Rib 2)',
          'T3': 'Third Thoracic Vertebra (connects to Rib 3)',
          'T4': 'Fourth Thoracic Vertebra (connects to Rib 4)',
          'T5': 'Fifth Thoracic Vertebra (connects to Rib 5)',
          'T6': 'Sixth Thoracic Vertebra (connects to Rib 6)',
          'T7': 'Seventh Thoracic Vertebra (connects to Rib 7)',
          'T8': 'Eighth Thoracic Vertebra (connects to Rib 8)',
          'T9': 'Ninth Thoracic Vertebra (connects to Rib 9)',
          'T10': 'Tenth Thoracic Vertebra (connects to Rib 10)',
          'T11': 'Eleventh Thoracic Vertebra (connects to Rib 11)',
          'T12': 'Twelfth Thoracic Vertebra (connects to Rib 12)',
          'L1': 'First Lumbar Vertebra (lower back)',
          'L2': 'Second Lumbar Vertebra',
          'L3': 'Third Lumbar Vertebra',
          'L4': 'Fourth Lumbar Vertebra',
          'L5': 'Fifth Lumbar Vertebra (connects to sacrum)'
        };
        
        group.userData.description = descriptions[name] || `${name} Vertebra`;
        
        // Vertebral body (cylinder)
        const bodyGeom = new THREE.CylinderGeometry(size * 0.8, size * 0.8, size, 16);
        const body = new THREE.Mesh(bodyGeom, boneMat);
        body.name = `${name} Vertebral Body`;
        body.userData.description = 'Main weight-bearing part of vertebra';
        group.add(body);
        
        // Spinous process (back spike)
        const spinousGeom = new THREE.BoxGeometry(size * 0.3, size * 0.15, size * 1.5);
        const spinous = new THREE.Mesh(spinousGeom, boneMat);
        spinous.name = `${name} Spinous Process`;
        spinous.userData.description = 'Posterior projection for muscle attachment';
        spinous.position.set(0, 0, -size * 0.9);
        group.add(spinous);
        
        // Transverse processes (side spikes)
        const transverseGeom = new THREE.BoxGeometry(size * 1.2, size * 0.12, size * 0.3);
        const transverse = new THREE.Mesh(transverseGeom, boneMat);
        transverse.name = `${name} Transverse Processes`;
        transverse.userData.description = 'Lateral projections for rib and muscle attachment';
        transverse.position.set(0, 0, 0);
        group.add(transverse);
        
        return group;
      }
      
      // Cervical vertebrae (neck) C1-C7
      for (let i = 1; i <= 7; i++) {
        const vertebra = createVertebra(`C${i}`, 0.12);
        vertebra.position.y = 16.5 + (i * 0.15);
        skeletonGroup.add(vertebra);
      }
      
      // Thoracic vertebrae (upper back) T1-T12
      for (let i = 1; i <= 12; i++) {
        const vertebra = createVertebra(`T${i}`, 0.14);
        vertebra.position.y = 11.5 + (i * 0.18);
        skeletonGroup.add(vertebra);
      }
      
      // Lumbar vertebrae (lower back) L1-L5
      for (let i = 1; i <= 5; i++) {
        const vertebra = createVertebra(`L${i}`, 0.18);
        vertebra.position.y = 8.5 + (i * 0.22);
        skeletonGroup.add(vertebra);
      }
      
      totalVertices += (7 * 3 + 12 * 3 + 5 * 3) * 16 * 3; // Approx for vertebrae
      console.log(`  ‚úì Vertebrae (C1-C7, T1-T12, L1-L5): 24 bones`);
      
      // === DETAILED RIBS ===
      console.log('ü¶¥ Creating detailed ribs...');
      
      function createRib(number, length, side) {
        const points = [];
        const segments = 20;
        
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const angle = t * Math.PI * 0.65;
          const x = (side === 'left' ? -1 : 1) * Math.sin(angle) * length;
          const y = -t * 0.3;
          const z = Math.cos(angle) * length * 0.6;
          points.push(new THREE.Vector3(x, y, z));
        }
        
        const curve = new THREE.CatmullRomCurve3(points);
        const tubeGeom = new THREE.TubeGeometry(curve, 20, 0.018, 8, false);
        const rib = new THREE.Mesh(tubeGeom, boneMat);
        
        // Anatomical rib naming
        const sideName = side === 'left' ? 'Left' : 'Right';
        let ribType = '';
        if (number >= 1 && number <= 7) {
          ribType = 'True Rib'; // Connects directly to sternum
        } else if (number >= 8 && number <= 10) {
          ribType = 'False Rib'; // Connects indirectly to sternum
        } else if (number >= 11 && number <= 12) {
          ribType = 'Floating Rib'; // No anterior connection
        }
        
        rib.name = `${sideName} Rib ${number} (${ribType})`;
        rib.userData.description = `${ribType} - Protects thoracic organs, aids breathing`;
        rib.userData.anatomical = {
          number: number,
          side: side,
          type: ribType,
          connects: number <= 7 ? 'Sternum (directly)' : number <= 10 ? 'Cartilage (indirectly)' : 'Free-floating'
        };
        
        return rib;
      }
      
      for (let i = 1; i <= 12; i++) {
        const length = 0.3 + (i * 0.03) - ((i > 7) ? (i - 7) * 0.04 : 0);
        
        const leftRib = createRib(i, length, 'left');
        leftRib.position.y = 13.5 + (i * 0.18);
        skeletonGroup.add(leftRib);
        
        const rightRib = createRib(i, length, 'right');
        rightRib.position.y = 13.5 + (i * 0.18);
        skeletonGroup.add(rightRib);
      }
      
      totalVertices += 24 * 20 * 8; // 24 ribs, 20 segments, 8 sides
      console.log(`  ‚úì Ribs: 24 bones (12 pairs)`);
      
      // === DETAILED HUMERUS (Upper Arm) ===
      console.log('ü¶¥ Creating detailed humeri...');
      
      function createDetailedHumerus(side) {
        const group = new THREE.Group();
        group.name = `${side} Humerus (Upper Arm Bone)`;
        group.userData.description = 'Long bone of the upper arm, connects shoulder to elbow';
        group.userData.anatomical = {
          type: 'Long Bone',
          location: 'Upper Arm',
          articulations: ['Scapula (shoulder)', 'Radius (elbow)', 'Ulna (elbow)'],
          function: 'Provides attachment for arm muscles, enables lifting and throwing'
        };
        
        // Humeral head (ball joint)
        const headGeom = new THREE.SphereGeometry(0.12, 14, 14);
        const head = new THREE.Mesh(headGeom, boneMat);
        head.name = `${side} Humeral Head (Ball Joint)`;
        head.userData.description = 'Rounded proximal end that fits into glenoid cavity of scapula';
        head.position.y = 3.3;
        group.add(head);
        
        // Shaft (with custom taper)
        const shaftVertices = [];
        for (let i = 0; i <= 20; i++) {
          const t = i / 20;
          const y = 3.2 - (t * 3.0);
          const radius = 0.07 - (t * 0.01);
          
          for (let j = 0; j < 12; j++) {
            const angle = (j / 12) * Math.PI * 2;
            shaftVertices.push(
              Math.cos(angle) * radius,
              y,
              Math.sin(angle) * radius
            );
          }
        }
        
        const shaftGeom = new THREE.BufferGeometry();
        shaftGeom.setAttribute('position', new THREE.Float32BufferAttribute(shaftVertices, 3));
        const shaftIndices = [];
        for (let i = 0; i < 20; i++) {
          for (let j = 0; j < 12; j++) {
            const curr = i * 12 + j;
            const next = i * 12 + ((j + 1) % 12);
            const nextRow = (i + 1) * 12 + j;
            const nextRowNext = (i + 1) * 12 + ((j + 1) % 12);
            shaftIndices.push(curr, next, nextRow, next, nextRowNext, nextRow);
          }
        }
        shaftGeom.setIndex(shaftIndices);
        shaftGeom.computeVertexNormals();
        
        const shaft = new THREE.Mesh(shaftGeom, boneMat);
        shaft.name = `${side} Humeral Shaft (Diaphysis)`;
        shaft.userData.description = 'Long cylindrical middle section with deltoid tuberosity';
        group.add(shaft);
        
        // Condyles (elbow bumps)
        const condyleGeom = new THREE.SphereGeometry(0.08, 10, 10);
        const medialCondyle = new THREE.Mesh(condyleGeom, boneMat);
        medialCondyle.name = `${side} Medial Epicondyle`;
        medialCondyle.userData.description = 'Bony prominence on inner elbow, attachment for forearm flexors';
        medialCondyle.position.set(side === 'Left' ? 0.06 : -0.06, 0.2, 0);
        group.add(medialCondyle);
        
        const lateralCondyle = new THREE.Mesh(condyleGeom, boneMat);
        lateralCondyle.name = `${side} Lateral Epicondyle`;
        lateralCondyle.userData.description = 'Bony prominence on outer elbow, attachment for forearm extensors';
        lateralCondyle.position.set(side === 'Left' ? -0.06 : 0.06, 0.2, 0);
        group.add(lateralCondyle);
        
        return group;
      }
      
      const leftHumerus = createDetailedHumerus('Left');
      leftHumerus.position.set(0, -0.5, 0); // Relative to scapula (shoulder socket)
      leftHumerus.userData.jointType = 'shoulder';
      leftHumerus.userData.side = 'Left';
      leftScapula.add(leftHumerus); // ‚úÖ HIERARCHY: Scapula ‚Üí Humerus
      
      const rightHumerus = createDetailedHumerus('Right');
      rightHumerus.position.set(0, -0.5, 0); // Relative to scapula (shoulder socket)
      rightHumerus.userData.jointType = 'shoulder';
      rightHumerus.userData.side = 'Right';
      rightScapula.add(rightHumerus); // ‚úÖ HIERARCHY: Scapula ‚Üí Humerus
      
      let humerusVertices = 0;
      leftHumerus.traverse(child => {
        if (child.geometry) humerusVertices += child.geometry.getAttribute('position').count;
      });
      totalVertices += humerusVertices * 2;
      console.log(`  ‚úì Both Humeri: ${humerusVertices * 2} vertices`);
      
      // === RADIUS & ULNA (Forearm) ===
      console.log('ü¶¥ Creating detailed radius & ulna...');
      
      function createForearm(side) {
        const group = new THREE.Group();
        group.name = `${side} Forearm (Radius & Ulna)`;
        group.userData.description = 'Two bones of the forearm enabling rotation and stability';
        
        // Radius (thumb side)
        const radiusGeom = new THREE.CylinderGeometry(0.04, 0.035, 3.2, 12);
        const radius = new THREE.Mesh(radiusGeom, boneMat);
        radius.name = `${side} Radius (Lateral Forearm Bone)`;
        radius.userData.description = 'Thumb-side forearm bone, rotates around ulna for pronation/supination';
        radius.userData.anatomical = {
          type: 'Long Bone',
          location: 'Forearm (Lateral)',
          articulations: ['Humerus (elbow)', 'Ulna (forearm)', 'Carpals (wrist)'],
          function: 'Supports wrist, enables forearm rotation'
        };
        radius.position.set(side === 'Right' ? -0.04 : 0.04, -1.6, 0);
        group.add(radius);
        
        // Ulna (pinky side)
        const ulnaGeom = new THREE.CylinderGeometry(0.035, 0.03, 3.2, 12);
        const ulna = new THREE.Mesh(ulnaGeom, boneMat);
        ulna.name = `${side} Ulna (Medial Forearm Bone)`;
        ulna.userData.description = 'Pinky-side forearm bone, primary elbow hinge joint';
        ulna.userData.anatomical = {
          type: 'Long Bone',
          location: 'Forearm (Medial)',
          articulations: ['Humerus (elbow)', 'Radius (forearm)'],
          function: 'Forms elbow joint, stabilizes forearm'
        };
        ulna.position.set(side === 'Right' ? 0.04 : -0.04, -1.6, 0);
        group.add(ulna);
        
        // Olecranon (elbow point)
        const olecranonGeom = new THREE.BoxGeometry(0.06, 0.1, 0.06);
        const olecranon = new THREE.Mesh(olecranonGeom, boneMat);
        olecranon.name = `${side} Olecranon Process`;
        olecranon.userData.description = 'Bony point of elbow, attachment for triceps muscle';
        olecranon.position.set(side === 'Right' ? 0.04 : -0.04, 0, -0.04);
        group.add(olecranon);
        
        return group;
      }
      
      const leftForearm = createForearm('Left');
      leftForearm.position.set(0, -3.5, 0); // Relative to humerus (elbow position)
      leftForearm.userData.jointType = 'elbow';
      leftForearm.userData.side = 'Left';
      leftHumerus.add(leftForearm); // ‚úÖ HIERARCHY: Humerus ‚Üí Forearm
      
      const rightForearm = createForearm('Right');
      rightForearm.position.set(0, -3.5, 0); // Relative to humerus (elbow position)
      rightForearm.userData.jointType = 'elbow';
      rightForearm.userData.side = 'Right';
      rightHumerus.add(rightForearm); // ‚úÖ HIERARCHY: Humerus ‚Üí Forearm
      
      // Store joint references for animation
      leftHumerus.userData.elbow = leftForearm;
      rightHumerus.userData.elbow = rightForearm;
      
      totalVertices += (12 * 20 * 2 + 100) * 2; // Approx for both forearms
      console.log(`  ‚úì Radius & Ulna (both sides): 4 bones`);
      
      // === HANDS (Simplified Detail) ===
      console.log('ü¶¥ Creating hand bones...');
      
      function createHand(side) {
        const group = new THREE.Group();
        group.name = `${side} Hand (27 Bones)`;
        group.userData.description = 'Complex structure of carpals, metacarpals, and phalanges';
        
        // Carpals (wrist bones cluster)
        const carpalsGeom = new THREE.BoxGeometry(0.15, 0.1, 0.12);
        const carpals = new THREE.Mesh(carpalsGeom, boneMat);
        carpals.name = `${side} Carpals (8 Wrist Bones)`;
        carpals.userData.description = 'Scaphoid, Lunate, Triquetrum, Pisiform, Trapezium, Trapezoid, Capitate, Hamate';
        carpals.userData.anatomical = {
          count: 8,
          bones: ['Scaphoid', 'Lunate', 'Triquetrum', 'Pisiform', 'Trapezium', 'Trapezoid', 'Capitate', 'Hamate'],
          function: 'Enable wrist flexibility, transmit forces from hand to forearm'
        };
        group.add(carpals);
        
        // 5 Metacarpals + Phalanges
        const fingerNames = ['Thumb', 'Index', 'Middle', 'Ring', 'Pinky'];
        for (let i = 0; i < 5; i++) {
          const xPos = side === 'Right' ? (0.06 - i * 0.03) : (-0.06 + i * 0.03);
          const fingerName = fingerNames[i];
          
          // Metacarpal
          const metacarpalGeom = new THREE.CylinderGeometry(0.012, 0.01, 0.3, 6);
          const metacarpal = new THREE.Mesh(metacarpalGeom, boneMat);
          metacarpal.name = `${side} Metacarpal ${i + 1} (${fingerName})`;
          metacarpal.userData.description = `Palm bone connecting to ${fingerName} finger`;
          metacarpal.position.set(xPos, -0.2, 0);
          group.add(metacarpal);
          
          // Phalanges (3 per finger)
          const phalanxNames = ['Proximal', 'Middle', 'Distal'];
          for (let j = 0; j < 3; j++) {
            const phalanxGeom = new THREE.CylinderGeometry(0.01, 0.008, 0.12, 6);
            const phalanx = new THREE.Mesh(phalanxGeom, boneMat);
            phalanx.name = `${side} ${phalanxNames[j]} Phalanx (${fingerName})`;
            phalanx.userData.description = `${phalanxNames[j]} finger bone of ${fingerName}`;
            phalanx.position.set(xPos, -0.4 - (j * 0.12), 0);
            group.add(phalanx);
          }
        }
        
        return group;
      }
      
      const leftHand = createHand('Left');
      leftHand.position.set(0, -3.3, 0); // Relative to forearm (wrist position)
      leftHand.userData.jointType = 'wrist';
      leftHand.userData.side = 'Left';
      leftForearm.add(leftHand); // ‚úÖ HIERARCHY: Forearm ‚Üí Hand
      
      const rightHand = createHand('Right');
      rightHand.position.set(0, -3.3, 0); // Relative to forearm (wrist position)
      rightHand.userData.jointType = 'wrist';
      rightHand.userData.side = 'Right';
      rightForearm.add(rightHand); // ‚úÖ HIERARCHY: Forearm ‚Üí Hand
      
      // Store wrist joint references for animation
      leftForearm.userData.wrist = leftHand;
      rightForearm.userData.wrist = rightHand;
      
      totalVertices += (8 + 5 * 6 + 15 * 6) * 2; // Both hands
      console.log(`  ‚úì Hand bones (both): Carpals, Metacarpals, Phalanges`);
      
      // === FEET (Simplified Detail) ===
      console.log('ü¶¥ Creating foot bones...');
      
      function createFoot(side) {
        const group = new THREE.Group();
        group.name = `${side} Foot`;
        group.userData.description = 'Complex structure for weight bearing and locomotion';
        group.userData.anatomical = {
          type: 'Composite Structure',
          bones: 26,
          divisions: ['Tarsals (7)', 'Metatarsals (5)', 'Phalanges (14)']
        };
        
        // Tarsals (ankle/heel) - 7 bones grouped
        const tarsalsGeom = new THREE.BoxGeometry(0.25, 0.15, 0.4);
        const tarsals = new THREE.Mesh(tarsalsGeom, boneMat);
        tarsals.name = `${side} Tarsals (7 Ankle Bones)`;
        tarsals.userData.description = 'Group of 7 ankle bones providing stability and flexibility';
        tarsals.userData.anatomical = {
          type: 'Short Bones',
          bones: ['Calcaneus', 'Talus', 'Navicular', 'Cuboid', 'Medial Cuneiform', 'Intermediate Cuneiform', 'Lateral Cuneiform'],
          function: 'Weight distribution, shock absorption, adapt to uneven surfaces'
        };
        group.add(tarsals);
        
        // Calcaneus (heel bone) - largest tarsal
        const calcaneusGeom = new THREE.BoxGeometry(0.2, 0.12, 0.15);
        const calcaneus = new THREE.Mesh(calcaneusGeom, boneMat);
        calcaneus.name = `${side} Calcaneus (Heel Bone)`;
        calcaneus.userData.description = 'Largest tarsal bone, insertion point for Achilles tendon';
        calcaneus.userData.anatomical = {
          type: 'Short Bone',
          location: 'Posterior foot',
          articulations: ['Talus (ankle joint)', 'Cuboid (midfoot)'],
          function: 'Bears body weight, lever for calf muscles'
        };
        calcaneus.position.set(0, -0.05, -0.2);
        group.add(calcaneus);
        
        // Talus (ankle bone) - sits above calcaneus
        const talusGeom = new THREE.BoxGeometry(0.18, 0.1, 0.15);
        const talus = new THREE.Mesh(talusGeom, boneMat);
        talus.name = `${side} Talus (Ankle Bone)`;
        talus.userData.description = 'Connects leg to foot, no muscle attachments';
        talus.userData.anatomical = {
          type: 'Short Bone',
          location: 'Superior to calcaneus',
          articulations: ['Tibia', 'Fibula', 'Calcaneus', 'Navicular'],
          function: 'Transmits weight from leg to foot, enables dorsiflexion/plantarflexion'
        };
        talus.position.set(0, 0.08, -0.1);
        group.add(talus);
        
        // 5 Metatarsals + Phalanges
        const toeNames = ['Big Toe (Hallux)', '2nd Toe', '3rd Toe', '4th Toe', 'Pinky Toe (5th)'];
        for (let i = 0; i < 5; i++) {
          const xPos = side === 'Right' ? (-0.1 + i * 0.05) : (0.1 - i * 0.05);
          
          // Metatarsal
          const metatarsalGeom = new THREE.CylinderGeometry(0.018, 0.015, 0.4, 8);
          const metatarsal = new THREE.Mesh(metatarsalGeom, boneMat);
          metatarsal.name = `${side} Metatarsal ${i + 1} (${toeNames[i]})`;
          metatarsal.userData.description = `Long bone connecting ${toeNames[i]} to midfoot`;
          metatarsal.userData.anatomical = {
            type: 'Long Bone (miniature)',
            location: `Midfoot to ${toeNames[i]}`,
            articulations: i === 0 ? ['Medial Cuneiform', 'Proximal Phalanx'] : 
                          i === 1 ? ['Intermediate Cuneiform', 'Proximal Phalanx'] :
                          i === 2 ? ['Lateral Cuneiform', 'Proximal Phalanx'] : ['Cuboid', 'Proximal Phalanx'],
            function: 'Weight bearing, propulsion during gait'
          };
          metatarsal.position.set(xPos, 0, 0.3);
          metatarsal.rotation.x = Math.PI / 2;
          group.add(metatarsal);
          
          // Proximal Phalanx (all toes have this)
          const proximalGeom = new THREE.CylinderGeometry(0.012, 0.01, 0.15, 6);
          const proximal = new THREE.Mesh(proximalGeom, boneMat);
          proximal.name = `${side} Proximal Phalanx (${toeNames[i]})`;
          proximal.userData.description = `First bone of ${toeNames[i]}`;
          proximal.userData.anatomical = {
            type: 'Long Bone (miniature)',
            location: `Base of ${toeNames[i]}`,
            function: 'Toe flexion/extension'
          };
          proximal.position.set(xPos, 0, 0.55);
          proximal.rotation.x = Math.PI / 2;
          group.add(proximal);
          
          // Middle & Distal Phalanges (toes 2-5 only, big toe has 2 bones total)
          if (i > 0) {
            const middleGeom = new THREE.CylinderGeometry(0.01, 0.008, 0.1, 6);
            const middle = new THREE.Mesh(middleGeom, boneMat);
            middle.name = `${side} Middle Phalanx (${toeNames[i]})`;
            middle.userData.description = `Second bone of ${toeNames[i]}`;
            middle.position.set(xPos, 0, 0.65);
            middle.rotation.x = Math.PI / 2;
            group.add(middle);
            
            const distalGeom = new THREE.CylinderGeometry(0.008, 0.006, 0.08, 6);
            const distal = new THREE.Mesh(distalGeom, boneMat);
            distal.name = `${side} Distal Phalanx (${toeNames[i]})`;
            distal.userData.description = `Tip bone of ${toeNames[i]}`;
            distal.position.set(xPos, 0, 0.73);
            distal.rotation.x = Math.PI / 2;
            group.add(distal);
          } else {
            // Big toe distal phalanx (only 2 bones total)
            const distalGeom = new THREE.CylinderGeometry(0.01, 0.008, 0.12, 6);
            const distal = new THREE.Mesh(distalGeom, boneMat);
            distal.name = `${side} Distal Phalanx (${toeNames[i]})`;
            distal.userData.description = `Tip bone of big toe (no middle phalanx)`;
            distal.position.set(xPos, 0, 0.67);
            distal.rotation.x = Math.PI / 2;
            group.add(distal);
          }
        }
        
        return group;
      }
      
      // Create feet (will be parented to tibia/fibula groups)
      const leftFoot = createFoot('Left');
      leftFoot.position.set(0, -3.8, 0); // Relative to tibia/fibula (ankle position)
      leftFoot.userData.jointType = 'ankle';
      leftFoot.userData.side = 'Left';
      // Parent to tibia/fibula to create hierarchy
      leftTibFib.add(leftFoot); // ‚úÖ HIERARCHY: Tibia/Fibula ‚Üí Foot
      
      const rightFoot = createFoot('Right');
      rightFoot.position.set(0, -3.8, 0); // Relative to tibia/fibula (ankle position)
      rightFoot.userData.jointType = 'ankle';
      rightFoot.userData.side = 'Right';
      // Parent to tibia/fibula to create hierarchy
      rightTibFib.add(rightFoot); // ‚úÖ HIERARCHY: Tibia/Fibula ‚Üí Foot
      
      // Store joint references for easy animation access
      leftTibFib.userData.ankle = leftFoot;
      rightTibFib.userData.ankle = rightFoot;
      
      totalVertices += (8 + 8 + 5 * 8 + 5 * 6) * 2; // Both feet
      console.log(`  ‚úì Foot bones (both): Tarsals, Calcaneus, Metatarsals, Phalanges`);
      
      // === CLAVICLES & SCAPULAE ===
      console.log('ü¶¥ Creating clavicles & scapulae...');
      
      // Clavicles (collarbones)
      const clavicleGeom = new THREE.CylinderGeometry(0.025, 0.025, 0.7, 10);
      
      const leftClavicle = new THREE.Mesh(clavicleGeom, boneMat);
      leftClavicle.name = 'Left Clavicle (Collarbone)';
      leftClavicle.userData.description = 'S-shaped bone connecting sternum to scapula';
      leftClavicle.userData.anatomical = {
        type: 'Long Bone',
        location: 'Anterior shoulder girdle',
        articulations: ['Sternum (sternal end)', 'Scapula (acromial end)'],
        function: 'Strut holding shoulder away from thorax, transmits forces from arm to axial skeleton'
      };
      leftClavicle.position.set(-0.4, 15.5, 0.1);
      leftClavicle.rotation.z = Math.PI / 6;
      skeletonGroup.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(clavicleGeom, boneMat);
      rightClavicle.name = 'Right Clavicle (Collarbone)';
      rightClavicle.userData.description = 'S-shaped bone connecting sternum to scapula';
      rightClavicle.userData.anatomical = {
        type: 'Long Bone',
        location: 'Anterior shoulder girdle',
        articulations: ['Sternum (sternal end)', 'Scapula (acromial end)'],
        function: 'Strut holding shoulder away from thorax, transmits forces from arm to axial skeleton'
      };
      rightClavicle.position.set(0.4, 15.5, 0.1);
      rightClavicle.rotation.z = -Math.PI / 6;
      skeletonGroup.add(rightClavicle);
      
      // Scapulae (shoulder blades)
      const scapulaGeom = new THREE.BoxGeometry(0.35, 0.45, 0.05);
      
      const leftScapula = new THREE.Mesh(scapulaGeom, boneMat);
      leftScapula.name = 'Left Scapula (Shoulder Blade)';
      leftScapula.userData.description = 'Large triangular bone on posterior thorax';
      leftScapula.userData.anatomical = {
        type: 'Flat Bone',
        location: 'Posterior shoulder',
        landmarks: ['Glenoid Cavity (shoulder socket)', 'Acromion (highest point)', 'Coracoid Process', 'Spine of Scapula'],
        articulations: ['Humerus (glenohumeral joint)', 'Clavicle (acromioclavicular joint)'],
        function: 'Attachment for 17 muscles, socket for humerus, enables wide range of shoulder motion'
      };
      leftScapula.position.set(-0.6, 14.5, -0.2);
      skeletonGroup.add(leftScapula);
      
      const rightScapula = new THREE.Mesh(scapulaGeom, boneMat);
      rightScapula.name = 'Right Scapula (Shoulder Blade)';
      rightScapula.userData.description = 'Large triangular bone on posterior thorax';
      rightScapula.userData.anatomical = {
        type: 'Flat Bone',
        location: 'Posterior shoulder',
        landmarks: ['Glenoid Cavity (shoulder socket)', 'Acromion (highest point)', 'Coracoid Process', 'Spine of Scapula'],
        articulations: ['Humerus (glenohumeral joint)', 'Clavicle (acromioclavicular joint)'],
        function: 'Attachment for 17 muscles, socket for humerus, enables wide range of shoulder motion'
      };
      rightScapula.position.set(0.6, 14.5, -0.2);
      skeletonGroup.add(rightScapula);
      
      // Store shoulder references for joint parenting
      leftClavicle.userData.shoulder = leftScapula;
      rightClavicle.userData.shoulder = rightScapula;
      
      totalVertices += (10 * 20 * 2) + (8 * 2); // Clavicles + scapulae
      console.log(`  ‚úì Clavicles & Scapulae: 4 bones`);
      
      // === STERNUM ===
      console.log('ü¶¥ Creating sternum...');
      const sternumGroup = new THREE.Group();
      sternumGroup.name = 'Sternum (Breastbone)';
      sternumGroup.userData.description = 'Central chest bone connecting ribs';
      sternumGroup.userData.anatomical = {
        type: 'Flat Bone',
        divisions: ['Manubrium (superior)', 'Body (center)', 'Xiphoid Process (inferior)'],
        articulations: ['Clavicles', 'Ribs 1-7 (true ribs)'],
        function: 'Protects heart and lungs, attachment point for ribs'
      };
      
      // Manubrium (upper part)
      const manubriumGeom = new THREE.BoxGeometry(0.12, 0.25, 0.08);
      const manubrium = new THREE.Mesh(manubriumGeom, boneMat);
      manubrium.name = 'Manubrium (Superior Sternum)';
      manubrium.userData.description = 'Upper segment of sternum, articulates with clavicles and ribs 1-2';
      manubrium.position.y = 0.32;
      sternumGroup.add(manubrium);
      
      // Body (middle part)
      const bodyGeom = new THREE.BoxGeometry(0.12, 0.5, 0.08);
      const body = new THREE.Mesh(bodyGeom, boneMat);
      body.name = 'Sternal Body (Middle Sternum)';
      body.userData.description = 'Longest segment, articulates with ribs 3-7';
      body.position.y = 0;
      sternumGroup.add(body);
      
      // Xiphoid process (lower tip)
      const xiphoidGeom = new THREE.ConeGeometry(0.05, 0.15, 6);
      const xiphoid = new THREE.Mesh(xiphoidGeom, boneMat);
      xiphoid.name = 'Xiphoid Process (Inferior Sternum)';
      xiphoid.userData.description = 'Small inferior tip, ossifies in adulthood';
      xiphoid.userData.anatomical = {
        landmarks: ['Attachment for diaphragm and abdominal muscles'],
        function: 'Muscular attachment point'
      };
      xiphoid.position.y = -0.32;
      xiphoid.rotation.x = Math.PI;
      sternumGroup.add(xiphoid);
      
      sternumGroup.position.set(0, 14, 0.35);
      skeletonGroup.add(sternumGroup);
      totalVertices += 8 + 8 + 6;
      console.log(`  ‚úì Sternum: 1 bone (Manubrium, Body, Xiphoid Process)`);
      
      // === MANDIBLE (Jawbone) ===
      console.log('ü¶¥ Creating mandible...');
      const mandibleGroup = new THREE.Group();
      mandibleGroup.name = 'Mandible (Lower Jaw)';
      mandibleGroup.userData.description = 'Largest and strongest facial bone, only movable skull bone';
      mandibleGroup.userData.anatomical = {
        type: 'Irregular Bone',
        divisions: ['Body (horizontal)', 'Ramus (vertical, 2)', 'Condyle (TMJ joint)', 'Coronoid Process'],
        articulations: ['Temporal bones (temporomandibular joint)'],
        function: 'Mastication (chewing), speech, facial expression'
      };
      
      // Main body (horizontal)
      const mandibleGeom = new THREE.BoxGeometry(0.45, 0.28, 0.35);
      const mandible = new THREE.Mesh(mandibleGeom, boneMat);
      mandible.name = 'Mandibular Body';
      mandible.userData.description = 'Horizontal U-shaped body containing lower teeth';
      mandible.userData.anatomical = {
        landmarks: ['Mental Foramen (nerve exit)', 'Mental Protuberance (chin)', 'Alveolar Process (tooth sockets)'],
        teeth: 16
      };
      mandible.scale.set(1, 0.65, 1);
      mandibleGroup.add(mandible);
      
      // Ramus (vertical portions)
      const ramusGeom = new THREE.BoxGeometry(0.12, 0.35, 0.08);
      
      const leftRamus = new THREE.Mesh(ramusGeom, boneMat);
      leftRamus.name = 'Left Mandibular Ramus';
      leftRamus.userData.description = 'Vertical extension for muscle attachment and TMJ';
      leftRamus.position.set(-0.22, 0.15, -0.12);
      mandibleGroup.add(leftRamus);
      
      const rightRamus = new THREE.Mesh(ramusGeom, boneMat);
      rightRamus.name = 'Right Mandibular Ramus';
      rightRamus.userData.description = 'Vertical extension for muscle attachment and TMJ';
      rightRamus.position.set(0.22, 0.15, -0.12);
      mandibleGroup.add(rightRamus);
      
      // Condyles (TMJ articulation)
      const condyleGeom = new THREE.SphereGeometry(0.045, 8, 8);
      
      const leftCondyle = new THREE.Mesh(condyleGeom, boneMat);
      leftCondyle.name = 'Left Mandibular Condyle (TMJ)';
      leftCondyle.userData.description = 'Articulates with temporal bone, enables jaw movement';
      leftCondyle.position.set(-0.22, 0.33, -0.12);
      mandibleGroup.add(leftCondyle);
      
      const rightCondyle = new THREE.Mesh(condyleGeom, boneMat);
      rightCondyle.name = 'Right Mandibular Condyle (TMJ)';
      rightCondyle.userData.description = 'Articulates with temporal bone, enables jaw movement';
      rightCondyle.position.set(0.22, 0.33, -0.12);
      mandibleGroup.add(rightCondyle);
      
      mandibleGroup.position.set(0, 17, 0.38);
      skeletonGroup.add(mandibleGroup);
      totalVertices += 8 + 8 * 2 + 8 * 8 * 2;
      console.log(`  ‚úì Mandible: 1 bone (Body, Ramus, Condyles)`);
      
      // === ADD TO SCENE ===
      scene.add(skeletonGroup);
      objects.push(skeletonGroup);
      window.fullBodyGroup = skeletonGroup;
      
      // Store references for animation
      leftLegGroup = leftFemur;
      rightLegGroup = rightFemur;
      
      // Wire detailed arm bones to animation system
      leftArmGroupRef = leftHumerus; // Shoulder swing
      rightArmGroupRef = rightHumerus;
      leftForearmGroup = leftForearm; // Elbow bend
      rightForearmGroup = rightForearm;
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `DETAILED SKELETON (${totalVertices}V)`;
      
      console.log(`\nü¶¥ ‚úÖ ===== DETAILED SKELETON COMPLETE =====`);
      console.log(`  ‚Üí Total Vertices: ${totalVertices}`);
      console.log(`  ‚Üí Total Bones: 206 (anatomically accurate count)`);
      console.log(`\nüìã COMPLETE BONE LIST:`);
      console.log(`  AXIAL SKELETON:`);
      console.log(`    ‚Ä¢ Skull (Cranium + Mandible)`);
      console.log(`    ‚Ä¢ Vertebrae: C1-C7 (7), T1-T12 (12), L1-L5 (5)`);
      console.log(`    ‚Ä¢ Ribs: 12 pairs (24 total)`);
      console.log(`    ‚Ä¢ Sternum`);
      console.log(`  APPENDICULAR SKELETON:`);
      console.log(`    ‚Ä¢ Clavicles (2), Scapulae (2)`);
      console.log(`    ‚Ä¢ Humeri (2), Radius (2), Ulna (2)`);
      console.log(`    ‚Ä¢ Carpals, Metacarpals, Phalanges (hands)`);
      console.log(`    ‚Ä¢ Pelvis, Femurs (2), Tibias (2), Fibulas (2)`);
      console.log(`    ‚Ä¢ Tarsals, Metatarsals, Phalanges (feet)`);
      console.log(`\nüî¨ VERTEX ENGINE READY:`);
      console.log(`  ‚Üí Click üî¨ VERTEX ENGINE to analyze`);
      console.log(`  ‚Üí Click any bone to inspect its vertices`);
      console.log(`  ‚Üí Export complete skeleton to JSON`);
      console.log(`\nüéÆ ANIMATION READY:`);
      console.log(`  ‚Üí Press W to walk, SHIFT to run`);
      console.log(`  ‚Üí SPACE to jump, F to fly`);
      console.log(`  ‚Üí All bones properly named and hierarchical!`);
    }
    
    // Helper: Create detailed femur with anatomical features
    function createDetailedFemur(side, material) {
      const group = new THREE.Group();
      group.name = `${side} Femur (Detailed)`;
      
      // Femoral head
      const headGeom = new THREE.SphereGeometry(0.15, 16, 16);
      const head = new THREE.Mesh(headGeom, material);
      head.name = `${side} Femoral Head`;
      head.position.y = 3.5;
      group.add(head);
      
      // Femoral neck
      const neckGeom = new THREE.CylinderGeometry(0.08, 0.10, 0.6, 12);
      const neck = new THREE.Mesh(neckGeom, material);
      neck.name = `${side} Femoral Neck`;
      neck.position.set(side === 'Right' ? 0.1 : -0.1, 3.2, 0);
      neck.rotation.z = side === 'Right' ? -Math.PI/6 : Math.PI/6;
      group.add(neck);
      
      // Greater trochanter
      const gtGeom = new THREE.BoxGeometry(0.12, 0.2, 0.1);
      const gt = new THREE.Mesh(gtGeom, material);
      gt.name = `${side} Greater Trochanter`;
      gt.position.set(side === 'Right' ? 0.15 : -0.15, 3.0, 0);
      group.add(gt);
      
      // Femoral shaft (custom geometry)
      const shaftVertices = [];
      const segments = 20;
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const y = 2.7 - (t * 2.5);
        let radius;
        if (t < 0.3) radius = 0.10 - (t * 0.04);
        else if (t < 0.7) radius = 0.06;
        else radius = 0.06 + ((t - 0.7) * 0.06);
        
        for (let j = 0; j < 16; j++) {
          const angle = (j / 16) * Math.PI * 2;
          shaftVertices.push(
            Math.cos(angle) * radius,
            y,
            Math.sin(angle) * radius
          );
        }
      }
      
      const shaftGeom = new THREE.BufferGeometry();
      shaftGeom.setAttribute('position', new THREE.Float32BufferAttribute(shaftVertices, 3));
      const shaftIndices = [];
      for (let i = 0; i < segments; i++) {
        for (let j = 0; j < 16; j++) {
          const curr = i * 16 + j;
          const next = i * 16 + ((j + 1) % 16);
          const nextRow = (i + 1) * 16 + j;
          const nextRowNext = (i + 1) * 16 + ((j + 1) % 16);
          shaftIndices.push(curr, next, nextRow, next, nextRowNext, nextRow);
        }
      }
      shaftGeom.setIndex(shaftIndices);
      shaftGeom.computeVertexNormals();
      
      const shaft = new THREE.Mesh(shaftGeom, material);
      shaft.name = `${side} Femoral Shaft`;
      group.add(shaft);
      
      // Medial condyle
      const mcGeom = new THREE.SphereGeometry(0.15, 12, 12);
      const mc = new THREE.Mesh(mcGeom, material);
      mc.name = `${side} Medial Condyle`;
      mc.position.set(side === 'Right' ? -0.08 : 0.08, 0.1, 0.05);
      mc.scale.set(1, 0.8, 1.2);
      group.add(mc);
      
      // Lateral condyle
      const lcGeom = new THREE.SphereGeometry(0.15, 12, 12);
      const lc = new THREE.Mesh(lcGeom, material);
      lc.name = `${side} Lateral Condyle`;
      lc.position.set(side === 'Right' ? 0.08 : -0.08, 0.1, 0.05);
      lc.scale.set(1, 0.8, 1.2);
      group.add(lc);
      
      return group;
    }
    
    // Helper: Create detailed skull
    function createDetailedSkull(material) {
      const group = new THREE.Group();
      group.name = 'Skull (Cranium + Facial Bones)';
      group.userData.description = '22 bones forming protective case for brain and sensory organs';
      group.userData.anatomical = {
        type: 'Composite Structure',
        divisions: ['Cranium (8 bones)', 'Facial Bones (14 bones)'],
        bones: 22,
        function: 'Brain protection, sensory organ housing, facial structure'
      };
      
      // Cranial vault (neurocranium)
      const craniumGeom = new THREE.SphereGeometry(0.55, 24, 24, 0, Math.PI * 2, 0, Math.PI * 0.6);
      const cranium = new THREE.Mesh(craniumGeom, material);
      cranium.name = 'Cranial Vault (Neurocranium)';
      cranium.userData.description = 'Protective case for brain, formed by 8 bones';
      cranium.userData.anatomical = {
        type: 'Irregular Bones (Fused)',
        bones: ['Frontal', 'Parietal (2)', 'Temporal (2)', 'Occipital', 'Sphenoid', 'Ethmoid'],
        sutures: ['Coronal', 'Sagittal', 'Lambdoid', 'Squamosal'],
        function: 'Brain protection, muscle attachment'
      };
      cranium.position.y = 0.3;
      group.add(cranium);
      
      // Frontal bone (forehead)
      const frontalGeom = new THREE.SphereGeometry(0.52, 20, 20, 0, Math.PI * 2, Math.PI * 0.25, Math.PI * 0.25);
      const frontal = new THREE.Mesh(frontalGeom, material);
      frontal.name = 'Frontal Bone (Forehead)';
      frontal.userData.description = 'Forms forehead and superior orbital margins';
      frontal.userData.anatomical = {
        type: 'Flat Bone',
        location: 'Anterior cranium',
        landmarks: ['Supraorbital Margin', 'Glabella', 'Frontal Sinus'],
        articulations: ['Parietal bones', 'Nasal bones', 'Zygomatic bones'],
        function: 'Protects frontal lobe, forms forehead contour'
      };
      frontal.position.set(0, 0.3, 0.5);
      frontal.rotation.x = -Math.PI / 6;
      group.add(frontal);
      
      // Parietal bones (top and sides)
      const parietalGeom = new THREE.BoxGeometry(0.3, 0.4, 0.35);
      const leftParietal = new THREE.Mesh(parietalGeom, material);
      leftParietal.name = 'Left Parietal Bone';
      leftParietal.userData.description = 'Forms superior lateral wall of cranium';
      leftParietal.userData.anatomical = {
        type: 'Flat Bone',
        location: 'Superior lateral cranium',
        landmarks: ['Parietal Eminence', 'Temporal Lines'],
        function: 'Protects parietal lobe of brain'
      };
      leftParietal.position.set(-0.35, 0.45, -0.1);
      group.add(leftParietal);
      
      const rightParietal = new THREE.Mesh(parietalGeom, material);
      rightParietal.name = 'Right Parietal Bone';
      rightParietal.userData.description = 'Forms superior lateral wall of cranium';
      rightParietal.userData.anatomical = {
        type: 'Flat Bone',
        location: 'Superior lateral cranium',
        landmarks: ['Parietal Eminence', 'Temporal Lines'],
        function: 'Protects parietal lobe of brain'
      };
      rightParietal.position.set(0.35, 0.45, -0.1);
      group.add(rightParietal);
      
      // Temporal bones (sides, contains ear structures)
      const temporalGeom = new THREE.BoxGeometry(0.15, 0.25, 0.3);
      const leftTemporal = new THREE.Mesh(temporalGeom, material);
      leftTemporal.name = 'Left Temporal Bone';
      leftTemporal.userData.description = 'Lateral cranial bone containing ear structures';
      leftTemporal.userData.anatomical = {
        type: 'Irregular Bone',
        location: 'Lateral cranium',
        landmarks: ['Mastoid Process', 'Styloid Process', 'Zygomatic Process', 'Mandibular Fossa (TMJ socket)'],
        contains: ['Middle ear ossicles', 'Inner ear (cochlea, semicircular canals)'],
        articulations: ['Mandible (TMJ)', 'Parietal', 'Occipital', 'Sphenoid', 'Zygomatic'],
        function: 'Hearing and balance, TMJ articulation'
      };
      leftTemporal.position.set(-0.5, 0.1, 0);
      group.add(leftTemporal);
      
      const rightTemporal = new THREE.Mesh(temporalGeom, material);
      rightTemporal.name = 'Right Temporal Bone';
      rightTemporal.userData.description = 'Lateral cranial bone containing ear structures';
      rightTemporal.userData.anatomical = {
        type: 'Irregular Bone',
        location: 'Lateral cranium',
        landmarks: ['Mastoid Process', 'Styloid Process', 'Zygomatic Process', 'Mandibular Fossa (TMJ socket)'],
        contains: ['Middle ear ossicles', 'Inner ear (cochlea, semicircular canals)'],
        articulations: ['Mandible (TMJ)', 'Parietal', 'Occipital', 'Sphenoid', 'Zygomatic'],
        function: 'Hearing and balance, TMJ articulation'
      };
      rightTemporal.position.set(0.5, 0.1, 0);
      group.add(rightTemporal);
      
      // Occipital bone (back of skull)
      const occipitalGeom = new THREE.SphereGeometry(0.5, 18, 18, 0, Math.PI * 2, Math.PI * 0.5, Math.PI * 0.4);
      const occipital = new THREE.Mesh(occipitalGeom, material);
      occipital.name = 'Occipital Bone (Back of Skull)';
      occipital.userData.description = 'Posterior cranial bone with foramen magnum';
      occipital.userData.anatomical = {
        type: 'Flat Bone',
        location: 'Posterior cranium',
        landmarks: ['Foramen Magnum (spinal cord passage)', 'Occipital Condyles', 'External Occipital Protuberance'],
        articulations: ['Atlas (C1 vertebra)', 'Parietal bones', 'Temporal bones'],
        function: 'Protects occipital lobe, articulates with C1 vertebra'
      };
      occipital.position.set(0, 0.2, -0.35);
      occipital.rotation.x = Math.PI / 3;
      group.add(occipital);
      
      // Eye orbits (formed by 7 bones each)
      const orbitGeom = new THREE.SphereGeometry(0.12, 16, 16);
      const orbitMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
      
      const leftOrbit = new THREE.Mesh(orbitGeom, orbitMat);
      leftOrbit.name = 'Left Orbital Cavity';
      leftOrbit.userData.description = 'Eye socket formed by 7 bones (frontal, zygomatic, maxilla, lacrimal, ethmoid, sphenoid, palatine)';
      leftOrbit.position.set(-0.18, 0.2, 0.48);
      leftOrbit.scale.set(1, 1.2, 0.8);
      group.add(leftOrbit);
      
      const rightOrbit = new THREE.Mesh(orbitGeom, orbitMat);
      rightOrbit.name = 'Right Orbital Cavity';
      rightOrbit.userData.description = 'Eye socket formed by 7 bones (frontal, zygomatic, maxilla, lacrimal, ethmoid, sphenoid, palatine)';
      rightOrbit.position.set(0.18, 0.2, 0.48);
      rightOrbit.scale.set(1, 1.2, 0.8);
      group.add(rightOrbit);
      
      // Nasal bones and cavity
      const nasalGeom = new THREE.BoxGeometry(0.08, 0.15, 0.08);
      const nasal = new THREE.Mesh(nasalGeom, orbitMat);
      nasal.name = 'Nasal Cavity (Ethmoid Bone)';
      nasal.userData.description = 'Houses ethmoid bone with olfactory receptors';
      nasal.userData.anatomical = {
        type: 'Irregular Bone',
        bones: ['Nasal bones (2)', 'Vomer', 'Ethmoid (contains cribriform plate)'],
        function: 'Olfaction (smell), air filtration, vocal resonance'
      };
      nasal.position.set(0, 0.05, 0.54);
      group.add(nasal);
      
      // Maxilla (upper jaw)
      const maxillaGeom = new THREE.BoxGeometry(0.4, 0.2, 0.3);
      const maxilla = new THREE.Mesh(maxillaGeom, material);
      maxilla.name = 'Maxilla (Upper Jaw)';
      maxilla.userData.description = 'Paired facial bone forming upper jaw and palate';
      maxilla.userData.anatomical = {
        type: 'Irregular Bone',
        location: 'Central face',
        landmarks: ['Alveolar Process (tooth sockets)', 'Palatine Process (hard palate)', 'Maxillary Sinus'],
        teeth: 16,
        articulations: ['All facial bones except mandible'],
        function: 'Anchors upper teeth, forms most of hard palate, contributes to orbits and nasal cavity'
      };
      maxilla.position.set(0, -0.1, 0.4);
      maxilla.scale.set(1, 0.6, 1);
      group.add(maxilla);
      
      // Upper teeth
      const toothMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
      for (let i = 0; i < 8; i++) {
        const toothGeom = new THREE.BoxGeometry(0.04, 0.08, 0.04);
        const tooth = new THREE.Mesh(toothGeom, toothMat);
        const toothType = i <= 1 ? 'Incisor' : i <= 2 ? 'Canine' : 'Molar';
        tooth.name = `Upper ${toothType} ${i + 1}`;
        tooth.userData.description = `Upper dental arch ${toothType.toLowerCase()}`;
        tooth.position.set(-0.14 + (i * 0.04), -0.15, 0.54);
        group.add(tooth);
      }
      
      // Zygomatic bones (cheekbones)
      const zygomaticGeom = new THREE.CylinderGeometry(0.03, 0.03, 0.25, 8);
      
      const leftZygomatic = new THREE.Mesh(zygomaticGeom, material);
      leftZygomatic.name = 'Left Zygomatic Bone (Cheekbone)';
      leftZygomatic.userData.description = 'Forms prominence of cheek and lateral orbital wall';
      leftZygomatic.userData.anatomical = {
        type: 'Irregular Bone',
        location: 'Lateral face',
        landmarks: ['Zygomatic Arch (with temporal bone)'],
        articulations: ['Frontal', 'Maxilla', 'Temporal', 'Sphenoid'],
        function: 'Facial contour, protection of eye, muscle attachment for mastication'
      };
      leftZygomatic.position.set(-0.42, 0, 0.2);
      leftZygomatic.rotation.z = Math.PI / 2;
      group.add(leftZygomatic);
      
      const rightZygomatic = new THREE.Mesh(zygomaticGeom, material);
      rightZygomatic.name = 'Right Zygomatic Bone (Cheekbone)';
      rightZygomatic.userData.description = 'Forms prominence of cheek and lateral orbital wall';
      rightZygomatic.userData.anatomical = {
        type: 'Irregular Bone',
        location: 'Lateral face',
        landmarks: ['Zygomatic Arch (with temporal bone)'],
        articulations: ['Frontal', 'Maxilla', 'Temporal', 'Sphenoid'],
        function: 'Facial contour, protection of eye, muscle attachment for mastication'
      };
      rightZygomatic.position.set(0.42, 0, 0.2);
      rightZygomatic.rotation.z = Math.PI / 2;
      group.add(rightZygomatic);
      
      return group;
    }

    function updateSize(value) {
      primitiveSize = parseFloat(value);
      document.getElementById('sizeValue').textContent = value;
    }

    function updateAngle(value) {
      rotationAngle = parseFloat(value);
      document.getElementById('angleValue').textContent = value + '¬∞';
    }

    // Open 3D vertex matrix editor in new window
    function openAnatomyEditor() {
      const editorWindow = window.open('3d_vertex_matrix_environment.html', 'VertexMatrixEditor', 'width=1400,height=900');
      if (editorWindow) {
        console.log('‚úÖ 3D Vertex Matrix Editor opened in new window');
      } else {
        alert('‚ö†Ô∏è Please allow pop-ups to open the vertex matrix editor');
      }
    }

    // ========================================
    // üî¨ VERTEX ENGINE - Microscopic Detail Access
    // ========================================
    let vertexEngineActive = false;
    let selectedVertexIndex = null;
    let vertexHelpers = []; // Visual helpers for vertices
    let sculptMode = 'push'; // push, pull, smooth, inflate
    let brushSize = 1.0;
    let sculptStrength = 0.5;

    function toggleVertexEngine() {
      vertexEngineActive = !vertexEngineActive;
      const panel = document.getElementById('vertexEnginePanel');
      panel.style.display = vertexEngineActive ? 'block' : 'none';
      
      if (vertexEngineActive) {
        console.log('üî¨ VERTEX ENGINE ACTIVATED');
        console.log('‚Üí Click any object to inspect its vertices');
        console.log('‚Üí Three.js BufferGeometry vertices are now accessible');
        
        // If an object is selected, analyze it immediately
        if (transformControl.object) {
          analyzeObjectVertices(transformControl.object);
        }
      } else {
        console.log('üî¨ Vertex Engine deactivated');
        clearVertexHelpers();
      }
    }

    function analyzeObjectVertices(object) {
      if (!object || !object.geometry) {
        // Check if this is a group (like fullBodyGroup)
        if (object && object.children && object.children.length > 0) {
          console.log(`\nüî¨ GROUP ANALYSIS: ${object.name || 'Body Group'}`);
          console.log(`‚Üí Contains ${object.children.length} child objects`);
          
          let totalVertices = 0;
          const bodyParts = [];
          
          // Recursively count all vertices in hierarchy
          object.traverse((child) => {
            if (child.geometry) {
              const posAttr = child.geometry.getAttribute('position');
              if (posAttr) {
                const vCount = posAttr.count;
                totalVertices += vCount;
                bodyParts.push({
                  name: child.name || child.type || 'Unnamed',
                  vertices: vCount,
                  object: child
                });
              }
            }
          });
          
          console.log(`‚Üí Total Vertices in Body: ${totalVertices}`);
          console.log(`\nüìã BODY PARTS (Click individual bones to inspect):`);
          bodyParts.forEach(part => {
            console.log(`  ‚Ä¢ ${part.name}: ${part.vertices} vertices`);
          });
          
          // Update UI
          document.getElementById('vertexObjectName').textContent = `${object.name || 'Body'} (${bodyParts.length} parts)`;
          document.getElementById('vertexTotalCount').textContent = `${totalVertices} (across all bones)`;
          
          console.log(`\nüí° TIP: Click individual bones (femur, skull, ribs, etc.) to see their vertices!`);
          return;
        }
        
        console.warn('‚ö†Ô∏è No geometry found on this object');
        return;
      }

      const geometry = object.geometry;
      const positionAttribute = geometry.getAttribute('position');
      
      if (!positionAttribute) {
        console.warn('‚ö†Ô∏è No position attribute found');
        return;
      }

      const vertexCount = positionAttribute.count;
      
      // Update UI
      document.getElementById('vertexObjectName').textContent = object.name || object.type || 'Unnamed';
      document.getElementById('vertexTotalCount').textContent = vertexCount;
      
      console.log(`\nüî¨ VERTEX ANALYSIS:`);
      console.log(`‚Üí Object: ${object.name || object.type}`);
      console.log(`‚Üí Total Vertices: ${vertexCount}`);
      console.log(`‚Üí Position Buffer: Float32Array[${positionAttribute.array.length}]`);
      console.log(`‚Üí Format: [x, y, z] for each vertex`);
      
      // Show first 10 vertices as example
      console.log(`\nüìç First 10 Vertices (local coordinates):`);
      for (let i = 0; i < Math.min(10, vertexCount); i++) {
        const x = positionAttribute.getX(i).toFixed(3);
        const y = positionAttribute.getY(i).toFixed(3);
        const z = positionAttribute.getZ(i).toFixed(3);
        console.log(`  Vertex ${i}: (${x}, ${y}, ${z})`);
      }
      
      if (vertexCount > 10) {
        console.log(`  ... ${vertexCount - 10} more vertices`);
      }
      
      // Show vertex density info
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      const bbox = geometry.boundingBox;
      const size = new THREE.Vector3();
      bbox.getSize(size);
      const volume = size.x * size.y * size.z;
      const density = (vertexCount / volume).toFixed(2);
      
      console.log(`\nüìä MESH STATISTICS:`);
      console.log(`  ‚Ä¢ Bounding Box: ${size.x.toFixed(2)} √ó ${size.y.toFixed(2)} √ó ${size.z.toFixed(2)}`);
      console.log(`  ‚Ä¢ Vertex Density: ${density} vertices/unit¬≥`);
      console.log(`  ‚Ä¢ Triangle Count: ${vertexCount / 3} (approx)`);
    }

    function toggleVertexVisualization(show) {
      clearVertexHelpers();
      
      if (show) {
        // Check if we have a selected object with geometry
        if (transformControl.object && transformControl.object.geometry) {
          const object = transformControl.object;
          const geometry = object.geometry;
          const positionAttribute = geometry.getAttribute('position');
          const vertexCount = positionAttribute.count;
          
          console.log(`üî¨ Rendering ${vertexCount} vertex points for ${object.name || 'selected object'}...`);
          
          // Create a point for each vertex
          const pointsGeometry = new THREE.BufferGeometry();
          pointsGeometry.setAttribute('position', positionAttribute.clone());
          
          const pointsMaterial = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.1,
            sizeAttenuation: true
          });
          
          const points = new THREE.Points(pointsGeometry, pointsMaterial);
          points.name = 'VertexHelper_Points';
          
          // Match the object's transform
          points.position.copy(object.position);
          points.rotation.copy(object.rotation);
          points.scale.copy(object.scale);
          
          scene.add(points);
          vertexHelpers.push(points);
          
          console.log(`‚úÖ ${vertexCount} vertices visualized as cyan points`);
        }
        // Or visualize entire body if loaded
        else if (window.fullBodyGroup) {
          console.log(`üî¨ Rendering vertices for entire body...`);
          let totalPoints = 0;
          
          window.fullBodyGroup.traverse((child) => {
            if (child.geometry) {
              const posAttr = child.geometry.getAttribute('position');
              if (posAttr) {
                const pointsGeometry = new THREE.BufferGeometry();
                pointsGeometry.setAttribute('position', posAttr.clone());
                
                const pointsMaterial = new THREE.PointsMaterial({
                  color: 0x00ffff,
                  size: 0.08,
                  sizeAttenuation: true
                });
                
                const points = new THREE.Points(pointsGeometry, pointsMaterial);
                points.name = 'VertexHelper_Points';
                
                // Match the child's world transform
                points.position.copy(child.getWorldPosition(new THREE.Vector3()));
                points.rotation.copy(child.getWorldQuaternion(new THREE.Quaternion()));
                points.scale.copy(child.getWorldScale(new THREE.Vector3()));
                
                scene.add(points);
                vertexHelpers.push(points);
                totalPoints += posAttr.count;
              }
            }
          });
          
          console.log(`‚úÖ ${totalPoints} vertices visualized across all bones`);
        }
        else {
          alert('‚ö†Ô∏è Please load a body (üßç or üíÄ) or select an object first');
          document.getElementById('showVertexPoints').checked = false;
        }
      }
    }

    function toggleVertexNumbers(show) {
      // Clear existing labels
      const existingLabels = scene.children.filter(c => c.name === 'VertexLabel');
      existingLabels.forEach(label => scene.remove(label));
      
      if (show) {
        // Check if we have a selected object with geometry
        if (transformControl.object && transformControl.object.geometry) {
          const object = transformControl.object;
          const geometry = object.geometry;
          const positionAttribute = geometry.getAttribute('position');
          const vertexCount = positionAttribute.count;
          
          console.log(`üî¢ Adding labels for ${vertexCount} vertices on ${object.name || 'selected object'}...`);
          
          // Only show labels for first 100 vertices (performance)
          const maxLabels = Math.min(100, vertexCount);
          
          for (let i = 0; i < maxLabels; i++) {
            const x = positionAttribute.getX(i);
            const y = positionAttribute.getY(i);
            const z = positionAttribute.getZ(i);
            
            // Create text sprite
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 32;
            context.fillStyle = '#00ffff';
            context.font = 'Bold 20px Arial';
            context.fillText(i.toString(), 10, 24);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(0.2, 0.1, 1);
            sprite.name = 'VertexLabel';
            
            // Transform to world space
            sprite.position.applyMatrix4(object.matrixWorld);
            
            scene.add(sprite);
            vertexHelpers.push(sprite);
          }
          
          if (vertexCount > 100) {
            console.log(`‚ÑπÔ∏è Showing first 100 labels only (${vertexCount} total vertices)`);
          }
        }
        else if (window.fullBodyGroup) {
          console.log(`üî¢ Adding vertex labels to body (first 10 per bone)...`);
          let totalLabels = 0;
          
          window.fullBodyGroup.traverse((child) => {
            if (child.geometry) {
              const posAttr = child.geometry.getAttribute('position');
              if (posAttr && totalLabels < 100) { // Limit total labels
                const maxPerBone = Math.min(10, posAttr.count, 100 - totalLabels);
                
                for (let i = 0; i < maxPerBone; i++) {
                  const vec = new THREE.Vector3(
                    posAttr.getX(i),
                    posAttr.getY(i),
                    posAttr.getZ(i)
                  );
                  
                  // Transform to world space
                  vec.applyMatrix4(child.matrixWorld);
                  
                  const canvas = document.createElement('canvas');
                  const context = canvas.getContext('2d');
                  canvas.width = 64;
                  canvas.height = 32;
                  context.fillStyle = '#00ffff';
                  context.font = 'Bold 16px Arial';
                  context.fillText(i.toString(), 10, 24);
                  
                  const texture = new THREE.CanvasTexture(canvas);
                  const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                  const sprite = new THREE.Sprite(spriteMaterial);
                  sprite.position.copy(vec);
                  sprite.scale.set(0.15, 0.075, 1);
                  sprite.name = 'VertexLabel';
                  
                  scene.add(sprite);
                  vertexHelpers.push(sprite);
                  totalLabels++;
                }
              }
            }
          });
          
          console.log(`‚ÑπÔ∏è Showing ${totalLabels} vertex labels (limited for performance)`);
        }
        else {
          alert('‚ö†Ô∏è Please load a body (üßç or üíÄ) or select an object first');
          document.getElementById('showVertexNumbers').checked = false;
        }
      }
    }

    function toggleWireframe(show) {
      // Check if we have a selected object
      if (transformControl.object && transformControl.object.material) {
        const object = transformControl.object;
        
        if (Array.isArray(object.material)) {
          object.material.forEach(mat => mat.wireframe = show);
        } else {
          object.material.wireframe = show;
        }
        
        console.log(`üî≤ Wireframe: ${show ? 'ON' : 'OFF'} for ${object.name || 'selected object'}`);
      }
      // Or apply to entire body
      else if (window.fullBodyGroup) {
        let count = 0;
        window.fullBodyGroup.traverse((child) => {
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.wireframe = show);
            } else {
              child.material.wireframe = show;
            }
            count++;
          }
        });
        console.log(`üî≤ Wireframe: ${show ? 'ON' : 'OFF'} for ${count} body parts`);
      }
      else {
        alert('‚ö†Ô∏è Please load a body (üßç or üíÄ) or select an object first');
        document.getElementById('showWireframe').checked = false;
      }
    }

    function clearVertexHelpers() {
      vertexHelpers.forEach(helper => scene.remove(helper));
      vertexHelpers = [];
      
      // Clear labels
      const labels = scene.children.filter(c => c.name === 'VertexLabel');
      labels.forEach(label => scene.remove(label));
    }

    function updateVertexPosition() {
      if (!transformControl.object || selectedVertexIndex === null) {
        alert('‚ö†Ô∏è No vertex selected');
        return;
      }

      const object = transformControl.object;
      const geometry = object.geometry;
      const positionAttribute = geometry.getAttribute('position');
      
      const x = parseFloat(document.getElementById('vertexPosX').value);
      const y = parseFloat(document.getElementById('vertexPosY').value);
      const z = parseFloat(document.getElementById('vertexPosZ').value);
      
      positionAttribute.setXYZ(selectedVertexIndex, x, y, z);
      positionAttribute.needsUpdate = true;
      
      // Recompute normals for proper lighting
      geometry.computeVertexNormals();
      
      console.log(`‚úÖ Vertex ${selectedVertexIndex} moved to (${x}, ${y}, ${z})`);
    }

    function setSculptMode(mode) {
      sculptMode = mode;
      console.log(`üé® Sculpt mode: ${mode.toUpperCase()}`);
    }

    function updateBrushSize(value) {
      brushSize = parseFloat(value);
    }

    function updateSculptStrength(value) {
      sculptStrength = parseFloat(value);
    }

    function exportVertexData() {
      if (!transformControl.object || !transformControl.object.geometry) {
        alert('‚ö†Ô∏è Please select an object first');
        return;
      }

      const object = transformControl.object;
      const geometry = object.geometry;
      const positionAttribute = geometry.getAttribute('position');
      const vertexCount = positionAttribute.count;
      
      const vertices = [];
      for (let i = 0; i < vertexCount; i++) {
        vertices.push({
          index: i,
          x: positionAttribute.getX(i),
          y: positionAttribute.getY(i),
          z: positionAttribute.getZ(i)
        });
      }
      
      const data = {
        objectName: object.name || object.type || 'Unnamed',
        vertexCount: vertexCount,
        vertices: vertices,
        exportDate: new Date().toISOString()
      };
      
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${object.name || 'object'}_vertices.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      console.log(`üíæ Exported ${vertexCount} vertices to JSON`);
      
      // Show preview in UI
      const preview = document.getElementById('vertexInfoDisplay');
      preview.style.display = 'block';
      preview.textContent = json.substring(0, 1000) + '\n...\n(Download complete file)';
    }
    
    // Smart export - detects if body is loaded and exports entire hierarchy
    function smartExportVertices() {
      if (window.fullBodyGroup) {
        // Export entire body
        exportBodyVertexData();
      } else if (transformControl.object && transformControl.object.geometry) {
        // Export single object
        exportVertexData();
      } else {
        alert('‚ö†Ô∏è Please select an object or load a body first!');
      }
    }
    
    // ========================================
    // BODY-SPECIFIC VERTEX ANALYSIS
    // ========================================
    
    function analyzeFullBody() {
      if (!window.fullBodyGroup) {
        alert('‚ö†Ô∏è No full body loaded! Click üßç FULL BODY button first.');
        return;
      }
      
      console.log('\nüßç ===== FULL BODY VERTEX ANALYSIS =====');
      analyzeObjectVertices(window.fullBodyGroup);
      
      // Auto-enable vertex engine if not active
      if (!vertexEngineActive) {
        toggleVertexEngine();
      }
    }
    
    function analyzeSkeletonBody() {
      if (!window.fullBodyGroup) {
        alert('‚ö†Ô∏è No skeleton body loaded! Click üíÄ BONES BODY button first.');
        return;
      }
      
      console.log('\nüíÄ ===== SKELETON BODY VERTEX ANALYSIS =====');
      analyzeObjectVertices(window.fullBodyGroup);
      
      // Auto-enable vertex engine if not active
      if (!vertexEngineActive) {
        toggleVertexEngine();
      }
    }
    
    // Export entire body's vertex data (all bones)
    function exportBodyVertexData() {
      if (!window.fullBodyGroup) {
        alert('‚ö†Ô∏è No body loaded!');
        return;
      }
      
      const bodyParts = [];
      let totalVertices = 0;
      
      window.fullBodyGroup.traverse((child) => {
        if (child.geometry) {
          const posAttr = child.geometry.getAttribute('position');
          if (posAttr) {
            const vertices = [];
            for (let i = 0; i < posAttr.count; i++) {
              vertices.push({
                index: i,
                x: posAttr.getX(i),
                y: posAttr.getY(i),
                z: posAttr.getZ(i)
              });
            }
            
            bodyParts.push({
              name: child.name || child.type || 'Unnamed',
              vertexCount: posAttr.count,
              vertices: vertices,
              position: {
                x: child.position.x,
                y: child.position.y,
                z: child.position.z
              },
              rotation: {
                x: child.rotation.x,
                y: child.rotation.y,
                z: child.rotation.z
              }
            });
            
            totalVertices += posAttr.count;
          }
        }
      });
      
      const data = {
        bodyName: window.fullBodyGroup.name || 'Full Body',
        totalVertices: totalVertices,
        bodyPartCount: bodyParts.length,
        bodyParts: bodyParts,
        exportDate: new Date().toISOString()
      };
      
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `full_body_vertices_${totalVertices}V.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      console.log(`üíæ Exported entire body: ${totalVertices} vertices across ${bodyParts.length} bones`);
    }

    // ========================================
    // END VERTEX ENGINE
    // ========================================

    function clearScene() {
      if (confirm('Clear all objects?')) {
        objects.forEach(obj => scene.remove(obj));
        objects = [];
        updateObjectCount();
      }
    }

    function switchWorkspace(workspace, btn) {
      // Update tab UI
      document.querySelectorAll('.workspace-tab').forEach(tab => tab.classList.remove('active'));
      btn.classList.add('active');

      // Hide all workspace content
      document.querySelectorAll('.workspace-content').forEach(content => {
        content.style.display = 'none';
      });

      // Show selected workspace
      const workspaceElement = document.getElementById(`workspace-${workspace}`);
      if (workspaceElement) {
        workspaceElement.style.display = 'block';
      }

      // Update display
      const workspaceNames = {
        'sculpt': '3D SCULPT',
        'css': 'CSS DESIGNER',
        'word': 'WORDWEAVER',
        'campus': 'CAMPUS',
        'perfect': 'PERFECT'
      };
      document.getElementById('workspaceDisplay').textContent = workspaceNames[workspace] || workspace.toUpperCase();
      
      console.log('Switched to:', workspace);
    }

    // =====================================
    // üåå DIMENSIONAL SWITCHING UI
    // =====================================
    
    /**
     * Switch dimension with UI updates (wrapper for switchDimension)
     */
    function switchDimensionUI(dimensionKey, buttonElement) {
      // Call the core dimension switching function
      if (typeof switchDimension === 'function') {
        switchDimension(dimensionKey);
        
        // Update button highlighting
        document.querySelectorAll('.workspace-tab').forEach(tab => {
          tab.classList.remove('active');
          tab.style.background = 'rgba(255, 255, 255, 0.1)';
          tab.style.borderBottom = 'none';
        });
        
        if (buttonElement) {
          buttonElement.classList.add('active');
          buttonElement.style.background = 'rgba(255, 255, 255, 0.3)';
          buttonElement.style.borderBottom = '3px solid #fff';
        }
        
        // Update dimension display
        const displayNames = {
          'skyrelics': 'üè∞ SkyRelics Universe',
          'wordweaver': '‚úçÔ∏è WordWeaver Studio',
          'anatomy': 'ü¶¥ Anatomical Explorer',
          'perfect': '‚ú® Perfect Universe'
        };
        
        const displayElement = document.getElementById('current-dimension-display');
        if (displayElement) {
          displayElement.textContent = displayNames[dimensionKey] || dimensionKey;
        }
        
        // Show dimension notification
        showDimensionNotification(dimensionKey);
        
        console.log(`üåÄ UI: Switched to ${dimensionKey} dimension`);
      } else {
        console.error('‚ùå switchDimension function not available yet. Dimensions will be ready after init.');
      }
    }
    
    /**
     * Show dimension switch notification
     */
    function showDimensionNotification(dimensionKey) {
      const notifications = {
        'skyrelics': 'üè∞ Entered SkyRelics Universe - Create primitives & Sky Relics',
        'wordweaver': '‚úçÔ∏è Entered WordWeaver Studio - Materialize 3D text',
        'anatomy': 'ü¶¥ Entered Anatomical Explorer - Explore human anatomy',
        'perfect': '‚ú® Entered Perfect Universe - Build perfect worlds'
      };
      
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 30px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        z-index: 10000;
        animation: slideDown 0.3s ease-out;
      `;
      notification.textContent = notifications[dimensionKey] || `Switched to ${dimensionKey}`;
      
      document.body.appendChild(notification);
      
      // Remove after 2 seconds
      setTimeout(() => {
        notification.style.animation = 'slideUp 0.3s ease-out';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 2000);
    }
    
    // Add CSS animations for notifications
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }
      
      @keyframes slideUp {
        from {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
        to {
          opacity: 0;
          transform: translateX(-50%) translateY(-20px);
        }
      }
    `;
    document.head.appendChild(style);

    function updateObjectCount() {
      document.getElementById('objectCount').textContent = objects.length;
    }

    function updateVertexCount() {
      let totalVertices = 0;
      objects.forEach(obj => {
        obj.traverse((child) => {
          if (child.geometry) {
            const positions = child.geometry.attributes.position;
            if (positions) {
              totalVertices += positions.count;
            }
          }
        });
      });
      document.getElementById('vertexCount').textContent = totalVertices;
      console.log(`üìä Total vertices in scene: ${totalVertices}`);
    }

    // =============================================
    // MATHEMATICIAN TRIBUTE SYSTEM
    // =============================================

    let learnModeActive = false;
    let currentMethod = 'fibonacci';

    const MATHEMATICIANS = {
      fibonacci: {
        name: "Leonardo Fibonacci",
        born: 1170,
        died: 1250,
        flag: "üáÆüáπ",
        nationality: "Italian",
        discovery: "Fibonacci Sequence",
        story: "Italian mathematician who discovered the famous sequence (0,1,1,2,3,5,8...) while studying rabbit populations. Each number is the sum of the two before it! This sequence appears everywhere in nature: sunflower spirals, pinecones, nautilus shells.",
        kidFact: "He introduced Arabic numerals (0-9) to Europe! Before him, Europeans used Roman numerals (I, II, III, IV...) which made math really hard."
      },
      catmull: {
        name: "Edwin Catmull",
        born: 1945,
        died: null,
        flag: "üá∫üá∏",
        nationality: "American",
        discovery: "Catmull-Rom Splines & Subdivision",
        story: "Co-founder of Pixar! Created smooth curve algorithms while dreaming of making the first computer-animated movie. His math makes characters move smoothly and naturally.",
        kidFact: "He won an Oscar for his technology! Every Pixar movie (Toy Story, Finding Nemo, The Incredibles) uses his math to make characters move smoothly."
      },
      bezier: {
        name: "Pierre B√©zier",
        born: 1910,
        died: 1999,
        flag: "üá´üá∑",
        nationality: "French",
        discovery: "B√©zier Curves",
        story: "Renault car designer who invented curves you can control with just a few points. Used in fonts, animations, car design, and every vector graphic you see!",
        kidFact: "Every letter you're reading right now uses B√©zier curves! Computer fonts are made entirely of his curves. Even emojis! üòä"
      },
      perlin: {
        name: "Ken Perlin",
        born: 1951,
        died: null,
        flag: "üéÆ",
        nationality: "American",
        discovery: "Perlin Noise",
        story: "NYU professor who created natural-looking randomness for the movie TRON (1982). Won an Oscar for making computer graphics look organic instead of artificial!",
        kidFact: "Minecraft's entire world generation uses Perlin noise! Every mountain, cave, and biome is created with his algorithm. Without it, Minecraft wouldn't exist!"
      },
      quaternion: {
        name: "William Hamilton",
        born: 1805,
        died: 1865,
        flag: "üáÆüá™",
        nationality: "Irish",
        discovery: "Quaternions",
        story: "Had a 'eureka moment' while walking across Brougham Bridge in Dublin. He was so excited he carved the formula (i¬≤=j¬≤=k¬≤=ijk=-1) into the bridge stone with his knife!",
        kidFact: "Every 3D video game character rotation uses quaternions! They prevent 'gimbal lock' - a glitch that made old games spin weirdly. Your character wouldn't turn smoothly without them!"
      },
      lsystem: {
        name: "Aristid Lindenmayer",
        born: 1925,
        died: 1989,
        flag: "üá≠üá∫",
        nationality: "Hungarian",
        discovery: "L-Systems (Lindenmayer Systems)",
        story: "Biologist and botanist who created a simple alphabet system to model how plants grow. Simple rules like 'A becomes AB, B becomes A' create complex fractal patterns that look like real plants!",
        kidFact: "Video game trees and plants are grown with L-Systems! One simple rule repeated over and over can create an entire realistic forest. It's like growing a digital plant from a seed!"
      },
      voronoi: {
        name: "Georgy Voronoi",
        born: 1868,
        died: 1908,
        flag: "üá∫üá¶",
        nationality: "Ukrainian",
        discovery: "Voronoi Diagrams",
        story: "Mathematician who figured out how to divide space based on nearest neighbors. Imagine drawing territories around each point where everything inside is closer to that point than any other!",
        kidFact: "Giraffe spots follow Voronoi patterns! Nature uses this math for animal patterns, cell structures, and crystal growth. Your body's cells organize using Voronoi math!"
      },
      phong: {
        name: "Bui Tuong Phong",
        born: 1942,
        died: 1975,
        flag: "üáªüá≥",
        nationality: "Vietnamese",
        discovery: "Phong Shading",
        story: "Created the lighting model that made 3D objects look shiny and realistic. His PhD thesis at University of Utah changed computer graphics forever. Tragically died of leukemia at age 32, but his legacy lives in every 3D game.",
        kidFact: "Every shiny surface in 3D games uses Phong shading! He made plastic, metal, and glass look real on computers. When you see light reflecting off a character's armor - that's his math!"
      },
      delaunay: {
        name: "Boris Delaunay",
        born: 1890,
        died: 1980,
        flag: "üá∑üá∫",
        nationality: "Russian",
        discovery: "Delaunay Triangulation",
        story: "Russian mathematician who figured out the optimal way to connect dots with triangles. His method creates the 'fattest' triangles possible, avoiding skinny ones that cause problems in 3D graphics.",
        kidFact: "3D game terrain is built with Delaunay triangles! Mountains, valleys, and landscapes are made by connecting height points with his optimal triangles. Every open-world game uses this!"
      },
      subdivision: {
        name: "Jim Clark & Edwin Catmull",
        born: 1944,
        died: null,
        flag: "üíé",
        nationality: "American",
        discovery: "Subdivision Surfaces",
        story: "Jim Clark founded Silicon Graphics (the company that made movie CGI possible) and Netscape (early web browser). With Catmull, they figured out how to make blocky shapes smooth by subdividing faces repeatedly.",
        kidFact: "Every smooth 3D character starts blocky! Artists model a simple cube-like shape, then subdivision turns it into a smooth character. It's like magic - a cube becomes a smooth head!"
      }
    };

    function toggleLearnMode(btn) {
      learnModeActive = !learnModeActive;
      const info = document.getElementById('learnModeInfo');
      
      if (learnModeActive) {
        btn.innerHTML = '<span class="tool-icon">üéì</span><span>Learn Mode ON</span>';
        btn.style.background = 'rgba(0, 255, 136, 0.3)';
        btn.style.borderColor = '#00ff88';
        info.style.display = 'block';
        
        // Show initial method story
        showMathematicianStory(currentMethod);
        
        console.log(`
üìö ============================================
   LEARN MODE ACTIVATED!
   
   Now when you select Mathematical Methods,
   you'll see the mathematician's story, their
   discovery, and how it powers your creations!
   
   Click any method below to learn! üèÜ
============================================
        `);
      } else {
        btn.innerHTML = '<span class="tool-icon">üë®‚Äçüè´</span><span>Enable Story Mode</span>';
        btn.style.background = 'rgba(0, 255, 136, 0.1)';
        btn.style.borderColor = 'rgba(0, 255, 136, 0.3)';
        info.style.display = 'none';
        document.getElementById('mathematicianStory').style.display = 'none';
      }
    }

    function selectMethod(method, btn) {
      currentMethod = method;
      
      // Update active button
      btn.parentElement.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Show story if Learn Mode is active
      if (learnModeActive) {
        showMathematicianStory(method);
      }
      
      // Log to console
      const mathematician = MATHEMATICIANS[method];
      console.log(`
üèÜ ============================================
   METHOD SELECTED: ${mathematician.discovery}
   Mathematician: ${mathematician.name} (${mathematician.born}-${mathematician.died || 'Present'})
   ${mathematician.flag} ${mathematician.nationality}
   
   üìñ Story: ${mathematician.story}
   
   üí° Kid Fact: ${mathematician.kidFact}
============================================
      `);
    }

    function showMathematicianStory(method) {
      const mathematician = MATHEMATICIANS[method];
      const panel = document.getElementById('mathematicianStory');
      
      // Update story content
      document.getElementById('storyTitle').textContent = `üèÜ ${mathematician.discovery}`;
      document.getElementById('storyFlag').textContent = mathematician.flag;
      document.getElementById('storyName').textContent = mathematician.name;
      document.getElementById('storyDates').textContent = `${mathematician.born}-${mathematician.died || 'Present'} ‚Ä¢ ${mathematician.nationality}`;
      document.getElementById('storyDiscovery').textContent = `Discovery: ${mathematician.discovery}`;
      document.getElementById('storyText').textContent = mathematician.story;
      document.getElementById('storyKidFact').textContent = mathematician.kidFact;
      
      // Show panel with smooth animation
      panel.style.display = 'block';
    }

    // ========================================
    // WORDWEAVER 3D DOCUMENT CANVAS
    // ========================================
    
    let documentCanvas;
    let currentDocumentMode = 'blog'; // 'blog' or 'pdf'
    
    // Initialize Document Canvas after scene is ready
    function initDocumentCanvas() {
      console.log('üîÑ Initializing WordWeaver Document Canvas...');
      
      if (typeof scene === 'undefined' || typeof camera === 'undefined') {
        console.warn('‚ö†Ô∏è Scene or camera not ready, retrying in 500ms...');
        setTimeout(initDocumentCanvas, 500);
        return;
      }
      
      if (typeof Document3DCanvas === 'undefined') {
        console.error('‚ùå Document3DCanvas class not loaded!');
        alert('Error: Document3DCanvas class not found. Please check document3d_canvas.js is loaded.');
        return;
      }
      
      try {
        documentCanvas = new Document3DCanvas(scene, camera);
        console.log('‚úÖ WordWeaver Document Canvas initialized!');
        
        // Set default settings
        documentCanvas.setShape('linear');
        documentCanvas.setMaterial('biblical');
        documentCanvas.setFont('helvetiker');
        
        // Update first shape button to active
        const firstShape = document.querySelector('.shape-selector[data-shape="linear"]');
        if (firstShape) {
          firstShape.style.background = 'rgba(102, 126, 234, 0.3)';
          firstShape.style.borderColor = 'rgba(102, 126, 234, 0.5)';
          firstShape.style.color = '#fff';
        }
        
        // Update first material button to active
        const firstMaterial = document.querySelector('.material-selector[data-material="biblical"]');
        if (firstMaterial) {
          firstMaterial.style.background = 'rgba(212, 165, 116, 0.3)';
          firstMaterial.style.borderColor = 'rgba(212, 165, 116, 0.5)';
          firstMaterial.style.color = '#fff';
        }
        
        // Update first font button to active
        const firstFont = document.querySelector('.font-selector[data-font="helvetiker"]');
        if (firstFont) {
          firstFont.style.background = 'rgba(102, 126, 234, 0.3)';
          firstFont.style.borderColor = 'rgba(102, 126, 234, 0.5)';
          firstFont.style.color = '#fff';
        }
      } catch (error) {
        console.error('‚ùå Error initializing Document Canvas:', error);
        alert('Error initializing WordWeaver: ' + error.message);
      }
    }
    
    // Switch between Blog and PDF document modes
    function selectDocumentMode(mode) {
      currentDocumentMode = mode;
      
      const blogFields = document.getElementById('blog-mode-fields');
      const pdfFields = document.getElementById('pdf-mode-fields');
      const blogBtn = document.getElementById('doc-mode-blog');
      const pdfBtn = document.getElementById('doc-mode-pdf');
      
      if (mode === 'blog') {
        blogFields.style.display = 'block';
        pdfFields.style.display = 'none';
        blogBtn.style.background = 'rgba(102, 126, 234, 0.3)';
        blogBtn.style.borderColor = 'rgba(102, 126, 234, 0.5)';
        pdfBtn.style.background = 'rgba(102, 126, 234, 0.1)';
        pdfBtn.style.borderColor = 'rgba(102, 126, 234, 0.3)';
      } else {
        blogFields.style.display = 'none';
        pdfFields.style.display = 'block';
        pdfBtn.style.background = 'rgba(102, 126, 234, 0.3)';
        pdfBtn.style.borderColor = 'rgba(102, 126, 234, 0.5)';
        blogBtn.style.background = 'rgba(102, 126, 234, 0.1)';
        blogBtn.style.borderColor = 'rgba(102, 126, 234, 0.3)';
      }
    }
    
    // Materialize document based on current mode
    function materializeDocument() {
      if (!documentCanvas) {
        alert('Document Canvas not ready yet. Please wait...');
        return;
      }
      
      if (currentDocumentMode === 'blog') {
        // Blog mode - materialize from center, expand into paragraph format
        const title = document.getElementById('blog-title').value;
        const content = document.getElementById('blog-content').value;
        
        if (!title && !content) {
          alert('Please enter a title and content for your blog post!');
          return;
        }
        
        // Clear previous content
        documentCanvas.clearDocument();
        
        // Materialize title from center
        if (title) {
          documentCanvas.materializeTitle(title);
        }
        
        // Split content into paragraphs and materialize each
        if (content) {
          const paragraphs = content.split('\n\n').filter(p => p.trim().length > 0);
          paragraphs.forEach((paragraph, index) => {
            setTimeout(() => {
              documentCanvas.materializeParagraph(paragraph.trim(), index);
            }, 500 + (index * 300)); // Stagger paragraph materialization
          });
        }
        
        updateWordCount();
        
      } else {
        // PDF mode - materialize with header section
        const name = document.getElementById('pdf-name').value;
        const city = document.getElementById('pdf-city').value;
        const state = document.getElementById('pdf-state').value;
        const zip = document.getElementById('pdf-zip').value;
        const title = document.getElementById('pdf-title').value;
        const paragraph = document.getElementById('pdf-paragraph').value;
        
        if (!title && !paragraph) {
          alert('Please enter a title and paragraph content!');
          return;
        }
        
        // Materialize header if provided
        if (name || city || state || zip) {
          const headerData = {
            name: name || 'Your Name',
            city: city || 'City',
            state: state || 'ST',
            zipCode: zip || '00000'
          };
          documentCanvas.materializeHeader(headerData);
          
          setTimeout(() => {
            if (title) documentCanvas.materializeTitle(title);
          }, 300);
          
          setTimeout(() => {
            if (paragraph) {
              const paragraphIndex = documentCanvas.document.paragraphs.length;
              documentCanvas.materializeParagraph(paragraph, paragraphIndex);
              document.getElementById('pdf-paragraph').value = ''; // Clear input
            }
          }, 600);
        } else {
          // No header, just title and paragraph
          if (title) documentCanvas.materializeTitle(title);
          setTimeout(() => {
            if (paragraph) {
              const paragraphIndex = documentCanvas.document.paragraphs.length;
              documentCanvas.materializeParagraph(paragraph, paragraphIndex);
              document.getElementById('pdf-paragraph').value = '';
            }
          }, 300);
        }
        
        updateWordCount();
      }
    }
    
    // Shape selection
    function selectDocShape(shapeName) {
      if (!documentCanvas) return;
      
      documentCanvas.setShape(shapeName);
      
      // Update UI
      document.querySelectorAll('.shape-selector').forEach(btn => {
        if (btn.dataset.shape === shapeName) {
          btn.style.background = 'rgba(102, 126, 234, 0.3)';
          btn.style.borderColor = 'rgba(102, 126, 234, 0.5)';
          btn.style.color = '#fff';
        } else {
          btn.style.background = 'rgba(102, 126, 234, 0.1)';
          btn.style.borderColor = 'rgba(102, 126, 234, 0.3)';
          btn.style.color = '#667eea';
        }
      });
    }
    
    // Global flag for matrix correlation
    let matrixCorrelationEnabled = true;
    
    // Material selection with auto-correlation
    function selectDocMaterial(materialName) {
      if (!documentCanvas) return;
      
      // Check if auto-correlation is enabled
      const autoCorrelate = document.getElementById('enable-matrix-correlation')?.checked !== false;
      
      if (autoCorrelate && matrixCorrelationEnabled) {
        // Use material-to-matrix correlation system
        const mapping = documentCanvas.setMaterialWithMatrixCorrelation(materialName);
        
        // Update correlation info display
        if (mapping) {
          const modeIcons = {
            paperback: 'üìÑ',
            magnetic: 'üß≤',
            holographic: 'üîÆ'
          };
          const modeNames = {
            paperback: 'Solid Grid',
            magnetic: 'Magnetic Field',
            holographic: 'Holographic Projector'
          };
          
          const infoElement = document.getElementById('material-correlation-info');
          if (infoElement) {
            const materialIcons = {
              biblical: 'üìñ',
              chrome: '‚öôÔ∏è',
              holographic: '‚ú®',
              metallic: 'üîß',
              glass: 'üîÆ',
              magnetic: 'üß≤',
              matte: 'üé®',
              rubber: 'üîò'
            };
            
            infoElement.innerHTML = `
              ${materialIcons[materialName] || '‚ú®'} ${materialName.toUpperCase()} ‚Üí 
              ${modeIcons[mapping.mode]} ${modeNames[mapping.mode]} 
              <span style="opacity: 0.6;">(${mapping.intensity}x intensity)</span><br>
              <span style="opacity: 0.7;">${mapping.description}</span>
            `;
            
            // Flash animation
            infoElement.style.background = 'rgba(102, 126, 234, 0.3)';
            setTimeout(() => {
              infoElement.style.transition = 'background 0.5s';
              infoElement.style.background = 'rgba(102, 126, 234, 0.1)';
            }, 100);
          }
        }
      } else {
        // Standard material change without correlation
        documentCanvas.setMaterial(materialName);
      }
      
      // Update UI button styling
      document.querySelectorAll('.material-selector').forEach(btn => {
        if (btn.dataset.material === materialName) {
          const colors = {
            biblical: { bg: 'rgba(212, 165, 116, 0.3)', border: 'rgba(212, 165, 116, 0.5)' },
            chrome: { bg: 'rgba(224, 224, 224, 0.3)', border: 'rgba(224, 224, 224, 0.5)' },
            holographic: { bg: 'rgba(102, 126, 234, 0.3)', border: 'rgba(102, 126, 234, 0.5)' },
            metallic: { bg: 'rgba(102, 126, 234, 0.3)', border: 'rgba(102, 126, 234, 0.5)' },
            glass: { bg: 'rgba(102, 126, 234, 0.3)', border: 'rgba(102, 126, 234, 0.5)' },
            magnetic: { bg: 'rgba(0, 255, 255, 0.3)', border: 'rgba(0, 255, 255, 0.5)' },
            matte: { bg: 'rgba(102, 126, 234, 0.3)', border: 'rgba(102, 126, 234, 0.5)' },
            rubber: { bg: 'rgba(102, 126, 234, 0.3)', border: 'rgba(102, 126, 234, 0.5)' }
          };
          btn.style.background = colors[materialName]?.bg || 'rgba(102, 126, 234, 0.3)';
          btn.style.borderColor = colors[materialName]?.border || 'rgba(102, 126, 234, 0.5)';
          btn.style.color = '#fff';
        } else {
          const inactiveColors = {
            biblical: { bg: 'rgba(212, 165, 116, 0.1)', border: 'rgba(212, 165, 116, 0.3)' },
            chrome: { bg: 'rgba(224, 224, 224, 0.1)', border: 'rgba(224, 224, 224, 0.3)' },
            holographic: { bg: 'rgba(102, 126, 234, 0.1)', border: 'rgba(102, 126, 234, 0.3)' },
            metallic: { bg: 'rgba(102, 126, 234, 0.1)', border: 'rgba(102, 126, 234, 0.3)' },
            glass: { bg: 'rgba(102, 126, 234, 0.1)', border: 'rgba(102, 126, 234, 0.3)' },
            magnetic: { bg: 'rgba(0, 255, 255, 0.1)', border: 'rgba(0, 255, 255, 0.3)' },
            matte: { bg: 'rgba(102, 126, 234, 0.1)', border: 'rgba(102, 126, 234, 0.3)' },
            rubber: { bg: 'rgba(102, 126, 234, 0.1)', border: 'rgba(102, 126, 234, 0.3)' }
          };
          const mat = btn.dataset.material;
          const inactive = inactiveColors[mat] || { bg: 'rgba(102, 126, 234, 0.1)', border: 'rgba(102, 126, 234, 0.3)' };
          btn.style.background = inactive.bg;
          btn.style.borderColor = inactive.border;
          btn.style.color = mat === 'biblical' ? '#d4a574' : (mat === 'chrome' ? '#e0e0e0' : '#667eea');
        }
      });
    }
    
    // Toggle matrix correlation
    function toggleMatrixCorrelation() {
      matrixCorrelationEnabled = document.getElementById('enable-matrix-correlation').checked;
      console.log(`üîÑ Matrix correlation: ${matrixCorrelationEnabled ? 'ENABLED' : 'DISABLED'}`);
      
      const infoElement = document.getElementById('material-correlation-info');
      if (infoElement) {
        if (matrixCorrelationEnabled) {
          infoElement.style.opacity = '1';
        } else {
          infoElement.style.opacity = '0.3';
          infoElement.innerHTML = 'üîÑ Auto-correlation disabled - Manual matrix control';
        }
      }
    }
    
    // Color picker
    function updateDocColor(color) {
      if (!documentCanvas) return;
      documentCanvas.setColor(color);
    }
    
    // Font selection
    function selectDocFont(fontName) {
      if (!documentCanvas) return;
      
      documentCanvas.setFont(fontName);
      
      // Update UI
      document.querySelectorAll('.font-selector').forEach(btn => {
        if (btn.dataset.font === fontName) {
          btn.style.background = 'rgba(102, 126, 234, 0.3)';
          btn.style.borderColor = 'rgba(102, 126, 234, 0.5)';
          btn.style.color = '#fff';
        } else {
          btn.style.background = 'rgba(102, 126, 234, 0.1)';
          btn.style.borderColor = 'rgba(102, 126, 234, 0.3)';
          btn.style.color = '#667eea';
        }
      });
    }
    
    // Export document
    function exportDocument() {
      if (!documentCanvas) return;
      
      const pdfData = documentCanvas.exportToPDF();
      const mode = currentDocumentMode === 'blog' ? 'Blog Post' : 'PDF Document';
      alert(`${mode} exported! Check your downloads folder.`);
    }
    
    // Clear document
    function clearDocument() {
      if (!documentCanvas) return;
      
      if (confirm('Clear entire 3D document? This cannot be undone.')) {
        documentCanvas.clearDocument();
        
        // Clear inputs based on mode
        if (currentDocumentMode === 'blog') {
          document.getElementById('blog-title').value = '';
          document.getElementById('blog-content').value = '';
        } else {
          document.getElementById('pdf-name').value = '';
          document.getElementById('pdf-city').value = '';
          document.getElementById('pdf-state').value = '';
          document.getElementById('pdf-zip').value = '';
          document.getElementById('pdf-title').value = '';
          document.getElementById('pdf-paragraph').value = '';
        }
        
        updateWordCount();
      }
    }
    
    // Update word count display
    function updateWordCount() {
      if (!documentCanvas) return;
      const count = documentCanvas.getTotalWordCount();
      document.getElementById('doc-word-count').textContent = count;
    }

    // ========================================
    // ADVANCED WORDWEAVER CONTROLS
    // ========================================
    
    // Document Templates
    const documentTemplates = {
      essay: {
        title: "Essay Title Here",
        content: "Introduction paragraph explaining the main topic and thesis statement.\n\nBody paragraph one with supporting evidence and analysis.\n\nBody paragraph two with additional points and examples.\n\nConclusion summarizing the key arguments and final thoughts."
      },
      letter: {
        header: { name: "Your Name", city: "Your City", state: "ST", zipCode: "12345" },
        title: "Formal Letter",
        content: "Dear Recipient,\n\nI am writing to you regarding [subject]. This letter serves to formally communicate my thoughts and intentions.\n\nThank you for your time and consideration.\n\nSincerely,\nYour Name"
      },
      report: {
        title: "Report Title",
        content: "Executive Summary:\nBrief overview of findings and recommendations.\n\nIntroduction:\nBackground and purpose of this report.\n\nFindings:\nDetailed analysis and data presentation.\n\nConclusions:\nKey takeaways and recommendations."
      },
      poem: {
        title: "Untitled Poem",
        content: "Roses are red,\nViolets are blue,\n3D letters materialize,\nIn this WordWeaver view.\n\nWords dance and spiral,\nIn three-dimensional space,\nCreating art from language,\nWith elegance and grace."
      },
      resume: {
        header: { name: "Your Name", city: "City", state: "State", zipCode: "Zip" },
        title: "Professional Resume",
        content: "EXPERIENCE:\nJob Title | Company Name | 2020-Present\n- Achievement one\n- Achievement two\n\nEDUCATION:\nDegree | University | Year\n\nSKILLS:\n3D Design, Creative Writing, Technical Communication"
      },
      script: {
        title: "Scene Title",
        content: "INT. WORDWEAVER STUDIO - DAY\n\nThe letters materialize one by one, floating in 3D space.\n\nNARRATOR\n(V.O.)\nIn a world where words become art...\n\nFADE IN: The text transforms, dancing through the digital realm."
      }
    };
    
    function loadDocTemplate(templateName) {
      const template = documentTemplates[templateName];
      if (!template) return;
      
      if (currentDocumentMode === 'blog') {
        document.getElementById('blog-title').value = template.title || '';
        document.getElementById('blog-content').value = template.content || '';
      } else {
        if (template.header) {
          document.getElementById('pdf-name').value = template.header.name || '';
          document.getElementById('pdf-city').value = template.header.city || '';
          document.getElementById('pdf-state').value = template.header.state || '';
          document.getElementById('pdf-zip').value = template.header.zipCode || '';
        }
        document.getElementById('pdf-title').value = template.title || '';
        document.getElementById('pdf-paragraph').value = template.content || '';
      }
      
      alert(`üìÑ Loaded ${templateName} template!`);
    }
    
    // Text Formatting Controls
    function selectFontWeight(weight) {
      if (!documentCanvas) return;
      documentCanvas.setFontWeight(weight);
      
      document.querySelectorAll('.weight-selector').forEach(btn => {
        if (btn.dataset.weight === weight) {
          btn.style.background = 'rgba(102, 126, 234, 0.3)';
          btn.style.borderColor = 'rgba(102, 126, 234, 0.5)';
          btn.style.color = '#fff';
        } else {
          btn.style.background = 'rgba(102, 126, 234, 0.1)';
          btn.style.borderColor = 'rgba(102, 126, 234, 0.3)';
          btn.style.color = '#667eea';
        }
      });
    }
    
    function toggleTextDecoration(style) {
      if (!documentCanvas) return;
      documentCanvas.setTextDecoration(style);
      
      document.querySelectorAll('.style-selector').forEach(btn => {
        if (btn.dataset.style === style) {
          btn.style.background = 'rgba(102, 126, 234, 0.3)';
          btn.style.borderColor = 'rgba(102, 126, 234, 0.5)';
          btn.style.color = '#fff';
        } else {
          btn.style.background = 'rgba(102, 126, 234, 0.1)';
          btn.style.borderColor = 'rgba(102, 126, 234, 0.3)';
          btn.style.color = '#667eea';
        }
      });
    }
    
    function updateLetterSize(value) {
      if (documentCanvas) documentCanvas.setLetterSize(parseFloat(value));
      document.getElementById('letter-size-value').textContent = value;
    }
    
    function updateLetterSpacing(value) {
      if (documentCanvas) documentCanvas.setLetterSpacing(parseFloat(value));
      document.getElementById('letter-spacing-value').textContent = value;
    }
    
    function updateExtrusionDepth(value) {
      if (documentCanvas) documentCanvas.setExtrusionDepth(parseFloat(value));
      document.getElementById('extrusion-depth-value').textContent = value;
    }
    
    // Word Placement Controls
    function selectAlignment(align) {
      if (!documentCanvas) return;
      documentCanvas.setAlignment(align);
      
      document.querySelectorAll('.align-selector').forEach(btn => {
        if (btn.dataset.align === align) {
          btn.style.background = 'rgba(102, 126, 234, 0.3)';
          btn.style.borderColor = 'rgba(102, 126, 234, 0.5)';
          btn.style.color = '#fff';
        } else {
          btn.style.background = 'rgba(102, 126, 234, 0.1)';
          btn.style.borderColor = 'rgba(102, 126, 234, 0.3)';
          btn.style.color = '#667eea';
        }
      });
    }
    
    function updateLineSpacing(value) {
      if (documentCanvas) documentCanvas.setLineSpacing(parseFloat(value));
      document.getElementById('line-spacing-value').textContent = value;
    }
    
    function updateWordsPerLine(value) {
      if (documentCanvas) documentCanvas.setWordsPerLine(parseInt(value));
      document.getElementById('words-per-line-value').textContent = value;
    }
    
    // Save & Load System
    function saveDocument() {
      if (!documentCanvas) return;
      
      const docName = document.getElementById('doc-save-name').value || `Document_${Date.now()}`;
      const docData = {
        name: docName,
        mode: currentDocumentMode,
        document: documentCanvas.document,
        settings: {
          shape: documentCanvas.currentShape,
          material: documentCanvas.currentMaterial,
          font: documentCanvas.currentFont,
          color: documentCanvas.currentColor,
          letterSize: documentCanvas.letterSize || 0.4,
          letterSpacing: documentCanvas.letterSpacing || 0.6,
          extrusionDepth: documentCanvas.extrusionDepth || 0.15
        },
        timestamp: new Date().toISOString()
      };
      
      // Save to localStorage
      const savedDocs = JSON.parse(localStorage.getItem('wordweaver_documents') || '[]');
      savedDocs.push(docData);
      localStorage.setItem('wordweaver_documents', JSON.stringify(savedDocs));
      
      refreshSavedDocsList();
      alert(`üíæ Document "${docName}" saved successfully!`);
    }
    
    function showLoadDialog() {
      const savedDocs = JSON.parse(localStorage.getItem('wordweaver_documents') || '[]');
      if (savedDocs.length === 0) {
        alert('No saved documents found!');
        return;
      }
      
      refreshSavedDocsList();
      alert('üìÇ Scroll down to "Saved Documents" section to load a document.');
    }
    
    function loadSavedDocument(index) {
      const savedDocs = JSON.parse(localStorage.getItem('wordweaver_documents') || '[]');
      const doc = savedDocs[index];
      
      if (!doc) return;
      
      // Clear current document
      clearDocument();
      
      // Load document data
      documentCanvas.document = doc.document;
      
      // Restore settings
      if (doc.settings) {
        documentCanvas.setShape(doc.settings.shape);
        documentCanvas.setMaterial(doc.settings.material);
        documentCanvas.setFont(doc.settings.font);
        documentCanvas.setColor(doc.settings.color);
        if (doc.settings.letterSize) documentCanvas.setLetterSize(doc.settings.letterSize);
        if (doc.settings.letterSpacing) documentCanvas.setLetterSpacing(doc.settings.letterSpacing);
        if (doc.settings.extrusionDepth) documentCanvas.setExtrusionDepth(doc.settings.extrusionDepth);
      }
      
      // Re-materialize the document
      if (doc.document.title) {
        documentCanvas.materializeTitle(doc.document.title);
      }
      doc.document.paragraphs.forEach((para, i) => {
        setTimeout(() => {
          documentCanvas.materializeParagraph(para, i);
        }, 300 * (i + 1));
      });
      
      updateWordCount();
      alert(`üìÇ Loaded document: ${doc.name}`);
    }
    
    function deleteSavedDocument(index) {
      if (!confirm('Delete this document?')) return;
      
      const savedDocs = JSON.parse(localStorage.getItem('wordweaver_documents') || '[]');
      savedDocs.splice(index, 1);
      localStorage.setItem('wordweaver_documents', JSON.stringify(savedDocs));
      
      refreshSavedDocsList();
    }
    
    function refreshSavedDocsList() {
      const savedDocs = JSON.parse(localStorage.getItem('wordweaver_documents') || '[]');
      const listContainer = document.getElementById('saved-docs-list');
      
      if (savedDocs.length === 0) {
        listContainer.innerHTML = '<div style="font-size: 10px; color: #666; font-style: italic; padding: 8px;">No saved documents yet...</div>';
        return;
      }
      
      listContainer.innerHTML = savedDocs.map((doc, index) => `
        <div class="saved-doc-item">
          <div style="flex: 1;">
            <div style="font-weight: 600; margin-bottom: 2px;">${doc.name}</div>
            <div style="font-size: 9px; color: #999;">${new Date(doc.timestamp).toLocaleString()}</div>
          </div>
          <div style="display: flex; gap: 4px;">
            <button onclick="loadSavedDocument(${index})" style="padding: 4px 8px; background: rgba(59, 130, 246, 0.3); border: 1px solid rgba(59, 130, 246, 0.5); border-radius: 4px; color: #3b82f6; font-size: 9px; cursor: pointer;">Load</button>
            <button onclick="deleteSavedDocument(${index})" style="padding: 4px 8px; background: rgba(239, 68, 68, 0.3); border: 1px solid rgba(239, 68, 68, 0.5); border-radius: 4px; color: #ef4444; font-size: 9px; cursor: pointer;">Delete</button>
          </div>
        </div>
      `).join('');
    }
    
    function newDocument() {
      if (confirm('Create new document? Current work will be cleared.')) {
        clearDocument();
        document.getElementById('doc-save-name').value = '';
        resetToDefaults();
      }
    }
    
    function duplicateDocument() {
      const currentName = document.getElementById('doc-save-name').value || 'Document';
      document.getElementById('doc-save-name').value = `${currentName} (Copy)`;
      saveDocument();
    }
    
    // Animation Controls
    function updateAnimationSpeed(value) {
      if (documentCanvas) documentCanvas.setAnimationSpeed(parseInt(value));
      document.getElementById('animation-speed-value').textContent = value + 'ms';
    }
    
    function updateStaggerDelay(value) {
      if (documentCanvas) documentCanvas.setStaggerDelay(parseInt(value));
      document.getElementById('stagger-delay-value').textContent = value + 'ms';
    }
    
    function toggleRotationAnimation() {
      const enabled = document.getElementById('enable-rotation').checked;
      if (documentCanvas) documentCanvas.setRotationEnabled(enabled);
    }
    
    function toggleMatrixGrid() {
      const enabled = document.getElementById('enable-matrix-grid').checked;
      if (documentCanvas) {
        documentCanvas.toggleMatrixGridBackwall(enabled);
        console.log(`üåê Matrix Grid Backwall: ${enabled ? 'ON' : 'OFF'}`);
      }
    }
    
    /**
     * Switch Matrix Wall Mode
     * @param {string} mode - 'paperback', 'magnetic', or 'holographic'
     */
    function switchMatrixMode(mode) {
      if (!documentCanvas) {
        console.warn('DocumentCanvas not initialized yet');
        return;
      }
      
      // Switch the mode
      documentCanvas.switchMatrixWallMode(mode);
      
      // Update button styling
      document.querySelectorAll('.matrix-mode-btn').forEach(btn => {
        btn.classList.remove('active-mode');
        btn.style.background = 'rgba(102, 126, 234, 0.1)';
        btn.style.borderColor = 'rgba(102, 126, 234, 0.3)';
        btn.style.color = '#667eea';
      });
      
      const activeBtn = document.getElementById(`mode-${mode}`);
      if (activeBtn) {
        activeBtn.classList.add('active-mode');
        activeBtn.style.background = 'rgba(102, 126, 234, 0.3)';
        activeBtn.style.borderColor = 'rgba(102, 126, 234, 0.6)';
        activeBtn.style.color = '#fff';
      }
      
      // Update description text
      const descriptions = {
        paperback: 'üìÑ Solid grid structure with clean lines',
        magnetic: 'üß≤ Magnetic field lines with spiraling particles',
        holographic: 'üîÆ Sphere projector emitting light particles upward'
      };
      
      const descElement = document.getElementById('matrix-mode-description');
      if (descElement) {
        descElement.textContent = descriptions[mode] || '';
        
        // Flash animation
        descElement.style.opacity = '0';
        setTimeout(() => {
          descElement.style.transition = 'opacity 0.3s';
          descElement.style.opacity = '1';
        }, 50);
      }
      
      // Show notification
      const notifications = {
        paperback: 'üìÑ Switched to SOLID GRID mode - Classic paperback structure',
        magnetic: 'üß≤ Switched to MAGNETIC FIELD mode - Letters attracted to field lines',
        holographic: 'üîÆ Switched to HOLOGRAPHIC mode - Sphere projector displays text'
      };
      
      console.log(`üé® ${notifications[mode]}`);
      
      // Visual notification
      showMatrixModeNotification(mode, notifications[mode]);
    }
    
    /**
     * Show matrix mode change notification
     */
    function showMatrixModeNotification(mode, message) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 30px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        z-index: 10000;
        animation: slideDown 0.3s ease-out;
      `;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'slideUp 0.3s ease-out';
        setTimeout(() => {
          if (notification.parentElement) {
            document.body.removeChild(notification);
          }
        }, 300);
      }, 2500);
    }
    
    // Quick Actions
    function selectAllLetters() {
      if (!documentCanvas) return;
      // TODO: Implement letter selection system
      alert('üîò Select all feature coming soon!');
    }
    
    function deselectAllLetters() {
      if (!documentCanvas) return;
      // TODO: Implement letter selection system
      alert('‚≠ï Deselect all feature coming soon!');
    }
    
    function randomizeColors() {
      if (!documentCanvas) return;
      const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16);
      documentCanvas.setColor(randomColor);
      document.getElementById('doc-color').value = randomColor;
      alert(`üåà Random color applied: ${randomColor}`);
    }
    
    function resetToDefaults() {
      if (!documentCanvas) return;
      
      // Reset all sliders and settings
      document.getElementById('letter-size-slider').value = 0.4;
      document.getElementById('letter-spacing-slider').value = 0.6;
      document.getElementById('extrusion-depth-slider').value = 0.15;
      document.getElementById('line-spacing-slider').value = 0.8;
      document.getElementById('words-per-line-slider').value = 8;
      document.getElementById('animation-speed-slider').value = 1200;
      document.getElementById('stagger-delay-slider').value = 50;
      document.getElementById('doc-color').value = '#667eea';
      
      // Update displays
      document.getElementById('letter-size-value').textContent = '0.4';
      document.getElementById('letter-spacing-value').textContent = '0.6';
      document.getElementById('extrusion-depth-value').textContent = '0.15';
      document.getElementById('line-spacing-value').textContent = '0.8';
      document.getElementById('words-per-line-value').textContent = '8';
      document.getElementById('animation-speed-value').textContent = '1200ms';
      document.getElementById('stagger-delay-value').textContent = '50ms';
      
      // Apply to document canvas
      documentCanvas.setLetterSize(0.4);
      documentCanvas.setLetterSpacing(0.6);
      documentCanvas.setExtrusionDepth(0.15);
      documentCanvas.setLineSpacing(0.8);
      documentCanvas.setWordsPerLine(8);
      documentCanvas.setAnimationSpeed(1200);
      documentCanvas.setStaggerDelay(50);
      documentCanvas.setColor('#667eea');
      documentCanvas.setShape('linear');
      documentCanvas.setMaterial('biblical');
      documentCanvas.setFont('helvetiker');
      
      alert('üîÑ Reset to default settings!');
    }
    
    function arrangeInCircle() {
      if (!documentCanvas) return;
      documentCanvas.setShape('sphere');
      selectDocShape('sphere');
      alert('‚≠ï Letters will arrange in circular pattern on next materialization!');
    }
    
    function arrangeInSpiral() {
      if (!documentCanvas) return;
      documentCanvas.setShape('helix');
      selectDocShape('helix');
      alert('üåÄ Letters will arrange in spiral pattern on next materialization!');
    }
    
    function toggleWordWeaverPanel() {
      alert('‚öôÔ∏è Settings panel - All controls are already visible in the sidebar!');
    }
    
    // Initialize saved docs list on load
    setTimeout(refreshSavedDocsList, 1500);

    // =====================================
    // üåå DIMENSIONAL WORKSPACE MANAGEMENT
    // =====================================
    
    /**
     * Initialize Dimensional Workspace System
     * Creates isolated 3D environments for each workspace
     */
    function initDimensionalSystem() {
      console.log('\nüåå ===== INITIALIZING DIMENSIONAL WORKSPACE SYSTEM =====\n');
      
      // Create dimensional spaces for each workspace
      Object.keys(DIMENSIONAL_CONFIGS).forEach(key => {
        dimensionalSpaces[key] = createDimensionalSpace(key, DIMENSIONAL_CONFIGS[key]);
        console.log(`  ‚úì ${DIMENSIONAL_CONFIGS[key].icon} ${DIMENSIONAL_CONFIGS[key].name} dimension created`);
      });
      
      // Create master matrix grid (universal boundary)
      createMasterMatrixGrid();
      
      // Create Matrix Prism Navigator (legacy cube grid)
      createMatrixPrismNavigator();
      
      // Create Spherical Navigator (new rotating layers system)
      createSphericalNavigator();
      
      // Create VenuesPro Interactive Gallery
      createVenuesProGallery();
      
      // Load initial dimension (SkyRelics)
      switchDimension('skyrelics');
      
      console.log('\n‚úÖ Dimensional Workspace System initialized!');
      console.log(`   ‚Üí ${Object.keys(dimensionalSpaces).length} dimensions active`);
      console.log(`   ‚Üí Master Matrix Grid: Universal boundary system`);
      console.log(`   ‚Üí Matrix Prism Navigator: 3D cube grid (legacy)`);
      console.log(`   ‚Üí Spherical Navigator: Rotating layers system (NEW!)`);
      console.log(`   ‚Üí VenuesPro Gallery: Interactive event showcases`);
      console.log(`   ‚Üí Current dimension: ${currentDimension}\n`);
    }
    
    /**
     * üéØ Create 3D Matrix Prism Navigator
     * Visual 3D menu system with preview cubes for each dimension
     */
    function createMatrixPrismNavigator() {
      console.log('\nüéØ Creating Matrix Prism Navigator...\n');
      
      // Navigator group (only visible in navigator dimension)
      const navigatorGroup = new THREE.Group();
      navigatorGroup.name = 'MatrixPrismNavigator';
      
      // Get all dimensions except navigator itself
      const dimensions = Object.keys(DIMENSIONAL_CONFIGS).filter(key => key !== 'navigator');
      
      // Arrange in 3D grid pattern
      const gridSize = Math.ceil(Math.sqrt(dimensions.length));
      const spacing = 8; // Space between preview cubes
      
      dimensions.forEach((key, index) => {
        const config = DIMENSIONAL_CONFIGS[key];
        
        // Calculate position in 3D grid
        const row = Math.floor(index / gridSize);
        const col = index % gridSize;
        const x = (col - gridSize / 2) * spacing;
        const z = (row - gridSize / 2) * spacing;
        const yPos = 0;
        
        // Create preview cube (room representation)
        const cubeGroup = new THREE.Group();
        cubeGroup.position.set(x, yPos, z);
        cubeGroup.userData.dimensionKey = key;
        cubeGroup.userData.config = config;
        
        // 1. Main cube (frosted glass look)
        const cubeGeometry = new THREE.BoxGeometry(5, 5, 5);
        const cubeMaterial = new THREE.MeshPhysicalMaterial({
          color: config.backgroundColor,
          transparent: true,
          opacity: 0.3,
          roughness: 0.1,
          metalness: 0.1,
          clearcoat: 1.0,
          side: THREE.DoubleSide
        });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cubeGroup.add(cube);
        
        // 2. Edge wireframe (dimension color)
        const edgesGeometry = new THREE.EdgesGeometry(cubeGeometry);
        const edgesMaterial = new THREE.LineBasicMaterial({
          color: config.gridConfig.centerColor,
          linewidth: 2
        });
        const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
        cubeGroup.add(edges);
        
        // 3. Icon sprite (floating above cube)
        const iconCanvas = document.createElement('canvas');
        iconCanvas.width = 256;
        iconCanvas.height = 256;
        const iconCtx = iconCanvas.getContext('2d');
        iconCtx.fillStyle = '#ffffff';
        iconCtx.font = 'bold 180px Arial';
        iconCtx.textAlign = 'center';
        iconCtx.textBaseline = 'middle';
        iconCtx.fillText(config.icon, 128, 128);
        
        const iconTexture = new THREE.CanvasTexture(iconCanvas);
        const iconMaterial = new THREE.SpriteMaterial({ map: iconTexture });
        const iconSprite = new THREE.Sprite(iconMaterial);
        iconSprite.position.y = 4;
        iconSprite.scale.set(2, 2, 1);
        cubeGroup.add(iconSprite);
        
        // 4. Preview text (3D text with dimension description)
        const textCanvas = document.createElement('canvas');
        textCanvas.width = 512;
        textCanvas.height = 256;
        const textCtx = textCanvas.getContext('2d');
        textCtx.fillStyle = 'rgba(0,0,0,0.8)';
        textCtx.fillRect(0, 0, 512, 256);
        textCtx.fillStyle = '#ffffff';
        textCtx.font = 'bold 28px Arial';
        textCtx.textAlign = 'center';
        textCtx.fillText(config.name, 256, 60);
        textCtx.font = '18px Arial';
        textCtx.fillStyle = '#aaaaaa';
        
        // Word wrap preview text
        const words = config.previewText.split(' ');
        let line = '';
        let textY = 110;
        words.forEach(word => {
          const testLine = line + word + ' ';
          const metrics = textCtx.measureText(testLine);
          if (metrics.width > 480 && line !== '') {
            textCtx.fillText(line, 256, textY);
            line = word + ' ';
            textY += 25;
          } else {
            line = testLine;
          }
        });
        textCtx.fillText(line, 256, textY);
        
        const textTexture = new THREE.CanvasTexture(textCanvas);
        const textGeometry = new THREE.PlaneGeometry(5, 2.5);
        const textMaterial = new THREE.MeshBasicMaterial({
          map: textTexture,
          transparent: true,
          side: THREE.DoubleSide
        });
        const textPlane = new THREE.Mesh(textGeometry, textMaterial);
        textPlane.position.y = -4;
        cubeGroup.add(textPlane);
        
        // 5. Glow effect (pulsing light)
        const glowGeometry = new THREE.SphereGeometry(3, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: config.gridConfig.centerColor,
          transparent: true,
          opacity: 0.1,
          side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.name = 'dimensionGlow';
        cubeGroup.add(glow);
        
        // 6. Make clickable
        cubeGroup.userData.isNavigatorCube = true;
        
        navigatorGroup.add(cubeGroup);
        
        console.log(`  ‚úì ${config.icon} ${config.name} preview cube created at (${x}, ${yPos}, ${z})`);
      });
      
      // Add navigator group to navigator dimension
      if (dimensionalSpaces['navigator']) {
        dimensionalSpaces['navigator'].objects.push(navigatorGroup);
        scene.add(navigatorGroup);
        navigatorGroup.visible = false; // Hidden until navigator is active
        
        console.log(`\n‚úÖ Matrix Prism Navigator created with ${dimensions.length} dimension previews`);
      }
    }
    
    /**
     * ÔøΩ Create Spherical Navigator (Rotating Layers System)
     * Multi-layered sphere with rotating segments - scroll to rotate, hover to interact
     */
    function createSphericalNavigator() {
      console.log('\nüåê Creating Spherical Navigator System...\n');
      
      const navConfig = DIMENSIONAL_CONFIGS['navigator'];
      if (!navConfig || !navConfig.sphericalNav || !navConfig.sphericalNav.enabled) {
        console.warn('‚ö†Ô∏è Spherical navigation not enabled');
        return;
      }
      
      const sphereGroup = new THREE.Group();
      sphereGroup.name = 'SphericalNavigator';
      
      const sphereConfig = navConfig.sphericalNav;
      const layers = sphereConfig.layers;
      const segmentConfig = sphereConfig.segmentConfig;
      const radius = sphereConfig.radius;
      
      // Store state for rotation
      sphereGroup.userData.currentRotation = 0;
      sphereGroup.userData.targetRotation = 0;
      sphereGroup.userData.layers = [];
      
      layers.forEach((layer, layerIndex) => {
        const layerGroup = new THREE.Group();
        layerGroup.name = `layer_${layer.category}`;
        layerGroup.userData.layerInfo = layer;
        layerGroup.userData.segments = [];
        
        const dimensions = layer.dimensions;
        const segmentCount = Math.min(dimensions.length, segmentConfig.segmentsPerLayer);
        const angleStep = (Math.PI * 2) / segmentCount;
        
        console.log(`  üìä Layer ${layerIndex + 1}: ${layer.name} (${layer.icon}) - ${segmentCount} segments`);
        
        dimensions.forEach((dimKey, segmentIndex) => {
          const dimConfig = DIMENSIONAL_CONFIGS[dimKey];
          if (!dimConfig) return;
          
          const segmentGroup = new THREE.Group();
          segmentGroup.name = `segment_${dimKey}`;
          
          // Calculate position on sphere surface
          const angle = angleStep * segmentIndex;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          const y = (layerIndex - layers.length / 2) * segmentConfig.segmentHeight;
          
          segmentGroup.position.set(x, y, z);
          
          // Create segment button (rounded box)
          const segmentWidth = (Math.PI * 2 * radius) / segmentCount * 0.8; // 80% of arc length
          const segmentGeometry = new THREE.BoxGeometry(
            segmentWidth,
            segmentConfig.segmentHeight * 0.8,
            segmentConfig.segmentThickness
          );
          
          const segmentMaterial = new THREE.MeshStandardMaterial({
            color: layer.color,
            metalness: 0.6,
            roughness: 0.3,
            emissive: layer.color,
            emissiveIntensity: 0.4,
            transparent: true,
            opacity: 0.85
          });
          
          const segmentMesh = new THREE.Mesh(segmentGeometry, segmentMaterial);
          segmentMesh.lookAt(0, y, 0); // Face the center
          segmentGroup.add(segmentMesh);
          
          // Create edge glow
          const edgesGeometry = new THREE.EdgesGeometry(segmentGeometry);
          const edgesMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            linewidth: 2,
            transparent: true,
            opacity: 0.8
          });
          const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
          edges.lookAt(0, y, 0);
          segmentGroup.add(edges);
          
          // Create icon sprite
          const iconCanvas = document.createElement('canvas');
          iconCanvas.width = 256;
          iconCanvas.height = 256;
          const iconCtx = iconCanvas.getContext('2d');
          iconCtx.fillStyle = '#ffffff';
          iconCtx.font = 'bold 120px Arial';
          iconCtx.textAlign = 'center';
          iconCtx.textBaseline = 'middle';
          iconCtx.fillText(dimConfig.icon, 128, 128);
          
          const iconTexture = new THREE.CanvasTexture(iconCanvas);
          const iconSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: iconTexture }));
          iconSprite.scale.set(1.2, 1.2, 1);
          iconSprite.position.z = segmentConfig.segmentThickness / 2 + 0.3;
          segmentGroup.add(iconSprite);
          
          // Create text label
          const labelCanvas = document.createElement('canvas');
          labelCanvas.width = 512;
          labelCanvas.height = 128;
          const labelCtx = labelCanvas.getContext('2d');
          
          labelCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          labelCtx.fillRect(0, 0, labelCanvas.width, labelCanvas.height);
          
          labelCtx.fillStyle = '#ffffff';
          labelCtx.font = 'bold 32px Arial';
          labelCtx.textAlign = 'center';
          labelCtx.textBaseline = 'middle';
          
          // Truncate long names
          let displayName = dimConfig.name;
          if (displayName.length > 20) {
            displayName = displayName.substring(0, 18) + '...';
          }
          labelCtx.fillText(displayName, 256, 64);
          
          const labelTexture = new THREE.CanvasTexture(labelCanvas);
          const labelGeometry = new THREE.PlaneGeometry(2, 0.5);
          const labelMaterial = new THREE.MeshBasicMaterial({ 
            map: labelTexture, 
            transparent: true,
            side: THREE.DoubleSide
          });
          const label = new THREE.Mesh(labelGeometry, labelMaterial);
          label.position.y = -(segmentConfig.segmentHeight * 0.8) / 2 - 0.4;
          label.lookAt(0, y, 0);
          segmentGroup.add(label);
          
          // Create glow sphere for hover effect
          const glowGeometry = new THREE.SphereGeometry(segmentWidth * 0.6, 16, 16);
          const glowMaterial = new THREE.MeshBasicMaterial({
            color: layer.color,
            transparent: true,
            opacity: 0,
            side: THREE.BackSide
          });
          const glow = new THREE.Mesh(glowGeometry, glowMaterial);
          glow.name = 'segmentGlow';
          segmentGroup.add(glow);
          
          // Store metadata
          segmentGroup.userData.isNavigatorSegment = true;
          segmentGroup.userData.dimensionKey = dimKey;
          segmentGroup.userData.dimensionConfig = dimConfig;
          segmentGroup.userData.layerCategory = layer.category;
          segmentGroup.userData.layerColor = layer.color;
          segmentGroup.userData.baseScale = new THREE.Vector3(1, 1, 1);
          segmentGroup.userData.isHovered = false;
          
          layerGroup.add(segmentGroup);
          layerGroup.userData.segments.push(segmentGroup);
          
          console.log(`    ‚úì ${dimConfig.icon} ${displayName} segment at angle ${(angle * 180 / Math.PI).toFixed(1)}¬∞`);
        });
        
        sphereGroup.add(layerGroup);
        sphereGroup.userData.layers.push(layerGroup);
      });
      
      // Add central core sphere (visual anchor)
      const coreGeometry = new THREE.SphereGeometry(1.5, 32, 32);
      const coreMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        metalness: 0.9,
        roughness: 0.1,
        emissive: 0x00ffff,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.6
      });
      const coreSphere = new THREE.Mesh(coreGeometry, coreMaterial);
      coreSphere.name = 'navigatorCore';
      sphereGroup.add(coreSphere);
      
      // Add wireframe sphere outline
      const wireframeGeometry = new THREE.SphereGeometry(radius + 0.5, 24, 24);
      const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        wireframe: true,
        transparent: true,
        opacity: 0.2
      });
      const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
      wireframe.name = 'sphereWireframe';
      sphereGroup.add(wireframe);
      
      // Add to scene
      if (dimensionalSpaces['navigator']) {
        dimensionalSpaces['navigator'].objects.push(sphereGroup);
        scene.add(sphereGroup);
        sphereGroup.visible = false; // Hidden until navigator is active
        
        const totalSegments = layers.reduce((sum, layer) => sum + layer.dimensions.length, 0);
        console.log(`\n‚úÖ Spherical Navigator created!`);
        console.log(`   ‚Üí ${layers.length} layers with ${totalSegments} total segments`);
        console.log(`   ‚Üí Radius: ${radius} units`);
        console.log(`   ‚Üí Scroll to rotate ‚Ä¢ Hover to highlight ‚Ä¢ Click to enter\n`);
      }
      
      return sphereGroup;
    }
    
    /**
     * ÔøΩüé™ Create VenuesPro Interactive Webpage Gallery
     * 3D displays showing different event/celebration webpage layouts
     * Interactive iframes that activate on proximity for scrolling
     */
    function createVenuesProGallery() {
      console.log('\nüé™ Creating VenuesPro Interactive Gallery...\n');
      
      const venueConfig = DIMENSIONAL_CONFIGS['venuespro'];
      if (!venueConfig || !venueConfig.venueConfig) {
        console.warn('‚ö†Ô∏è VenuesPro config not found');
        return;
      }
      
      const venueGroup = new THREE.Group();
      venueGroup.name = 'VenuesProGallery';
      
      const layouts = venueConfig.venueConfig.layouts;
      const displayConfig = venueConfig.venueConfig.interactionConfig;
      
      layouts.forEach((layout, index) => {
        const displayGroup = new THREE.Group();
        displayGroup.name = `venue_${layout.category}_${index}`;
        
        const { x, y, z } = layout.position;
        displayGroup.position.set(x, y, z);
        
        // 1. Create display frame (border around the "screen")
        const frameDepth = 0.3;
        const frameThickness = 0.2;
        const frameGeometry = new THREE.BoxGeometry(
          displayConfig.displaySize.width + frameThickness,
          displayConfig.displaySize.height + frameThickness,
          frameDepth
        );
        const frameMaterial = new THREE.MeshStandardMaterial({
          color: layout.color,
          metalness: 0.8,
          roughness: 0.2,
          emissive: layout.color,
          emissiveIntensity: 0.3
        });
        const frame = new THREE.Mesh(frameGeometry, frameMaterial);
        displayGroup.add(frame);
        
        // 2. Create display screen (canvas-based texture placeholder)
        const canvas = document.createElement('canvas');
        canvas.width = displayConfig.resolution.width;
        canvas.height = displayConfig.resolution.height;
        const ctx = canvas.getContext('2d');
        
        // Draw layout preview
        ctx.fillStyle = `#${layout.color.toString(16).padStart(6, '0')}`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add gradient overlay
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, 'rgba(0,0,0,0.3)');
        gradient.addColorStop(1, 'rgba(0,0,0,0.7)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw title
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 120px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(layout.name, canvas.width / 2, 250);
        
        // Draw category badge
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.font = 'bold 60px Arial';
        ctx.fillText(layout.category.toUpperCase(), canvas.width / 2, 350);
        
        // Draw style keywords
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.font = '40px Arial';
        const keywordsText = layout.keywords.slice(0, 5).join(' ‚Ä¢ ');
        ctx.fillText(keywordsText, canvas.width / 2, 450);
        
        // Draw target audience (wrapped text)
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.font = '36px Arial';
        const audience = layout.targetAudience;
        const maxWidth = canvas.width - 200;
        const words = audience.split(' ');
        let line = '';
        let lineY = 600;
        
        words.forEach(word => {
          const testLine = line + word + ' ';
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && line !== '') {
            ctx.fillText(line, canvas.width / 2, lineY);
            line = word + ' ';
            lineY += 50;
          } else {
            line = testLine;
          }
        });
        ctx.fillText(line, canvas.width / 2, lineY);
        
        // Draw interaction hint
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.font = 'italic 32px Arial';
        ctx.fillText('üñ±Ô∏è Approach to interact', canvas.width / 2, canvas.height - 100);
        
        const screenTexture = new THREE.CanvasTexture(canvas);
        const screenGeometry = new THREE.PlaneGeometry(
          displayConfig.displaySize.width,
          displayConfig.displaySize.height
        );
        const screenMaterial = new THREE.MeshBasicMaterial({
          map: screenTexture,
          side: THREE.DoubleSide,
          transparent: true
        });
        const screen = new THREE.Mesh(screenGeometry, screenMaterial);
        screen.position.z = frameDepth / 2 + 0.01; // Slightly in front of frame
        displayGroup.add(screen);
        
        // 3. Add spotlight above display
        const spotlight = new THREE.SpotLight(layout.color, 0.8);
        spotlight.position.set(0, 4, 1);
        spotlight.angle = Math.PI / 6;
        spotlight.penumbra = 0.3;
        spotlight.decay = 2;
        spotlight.distance = 10;
        spotlight.target = displayGroup;
        displayGroup.add(spotlight);
        
        // 4. Add label below display
        const labelCanvas = document.createElement('canvas');
        labelCanvas.width = 1024;
        labelCanvas.height = 128;
        const labelCtx = labelCanvas.getContext('2d');
        
        labelCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        labelCtx.fillRect(0, 0, labelCanvas.width, labelCanvas.height);
        
        labelCtx.fillStyle = '#ffffff';
        labelCtx.font = 'bold 48px Arial';
        labelCtx.textAlign = 'center';
        labelCtx.fillText(layout.name, labelCanvas.width / 2, 70);
        
        const labelTexture = new THREE.CanvasTexture(labelCanvas);
        const labelGeometry = new THREE.PlaneGeometry(4, 0.5);
        const labelMaterial = new THREE.MeshBasicMaterial({
          map: labelTexture,
          transparent: true,
          side: THREE.DoubleSide
        });
        const label = new THREE.Mesh(labelGeometry, labelMaterial);
        label.position.y = -(displayConfig.displaySize.height / 2) - 0.7;
        displayGroup.add(label);
        
        // 5. Store metadata for interaction
        displayGroup.userData.isVenueDisplay = true;
        displayGroup.userData.layout = layout;
        displayGroup.userData.canvasElement = canvas;
        displayGroup.userData.proximityDistance = displayConfig.proximityActivation;
        displayGroup.userData.iframeURL = `https://venuespro.example.com/${layout.style}`;  // Placeholder URL
        
        venueGroup.add(displayGroup);
        
        console.log(`  ‚úì ${layout.name} display created at (${x}, ${y}, ${z}) - ${layout.category}`);
      });
      
      // Add venue group to venuespro dimension
      if (dimensionalSpaces['venuespro']) {
        dimensionalSpaces['venuespro'].objects.push(venueGroup);
        scene.add(venueGroup);
        venueGroup.visible = false; // Hidden until venuespro is active
        
        console.log(`\n‚úÖ VenuesPro Gallery created with ${layouts.length} interactive displays`);
        console.log(`   ‚Üí Partnership opportunities: ${venueConfig.venueConfig.partnershipOpportunities.length} identified`);
      }
    }
    
    /**
     * Create a dimensional space (isolated 3D environment)
     */
    function createDimensionalSpace(key, config) {
      const space = {
        key: key,
        config: config,
        objects: [], // Objects in this dimension
        lights: [], // Lights specific to this dimension
        matrixGrid: null, // Custom grid for this dimension
        active: false
      };
      
      // Create dimension-specific matrix grid
      space.matrixGrid = createDimensionMatrixGrid(config.gridConfig, key);
      space.matrixGrid.visible = false; // Hidden until dimension is active
      scene.add(space.matrixGrid);
      
      // Create dimension-specific lights
      const lights = createDimensionLights(config.lighting);
      lights.forEach(light => {
        light.visible = false; // Hidden until dimension is active
        scene.add(light);
        space.lights.push(light);
      });
      
      return space;
    }
    
    /**
     * Create custom matrix grid for a dimension
     */
    function createDimensionMatrixGrid(gridConfig, dimensionKey) {
      const group = new THREE.Group();
      group.name = `MatrixGrid_${dimensionKey}`;
      
      const { size, divisions, centerColor, gridColor, wallColor, showWalls, wallHeight, wallOpacity, backwallZ, circular } = gridConfig;
      const halfSize = size / 2;
      
      // 1. Floor grid
      const gridHelper = new THREE.GridHelper(size, divisions, centerColor, gridColor);
      gridHelper.position.y = 0;
      group.add(gridHelper);
      
      // 2. Floor plane (subtle glow)
      const floorGeom = new THREE.PlaneGeometry(size, size);
      const floorMat = new THREE.MeshBasicMaterial({
        color: wallColor,
        transparent: true,
        opacity: 0.2,
        side: THREE.DoubleSide
      });
      const floor = new THREE.Mesh(floorGeom, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -0.01;
      group.add(floor);
      
      if (showWalls) {
        // 3. Create boundary walls (4 walls forming a box)
        const wallMat = new THREE.MeshBasicMaterial({
          color: wallColor,
          transparent: true,
          opacity: wallOpacity,
          side: THREE.DoubleSide
        });
        
        const lineMat = new THREE.LineBasicMaterial({
          color: centerColor,
          transparent: true,
          opacity: 0.6,
          linewidth: 2
        });
        
        const halfSize = size / 2;
        
        // Back wall (most visible for reference)
        const backWallGeom = new THREE.PlaneGeometry(size, wallHeight);
        const backWall = new THREE.Mesh(backWallGeom, wallMat);
        backWall.position.set(0, wallHeight / 2, -halfSize);
        group.add(backWall);
        
        // Add grid lines to back wall
        for (let i = 0; i <= divisions; i++) {
          const x = -halfSize + (i * size / divisions);
          const points = [
            new THREE.Vector3(x, 0, -halfSize + 0.1),
            new THREE.Vector3(x, wallHeight, -halfSize + 0.1)
          ];
          const geom = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(geom, lineMat);
          group.add(line);
        }
        
        for (let i = 0; i <= Math.floor(wallHeight); i++) {
          const y = i;
          const points = [
            new THREE.Vector3(-halfSize, y, -halfSize + 0.1),
            new THREE.Vector3(halfSize, y, -halfSize + 0.1)
          ];
          const geom = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(geom, lineMat);
          group.add(line);
        }
        
        // Left wall
        const leftWall = backWall.clone();
        leftWall.rotation.y = Math.PI / 2;
        leftWall.position.set(-halfSize, wallHeight / 2, 0);
        group.add(leftWall);
        
        // Right wall
        const rightWall = backWall.clone();
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.position.set(halfSize, wallHeight / 2, 0);
        group.add(rightWall);
        
        // Front wall (more transparent for visibility)
        const frontWallMat = wallMat.clone();
        frontWallMat.opacity = wallOpacity * 0.3;
        const frontWall = new THREE.Mesh(backWallGeom, frontWallMat);
        frontWall.rotation.y = Math.PI;
        frontWall.position.set(0, wallHeight / 2, halfSize);
        group.add(frontWall);
      }
      
      // 4. Center marker (origin point)
      const markerGeom = new THREE.SphereGeometry(0.2, 16, 16);
      const markerMat = new THREE.MeshBasicMaterial({
        color: centerColor,
        transparent: true,
        opacity: 0.8
      });
      const marker = new THREE.Mesh(markerGeom, markerMat);
      marker.position.y = 0.2;
      marker.name = 'dimensionOrigin';
      group.add(marker);
      
      // 5. Pulsing glow at center (animated)
      const glowGeom = new THREE.CircleGeometry(1, 32);
      const glowMat = new THREE.MeshBasicMaterial({
        color: centerColor,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      const glow = new THREE.Mesh(glowGeom, glowMat);
      glow.rotation.x = -Math.PI / 2;
      glow.position.y = 0.01;
      glow.name = 'dimensionGlow';
      group.add(glow);
      
      // 6. Corner markers for spatial reference
      const cornerGeom = new THREE.ConeGeometry(0.3, 1, 8);
      const cornerMat = new THREE.MeshBasicMaterial({
        color: centerColor,
        transparent: true,
        opacity: 0.6
      });
      
      const corners = [
        { x: -halfSize + 1, z: -halfSize + 1 },
        { x: halfSize - 1, z: -halfSize + 1 },
        { x: -halfSize + 1, z: halfSize - 1 },
        { x: halfSize - 1, z: halfSize - 1 }
      ];
      
      corners.forEach(corner => {
        const cone = new THREE.Mesh(cornerGeom, cornerMat);
        cone.position.set(corner.x, 0.5, corner.z);
        group.add(cone);
      });
      
      return group;
    }
    
    /**
     * Create dimension-specific lights
     */
    function createDimensionLights(lightingConfig) {
      const lights = [];
      
      // Ambient light
      const ambient = new THREE.AmbientLight(
        lightingConfig.ambient.color,
        lightingConfig.ambient.intensity
      );
      lights.push(ambient);
      
      // Directional light
      const directional = new THREE.DirectionalLight(
        lightingConfig.directional.color,
        lightingConfig.directional.intensity
      );
      const dirPos = lightingConfig.directional.position;
      directional.position.set(dirPos.x, dirPos.y, dirPos.z);
      directional.castShadow = true;
      lights.push(directional);
      
      // Point light(s)
      if (Array.isArray(lightingConfig.point)) {
        lightingConfig.point.forEach(pointConfig => {
          const point = new THREE.PointLight(
            pointConfig.color,
            pointConfig.intensity,
            50
          );
          point.position.set(
            pointConfig.position.x,
            pointConfig.position.y,
            pointConfig.position.z
          );
          lights.push(point);
        });
      } else {
        const point = new THREE.PointLight(
          lightingConfig.point.color,
          lightingConfig.point.intensity,
          50
        );
        const pointPos = lightingConfig.point.position;
        point.position.set(pointPos.x, pointPos.y, pointPos.z);
        lights.push(point);
      }
      
      return lights;
    }
    
    /**
     * Create Master Matrix Grid (universal boundary - always visible)
     */
    function createMasterMatrixGrid() {
      masterMatrixGrid = new THREE.Group();
      masterMatrixGrid.name = 'MasterMatrixGrid';
      
      // Massive outer boundary box
      const size = 100;
      const height = 50;
      
      const boundaryMat = new THREE.LineBasicMaterial({
        color: 0xff00ff,
        transparent: true,
        opacity: 0.2,
        linewidth: 1
      });
      
      // Create wireframe box
      const points = [
        // Bottom face
        new THREE.Vector3(-size/2, 0, -size/2),
        new THREE.Vector3(size/2, 0, -size/2),
        new THREE.Vector3(size/2, 0, size/2),
        new THREE.Vector3(-size/2, 0, size/2),
        new THREE.Vector3(-size/2, 0, -size/2),
        // Go up to top face
        new THREE.Vector3(-size/2, height, -size/2),
        new THREE.Vector3(size/2, height, -size/2),
        new THREE.Vector3(size/2, height, size/2),
        new THREE.Vector3(-size/2, height, size/2),
        new THREE.Vector3(-size/2, height, -size/2)
      ];
      
      // Vertical edges
      const verticalEdges = [
        [new THREE.Vector3(size/2, 0, -size/2), new THREE.Vector3(size/2, height, -size/2)],
        [new THREE.Vector3(size/2, 0, size/2), new THREE.Vector3(size/2, height, size/2)],
        [new THREE.Vector3(-size/2, 0, size/2), new THREE.Vector3(-size/2, height, size/2)]
      ];
      
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const boundaryBox = new THREE.Line(geometry, boundaryMat);
      masterMatrixGrid.add(boundaryBox);
      
      verticalEdges.forEach(edge => {
        const geom = new THREE.BufferGeometry().setFromPoints(edge);
        const line = new THREE.Line(geom, boundaryMat);
        masterMatrixGrid.add(line);
      });
      
      masterMatrixGrid.visible = true; // Always visible
      scene.add(masterMatrixGrid);
      
      console.log('üåê Master Matrix Grid created: 100x50x100 universal boundary');
    }
    
    /**
     * Switch to a different dimensional workspace
     */
    function switchDimension(dimensionKey) {
      if (!dimensionalSpaces[dimensionKey]) {
        console.error(`‚ùå Dimension '${dimensionKey}' does not exist!`);
        return;
      }
      
      const oldDimension = currentDimension;
      const newDimension = dimensionKey;
      
      console.log(`\nüåÄ Switching dimension: ${oldDimension} ‚Üí ${newDimension}`);
      
      // Hide old dimension
      if (dimensionalSpaces[oldDimension]) {
        dimensionalSpaces[oldDimension].matrixGrid.visible = false;
        dimensionalSpaces[oldDimension].lights.forEach(light => light.visible = false);
        dimensionalSpaces[oldDimension].active = false;
        
        // Hide dimension-specific objects
        dimensionalSpaces[oldDimension].objects.forEach(obj => {
          obj.visible = false;
        });
      }
      
      // Show new dimension
      const space = dimensionalSpaces[newDimension];
      const config = space.config;
      
      space.matrixGrid.visible = true;
      space.lights.forEach(light => light.visible = true);
      space.active = true;
      
      // Show dimension-specific objects
      space.objects.forEach(obj => {
        obj.visible = true;
      });
      
      // Update scene environment
      scene.background = new THREE.Color(config.backgroundColor);
      scene.fog = new THREE.Fog(config.fogColor, config.fogNear, config.fogFar);
      
      // Move camera to dimension's default position
      const camPos = config.cameraPosition;
      const camTarget = config.cameraTarget;
      
      camera.position.set(camPos.x, camPos.y, camPos.z);
      controls.target.set(camTarget.x, camTarget.y, camTarget.z);
      controls.update();
      
      currentDimension = newDimension;
      
      console.log(`‚úÖ Now in ${config.icon} ${config.name}`);
      console.log(`   ${config.description}`);
      
      // Update UI workspace tab highlighting
      updateWorkspaceTabHighlight(newDimension);
      
      // Show appropriate workspace panel
      showWorkspacePanel(newDimension);
    }
    
    /**
     * Update workspace tab highlighting
     */
    function updateWorkspaceTabHighlight(activeTab) {
      document.querySelectorAll('.workspace-tab').forEach(tab => {
        const tabKey = tab.getAttribute('onclick').match(/'([^']+)'/)[1];
        if (tabKey === activeTab) {
          tab.style.background = 'rgba(255, 255, 255, 0.3)';
          tab.style.borderBottom = '3px solid #fff';
        } else {
          tab.style.background = 'rgba(255, 255, 255, 0.1)';
          tab.style.borderBottom = 'none';
        }
      });
    }
    
    /**
     * Show appropriate workspace control panel
     */
    function showWorkspacePanel(workspaceKey) {
      // Hide all workspace panels
      document.querySelectorAll('.workspace-content').forEach(panel => {
        panel.style.display = 'none';
      });
      
      // Show selected workspace panel
      const panelId = `workspace-${workspaceKey}`;
      const panel = document.getElementById(panelId);
      if (panel) {
        panel.style.display = 'block';
      }
    }
    
    /**
     * Add object to current dimension
     */
    function addObjectToDimension(object) {
      if (dimensionalSpaces[currentDimension]) {
        dimensionalSpaces[currentDimension].objects.push(object);
        object.userData.dimension = currentDimension;
      }
    }
    
    /**
     * Update dimensional animations (call in animate loop)
     */
    function updateDimensionalAnimations() {
      if (!dimensionalSpaces[currentDimension]) return;
      
      const space = dimensionalSpaces[currentDimension];
      const time = Date.now() * 0.001;
      
      // Animate pulsing glow
      const glow = space.matrixGrid.getObjectByName('dimensionGlow');
      if (glow) {
        const scale = 1 + Math.sin(time * 2) * 0.2;
        glow.scale.set(scale, 1, scale);
        glow.material.opacity = 0.2 + Math.sin(time * 2) * 0.1;
      }
      
      // Animate origin marker
      const marker = space.matrixGrid.getObjectByName('dimensionOrigin');
      if (marker) {
        marker.rotation.y += 0.02;
        marker.position.y = 0.2 + Math.sin(time * 3) * 0.1;
      }
      
      // üéØ Animate Matrix Prism Navigator cubes (legacy)
      if (currentDimension === 'navigator') {
        const navigatorGroup = space.objects.find(obj => obj.name === 'MatrixPrismNavigator');
        
        if (navigatorGroup) {
          navigatorGroup.children.forEach((cubeGroup, index) => {
            if (cubeGroup.userData.isNavigatorCube) {
              // Pulsing glow with phase offset per cube
              const glow = cubeGroup.getObjectByName('dimensionGlow');
              if (glow && cubeGroup !== hoveredNavigatorCube) {
                const baseOpacity = 0.1;
                const pulseAmount = Math.sin(time * 2 + index * 0.5) * 0.05;
                glow.material.opacity = baseOpacity + pulseAmount;
              }
              
              // Gentle rotation
              cubeGroup.rotation.y += 0.002;
              
              // Subtle floating motion
              const floatAmount = Math.sin(time * 1.5 + index * 0.3) * 0.1;
              cubeGroup.position.y = floatAmount;
            }
          });
        }
        
        // üåê Animate Spherical Navigator (new rotating layers system)
        const sphereGroup = space.objects.find(obj => obj.name === 'SphericalNavigator');
        
        if (sphereGroup) {
          const navConfig = DIMENSIONAL_CONFIGS['navigator'];
          const transitionTime = navConfig.sphericalNav.segmentConfig.transitionTime || 0.5;
          
          // Smooth rotation towards target
          const rotationDiff = sphereGroup.userData.targetRotation - sphereGroup.userData.currentRotation;
          if (Math.abs(rotationDiff) > 0.001) {
            const rotationSpeed = rotationDiff * (1 / (transitionTime * 60)); // 60 fps assumption
            sphereGroup.userData.currentRotation += rotationSpeed;
            sphereGroup.rotation.y = sphereGroup.userData.currentRotation;
          }
          
          // Animate central core sphere
          const core = sphereGroup.getObjectByName('navigatorCore');
          if (core) {
            core.rotation.y += 0.01;
            core.rotation.x += 0.005;
            
            // Pulsing glow
            const pulseScale = 1 + Math.sin(time * 3) * 0.1;
            core.scale.set(pulseScale, pulseScale, pulseScale);
            core.material.emissiveIntensity = 0.5 + Math.sin(time * 2) * 0.2;
          }
          
          // Animate wireframe sphere
          const wireframe = sphereGroup.getObjectByName('sphereWireframe');
          if (wireframe) {
            wireframe.rotation.y -= 0.003;
            wireframe.rotation.x += 0.002;
            wireframe.material.opacity = 0.2 + Math.sin(time * 1.5) * 0.1;
          }
          
          // Animate segments (gentle pulsing for non-hovered)
          sphereGroup.userData.layers.forEach((layerGroup, layerIndex) => {
            layerGroup.userData.segments.forEach((segment, segmentIndex) => {
              if (!segment.userData.isHovered) {
                // Gentle pulsing emissive intensity
                const meshes = segment.children.filter(child => child.type === 'Mesh' && child.material.emissive);
                meshes.forEach(mesh => {
                  const phaseOffset = layerIndex * 0.5 + segmentIndex * 0.3;
                  mesh.material.emissiveIntensity = 0.4 + Math.sin(time * 2 + phaseOffset) * 0.1;
                });
                
                // Very subtle breathing scale
                const breatheScale = 1 + Math.sin(time + segmentIndex * 0.5) * 0.02;
                segment.scale.set(breatheScale, breatheScale, breatheScale);
              }
            });
          });
        }
      }
      
      // üé™ VenuesPro Gallery: Proximity-based interaction and animation
      if (currentDimension === 'venuespro') {
        const venueGroup = space.objects.find(obj => obj.name === 'VenuesProGallery');
        
        if (venueGroup) {
          venueGroup.children.forEach((displayGroup, index) => {
            if (displayGroup.userData.isVenueDisplay) {
              // Calculate distance from camera
              const cameraPos = new THREE.Vector3();
              camera.getWorldPosition(cameraPos);
              const displayPos = new THREE.Vector3();
              displayGroup.getWorldPosition(displayPos);
              const distance = cameraPos.distanceTo(displayPos);
              
              // Get frame for proximity effects
              const frame = displayGroup.children.find(child => child.geometry && child.geometry.type === 'BoxGeometry');
              
              if (frame) {
                // Proximity-based glow intensity
                const proximityRange = displayGroup.userData.proximityDistance || 3.5;
                const proximityFactor = Math.max(0, 1 - (distance / proximityRange));
                
                // Update emissive intensity based on proximity
                if (proximityFactor > 0) {
                  frame.material.emissiveIntensity = 0.3 + proximityFactor * 0.7;
                  
                  // Show interaction indicator when very close
                  if (proximityFactor > 0.7) {
                    console.log(`üé™ Near ${displayGroup.userData.layout.name} - Distance: ${distance.toFixed(2)}`);
                  }
                } else {
                  frame.material.emissiveIntensity = 0.3;
                }
              }
              
              // Gentle pulsing animation
              const spotlight = displayGroup.children.find(child => child.type === 'SpotLight');
              if (spotlight) {
                spotlight.intensity = 0.8 + Math.sin(time * 2 + index * 0.4) * 0.2;
              }
              
              // Subtle hover animation
              const baseY = displayGroup.userData.layout.position.y;
              const hoverAmount = Math.sin(time * 1 + index * 0.5) * 0.05;
              displayGroup.position.y = baseY + hoverAmount;
            }
          });
        }
      }
    }

    // Start
    window.addEventListener('load', () => {
      init();
      setTimeout(() => {
        initDimensionalSystem();
      }, 500);
    });
    
    // Initialize Document Canvas after scene loads
    setTimeout(initDocumentCanvas, 1000);
  </script>
</body>
</html>
