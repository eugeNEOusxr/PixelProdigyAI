<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PixelProdigy Universe - Multi-Workspace Studio</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      height: 100vh;
    }

    #container {
      display: grid;
      grid-template-columns: 250px 1fr;
      grid-template-rows: 60px 1fr 40px;
      height: 100vh;
    }

    #header {
      grid-column: 1 / -1;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 20px;
    }

    #header h1 {
      font-size: 24px;
      font-weight: 600;
    }

    .workspace-tabs {
      display: flex;
      gap: 4px;
      flex: 1;
    }

    .workspace-tab {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: rgba(255, 255, 255, 0.7);
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 6px 6px 0 0;
      transition: all 0.2s;
      font-size: 13px;
      font-weight: 500;
    }

    .workspace-tab:hover {
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
    }

    .workspace-tab.active {
      background: #1a1a1a;
      color: #fff;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
    }

    #sidebar {
      background: #1a1a1a;
      padding: 20px;
      overflow-y: auto;
      border-right: 2px solid #333;
    }

    #viewport {
      background: #0f0f0f;
      position: relative;
      overflow: hidden;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
    }

    #footer {
      grid-column: 1 / -1;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      border-top: 2px solid #333;
      font-size: 13px;
      color: #888;
    }

    .section {
      margin-bottom: 25px;
    }

    .section-title {
      font-size: 12px;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 12px;
      font-weight: 600;
      letter-spacing: 1px;
    }

    .tool-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .tool-btn {
      background: #2a2a2a;
      border: 2px solid #3a3a3a;
      color: #fff;
      padding: 12px 8px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
      font-size: 13px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .tool-btn:hover {
      background: #3a3a3a;
      border-color: #667eea;
    }

    .tool-btn.active {
      background: #667eea;
      border-color: #764ba2;
      box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
    }

    .tool-icon {
      font-size: 24px;
    }

    .slider-control {
      margin-bottom: 15px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 12px;
      color: #aaa;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      background: #2a2a2a;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #667eea;
      cursor: pointer;
      border-radius: 50%;
      transition: all 0.2s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #764ba2;
      transform: scale(1.2);
    }

    .primitive-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #667eea;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="header">
      <h1>âš¡ PixelProdigy Universe</h1>
      <div class="workspace-tabs">
        <button class="workspace-tab active" onclick="switchWorkspace('sculpt', this)">3D Sculpt</button>
        <button class="workspace-tab" onclick="switchWorkspace('css', this)">CSS Designer</button>
        <button class="workspace-tab" onclick="switchWorkspace('word', this)">WordWeaver</button>
        <button class="workspace-tab" onclick="switchWorkspace('campus', this)">Campus</button>
        <button class="workspace-tab" onclick="switchWorkspace('perfect', this)">Perfect</button>
      </div>
      <div style="color: rgba(255,255,255,0.8); font-size: 14px;">Multi-Workspace Studio</div>
      
      <!-- Camera Controls -->
      <div style="display: flex; gap: 8px; margin-left: auto;">
        <button id="orbitToggle" onclick="toggleOrbitControls()" style="padding: 8px 16px; background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          ğŸ¥ Orbit: ON
        </button>
        <button id="walkModeToggle" onclick="toggleWalkMode()" style="padding: 8px 16px; background: rgba(255,165,0,0.15); border: 2px solid rgba(255,165,0,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          ğŸš¶ Walk Mode: OFF
        </button>
      </div>
    </div>

    <div id="sidebar">
      <!-- Sculpt Workspace -->
      <div id="workspace-sculpt" class="workspace-content">
        <div class="section">
          <div class="section-title">ğŸ”§ Mode</div>
          <div class="tool-grid">
            <button class="tool-btn active" onclick="setMode('add', this)">
              <span class="tool-icon">â•</span>
              <span>Add</span>
            </button>
            <button class="tool-btn" onclick="setMode('subtract', this)">
              <span class="tool-icon">â–</span>
              <span>Subtract</span>
            </button>
          </div>
        </div>

        <div class="section">
          <div class="section-title">âœ‹ Manipulate</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="setTransformMode('translate')">
              <span class="tool-icon">â†”ï¸</span>
              <span>Move (W)</span>
            </button>
            <button class="tool-btn" onclick="setTransformMode('rotate')">
              <span class="tool-icon">ğŸ”„</span>
              <span>Rotate (E)</span>
            </button>
            <button class="tool-btn" onclick="setTransformMode('scale')">
              <span class="tool-icon">ğŸ“</span>
              <span>Scale (R)</span>
            </button>
          </div>
        </div>

        <div class="section">
          <div class="section-title">ğŸ¨ Primitives</div>
          <div class="primitive-grid">
            <button class="tool-btn active" onclick="setPrimitive('sphere', this)">
              <span class="tool-icon">âšª</span>
              <span>Sphere</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cube', this)">
              <span class="tool-icon">â¬›</span>
              <span>Cube</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cylinder', this)">
              <span class="tool-icon">ğŸ”µ</span>
              <span>Cylinder</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cone', this)">
              <span class="tool-icon">ğŸ”»</span>
              <span>Cone</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('torus', this)">
              <span class="tool-icon">ğŸ©</span>
              <span>Torus</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('pyramid', this)">
              <span class="tool-icon">ğŸ”º</span>
              <span>Pyramid</span>
            </button>
            <button class="tool-btn" onclick="loadHumanAnatomy(this)" style="grid-column: 1 / -1; background: rgba(102, 126, 234, 0.2);">
              <span class="tool-icon">ğŸ¦¾</span>
              <span>Load Arm (86V)</span>
            </button>
            <button class="tool-btn" onclick="loadBothArms(this)" style="grid-column: 1 / -1; background: rgba(63, 81, 181, 0.25); border: 2px solid rgba(63, 81, 181, 0.5);">
              <span class="tool-icon">ğŸ¦¾ğŸ¦¾</span>
              <span>Both Arms (172V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanLeg(this)" style="grid-column: 1 / -1; background: rgba(76, 175, 80, 0.2); border: 2px solid rgba(76, 175, 80, 0.4);">
              <span class="tool-icon">ğŸ¦µ</span>
              <span>Load Leg (86V)</span>
            </button>
            <button class="tool-btn" onclick="loadBothLegs(this)" style="grid-column: 1 / -1; background: rgba(46, 125, 50, 0.25); border: 2px solid rgba(46, 125, 50, 0.5);">
              <span class="tool-icon">ğŸ¦µğŸ¦µ</span>
              <span>Both Legs (172V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanTorso(this)" style="grid-column: 1 / -1; background: rgba(255, 193, 7, 0.2); border: 2px solid rgba(255, 193, 7, 0.4);">
              <span class="tool-icon">ğŸ¦´</span>
              <span>Load Torso (120V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanHead(this)" style="grid-column: 1 / -1; background: rgba(156, 39, 176, 0.2); border: 2px solid rgba(156, 39, 176, 0.4);">
              <span class="tool-icon">ğŸ§ </span>
              <span>Load Head (100V)</span>
            </button>
            <button class="tool-btn" onclick="loadFullBody(this)" style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(255, 64, 129, 0.3), rgba(63, 81, 181, 0.3)); border: 3px solid rgba(255, 255, 255, 0.6); box-shadow: 0 0 15px rgba(255, 64, 129, 0.4); font-weight: bold; font-size: 1.1em;">
              <span class="tool-icon">ğŸ§</span>
              <span>FULL BODY (564V)</span>
            </button>
            <button class="tool-btn" onclick="openAnatomyEditor()" style="grid-column: 1 / -1; background: rgba(255, 165, 0, 0.2); border: 2px solid rgba(255, 165, 0, 0.4);">
              <span class="tool-icon">âœï¸</span>
              <span>Edit Anatomy (Advanced)</span>
            </button>
          </div>
        </div>

        <!-- ARM ARTICULATION -->
        <div class="section" id="armArticulation" style="display: none;">
          <div class="section-title">ğŸ’ª Arm Articulation</div>
          <div style="margin-bottom: 15px;">
            <label style="font-size: 12px; color: #888; display: flex; justify-content: space-between; margin-bottom: 5px;">
              <span>Elbow Angle</span>
              <span id="elbowAngleValue" style="color: #00ff88;">180Â°</span>
            </label>
            <input type="range" id="elbowAngle" min="180" max="340" value="180" step="1" 
                   oninput="updateElbowAngle(parseInt(this.value))"
                   style="width: 100%; cursor: pointer;">
            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;">
              <span>180Â° (straight)</span>
              <span>340Â° (bent)</span>
            </div>
          </div>
        </div>

        <!-- NECK SWIVEL -->
        <div class="section" id="neckSwivel" style="display: none;">
          <div class="section-title">ğŸ”„ Neck Swivel</div>
          <div style="margin-bottom: 15px;">
            <label style="font-size: 12px; color: #888; display: flex; justify-content: space-between; margin-bottom: 5px;">
              <span>Head Rotation</span>
              <span id="neckSwivelValue" style="color: #00ff88;">0Â°</span>
            </label>
            <input type="range" id="neckSwivelAngle" min="-180" max="180" value="0" step="1" 
                   oninput="updateNeckSwivel(parseInt(this.value))"
                   style="width: 100%; cursor: pointer;">
            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;">
              <span>-180Â° (left)</span>
              <span>0Â° (center)</span>
              <span>180Â° (right)</span>
            </div>
          </div>
        </div>

        <!-- LEARN MODE TOGGLE -->
        <div class="section">
          <div class="section-title">ğŸ“š Learn Mode</div>
          <button class="tool-btn" id="learnModeToggle" onclick="toggleLearnMode(this)" style="width: 100%; background: rgba(0, 255, 136, 0.1); border: 2px solid rgba(0, 255, 136, 0.3);">
            <span class="tool-icon">ğŸ‘¨â€ğŸ«</span>
            <span>Enable Story Mode</span>
          </button>
          <div id="learnModeInfo" style="display: none; margin-top: 10px; padding: 12px; background: rgba(0, 255, 136, 0.1); border-radius: 8px; font-size: 11px; line-height: 1.5; color: rgba(255, 255, 255, 0.9);">
            <strong>Learn Mode Active!</strong><br>
            Click any Mathematical Method below to see the mathematician's story and how their discovery powers your creations! ğŸ†
          </div>
        </div>

        <!-- MATHEMATICAL METHODS -->
        <div class="section">
          <div class="section-title">ğŸ† Mathematical Methods</div>
          <div class="tool-grid">
            <button class="tool-btn active" onclick="selectMethod('fibonacci', this)">
              <span class="tool-icon">ğŸ‡®ğŸ‡¹</span>
              <span>Fibonacci</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('catmull', this)">
              <span class="tool-icon">ğŸ‡ºğŸ‡¸</span>
              <span>Catmull-Rom</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('bezier', this)">
              <span class="tool-icon">ğŸ‡«ğŸ‡·</span>
              <span>BÃ©zier</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('perlin', this)">
              <span class="tool-icon">ğŸ®</span>
              <span>Perlin Noise</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('quaternion', this)">
              <span class="tool-icon">ğŸ‡®ğŸ‡ª</span>
              <span>Quaternion</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('lsystem', this)">
              <span class="tool-icon">ğŸ‡­ğŸ‡º</span>
              <span>L-System</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('voronoi', this)">
              <span class="tool-icon">ğŸ‡ºğŸ‡¦</span>
              <span>Voronoi</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('phong', this)">
              <span class="tool-icon">ğŸ‡»ğŸ‡³</span>
              <span>Phong</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('delaunay', this)">
              <span class="tool-icon">ğŸ‡·ğŸ‡º</span>
              <span>Delaunay</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('subdivision', this)">
              <span class="tool-icon">ğŸ’</span>
              <span>Subdivision</span>
            </button>
          </div>
        </div>

        <!-- MATHEMATICIAN STORY PANEL -->
        <div id="mathematicianStory" class="section" style="display: none;">
          <div class="section-title" id="storyTitle">ğŸ† Mathematician Story</div>
          <div style="padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 2px solid rgba(102, 126, 234, 0.3);">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
              <span id="storyFlag" style="font-size: 24px;">ğŸ‡®ğŸ‡¹</span>
              <div>
                <div id="storyName" style="font-weight: 700; font-size: 14px; color: #00ff88;">Leonardo Fibonacci</div>
                <div id="storyDates" style="font-size: 11px; opacity: 0.8;">1170-1250</div>
              </div>
            </div>
            <div id="storyDiscovery" style="font-size: 12px; font-weight: 600; color: #667eea; margin-bottom: 8px;">
              Discovery: Fibonacci Sequence
            </div>
            <div id="storyText" style="font-size: 11px; line-height: 1.6; margin-bottom: 10px; color: rgba(255, 255, 255, 0.9);">
              Italian mathematician who discovered the famous sequence (0,1,1,2,3,5,8...) while studying rabbit populations.
            </div>
            <div style="background: rgba(0, 255, 136, 0.1); padding: 8px; border-radius: 6px; border-left: 3px solid #00ff88;">
              <div style="font-size: 10px; font-weight: 700; color: #00ff88; margin-bottom: 4px;">ğŸ’¡ KID FACT:</div>
              <div id="storyKidFact" style="font-size: 11px; line-height: 1.5;">
                He introduced Arabic numerals (0-9) to Europe! Before him, Europeans used Roman numerals.
              </div>
            </div>
          </div>
        </div>

        <div class="section">
          <div class="section-title">âš™ï¸ Settings</div>
          <div class="slider-control">
            <div class="slider-label">
              <span>Size</span>
              <span id="sizeValue">0.5</span>
            </div>
            <input type="range" min="0.1" max="2" step="0.1" value="0.5" oninput="updateSize(this.value)">
          </div>
          <div class="slider-control">
            <div class="slider-label">
              <span>Angle</span>
              <span id="angleValue">0Â°</span>
            </div>
            <input type="range" min="0" max="360" step="15" value="0" oninput="updateAngle(this.value)">
          </div>
        </div>

        <div class="section">
          <div class="section-title">ğŸ¯ Actions</div>
          <button class="tool-btn" onclick="clearScene()" style="width: 100%; grid-column: 1 / -1;">
            <span class="tool-icon">ğŸ—‘ï¸</span>
            <span>Clear All</span>
          </button>
        </div>
      </div>

      <!-- CSS Designer Workspace -->
      <div id="workspace-css" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">ğŸ’… CSS Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Gradient generator coming soon!')">
              <span class="tool-icon">ğŸŒˆ</span>
              <span>Gradient</span>
            </button>
            <button class="tool-btn" onclick="alert('Shadow generator coming soon!')">
              <span class="tool-icon">ğŸŒ«ï¸</span>
              <span>Shadow</span>
            </button>
            <button class="tool-btn" onclick="alert('Border designer coming soon!')">
              <span class="tool-icon">ğŸ”²</span>
              <span>Border</span>
            </button>
            <button class="tool-btn" onclick="alert('Animation builder coming soon!')">
              <span class="tool-icon">ğŸ¬</span>
              <span>Animate</span>
            </button>
          </div>
        </div>
      </div>

      <!-- WordWeaver Workspace -->
      <div id="workspace-word" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">ğŸ“ Writing Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Text editor coming soon!')">
              <span class="tool-icon">âœï¸</span>
              <span>Editor</span>
            </button>
            <button class="tool-btn" onclick="alert('Templates coming soon!')">
              <span class="tool-icon">ğŸ“„</span>
              <span>Templates</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Campus Workspace -->
      <div id="workspace-campus" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">ğŸ« Campus Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Building designer coming soon!')">
              <span class="tool-icon">ğŸ¢</span>
              <span>Buildings</span>
            </button>
            <button class="tool-btn" onclick="alert('Layout planner coming soon!')">
              <span class="tool-icon">ğŸ—ºï¸</span>
              <span>Layout</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Perfect Workspace -->
      <div id="workspace-perfect" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">âœ¨ Perfect Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Perfect system coming soon!')">
              <span class="tool-icon">â­</span>
              <span>Optimize</span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <div id="viewport">
      <canvas id="canvas"></canvas>
      <div class="loading" id="loading">Initializing 3D Engine...</div>
    </div>

    <div id="footer">
      <div>Workspace: <strong id="workspaceDisplay">3D SCULPT</strong> | Mode: <strong id="modeDisplay">ADD</strong> | Primitive: <strong id="primitiveDisplay">SPHERE</strong></div>
      <div>Click viewport to place objects | Drag to rotate view</div>
      <div>Objects: <strong id="objectCount">0</strong> | Vertices: <strong id="vertexCount">0</strong></div>
    </div>
  </div>

  <script src="lib/three.min.js"></script>
  <script src="lib/OrbitControls.js"></script>
  <script src="lib/TransformControls.js"></script>
  <script>
    // State
    let scene, camera, renderer, controls, transformControl;
    let currentMode = 'add';
    let currentPrimitive = 'sphere';
    let primitiveSize = 0.5;
    let rotationAngle = 0;
    let objects = [];
    let selectedObject = null;
    let selectionBox = null; // Visual selection indicator
    let orbitEnabled = true; // Camera orbit control state
    let currentArmGroup = null; // Reference to loaded arm for articulation
    let armForearmPart = null; // Reference to forearm+hand section
    let currentHeadGroup = null; // Reference to loaded head
    let headNeckSwivel = null; // Reference to neck swivel group
    
    // Full body part references (for hierarchical selection)
    let fullBodyGroup = null;
    let bodyPartMap = new Map(); // Maps mesh objects to their body part names and control groups
    let selectedBodyPart = null; // Currently selected body part
    let bodyPartControlMode = null; // 'shoulder', 'elbow', 'wrist', 'hip', 'knee', 'ankle', 'neck'
    
    // Walking/Running animation state
    let walkModeEnabled = false; // Toggle between stationary animation and forward movement
    let walkCycleSpeed = 0; // 0 = stopped, 1-3 = walking, 4+ = running
    let walkCyclePhase = 0; // Current phase in walk cycle (0 to 2*PI)
    let lastWheelTime = 0;
    let walkDecayRate = 0.95; // How quickly walking slows down
    let leftLegGroup = null; // Reference to left leg for animation
    let rightLegGroup = null; // Reference to right leg for animation
    let leftArmGroupRef = null; // Reference to left arm for swing
    let rightArmGroupRef = null; // Reference to right arm for swing
    let leftKneeGroup = null; // Reference to left lower leg (for knee flexion)
    let rightKneeGroup = null; // Reference to right lower leg (for knee flexion)
    let leftFootGroup = null; // Reference to left foot (for heel-toe placement)
    let rightFootGroup = null; // Reference to right foot (for heel-toe placement)
    
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();

    // Initialize
    function init() {
      const canvas = document.getElementById('canvas');
      
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);
      scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);

      // Camera
      camera = new THREE.PerspectiveCamera(
        75,
        canvas.parentElement.offsetWidth / canvas.parentElement.offsetHeight,
        0.1,
        1000
      );
      camera.position.set(5, 5, 5);

      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.parentElement.offsetWidth, canvas.parentElement.offsetHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 2;
      controls.maxDistance = 50;

      // Transform Controls for object manipulation
      transformControl = new THREE.TransformControls(camera, renderer.domElement);
      transformControl.addEventListener('dragging-changed', function(event) {
        controls.enabled = !event.value;
      });
      scene.add(transformControl);
      
      // Keyboard: W=move, E=rotate, R=scale, Delete=remove
      window.addEventListener('keydown', function(event) {
        switch(event.key.toLowerCase()) {
          case 'w': 
            if (selectedObject) setTransformMode('translate');
            break;
          case 'e': 
            if (selectedObject) setTransformMode('rotate');
            break;
          case 'r': 
            if (selectedObject) setTransformMode('scale');
            break;
          case 'delete':
          case 'backspace':
            if (selectedObject) {
              scene.remove(selectedObject);
              objects = objects.filter(obj => obj !== selectedObject);
              transformControl.detach();
              selectedObject = null;
              
              // Remove selection box
              if (selectionBox) {
                scene.remove(selectionBox);
                selectionBox = null;
              }
              
              updateObjectCount();
            }
            break;
        }
      });

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 10, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0x667eea, 1, 100);
      pointLight.position.set(-5, 5, -5);
      scene.add(pointLight);

      // Ground plane
      const groundGeometry = new THREE.PlaneGeometry(50, 50);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a,
        roughness: 0.8,
        metalness: 0.2
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid
      const gridHelper = new THREE.GridHelper(50, 50, 0x667eea, 0x2a2a2a);
      scene.add(gridHelper);

      // Events
      canvas.addEventListener('click', onCanvasClick);
      canvas.addEventListener('wheel', onMouseWheel, { passive: false });
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', onKeyDown);

      // Hide loading
      document.getElementById('loading').style.display = 'none';

      // Start animation
      animate();
    }
    
    // Keyboard controls for body rotation in Walk Mode
    function onKeyDown(event) {
      if (!walkModeEnabled || !window.fullBodyGroup) return;
      
      const rotationSpeed = 0.05;
      
      switch(event.key.toLowerCase()) {
        case 'a':
        case 'arrowleft':
          // Turn left
          window.fullBodyGroup.rotation.y += rotationSpeed;
          console.log('â†¶ Turning left');
          break;
        case 'd':
        case 'arrowright':
          // Turn right
          window.fullBodyGroup.rotation.y -= rotationSpeed;
          console.log('â†· Turning right');
          break;
        case 'w':
        case 'arrowup':
          // Speed up (simulate scroll)
          walkCycleSpeed = Math.min(walkCycleSpeed + 0.5, 10);
          lastWheelTime = Date.now();
          break;
        case 's':
        case 'arrowdown':
          // Slow down
          walkCycleSpeed = Math.max(walkCycleSpeed - 0.5, 0);
          break;
      }
    }

    // Toggle orbit controls on/off
    function toggleOrbitControls() {
      orbitEnabled = !orbitEnabled;
      controls.enabled = orbitEnabled;
      
      const btn = document.getElementById('orbitToggle');
      if (orbitEnabled) {
        btn.textContent = 'ğŸ¥ Orbit: ON';
        btn.style.background = 'rgba(76, 175, 80, 0.3)';
        btn.style.borderColor = 'rgba(76, 175, 80, 0.6)';
      } else {
        btn.textContent = 'ğŸ¥ Orbit: OFF';
        btn.style.background = 'rgba(244, 67, 54, 0.3)';
        btn.style.borderColor = 'rgba(244, 67, 54, 0.6)';
      }
      
      console.log(`ğŸ¥ Orbit controls: ${orbitEnabled ? 'ENABLED' : 'DISABLED'}`);
    }
    
    // Toggle Walk Mode (stationary animation vs. forward movement)
    function toggleWalkMode() {
      walkModeEnabled = !walkModeEnabled;
      
      const btn = document.getElementById('walkModeToggle');
      if (walkModeEnabled) {
        btn.textContent = 'ğŸš¶ Walk Mode: ON';
        btn.style.background = 'rgba(255, 165, 0, 0.3)';
        btn.style.borderColor = 'rgba(255, 165, 0, 0.6)';
        console.log('ğŸš¶ WALK MODE ENABLED: Body will move forward when scrolling!');
        console.log('   â†’ Scroll mouse wheel to walk/run through the scene');
        console.log('   â†’ Camera follows body automatically');
        
        // Disable orbit controls in walk mode
        if (orbitEnabled) {
          toggleOrbitControls();
        }
      } else {
        btn.textContent = 'ğŸš¶ Walk Mode: OFF';
        btn.style.background = 'rgba(255,165,0,0.15)';
        btn.style.borderColor = 'rgba(255,165,0,0.3)';
        console.log('ğŸš¶ Walk Mode DISABLED: Body stays in place (stationary animation)');
        
        // Re-enable orbit controls
        if (!orbitEnabled) {
          toggleOrbitControls();
        }
      }
    }
    
    // Procedural walking/running animation with realistic biomechanics
    function updateWalkingAnimation() {
      // Decay walk speed over time if no wheel input
      const timeSinceWheel = Date.now() - lastWheelTime;
      if (timeSinceWheel > 100) { // Start decaying after 100ms
        walkCycleSpeed *= walkDecayRate;
        if (walkCycleSpeed < 0.01) {
          walkCycleSpeed = 0;
          walkCyclePhase = 0; // Reset phase when stopped
        }
      }
      
      // Only animate if walking/running
      if (walkCycleSpeed > 0 && leftLegGroup && rightLegGroup && leftKneeGroup && rightKneeGroup) {
        // Determine animation speed based on walk/run state
        const isRunning = walkCycleSpeed > 4;
        const cycleSpeedMultiplier = isRunning ? 0.15 : 0.08;
        walkCyclePhase += walkCycleSpeed * cycleSpeedMultiplier;
        
        // === BIOMECHANICAL WALKING CYCLE ===
        // Phase 0-PI: Right leg forward (heel strike), left leg back (toe-off)
        // Phase PI-2PI: Left leg forward (heel strike), right leg back (toe-off)
        
        const legSwingAmplitude = isRunning ? 0.6 : 0.4; // Hip swing
        const kneeFlexionMax = isRunning ? 1.2 : 0.8; // Knee bend angle
        const armSwingAmplitude = isRunning ? 0.5 : 0.3;
        
        // === RIGHT LEG CYCLE ===
        const rightPhase = walkCyclePhase % (Math.PI * 2);
        
        // Right leg hip swing
        const rightHipSwing = Math.sin(rightPhase) * legSwingAmplitude;
        rightLegGroup.rotation.x = rightHipSwing;
        
        // Right knee flexion (bends during swing phase)
        if (rightPhase < Math.PI) {
          // Swing phase: knee flexes to lift foot
          const flexProgress = Math.sin(rightPhase); // 0 to 1 to 0
          rightKneeGroup.rotation.x = -flexProgress * kneeFlexionMax; // Negative = bend forward
        } else {
          // Stance phase: knee mostly straight (slight flex for cushioning)
          const stanceProgress = Math.sin(rightPhase - Math.PI);
          rightKneeGroup.rotation.x = -stanceProgress * 0.2; // Slight bend
        }
        
        // Right foot heel-toe placement
        if (rightPhase < Math.PI * 0.3) {
          // Heel strike - dorsiflexion (toe up)
          rightFootGroup.rotation.x = 0.3;
        } else if (rightPhase < Math.PI * 0.7) {
          // Mid-stance - foot flat
          rightFootGroup.rotation.x = 0;
        } else if (rightPhase < Math.PI) {
          // Toe-off - plantarflexion (toe push)
          rightFootGroup.rotation.x = -0.4;
        } else {
          // Swing phase - neutral
          rightFootGroup.rotation.x = 0.1;
        }
        
        // === LEFT LEG CYCLE (opposite phase) ===
        const leftPhase = (walkCyclePhase + Math.PI) % (Math.PI * 2);
        
        // Left leg hip swing
        const leftHipSwing = Math.sin(leftPhase) * legSwingAmplitude;
        leftLegGroup.rotation.x = leftHipSwing;
        
        // Left knee flexion
        if (leftPhase < Math.PI) {
          // Swing phase: knee flexes
          const flexProgress = Math.sin(leftPhase);
          leftKneeGroup.rotation.x = -flexProgress * kneeFlexionMax;
        } else {
          // Stance phase: knee mostly straight
          const stanceProgress = Math.sin(leftPhase - Math.PI);
          leftKneeGroup.rotation.x = -stanceProgress * 0.2;
        }
        
        // Left foot heel-toe placement
        if (leftPhase < Math.PI * 0.3) {
          // Heel strike
          leftFootGroup.rotation.x = 0.3;
        } else if (leftPhase < Math.PI * 0.7) {
          // Mid-stance
          leftFootGroup.rotation.x = 0;
        } else if (leftPhase < Math.PI) {
          // Toe-off
          leftFootGroup.rotation.x = -0.4;
        } else {
          // Swing phase
          leftFootGroup.rotation.x = 0.1;
        }
        
        // === ARM SWING (opposite to legs) ===
        const leftArmSwing = Math.sin(leftPhase) * armSwingAmplitude;
        const rightArmSwing = Math.sin(rightPhase) * armSwingAmplitude;
        
        if (leftArmGroupRef) {
          leftArmGroupRef.rotation.x = leftArmSwing;
        }
        if (rightArmGroupRef) {
          rightArmGroupRef.rotation.x = rightArmSwing;
        }
        
        // === BODY BOB (vertical center of mass movement) ===
        const bobAmount = isRunning ? 0.15 : 0.08;
        const bodyBob = Math.abs(Math.sin(walkCyclePhase * 2)) * bobAmount;
        if (window.fullBodyGroup) {
          window.fullBodyGroup.position.y = bodyBob;
          
          // If Walk Mode is enabled, move body forward
          if (walkModeEnabled) {
            const forwardSpeed = isRunning ? 0.08 : 0.04; // Running is 2x faster
            const bodyRotation = window.fullBodyGroup.rotation.y; // Face direction
            
            // Move forward based on body's facing direction
            window.fullBodyGroup.position.x += Math.sin(bodyRotation) * walkCycleSpeed * forwardSpeed;
            window.fullBodyGroup.position.z += Math.cos(bodyRotation) * walkCycleSpeed * forwardSpeed;
            
            // Camera follows body
            const cameraOffset = new THREE.Vector3(5, 5, 5); // Offset behind and above
            const cameraTargetPos = window.fullBodyGroup.position.clone();
            
            // Rotate camera offset based on body rotation
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), bodyRotation);
            
            // Smooth camera follow
            camera.position.lerp(cameraTargetPos.clone().add(cameraOffset), 0.1);
            camera.lookAt(cameraTargetPos);
          }
        }
        
        // Log state transitions
        if (walkCycleSpeed < 1 && walkCycleSpeed > 0.1) {
          // Slowing down
        } else if (walkCycleSpeed < 0.1 && walkCycleSpeed > 0.01) {
          console.log('ğŸ›‘ Coming to a stop...');
        }
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      
      // Update walking/running animation
      updateWalkingAnimation();
      
      // Update selection box to follow selected object
      if (selectionBox && selectedObject) {
        selectionBox.update();
      }
      
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const canvas = document.getElementById('canvas');
      camera.aspect = canvas.parentElement.offsetWidth / canvas.parentElement.offsetHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.parentElement.offsetWidth, canvas.parentElement.offsetHeight);
    }

    function onCanvasClick(event) {
      const canvas = document.getElementById('canvas');
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      // Check if clicking existing object to select it
      const intersects = raycaster.intersectObjects(objects, true);
      
      if (intersects.length > 0) {
        // Check if this is a body part (for hierarchical control)
        const clickedMesh = intersects[0].object;
        const bodyPartInfo = getBodyPartFromMesh(clickedMesh);
        
        if (bodyPartInfo) {
          handleBodyPartSelection(bodyPartInfo, clickedMesh);
          return;
        }
        
        // Find the root object (in case of groups like anatomical arm)
        let clickedObject = intersects[0].object;
        while (clickedObject.parent && !objects.includes(clickedObject)) {
          clickedObject = clickedObject.parent;
        }
        
        selectedObject = clickedObject;
        selectedBodyPart = null; // Clear body part selection when selecting whole object
        bodyPartControlMode = null;
        
        // Don't auto-attach transform, just select
        console.log('âœ… Object selected - Click Move/Rotate/Scale or press W/E/R');
        return;
      }
      
      // Otherwise place new object on ground
      if (currentMode === 'add') {
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(groundPlane, intersectPoint);

        if (intersectPoint) {
          placePrimitive(intersectPoint);
        }
      }
    }
    
    // Detect which body part was clicked
    function getBodyPartFromMesh(mesh) {
      // Traverse up to find labeled groups
      let current = mesh;
      while (current) {
        if (current.userData && current.userData.bodyPart) {
          return {
            part: current.userData.bodyPart,
            group: current.userData.controlGroup || current,
            name: current.userData.partName || current.userData.bodyPart
          };
        }
        current = current.parent;
      }
      return null;
    }
    
    // Handle body part selection and enable specific controls
    function handleBodyPartSelection(bodyPartInfo, mesh) {
      selectedBodyPart = bodyPartInfo.group;
      bodyPartControlMode = bodyPartInfo.part;
      
      console.log(`ğŸ¯ Selected: ${bodyPartInfo.name}`);
      
      // Enable specific controls based on body part
      switch(bodyPartInfo.part) {
        case 'leftArm':
        case 'rightArm':
          console.log('ğŸ’ª ARM CONTROL: Click and drag to rotate at shoulder');
          console.log('   Hold SHIFT + drag for elbow bend');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'leftHand':
        case 'rightHand':
          console.log('âœ‹ HAND CONTROL: Mouse wheel to rotate wrist');
          console.log('   Click and drag to move hand position');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'head':
          console.log('ğŸ§  HEAD CONTROL: Click and drag to swivel neck');
          console.log('   Or use neck swivel slider');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          document.getElementById('neckSwivelControls').style.display = 'block';
          break;
          
        case 'leftLeg':
        case 'rightLeg':
          console.log('ğŸ¦µ LEG CONTROL: Click and drag to rotate at hip');
          console.log('   Hold SHIFT + drag for knee bend');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'torso':
          console.log('ğŸ¦´ TORSO CONTROL: Click and drag to bend/twist spine');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'leftFoot':
        case 'rightFoot':
          console.log('ğŸ‘Ÿ FOOT CONTROL: Click and drag to rotate ankle');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        default:
          console.log('âœ… Body part selected');
          break;
      }
      
      // Select the root object for whole-body movement
      selectedObject = fullBodyGroup || objects.find(obj => obj.children.length > 0);
    }
    
    // Mouse wheel handler for wrist/hand rotation OR walking animation
    function onMouseWheel(event) {
      // If hand is selected, rotate wrist
      if (selectedBodyPart && (bodyPartControlMode === 'leftHand' || bodyPartControlMode === 'rightHand')) {
        event.preventDefault();
        const rotationSpeed = 0.002;
        const delta = event.deltaY * rotationSpeed;
        selectedBodyPart.rotation.z += delta;
        console.log(`âœ‹ Wrist rotation: ${(selectedBodyPart.rotation.z * 180 / Math.PI).toFixed(1)}Â°`);
        return;
      }
      
      // If whole body is selected OR clicking on body triggers walking/running
      // Check if fullBodyGroup exists and either selected or we're in the scene
      if (window.fullBodyGroup && !selectedBodyPart) {
        event.preventDefault();
        
        // Update walk speed based on wheel delta
        const wheelSpeed = Math.abs(event.deltaY) / 100;
        walkCycleSpeed = Math.min(walkCycleSpeed + wheelSpeed, 10); // Cap at 10 (full sprint)
        lastWheelTime = Date.now();
        
        // Log state changes
        if (walkCycleSpeed < 1 && walkCycleSpeed > 0) {
          console.log('ğŸš¶ Starting to walk...');
        } else if (walkCycleSpeed > 4 && walkCycleSpeed < 5) {
          console.log('ğŸƒ Breaking into a run!');
        } else if (walkCycleSpeed > 7) {
          console.log('ğŸ’¨ Full sprint!');
        }
        
        return;
      }
    }

    function placePrimitive(position) {
      let geometry;
      
      switch(currentPrimitive) {
        case 'sphere':
          geometry = new THREE.SphereGeometry(primitiveSize, 32, 32);
          break;
        case 'cube':
          geometry = new THREE.BoxGeometry(primitiveSize, primitiveSize, primitiveSize);
          break;
        case 'cylinder':
          geometry = new THREE.CylinderGeometry(primitiveSize, primitiveSize, primitiveSize * 2, 32);
          break;
        case 'cone':
          geometry = new THREE.ConeGeometry(primitiveSize, primitiveSize * 2, 32);
          break;
        case 'torus':
          geometry = new THREE.TorusGeometry(primitiveSize, primitiveSize * 0.3, 16, 32);
          break;
        case 'pyramid':
          geometry = new THREE.ConeGeometry(primitiveSize, primitiveSize * 1.5, 4);
          break;
      }

      const material = new THREE.MeshStandardMaterial({
        color: currentMode === 'add' ? 0x00ff88 : 0xff3366,
        roughness: 0.7,
        metalness: 0.3,
        transparent: true,
        opacity: 0.9
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.position.y = primitiveSize / 2;
      mesh.rotation.y = (rotationAngle * Math.PI) / 180;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData.mode = currentMode;

      scene.add(mesh);
      objects.push(mesh);
      
      updateObjectCount();
      console.log(`Placed ${currentPrimitive} at`, position);
    }

    function setMode(mode, btn) {
      currentMode = mode;
      document.querySelectorAll('#sidebar .tool-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('modeDisplay').textContent = mode.toUpperCase();
      
      // Detach transform and remove selection box when switching to add mode
      if (mode === 'add' && selectedObject) {
        transformControl.detach();
        selectedObject = null;
        
        if (selectionBox) {
          scene.remove(selectionBox);
          selectionBox = null;
        }
      }
    }

    function setTransformMode(mode) {
      if (!selectedObject) {
        alert('âš ï¸ Click an object first to select it!\n\n1. Click any object in the scene\n2. Then use Move/Rotate/Scale buttons\n3. Or press W/E/R keys');
        return;
      }
      
      // Disable orbit controls when using transform
      if (orbitEnabled) {
        orbitEnabled = false;
        controls.enabled = false;
        const btn = document.getElementById('orbitToggle');
        btn.textContent = 'ğŸ¥ Orbit: OFF';
        btn.style.background = 'rgba(244, 67, 54, 0.3)';
        btn.style.borderColor = 'rgba(244, 67, 54, 0.6)';
      }
      
      transformControl.setMode(mode);
      
      // Show selection box when entering transform mode
      if (!selectionBox && selectedObject) {
        selectionBox = new THREE.BoxHelper(selectedObject, 0x00ff88);
        scene.add(selectionBox);
      }
      console.log(`ğŸ¨ Transform mode: ${mode.toUpperCase()}`);
    }

    function setPrimitive(primitive, btn) {
      currentPrimitive = primitive;
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('primitiveDisplay').textContent = primitive.toUpperCase();
    }

    // ğŸ¦¾ HUMAN ANATOMY LOADER (86-Vertex System)
    function loadHumanAnatomy(btn) {
      console.log('ğŸ¦¾ Loading 86-vertex human anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical arm with 86 vertices
      const armGroup = new THREE.Group();
      const vertexCount = 86;
      
      // Shoulder (origin point)
      const shoulderGeom = new THREE.SphereGeometry(0.3, 8, 8);
      const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
      armGroup.add(shoulder);
      
      // Upper arm (14" / 35cm extended cylinder)
      const upperArmGeom = new THREE.CylinderGeometry(0.2, 0.18, 3.5, 16);
      const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
      upperArm.position.y = -1.75;
      armGroup.add(upperArm);
      
      // Elbow joint (180Â° pivot capability)
      const elbowGeom = new THREE.SphereGeometry(0.22, 8, 8);
      const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const elbow = new THREE.Mesh(elbowGeom, elbowMat);
      elbow.position.y = -3.5;
      armGroup.add(elbow);
      
      // Create forearm group for articulation (rotates at elbow)
      const forearmGroup = new THREE.Group();
      forearmGroup.position.y = -3.5; // At elbow position
      armGroup.add(forearmGroup);
      
      // Forearm (14" / 35cm) - relative to elbow
      const forearmGeom = new THREE.CylinderGeometry(0.18, 0.15, 3.5, 16);
      const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const forearm = new THREE.Mesh(forearmGeom, forearmMat);
      forearm.position.y = -1.75; // Relative to elbow
      forearmGroup.add(forearm);
      
      // Wrist joint
      const wristGeom = new THREE.SphereGeometry(0.16, 8, 8);
      const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const wrist = new THREE.Mesh(wristGeom, wristMat);
      wrist.position.y = -3.5; // Relative to elbow
      forearmGroup.add(wrist);
      
      // Wrist bone protrusion (270-300Â° styloid process)
      const wristBoneGeom = new THREE.SphereGeometry(0.01, 8, 8);
      const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
      wristBone.position.set(0.15, -3.5, 0); // Relative to elbow
      forearmGroup.add(wristBone);
      
      // Hand (oval with 40% growth + curl)
      const handGeom = new THREE.BoxGeometry(0.4, 0.6, 0.15);
      const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const hand = new THREE.Mesh(handGeom, handMat);
      hand.position.y = -4.3; // Relative to elbow
      hand.rotation.x = Math.PI / 8; // 45Â° curl
      forearmGroup.add(hand);
      
      // Thumb (190Â° hump alignment)
      const thumbGeom = new THREE.CylinderGeometry(0.08, 0.06, 0.5, 8);
      const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const thumb = new THREE.Mesh(thumbGeom, thumbMat);
      thumb.position.set(-0.25, -4.1, 0.1); // Relative to elbow
      thumb.rotation.z = -Math.PI / 3;
      forearmGroup.add(thumb);
      
      // 4 Fingers (progressive sizing: 3.5" base, -10% per finger)
      const fingerLengths = [0.875, 0.7875, 0.7, 0.6125];
      for (let i = 0; i < 4; i++) {
        const fingerGeom = new THREE.CylinderGeometry(0.06 * (1 - i * 0.1), 0.04 * (1 - i * 0.1), fingerLengths[i], 8);
        const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const finger = new THREE.Mesh(fingerGeom, fingerMat);
        finger.position.set(-0.15 + (i * 0.1), -4.8, 0); // Relative to elbow
        finger.rotation.x = Math.PI / 12;
        forearmGroup.add(finger);
        
        // Fingertip (spherical)
        const tipGeom = new THREE.SphereGeometry(0.05 * (1 - i * 0.1), 8, 8);
        const tipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const tip = new THREE.Mesh(tipGeom, tipMat);
        tip.position.set(-0.15 + (i * 0.1), -4.8 - fingerLengths[i] / 2, 0); // Relative to elbow
        forearmGroup.add(tip);
      }
      
      // Store references for articulation
      currentArmGroup = armGroup;
      armForearmPart = forearmGroup;
      
      // Position the arm group so hand rests on ground
      armGroup.position.set(0, 8.75, 0);
      scene.add(armGroup);
      objects.push(armGroup);
      
      // Show articulation controls
      document.getElementById('armArticulation').style.display = 'block';
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HUMAN ARM (${vertexCount}V)`;
      
      console.log(`âœ… Anatomical arm loaded: ${vertexCount} vertices - shoulder, upper arm, elbow, forearm, wrist, hand, thumb, 4 fingers - ARTICULATION ENABLED`);
    }
    
    // ğŸ¦¾ğŸ¦¾ DUAL ARMS LOADER (172 Vertices Total)
    function loadBothArms(btn) {
      console.log('ğŸ¦¾ğŸ¦¾ Loading both arms (left + right)...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      const bothArmsGroup = new THREE.Group();
      const totalVertexCount = 172;
      
      // Helper function to create a single arm
      function createArm(xOffset, isRight = false) {
        const armGroup = new THREE.Group();
        
        // Shoulder
        const shoulderGeom = new THREE.SphereGeometry(0.3, 8, 8);
        const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
        armGroup.add(shoulder);
        
        // Upper arm
        const upperArmGeom = new THREE.CylinderGeometry(0.2, 0.18, 3.5, 16);
        const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
        upperArm.position.y = -1.75;
        armGroup.add(upperArm);
        
        // Elbow joint
        const elbowGeom = new THREE.SphereGeometry(0.22, 8, 8);
        const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const elbow = new THREE.Mesh(elbowGeom, elbowMat);
        elbow.position.y = -3.5;
        armGroup.add(elbow);
        
        // Forearm group for articulation
        const forearmGroup = new THREE.Group();
        forearmGroup.position.y = -3.5;
        armGroup.add(forearmGroup);
        
        // Forearm
        const forearmGeom = new THREE.CylinderGeometry(0.18, 0.15, 3.5, 16);
        const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const forearm = new THREE.Mesh(forearmGeom, forearmMat);
        forearm.position.y = -1.75;
        forearmGroup.add(forearm);
        
        // Wrist
        const wristGeom = new THREE.SphereGeometry(0.16, 8, 8);
        const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const wrist = new THREE.Mesh(wristGeom, wristMat);
        wrist.position.y = -3.5;
        forearmGroup.add(wrist);
        
        // Wrist bone (mirror for right arm)
        const wristBoneGeom = new THREE.SphereGeometry(0.01, 8, 8);
        const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
        wristBone.position.set(isRight ? -0.15 : 0.15, -3.5, 0);
        forearmGroup.add(wristBone);
        
        // Hand
        const handGeom = new THREE.BoxGeometry(0.4, 0.6, 0.15);
        const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hand = new THREE.Mesh(handGeom, handMat);
        hand.position.y = -4.3;
        hand.rotation.x = Math.PI / 8;
        forearmGroup.add(hand);
        
        // Thumb (mirror position for right arm)
        const thumbGeom = new THREE.CylinderGeometry(0.08, 0.06, 0.5, 8);
        const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thumb = new THREE.Mesh(thumbGeom, thumbMat);
        thumb.position.set(isRight ? 0.25 : -0.25, -4.1, 0.1);
        thumb.rotation.z = isRight ? Math.PI / 3 : -Math.PI / 3;
        forearmGroup.add(thumb);
        
        // 4 Fingers
        const fingerLengths = [0.875, 0.7875, 0.7, 0.6125];
        for (let i = 0; i < 4; i++) {
          const fingerGeom = new THREE.CylinderGeometry(0.06 * (1 - i * 0.1), 0.04 * (1 - i * 0.1), fingerLengths[i], 8);
          const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const finger = new THREE.Mesh(fingerGeom, fingerMat);
          const xPos = isRight ? 0.15 - (i * 0.1) : -0.15 + (i * 0.1);
          finger.position.set(xPos, -4.8, 0);
          finger.rotation.x = Math.PI / 12;
          forearmGroup.add(finger);
          
          // Fingertip
          const tipGeom = new THREE.SphereGeometry(0.05 * (1 - i * 0.1), 8, 8);
          const tipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const tip = new THREE.Mesh(tipGeom, tipMat);
          tip.position.set(xPos, -4.8 - fingerLengths[i] / 2, 0);
          forearmGroup.add(tip);
        }
        
        // Position arm at shoulder offset
        armGroup.position.set(xOffset, 0, 0);
        
        return { armGroup, forearmGroup };
      }
      
      // Create left arm (negative X)
      const leftArm = createArm(-1.2, false);
      bothArmsGroup.add(leftArm.armGroup);
      
      // Create right arm (positive X)
      const rightArm = createArm(1.2, true);
      bothArmsGroup.add(rightArm.armGroup);
      
      // Position both arms at shoulder height
      bothArmsGroup.position.set(0, 8.75, 0);
      scene.add(bothArmsGroup);
      objects.push(bothArmsGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `BOTH ARMS (${totalVertexCount}V)`;
      
      console.log(`âœ… Both arms loaded: ${totalVertexCount} vertices (86V Ã— 2) - left shoulder at X=-1.2, right shoulder at X=1.2`);
    }
    
    // Update elbow angle (180Â° = straight, 340Â° = fully bent)
    function updateElbowAngle(angle) {
      if (!armForearmPart) {
        console.warn('âš ï¸ No arm loaded for articulation');
        return;
      }
      
      // Convert angle to radians (180Â° = 0 rad, 340Â° = bent forward)
      // Rotate around X axis to bend elbow
      const bendAngle = (angle - 180) * (Math.PI / 180);
      armForearmPart.rotation.x = bendAngle;
      
      // Update display
      document.getElementById('elbowAngleValue').textContent = angle + 'Â°';
      
      console.log(`ğŸ’ª Elbow angle: ${angle}Â° (${bendAngle.toFixed(2)} rad)`);
    }

    // ğŸ¦µ HUMAN LEG LOADER (86-Vertex System)
    function loadHumanLeg(btn) {
      console.log('ğŸ¦µ Loading 86-vertex leg anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical leg with 86 vertices
      const legGroup = new THREE.Group();
      const vertexCount = 86;
      
      // Hip joint (origin point)
      const hipGeom = new THREE.SphereGeometry(0.35, 8, 8);
      const hipMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const hip = new THREE.Mesh(hipGeom, hipMat);
      legGroup.add(hip);
      
      // Thigh (14" / 35cm extended cylinder)
      const thighGeom = new THREE.CylinderGeometry(0.25, 0.22, 3.5, 16);
      const thighMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const thigh = new THREE.Mesh(thighGeom, thighMat);
      thigh.position.y = -1.75;
      legGroup.add(thigh);
      
      // Knee joint (180Â° pivot capability)
      const kneeGeom = new THREE.SphereGeometry(0.24, 8, 8);
      const kneeMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const knee = new THREE.Mesh(kneeGeom, kneeMat);
      knee.position.y = -3.5;
      legGroup.add(knee);
      
      // Calf (14" / 35cm)
      const calfGeom = new THREE.CylinderGeometry(0.22, 0.18, 3.5, 16);
      const calfMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const calf = new THREE.Mesh(calfGeom, calfMat);
      calf.position.y = -5.25;
      legGroup.add(calf);
      
      // Ankle joint
      const ankleGeom = new THREE.SphereGeometry(0.18, 8, 8);
      const ankleMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const ankle = new THREE.Mesh(ankleGeom, ankleMat);
      ankle.position.y = -7;
      legGroup.add(ankle);
      
      // Ankle bone protrusion (malleolus)
      const ankleBoneGeom = new THREE.SphereGeometry(0.012, 8, 8);
      const ankleBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const ankleBone = new THREE.Mesh(ankleBoneGeom, ankleBoneMat);
      ankleBone.position.set(0.18, -7, 0);
      legGroup.add(ankleBone);
      
      // Foot (elongated with 40% growth)
      const footGeom = new THREE.BoxGeometry(0.35, 0.25, 0.8);
      const footMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const foot = new THREE.Mesh(footGeom, footMat);
      foot.position.set(0, -7.3, 0.3);
      foot.rotation.x = -Math.PI / 16; // Slight arch
      legGroup.add(foot);
      
      // Big toe (larger and separate)
      const bigToeGeom = new THREE.CylinderGeometry(0.07, 0.05, 0.35, 8);
      const bigToeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const bigToe = new THREE.Mesh(bigToeGeom, bigToeMat);
      bigToe.position.set(-0.12, -7.5, 0.65);
      bigToe.rotation.x = Math.PI / 2;
      legGroup.add(bigToe);
      
      // 4 Toes (progressive sizing: smaller than big toe, decreasing)
      const toeLengths = [0.28, 0.26, 0.24, 0.22]; // Progressive reduction
      for (let i = 0; i < 4; i++) {
        const toeGeom = new THREE.CylinderGeometry(0.045 * (1 - i * 0.08), 0.03 * (1 - i * 0.08), toeLengths[i], 8);
        const toeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const toe = new THREE.Mesh(toeGeom, toeMat);
        toe.position.set(-0.05 + (i * 0.08), -7.5, 0.65);
        toe.rotation.x = Math.PI / 2;
        legGroup.add(toe);
        
        // Toe tip (spherical)
        const toeTipGeom = new THREE.SphereGeometry(0.035 * (1 - i * 0.08), 8, 8);
        const toeTipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const toeTip = new THREE.Mesh(toeTipGeom, toeTipMat);
        toeTip.position.set(-0.05 + (i * 0.08), -7.5, 0.65 + toeLengths[i] / 2);
        legGroup.add(toeTip);
      }
      
      // Position the leg group so foot rests on ground (foot bottom is at ~Y=-7.5, so lift by 7.5)
      legGroup.position.set(0, 7.5, 0);
      scene.add(legGroup);
      objects.push(legGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HUMAN LEG (${vertexCount}V)`;
      
      console.log(`âœ… Anatomical leg loaded: ${vertexCount} vertices - hip, thigh, knee, calf, ankle, foot, big toe, 4 toes`);
    }

    // ï¿½ğŸ¦µ BOTH LEGS LOADER (172 Vertices Total - 86V each)
    function loadBothLegs(btn) {
      console.log('ğŸ¦µğŸ¦µ Loading both legs with symmetry...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Helper function to create a single leg with mirroring
      function createLeg(xOffset, isRight) {
        const legGroup = new THREE.Group();
        
        // Hip joint (origin point)
        const hipGeom = new THREE.SphereGeometry(0.35, 8, 8);
        const hipMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hip = new THREE.Mesh(hipGeom, hipMat);
        legGroup.add(hip);
        
        // Thigh (14" / 35cm extended cylinder)
        const thighGeom = new THREE.CylinderGeometry(0.25, 0.22, 3.5, 16);
        const thighMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thigh = new THREE.Mesh(thighGeom, thighMat);
        thigh.position.y = -1.75;
        legGroup.add(thigh);
        
        // Knee joint (180Â° pivot capability)
        const kneeGeom = new THREE.SphereGeometry(0.24, 8, 8);
        const kneeMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const knee = new THREE.Mesh(kneeGeom, kneeMat);
        knee.position.y = -3.5;
        legGroup.add(knee);
        
        // Calf (14" / 35cm)
        const calfGeom = new THREE.CylinderGeometry(0.22, 0.18, 3.5, 16);
        const calfMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const calf = new THREE.Mesh(calfGeom, calfMat);
        calf.position.y = -5.25;
        legGroup.add(calf);
        
        // Ankle joint
        const ankleGeom = new THREE.SphereGeometry(0.18, 8, 8);
        const ankleMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const ankle = new THREE.Mesh(ankleGeom, ankleMat);
        ankle.position.y = -7;
        legGroup.add(ankle);
        
        // Ankle bone protrusion (malleolus) - MIRRORED
        const ankleBoneGeom = new THREE.SphereGeometry(0.012, 8, 8);
        const ankleBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const ankleBone = new THREE.Mesh(ankleBoneGeom, ankleBoneMat);
        ankleBone.position.set(isRight ? 0.18 : -0.18, -7, 0); // Mirror X position
        legGroup.add(ankleBone);
        
        // Foot (elongated with 40% growth)
        const footGeom = new THREE.BoxGeometry(0.35, 0.25, 0.8);
        const footMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const foot = new THREE.Mesh(footGeom, footMat);
        foot.position.set(0, -7.3, 0.3);
        foot.rotation.x = -Math.PI / 16; // Slight arch
        legGroup.add(foot);
        
        // Big toe (larger and separate) - MIRRORED
        const bigToeGeom = new THREE.CylinderGeometry(0.07, 0.05, 0.35, 8);
        const bigToeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const bigToe = new THREE.Mesh(bigToeGeom, bigToeMat);
        bigToe.position.set(isRight ? -0.12 : 0.12, -7.5, 0.65); // Mirror X (big toe on inside)
        bigToe.rotation.x = Math.PI / 2;
        legGroup.add(bigToe);
        
        // 4 Toes (progressive sizing) - MIRRORED X positions
        const toeLengths = [0.28, 0.26, 0.24, 0.22]; // Progressive reduction
        for (let i = 0; i < 4; i++) {
          const toeGeom = new THREE.CylinderGeometry(0.045 * (1 - i * 0.08), 0.03 * (1 - i * 0.08), toeLengths[i], 8);
          const toeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const toe = new THREE.Mesh(toeGeom, toeMat);
          const toeXBase = isRight ? -0.05 : 0.05;
          const toeXOffset = isRight ? (i * 0.08) : -(i * 0.08);
          toe.position.set(toeXBase + toeXOffset, -7.5, 0.65);
          toe.rotation.x = Math.PI / 2;
          legGroup.add(toe);
          
          // Toe tip (spherical)
          const toeTipGeom = new THREE.SphereGeometry(0.035 * (1 - i * 0.08), 8, 8);
          const toeTipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const toeTip = new THREE.Mesh(toeTipGeom, toeTipMat);
          toeTip.position.set(toeXBase + toeXOffset, -7.5, 0.65 + toeLengths[i] / 2);
          legGroup.add(toeTip);
        }
        
        // Position leg at specified X offset
        legGroup.position.set(xOffset, 0, 0);
        return legGroup;
      }
      
      // Create container group for both legs
      const bothLegsGroup = new THREE.Group();
      
      // Create left leg (X = -0.4, at left hip)
      const leftLeg = createLeg(-0.4, false);
      bothLegsGroup.add(leftLeg);
      
      // Create right leg (X = 0.4, at right hip)
      const rightLeg = createLeg(0.4, true);
      bothLegsGroup.add(rightLeg);
      
      // Position both legs so feet rest on ground (foot bottom is at ~Y=-7.5, so lift by 7.5)
      bothLegsGroup.position.set(0, 7.5, 0);
      
      scene.add(bothLegsGroup);
      objects.push(bothLegsGroup);
      
      // Update UI
      const totalVertexCount = 172; // 86V Ã— 2 legs
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `BOTH LEGS (${totalVertexCount}V)`;
      
      console.log(`âœ… Both legs loaded: ${totalVertexCount} vertices (86V each) - left at X=-0.4, right at X=0.4`);
    }

    // ï¿½ğŸ¦´ HUMAN TORSO LOADER (120+ Vertices)
    function loadHumanTorso(btn) {
      console.log('ğŸ¦´ Loading torso anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical torso
      const torsoGroup = new THREE.Group();
      let vertexCount = 120;
      
      // Pelvis base (hip connector)
      const pelvisGeom = new THREE.CylinderGeometry(0.45, 0.5, 0.6, 16);
      const pelvisMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const pelvis = new THREE.Mesh(pelvisGeom, pelvisMat);
      pelvis.position.y = 0;
      torsoGroup.add(pelvis);
      
      // Lower spine (L1-L5 lumbar vertebrae)
      const lowerSpineGeom = new THREE.CylinderGeometry(0.12, 0.12, 1.2, 12);
      const spineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const lowerSpine = new THREE.Mesh(lowerSpineGeom, spineMat);
      lowerSpine.position.y = 0.9;
      torsoGroup.add(lowerSpine);
      
      // Mid spine (T7-T12 thoracic vertebrae)
      const midSpineGeom = new THREE.CylinderGeometry(0.13, 0.12, 1.5, 12);
      const midSpine = new THREE.Mesh(midSpineGeom, spineMat);
      midSpine.position.y = 2.25;
      torsoGroup.add(midSpine);
      
      // Upper spine (T1-T6 thoracic vertebrae)
      const upperSpineGeom = new THREE.CylinderGeometry(0.14, 0.13, 1.2, 12);
      const upperSpine = new THREE.Mesh(upperSpineGeom, spineMat);
      upperSpine.position.y = 3.6;
      torsoGroup.add(upperSpine);
      
      // Ribcage (12 ribs on each side)
      for (let i = 0; i < 12; i++) {
        const ribHeight = 2.0 + (i * 0.15);
        const ribWidth = 0.35 + (i * 0.04);
        const ribDepth = 0.25 + (i * 0.03);
        
        // Left rib
        const leftRibGeom = new THREE.TorusGeometry(ribWidth, 0.02, 8, 16, Math.PI);
        const ribMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const leftRib = new THREE.Mesh(leftRibGeom, ribMat);
        leftRib.position.set(-0.15, ribHeight, 0);
        leftRib.rotation.y = Math.PI / 2;
        leftRib.rotation.z = -Math.PI / 12;
        torsoGroup.add(leftRib);
        
        // Right rib
        const rightRib = new THREE.Mesh(leftRibGeom.clone(), ribMat);
        rightRib.position.set(0.15, ribHeight, 0);
        rightRib.rotation.y = -Math.PI / 2;
        rightRib.rotation.z = Math.PI / 12;
        torsoGroup.add(rightRib);
      }
      
      // Chest/sternum
      const chestGeom = new THREE.BoxGeometry(0.4, 1.8, 0.2);
      const chestMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.7 });
      const chest = new THREE.Mesh(chestGeom, chestMat);
      chest.position.set(0, 3.0, 0.35);
      torsoGroup.add(chest);
      
      // Left shoulder socket
      const leftShoulderGeom = new THREE.SphereGeometry(0.25, 8, 8);
      const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.6 });
      const leftShoulder = new THREE.Mesh(leftShoulderGeom, shoulderMat);
      leftShoulder.position.set(-0.6, 4.0, 0);
      torsoGroup.add(leftShoulder);
      
      // Right shoulder socket
      const rightShoulder = new THREE.Mesh(leftShoulderGeom, shoulderMat);
      rightShoulder.position.set(0.6, 4.0, 0);
      torsoGroup.add(rightShoulder);
      
      // Clavicles (collar bones)
      const clavicleGeom = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8);
      const clavicleMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      
      const leftClavicle = new THREE.Mesh(clavicleGeom, clavicleMat);
      leftClavicle.position.set(-0.35, 4.0, 0.1);
      leftClavicle.rotation.z = Math.PI / 6;
      torsoGroup.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(clavicleGeom, clavicleMat);
      rightClavicle.position.set(0.35, 4.0, 0.1);
      rightClavicle.rotation.z = -Math.PI / 6;
      torsoGroup.add(rightClavicle);
      
      // Position torso at ground level (pelvis at Y=0, lift to ground)
      torsoGroup.position.set(0, 0.3, 0);
      scene.add(torsoGroup);
      objects.push(torsoGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `TORSO (${vertexCount}V)`;
      
      console.log(`âœ… Anatomical torso loaded: ${vertexCount}+ vertices - pelvis, spine, 24 ribs, chest, shoulders, clavicles`);
    }

    // ğŸ§  HUMAN HEAD & NECK LOADER (100+ Vertices)
    function loadHumanHead(btn) {
      console.log('ğŸ§  Loading head and neck anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical head & neck group
      const headGroup = new THREE.Group();
      let vertexCount = 100;
      
      // Neck base (C7 vertebra)
      const neckBaseGeom = new THREE.CylinderGeometry(0.14, 0.12, 0.4, 12);
      const neckMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const neckBase = new THREE.Mesh(neckBaseGeom, neckMat);
      neckBase.position.y = 0.2;
      headGroup.add(neckBase);
      
      // Create neck swivel group (rotates for head turning)
      const neckSwivelGroup = new THREE.Group();
      neckSwivelGroup.position.y = 0.4;
      headGroup.add(neckSwivelGroup);
      
      // Neck cylinder (C1-C6 cervical vertebrae)
      const neckGeom = new THREE.CylinderGeometry(0.12, 0.14, 1.0, 12);
      const neck = new THREE.Mesh(neckGeom, neckMat);
      neck.position.y = 0.5;
      neckSwivelGroup.add(neck);
      
      // Skull base (foramen magnum)
      const skullBaseGeom = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 12);
      const boneMat = new THREE.MeshStandardMaterial({ color: 0xfff8e7, roughness: 0.4 });
      const skullBase = new THREE.Mesh(skullBaseGeom, boneMat);
      skullBase.position.y = 1.1;
      neckSwivelGroup.add(skullBase);
      
      // Cranium (main skull sphere)
      const craniumGeom = new THREE.SphereGeometry(0.65, 16, 16);
      const cranium = new THREE.Mesh(craniumGeom, boneMat);
      cranium.position.y = 1.6;
      cranium.scale.set(1, 1.1, 1); // Slightly taller
      neckSwivelGroup.add(cranium);
      
      // Jaw (mandible)
      const jawGeom = new THREE.BoxGeometry(0.5, 0.3, 0.4);
      const skinMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const jaw = new THREE.Mesh(jawGeom, skinMat);
      jaw.position.set(0, 1.0, 0.25);
      neckSwivelGroup.add(jaw);
      
      // Face plane (for features)
      const faceGeom = new THREE.CircleGeometry(0.55, 16);
      const faceMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.6, side: THREE.DoubleSide });
      const face = new THREE.Mesh(faceGeom, faceMat);
      face.position.set(0, 1.6, 0.6);
      neckSwivelGroup.add(face);
      
      // Left eye
      const eyeGeom = new THREE.SphereGeometry(0.08, 12, 12);
      const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const leftEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
      leftEye.position.set(-0.18, 1.7, 0.58);
      neckSwivelGroup.add(leftEye);
      
      // Left pupil
      const pupilGeom = new THREE.SphereGeometry(0.04, 12, 12);
      const pupilMat = new THREE.MeshStandardMaterial({ color: 0x2a4d69, roughness: 0.2 });
      const leftPupil = new THREE.Mesh(pupilGeom, pupilMat);
      leftPupil.position.set(-0.18, 1.7, 0.63);
      neckSwivelGroup.add(leftPupil);
      
      // Right eye
      const rightEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
      rightEye.position.set(0.18, 1.7, 0.58);
      neckSwivelGroup.add(rightEye);
      
      // Right pupil
      const rightPupil = new THREE.Mesh(pupilGeom, pupilMat);
      rightPupil.position.set(0.18, 1.7, 0.63);
      neckSwivelGroup.add(rightPupil);
      
      // Nose
      const noseGeom = new THREE.ConeGeometry(0.08, 0.2, 8);
      const nose = new THREE.Mesh(noseGeom, skinMat);
      nose.position.set(0, 1.5, 0.62);
      nose.rotation.x = Math.PI / 2;
      neckSwivelGroup.add(nose);
      
      // Mouth
      const mouthGeom = new THREE.BoxGeometry(0.25, 0.05, 0.1);
      const mouthMat = new THREE.MeshStandardMaterial({ color: 0xff6b8a, roughness: 0.5 });
      const mouth = new THREE.Mesh(mouthGeom, mouthMat);
      mouth.position.set(0, 1.25, 0.6);
      neckSwivelGroup.add(mouth);
      
      // Left ear
      const earGeom = new THREE.SphereGeometry(0.12, 12, 12);
      const leftEar = new THREE.Mesh(earGeom, skinMat);
      leftEar.position.set(-0.6, 1.6, 0.1);
      leftEar.scale.set(0.5, 1, 0.8);
      neckSwivelGroup.add(leftEar);
      
      // Right ear
      const rightEar = new THREE.Mesh(earGeom, skinMat);
      rightEar.position.set(0.6, 1.6, 0.1);
      rightEar.scale.set(0.5, 1, 0.8);
      neckSwivelGroup.add(rightEar);
      
      // Store reference for neck swivel
      currentHeadGroup = headGroup;
      headNeckSwivel = neckSwivelGroup;
      
      // Position head at appropriate height
      headGroup.position.set(0, 4.5, 0);
      scene.add(headGroup);
      objects.push(headGroup);
      
      // Show neck swivel controls
      document.getElementById('neckSwivel').style.display = 'block';
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HEAD (${vertexCount}V)`;
      
      console.log(`âœ… Anatomical head loaded: ${vertexCount}+ vertices - neck, skull, jaw, eyes, nose, mouth, ears - NECK SWIVEL ENABLED`);
    }
    
    // Update neck swivel angle (-180Â° to 180Â°)
    function updateNeckSwivel(angle) {
      if (!headNeckSwivel) {
        console.warn('âš ï¸ No head loaded for neck swivel');
        return;
      }
      
      // Convert angle to radians and rotate around Y axis
      const swivelAngle = angle * (Math.PI / 180);
      headNeckSwivel.rotation.y = swivelAngle;
      
      // Update display
      document.getElementById('neckSwivelValue').textContent = angle + 'Â°';
      
      console.log(`ğŸ”„ Neck swivel: ${angle}Â° (${swivelAngle.toFixed(2)} rad)`);
    }

    // ğŸ§ FULL BODY LOADER (564+ Vertices Total)
    function loadFullBody(btn) {
      console.log('ğŸ§ Loading complete human body with all parts...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create main body container
      const fullBodyGroup = new THREE.Group();
      let totalVertices = 0;
      
      // ===== LEGS (172V) - Ground Level =====
      const legsGroup = new THREE.Group();
      
      function createLeg(xOffset, isRight) {
        const legGroup = new THREE.Group();
        
        // Hip joint
        const hipGeom = new THREE.SphereGeometry(0.35, 8, 8);
        const hipMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hip = new THREE.Mesh(hipGeom, hipMat);
        legGroup.add(hip);
        
        // Thigh (femur)
        const thighGeom = new THREE.CylinderGeometry(0.25, 0.22, 3.5, 16);
        const thighMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thigh = new THREE.Mesh(thighGeom, thighMat);
        thigh.position.y = -1.75;
        legGroup.add(thigh);
        
        // === KNEE GROUP (for flexion/bending) ===
        const kneeGroup = new THREE.Group();
        kneeGroup.position.y = -3.5; // Position at knee joint
        
        // Knee joint
        const kneeGeom = new THREE.SphereGeometry(0.24, 8, 8);
        const kneeMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const knee = new THREE.Mesh(kneeGeom, kneeMat);
        knee.position.y = 0; // Relative to kneeGroup
        kneeGroup.add(knee);
        
        // Calf (tibia/fibula) - part of knee group so it bends with knee
        const calfGeom = new THREE.CylinderGeometry(0.22, 0.18, 3.5, 16);
        const calfMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const calf = new THREE.Mesh(calfGeom, calfMat);
        calf.position.y = -1.75; // Relative to knee
        kneeGroup.add(calf);
        
        // Ankle joint - part of knee group
        const ankleGeom = new THREE.SphereGeometry(0.18, 8, 8);
        const ankleMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const ankle = new THREE.Mesh(ankleGeom, ankleMat);
        ankle.position.y = -3.5; // Relative to knee
        kneeGroup.add(ankle);
        
        // Ankle bone (malleolus) - mirrored
        const ankleBoneGeom = new THREE.SphereGeometry(0.012, 8, 8);
        const ankleBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const ankleBone = new THREE.Mesh(ankleBoneGeom, ankleBoneMat);
        ankleBone.position.set(isRight ? 0.18 : -0.18, -3.5, 0);
        kneeGroup.add(ankleBone);
        
        // === FOOT GROUP (for heel-toe placement) ===
        const footGroup = new THREE.Group();
        footGroup.position.y = -3.8; // Relative to knee
        
        // Foot
        const footGeom = new THREE.BoxGeometry(0.35, 0.25, 0.8);
        const footMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const foot = new THREE.Mesh(footGeom, footMat);
        foot.position.set(0, 0, 0.3);
        foot.rotation.x = -Math.PI / 16;
        footGroup.add(foot);
        
        // Big toe - mirrored
        const bigToeGeom = new THREE.CylinderGeometry(0.07, 0.05, 0.35, 8);
        const bigToeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const bigToe = new THREE.Mesh(bigToeGeom, bigToeMat);
        bigToe.position.set(isRight ? -0.12 : 0.12, -0.2, 0.65);
        bigToe.rotation.x = Math.PI / 2;
        footGroup.add(bigToe);
        
        // 4 Toes - mirrored
        const toeLengths = [0.28, 0.26, 0.24, 0.22];
        for (let i = 0; i < 4; i++) {
          const toeGeom = new THREE.CylinderGeometry(0.045 * (1 - i * 0.08), 0.03 * (1 - i * 0.08), toeLengths[i], 8);
          const toeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const toe = new THREE.Mesh(toeGeom, toeMat);
          const toeXBase = isRight ? -0.05 : 0.05;
          const toeXOffset = isRight ? (i * 0.08) : -(i * 0.08);
          toe.position.set(toeXBase + toeXOffset, -0.2, 0.65);
          toe.rotation.x = Math.PI / 2;
          footGroup.add(toe);
          
          // Toe tip
          const toeTipGeom = new THREE.SphereGeometry(0.035 * (1 - i * 0.08), 8, 8);
          const toeTipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const toeTip = new THREE.Mesh(toeTipGeom, toeTipMat);
          toeTip.position.set(toeXBase + toeXOffset, -0.2, 0.65 + toeLengths[i] / 2);
          footGroup.add(toeTip);
        }
        
        kneeGroup.add(footGroup);
        legGroup.add(kneeGroup);
        legGroup.position.set(xOffset, 0, 0);
        
        // Tag leg group for selection
        legGroup.userData.bodyPart = isRight ? 'rightLeg' : 'leftLeg';
        legGroup.userData.partName = isRight ? 'Right Leg' : 'Left Leg';
        legGroup.userData.controlGroup = legGroup;
        
        // Tag foot for separate control
        footGroup.userData.bodyPart = isRight ? 'rightFoot' : 'leftFoot';
        footGroup.userData.partName = isRight ? 'Right Foot' : 'Left Foot';
        
        return { legGroup, kneeGroup, footGroup };
      }
      
      // Create both legs
      const leftLegData = createLeg(-0.4, false);
      const rightLegData = createLeg(0.4, true);
      legsGroup.add(leftLegData.legGroup);
      legsGroup.add(rightLegData.legGroup);
      legsGroup.position.set(0, 7.5, 0); // Feet on ground
      fullBodyGroup.add(legsGroup);
      totalVertices += 172; // 86V Ã— 2
      
      // Store references for walking animation
      leftLegGroup = leftLegData.legGroup;
      rightLegGroup = rightLegData.legGroup;
      leftKneeGroup = leftLegData.kneeGroup;
      rightKneeGroup = rightLegData.kneeGroup;
      leftFootGroup = leftLegData.footGroup;
      rightFootGroup = rightLegData.footGroup;
      
      // ===== TORSO (120V) - Connects legs to arms =====
      const torsoGroup = new THREE.Group();
      
      // Pelvis base
      const pelvisGeom = new THREE.CylinderGeometry(0.45, 0.5, 0.6, 16);
      const pelvisMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const pelvis = new THREE.Mesh(pelvisGeom, pelvisMat);
      pelvis.position.y = 0;
      torsoGroup.add(pelvis);
      
      // Lower spine (L1-L5 lumbar vertebrae)
      const lowerSpineGeom = new THREE.CylinderGeometry(0.12, 0.12, 1.2, 12);
      const spineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const lowerSpine = new THREE.Mesh(lowerSpineGeom, spineMat);
      lowerSpine.position.y = 0.9;
      torsoGroup.add(lowerSpine);
      
      // Mid spine (T7-T12 thoracic vertebrae)
      const midSpineGeom = new THREE.CylinderGeometry(0.13, 0.12, 1.5, 12);
      const midSpine = new THREE.Mesh(midSpineGeom, spineMat);
      midSpine.position.y = 2.25;
      torsoGroup.add(midSpine);
      
      // Upper spine (T1-T6 thoracic vertebrae)
      const upperSpineGeom = new THREE.CylinderGeometry(0.14, 0.13, 1.2, 12);
      const upperSpine = new THREE.Mesh(upperSpineGeom, spineMat);
      upperSpine.position.y = 3.6;
      torsoGroup.add(upperSpine);
      
      // Ribcage (12 ribs on each side)
      for (let i = 0; i < 12; i++) {
        const ribHeight = 2.0 + (i * 0.15);
        const ribWidth = 0.35 + (i * 0.04);
        
        // Left rib
        const leftRibGeom = new THREE.TorusGeometry(ribWidth, 0.02, 8, 16, Math.PI);
        const ribMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const leftRib = new THREE.Mesh(leftRibGeom, ribMat);
        leftRib.position.set(-0.15, ribHeight, 0);
        leftRib.rotation.y = Math.PI / 2;
        leftRib.rotation.z = -Math.PI / 12;
        torsoGroup.add(leftRib);
        
        // Right rib
        const rightRibGeom = new THREE.TorusGeometry(ribWidth, 0.02, 8, 16, Math.PI);
        const rightRib = new THREE.Mesh(rightRibGeom, ribMat);
        rightRib.position.set(0.15, ribHeight, 0);
        rightRib.rotation.y = -Math.PI / 2;
        rightRib.rotation.z = Math.PI / 12;
        torsoGroup.add(rightRib);
      }
      
      // Chest
      const chestGeom = new THREE.CylinderGeometry(0.55, 0.45, 1.5, 16);
      const chestMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const chest = new THREE.Mesh(chestGeom, chestMat);
      chest.position.y = 3.5;
      torsoGroup.add(chest);
      
      // Shoulders
      const shouldersGeom = new THREE.CylinderGeometry(0.65, 0.55, 0.5, 16);
      const shouldersMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const shoulders = new THREE.Mesh(shouldersGeom, shouldersMat);
      shoulders.position.y = 4.5;
      torsoGroup.add(shoulders);
      
      // Clavicles (collarbones)
      const leftClavicleGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
      const clavicleMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const leftClavicle = new THREE.Mesh(leftClavicleGeom, clavicleMat);
      leftClavicle.position.set(-0.5, 4.6, 0);
      leftClavicle.rotation.z = Math.PI / 6;
      torsoGroup.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(leftClavicleGeom, clavicleMat);
      rightClavicle.position.set(0.5, 4.6, 0);
      rightClavicle.rotation.z = -Math.PI / 6;
      torsoGroup.add(rightClavicle);
      
      // Tag torso for selection
      torsoGroup.userData.bodyPart = 'torso';
      torsoGroup.userData.partName = 'Torso';
      torsoGroup.userData.controlGroup = torsoGroup;
      
      torsoGroup.position.set(0, 7.5, 0); // Align with legs at ground level
      fullBodyGroup.add(torsoGroup);
      totalVertices += 120;
      
      // ===== ARMS (172V) - At shoulder height =====
      const armsGroup = new THREE.Group();
      
      function createArm(xOffset, isRight) {
        const armGroup = new THREE.Group();
        const forearmGroup = new THREE.Group(); // For elbow articulation
        
        // Shoulder joint
        const shoulderGeom = new THREE.SphereGeometry(0.25, 8, 8);
        const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
        armGroup.add(shoulder);
        
        // Upper arm (bicep/tricep area)
        const upperArmGeom = new THREE.CylinderGeometry(0.18, 0.15, 2.5, 16);
        const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
        upperArm.position.y = -1.25;
        armGroup.add(upperArm);
        
        // Elbow joint
        const elbowGeom = new THREE.SphereGeometry(0.16, 8, 8);
        const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const elbow = new THREE.Mesh(elbowGeom, elbowMat);
        elbow.position.y = -2.5;
        armGroup.add(elbow);
        
        // === FOREARM GROUP (for articulation) ===
        forearmGroup.position.y = -2.5; // Position at elbow
        
        // Forearm
        const forearmGeom = new THREE.CylinderGeometry(0.14, 0.12, 2.3, 16);
        const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const forearm = new THREE.Mesh(forearmGeom, forearmMat);
        forearm.position.y = -1.15;
        forearmGroup.add(forearm);
        
        // Wrist joint
        const wristGeom = new THREE.SphereGeometry(0.12, 8, 8);
        const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const wrist = new THREE.Mesh(wristGeom, wristMat);
        wrist.position.y = -2.3;
        forearmGroup.add(wrist);
        
        // Wrist bone (styloid process) - mirrored
        const wristBoneGeom = new THREE.SphereGeometry(0.008, 8, 8);
        const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
        wristBone.position.set(isRight ? -0.15 : 0.15, -2.3, 0);
        forearmGroup.add(wristBone);
        
        // Hand (palm)
        const handGeom = new THREE.BoxGeometry(0.3, 0.12, 0.45);
        const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hand = new THREE.Mesh(handGeom, handMat);
        hand.position.y = -2.65;
        forearmGroup.add(hand);
        
        // Thumb - mirrored rotation
        const thumbGeom = new THREE.CylinderGeometry(0.05, 0.04, 0.35, 8);
        const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thumb = new THREE.Mesh(thumbGeom, thumbMat);
        thumb.position.set(isRight ? 0.25 : -0.25, -2.65, 0);
        thumb.rotation.z = isRight ? Math.PI / 3 : -Math.PI / 3;
        forearmGroup.add(thumb);
        
        // 4 Fingers - mirrored X positions
        const fingerLengths = [0.45, 0.48, 0.46, 0.42];
        for (let i = 0; i < 4; i++) {
          const fingerGeom = new THREE.CylinderGeometry(0.035 * (1 - i * 0.05), 0.025 * (1 - i * 0.05), fingerLengths[i], 8);
          const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const finger = new THREE.Mesh(fingerGeom, fingerMat);
          const fingerXBase = isRight ? -0.12 : 0.12;
          const fingerXOffset = isRight ? (i * 0.08) : -(i * 0.08);
          finger.position.set(fingerXBase + fingerXOffset, -3.1, 0);
          forearmGroup.add(finger);
          
          // Fingertip
          const fingertipGeom = new THREE.SphereGeometry(0.03 * (1 - i * 0.05), 8, 8);
          const fingertipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const fingertip = new THREE.Mesh(fingertipGeom, fingertipMat);
          fingertip.position.set(fingerXBase + fingerXOffset, -3.1 - fingerLengths[i] / 2, 0);
          forearmGroup.add(fingertip);
        }
        
        armGroup.add(forearmGroup);
        armGroup.position.set(xOffset, 0, 0);
        
        // Tag arm group for selection
        armGroup.userData.bodyPart = isRight ? 'rightArm' : 'leftArm';
        armGroup.userData.partName = isRight ? 'Right Arm' : 'Left Arm';
        armGroup.userData.controlGroup = armGroup;
        
        // Tag forearm/hand group for wrist control
        forearmGroup.userData.bodyPart = isRight ? 'rightHand' : 'leftHand';
        forearmGroup.userData.partName = isRight ? 'Right Hand' : 'Left Hand';
        forearmGroup.userData.controlGroup = forearmGroup;
        
        return { armGroup, forearmGroup };
      }
      
      // Create both arms
      const leftArmData = createArm(-1.2, false);
      const rightArmData = createArm(1.2, true);
      armsGroup.add(leftArmData.armGroup);
      armsGroup.add(rightArmData.armGroup);
      armsGroup.position.set(0, 12.25, 0); // At shoulder height (torso top ~4.5 + base 7.5)
      fullBodyGroup.add(armsGroup);
      totalVertices += 172; // 86V Ã— 2
      
      // Store references for walking animation (arm swing)
      leftArmGroupRef = leftArmData.armGroup;
      rightArmGroupRef = rightArmData.armGroup;
      
      // ===== HEAD (100V) - Top of torso =====
      const headGroup = new THREE.Group();
      const neckSwivelGroup = new THREE.Group(); // For head rotation
      
      // Cervical spine (C1-C7 vertebrae)
      const cervicalSpineGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 12);
      const cervicalSpineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const cervicalSpine = new THREE.Mesh(cervicalSpineGeom, cervicalSpineMat);
      cervicalSpine.position.y = 0.3;
      headGroup.add(cervicalSpine);
      
      // Neck base
      const neckBaseGeom = new THREE.CylinderGeometry(0.2, 0.18, 0.5, 16);
      const neckBaseMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const neckBase = new THREE.Mesh(neckBaseGeom, neckBaseMat);
      neckBase.position.y = 0.8;
      headGroup.add(neckBase);
      
      // === NECK SWIVEL GROUP (for head rotation) ===
      neckSwivelGroup.position.y = 1.1; // Position at top of neck
      
      // Skull base (occipital bone)
      const skullBaseGeom = new THREE.SphereGeometry(0.25, 12, 12);
      const skullBaseMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const skullBase = new THREE.Mesh(skullBaseGeom, skullBaseMat);
      skullBase.position.y = 0.2;
      neckSwivelGroup.add(skullBase);
      
      // Cranium (skull)
      const craniumGeom = new THREE.SphereGeometry(0.45, 16, 16);
      const craniumMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const cranium = new THREE.Mesh(craniumGeom, craniumMat);
      cranium.position.y = 0.65;
      neckSwivelGroup.add(cranium);
      
      // Jaw (mandible)
      const jawGeom = new THREE.BoxGeometry(0.4, 0.2, 0.35);
      const jawMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const jaw = new THREE.Mesh(jawGeom, jawMat);
      jaw.position.set(0, 0.3, 0.25);
      neckSwivelGroup.add(jaw);
      
      // Eyes
      const eyeGeom = new THREE.SphereGeometry(0.08, 12, 12);
      const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
      leftEye.position.set(-0.15, 0.7, 0.4);
      neckSwivelGroup.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
      rightEye.position.set(0.15, 0.7, 0.4);
      neckSwivelGroup.add(rightEye);
      
      // Pupils
      const pupilGeom = new THREE.SphereGeometry(0.04, 8, 8);
      const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.2 });
      const leftPupil = new THREE.Mesh(pupilGeom, pupilMat);
      leftPupil.position.set(-0.15, 0.7, 0.48);
      neckSwivelGroup.add(leftPupil);
      
      const rightPupil = new THREE.Mesh(pupilGeom, pupilMat);
      rightPupil.position.set(0.15, 0.7, 0.48);
      neckSwivelGroup.add(rightPupil);
      
      // Nose
      const noseGeom = new THREE.ConeGeometry(0.08, 0.15, 8);
      const noseMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const nose = new THREE.Mesh(noseGeom, noseMat);
      nose.position.set(0, 0.55, 0.45);
      nose.rotation.x = Math.PI / 2;
      neckSwivelGroup.add(nose);
      
      // Mouth
      const mouthGeom = new THREE.BoxGeometry(0.25, 0.05, 0.1);
      const mouthMat = new THREE.MeshStandardMaterial({ color: 0xff6666, roughness: 0.4 });
      const mouth = new THREE.Mesh(mouthGeom, mouthMat);
      mouth.position.set(0, 0.4, 0.42);
      neckSwivelGroup.add(mouth);
      
      // Ears
      const earGeom = new THREE.SphereGeometry(0.1, 8, 8);
      const earMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const leftEar = new THREE.Mesh(earGeom, earMat);
      leftEar.position.set(-0.45, 0.65, 0);
      leftEar.scale.set(0.4, 1, 0.6);
      neckSwivelGroup.add(leftEar);
      
      const rightEar = new THREE.Mesh(earGeom, earMat);
      rightEar.position.set(0.45, 0.65, 0);
      rightEar.scale.set(0.4, 1, 0.6);
      neckSwivelGroup.add(rightEar);
      
      // Tag head group for selection
      neckSwivelGroup.userData.bodyPart = 'head';
      neckSwivelGroup.userData.partName = 'Head';
      neckSwivelGroup.userData.controlGroup = neckSwivelGroup;
      
      headGroup.add(neckSwivelGroup);
      headGroup.position.set(0, 12, 0); // At top of torso (4.5 + 7.5)
      fullBodyGroup.add(headGroup);
      totalVertices += 100;
      
      // ===== ADD TO SCENE =====
      fullBodyGroup.position.set(0, 0, 0); // Standing upright at origin
      
      // Store global reference for body part selection
      window.fullBodyGroup = fullBodyGroup;
      
      scene.add(fullBodyGroup);
      objects.push(fullBodyGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `FULL BODY (${totalVertices}V)`;
      
      // Show articulation controls
      document.getElementById('armArticulationControls').style.display = 'block';
      document.getElementById('neckSwivelControls').style.display = 'block';
      
      console.log(`ğŸ§ âœ… FULL BODY loaded: ${totalVertices} vertices total`);
      console.log(`  â†’ Legs: 172V (86V Ã— 2) at ground level`);
      console.log(`  â†’ Torso: 120V connecting legs to arms`);
      console.log(`  â†’ Arms: 172V (86V Ã— 2) at shoulder height`);
      console.log(`  â†’ Head: 100V at top of torso`);
      console.log(`  â†’ All articulation controls enabled (elbow bend, neck swivel)`);
      console.log(`  â†’ ğŸš¶ WALKING ANIMATION: Click body, then scroll mouse wheel!`);
      console.log(`     â€¢ Scroll slowly = walking | Scroll faster = running`);
      console.log(`     â€¢ Stop scrolling to slow down naturally`);
      console.log(`  â†’ ğŸš¶ WALK MODE: Enable 'Walk Mode' button to move through scene!`);
      console.log(`     â€¢ A/D or â†/â†’ = Turn body left/right`);
      console.log(`     â€¢ W/S or â†‘/â†“ = Speed up/slow down`);
      console.log(`     â€¢ Camera follows body automatically`);
    }

    function updateSize(value) {
      primitiveSize = parseFloat(value);
      document.getElementById('sizeValue').textContent = value;
    }

    function updateAngle(value) {
      rotationAngle = parseFloat(value);
      document.getElementById('angleValue').textContent = value + 'Â°';
    }

    // Open 3D vertex matrix editor in new window
    function openAnatomyEditor() {
      const editorWindow = window.open('3d_vertex_matrix_environment.html', 'VertexMatrixEditor', 'width=1400,height=900');
      if (editorWindow) {
        console.log('âœ… 3D Vertex Matrix Editor opened in new window');
      } else {
        alert('âš ï¸ Please allow pop-ups to open the vertex matrix editor');
      }
    }

    function clearScene() {
      if (confirm('Clear all objects?')) {
        objects.forEach(obj => scene.remove(obj));
        objects = [];
        updateObjectCount();
      }
    }

    function switchWorkspace(workspace, btn) {
      // Update tab UI
      document.querySelectorAll('.workspace-tab').forEach(tab => tab.classList.remove('active'));
      btn.classList.add('active');

      // Hide all workspace content
      document.querySelectorAll('.workspace-content').forEach(content => {
        content.style.display = 'none';
      });

      // Show selected workspace
      const workspaceElement = document.getElementById(`workspace-${workspace}`);
      if (workspaceElement) {
        workspaceElement.style.display = 'block';
      }

      // Update display
      const workspaceNames = {
        'sculpt': '3D SCULPT',
        'css': 'CSS DESIGNER',
        'word': 'WORDWEAVER',
        'campus': 'CAMPUS',
        'perfect': 'PERFECT'
      };
      document.getElementById('workspaceDisplay').textContent = workspaceNames[workspace] || workspace.toUpperCase();
      
      console.log('Switched to:', workspace);
    }

    function updateObjectCount() {
      document.getElementById('objectCount').textContent = objects.length;
    }

    function updateVertexCount() {
      let totalVertices = 0;
      objects.forEach(obj => {
        obj.traverse((child) => {
          if (child.geometry) {
            const positions = child.geometry.attributes.position;
            if (positions) {
              totalVertices += positions.count;
            }
          }
        });
      });
      document.getElementById('vertexCount').textContent = totalVertices;
      console.log(`ğŸ“Š Total vertices in scene: ${totalVertices}`);
    }

    // =============================================
    // MATHEMATICIAN TRIBUTE SYSTEM
    // =============================================

    let learnModeActive = false;
    let currentMethod = 'fibonacci';

    const MATHEMATICIANS = {
      fibonacci: {
        name: "Leonardo Fibonacci",
        born: 1170,
        died: 1250,
        flag: "ğŸ‡®ğŸ‡¹",
        nationality: "Italian",
        discovery: "Fibonacci Sequence",
        story: "Italian mathematician who discovered the famous sequence (0,1,1,2,3,5,8...) while studying rabbit populations. Each number is the sum of the two before it! This sequence appears everywhere in nature: sunflower spirals, pinecones, nautilus shells.",
        kidFact: "He introduced Arabic numerals (0-9) to Europe! Before him, Europeans used Roman numerals (I, II, III, IV...) which made math really hard."
      },
      catmull: {
        name: "Edwin Catmull",
        born: 1945,
        died: null,
        flag: "ğŸ‡ºğŸ‡¸",
        nationality: "American",
        discovery: "Catmull-Rom Splines & Subdivision",
        story: "Co-founder of Pixar! Created smooth curve algorithms while dreaming of making the first computer-animated movie. His math makes characters move smoothly and naturally.",
        kidFact: "He won an Oscar for his technology! Every Pixar movie (Toy Story, Finding Nemo, The Incredibles) uses his math to make characters move smoothly."
      },
      bezier: {
        name: "Pierre BÃ©zier",
        born: 1910,
        died: 1999,
        flag: "ğŸ‡«ğŸ‡·",
        nationality: "French",
        discovery: "BÃ©zier Curves",
        story: "Renault car designer who invented curves you can control with just a few points. Used in fonts, animations, car design, and every vector graphic you see!",
        kidFact: "Every letter you're reading right now uses BÃ©zier curves! Computer fonts are made entirely of his curves. Even emojis! ğŸ˜Š"
      },
      perlin: {
        name: "Ken Perlin",
        born: 1951,
        died: null,
        flag: "ğŸ®",
        nationality: "American",
        discovery: "Perlin Noise",
        story: "NYU professor who created natural-looking randomness for the movie TRON (1982). Won an Oscar for making computer graphics look organic instead of artificial!",
        kidFact: "Minecraft's entire world generation uses Perlin noise! Every mountain, cave, and biome is created with his algorithm. Without it, Minecraft wouldn't exist!"
      },
      quaternion: {
        name: "William Hamilton",
        born: 1805,
        died: 1865,
        flag: "ğŸ‡®ğŸ‡ª",
        nationality: "Irish",
        discovery: "Quaternions",
        story: "Had a 'eureka moment' while walking across Brougham Bridge in Dublin. He was so excited he carved the formula (iÂ²=jÂ²=kÂ²=ijk=-1) into the bridge stone with his knife!",
        kidFact: "Every 3D video game character rotation uses quaternions! They prevent 'gimbal lock' - a glitch that made old games spin weirdly. Your character wouldn't turn smoothly without them!"
      },
      lsystem: {
        name: "Aristid Lindenmayer",
        born: 1925,
        died: 1989,
        flag: "ğŸ‡­ğŸ‡º",
        nationality: "Hungarian",
        discovery: "L-Systems (Lindenmayer Systems)",
        story: "Biologist and botanist who created a simple alphabet system to model how plants grow. Simple rules like 'A becomes AB, B becomes A' create complex fractal patterns that look like real plants!",
        kidFact: "Video game trees and plants are grown with L-Systems! One simple rule repeated over and over can create an entire realistic forest. It's like growing a digital plant from a seed!"
      },
      voronoi: {
        name: "Georgy Voronoi",
        born: 1868,
        died: 1908,
        flag: "ğŸ‡ºğŸ‡¦",
        nationality: "Ukrainian",
        discovery: "Voronoi Diagrams",
        story: "Mathematician who figured out how to divide space based on nearest neighbors. Imagine drawing territories around each point where everything inside is closer to that point than any other!",
        kidFact: "Giraffe spots follow Voronoi patterns! Nature uses this math for animal patterns, cell structures, and crystal growth. Your body's cells organize using Voronoi math!"
      },
      phong: {
        name: "Bui Tuong Phong",
        born: 1942,
        died: 1975,
        flag: "ğŸ‡»ğŸ‡³",
        nationality: "Vietnamese",
        discovery: "Phong Shading",
        story: "Created the lighting model that made 3D objects look shiny and realistic. His PhD thesis at University of Utah changed computer graphics forever. Tragically died of leukemia at age 32, but his legacy lives in every 3D game.",
        kidFact: "Every shiny surface in 3D games uses Phong shading! He made plastic, metal, and glass look real on computers. When you see light reflecting off a character's armor - that's his math!"
      },
      delaunay: {
        name: "Boris Delaunay",
        born: 1890,
        died: 1980,
        flag: "ğŸ‡·ğŸ‡º",
        nationality: "Russian",
        discovery: "Delaunay Triangulation",
        story: "Russian mathematician who figured out the optimal way to connect dots with triangles. His method creates the 'fattest' triangles possible, avoiding skinny ones that cause problems in 3D graphics.",
        kidFact: "3D game terrain is built with Delaunay triangles! Mountains, valleys, and landscapes are made by connecting height points with his optimal triangles. Every open-world game uses this!"
      },
      subdivision: {
        name: "Jim Clark & Edwin Catmull",
        born: 1944,
        died: null,
        flag: "ğŸ’",
        nationality: "American",
        discovery: "Subdivision Surfaces",
        story: "Jim Clark founded Silicon Graphics (the company that made movie CGI possible) and Netscape (early web browser). With Catmull, they figured out how to make blocky shapes smooth by subdividing faces repeatedly.",
        kidFact: "Every smooth 3D character starts blocky! Artists model a simple cube-like shape, then subdivision turns it into a smooth character. It's like magic - a cube becomes a smooth head!"
      }
    };

    function toggleLearnMode(btn) {
      learnModeActive = !learnModeActive;
      const info = document.getElementById('learnModeInfo');
      
      if (learnModeActive) {
        btn.innerHTML = '<span class="tool-icon">ğŸ“</span><span>Learn Mode ON</span>';
        btn.style.background = 'rgba(0, 255, 136, 0.3)';
        btn.style.borderColor = '#00ff88';
        info.style.display = 'block';
        
        // Show initial method story
        showMathematicianStory(currentMethod);
        
        console.log(`
ğŸ“š ============================================
   LEARN MODE ACTIVATED!
   
   Now when you select Mathematical Methods,
   you'll see the mathematician's story, their
   discovery, and how it powers your creations!
   
   Click any method below to learn! ğŸ†
============================================
        `);
      } else {
        btn.innerHTML = '<span class="tool-icon">ğŸ‘¨â€ğŸ«</span><span>Enable Story Mode</span>';
        btn.style.background = 'rgba(0, 255, 136, 0.1)';
        btn.style.borderColor = 'rgba(0, 255, 136, 0.3)';
        info.style.display = 'none';
        document.getElementById('mathematicianStory').style.display = 'none';
      }
    }

    function selectMethod(method, btn) {
      currentMethod = method;
      
      // Update active button
      btn.parentElement.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Show story if Learn Mode is active
      if (learnModeActive) {
        showMathematicianStory(method);
      }
      
      // Log to console
      const mathematician = MATHEMATICIANS[method];
      console.log(`
ğŸ† ============================================
   METHOD SELECTED: ${mathematician.discovery}
   Mathematician: ${mathematician.name} (${mathematician.born}-${mathematician.died || 'Present'})
   ${mathematician.flag} ${mathematician.nationality}
   
   ğŸ“– Story: ${mathematician.story}
   
   ğŸ’¡ Kid Fact: ${mathematician.kidFact}
============================================
      `);
    }

    function showMathematicianStory(method) {
      const mathematician = MATHEMATICIANS[method];
      const panel = document.getElementById('mathematicianStory');
      
      // Update story content
      document.getElementById('storyTitle').textContent = `ğŸ† ${mathematician.discovery}`;
      document.getElementById('storyFlag').textContent = mathematician.flag;
      document.getElementById('storyName').textContent = mathematician.name;
      document.getElementById('storyDates').textContent = `${mathematician.born}-${mathematician.died || 'Present'} â€¢ ${mathematician.nationality}`;
      document.getElementById('storyDiscovery').textContent = `Discovery: ${mathematician.discovery}`;
      document.getElementById('storyText').textContent = mathematician.story;
      document.getElementById('storyKidFact').textContent = mathematician.kidFact;
      
      // Show panel with smooth animation
      panel.style.display = 'block';
    }

    // Start
    window.addEventListener('load', init);
  </script>
</body>
</html>
