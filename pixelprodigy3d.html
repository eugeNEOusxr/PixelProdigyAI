<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="referrer" content="no-referrer">
  <title>PixelProdigyOS AI ‚Äì Creative Operating System</title>
  
  <!-- Security Policy: Block external manipulation -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://*.eugeneous.dev https://*.eugeneous.com https://api.eugeneous.dev https://api.eugeneous.com https://*.amazonaws.com; frame-ancestors 'none';">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta name="referrer" content="no-referrer">
  
  <!-- ANTI-TAMPERING PROTECTION -->
  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SECURITY LAYER 1: Code Integrity Protection
    // Prevents Python memory hacking, code injection, and runtime manipulation
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    (function() {
      'use strict';
      
      // 1. FREEZE CRITICAL OBJECTS - Prevent prototype pollution
      Object.freeze(Object.prototype);
      Object.freeze(Array.prototype);
      Object.freeze(Function.prototype);
      Object.freeze(Math);
      Object.freeze(JSON);
      
      // 2. DISABLE DANGEROUS EVAL METHODS - Block code injection
      const originalEval = window.eval;
      window.eval = function() {
        console.warn('üö® Blocked eval() attempt - Code injection prevented');
        return null;
      };
      
      const originalFunction = window.Function;
      window.Function = function() {
        console.warn('üö® Blocked Function() constructor - Code injection prevented');
        return function() {};
      };
      
      // 3. DETECT DEBUGGER ATTACHMENT - Block reverse engineering
      let debuggerDetected = false;
      setInterval(function() {
        const start = performance.now();
        debugger;
        const elapsed = performance.now() - start;
        if (elapsed > 100 && !debuggerDetected) {
          debuggerDetected = true;
          console.warn('üö® Debugger detected - Tampering attempt logged');
          // In production: Send alert to server
        }
      }, 1000);
      
      // 4. CONSOLE PROTECTION - Prevent console manipulation
      const noop = function() {};
      const originalConsole = { ...console };
      Object.defineProperty(window, 'console', {
        get: function() { return originalConsole; },
        set: function() { 
          console.warn('üö® Blocked console override attempt');
          return false;
        }
      });
      
      // 5. DETECT AUTOMATION TOOLS - Block bot/script attacks
      Object.defineProperty(navigator, 'webdriver', {
        get: () => false,
        configurable: false
      });
      
      // 6. MEMORY CHECKSUM VALIDATION
      let checksumCache = {};
      window._pixelProdigyIntegrity = function(funcName, funcCode) {
        const hash = btoa(funcCode.toString());
        if (checksumCache[funcName] && checksumCache[funcName] !== hash) {
          console.error(`üö® SECURITY BREACH: Function "${funcName}" was modified!`);
          alert('Security Warning: Code tampering detected. Reloading application...');
          location.reload();
          return false;
        }
        checksumCache[funcName] = hash;
        return true;
      };
      
      // 7. DISABLE DEVTOOLS SHORTCUTS + SHOW WARNING
      let devToolsWarningShown = false;
      
      function showDevToolsWarning() {
        if (!devToolsWarningShown) {
          devToolsWarningShown = true;
          const warningDiv = document.createElement('div');
          warningDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #FFD700;
            border-radius: 12px;
            padding: 30px;
            z-index: 999999;
            color: #FFD700;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
            max-width: 500px;
          `;
          warningDiv.innerHTML = `
            <h2 style="margin: 0 0 20px 0; font-size: 24px;">‚ö†Ô∏è Developer Tools Detected</h2>
            <p style="margin: 10px 0; line-height: 1.6;">
              This application is protected by <strong>10-layer security system</strong>.<br><br>
              Tampering with code may result in:<br>
              ‚Ä¢ Loss of unsaved work<br>
              ‚Ä¢ Account suspension<br>
              ‚Ä¢ Automatic reload<br><br>
              <strong>Official Site:</strong> eugeneous.dev<br>
              <strong>Security Policy:</strong> No referer tracking
            </p>
            <button onclick="this.parentElement.remove()" style="
              margin-top: 20px;
              padding: 12px 30px;
              background: #FFD700;
              color: #000;
              border: none;
              border-radius: 6px;
              font-weight: bold;
              cursor: pointer;
              font-size: 14px;
            ">I Understand</button>
          `;
          document.body.appendChild(warningDiv);
          setTimeout(() => warningDiv.remove(), 10000); // Auto-remove after 10s
        }
      }
      
      document.addEventListener('keydown', function(e) {
        // F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
        if (e.keyCode === 123 || 
            (e.ctrlKey && e.shiftKey && (e.keyCode === 73 || e.keyCode === 74)) ||
            (e.ctrlKey && e.keyCode === 85)) {
          e.preventDefault();
          showDevToolsWarning();
          console.warn('üö® DevTools shortcut blocked - See warning message');
          return false;
        }
      });
      
      // 8. DETECT CODE INJECTION VIA DOM
      const trustedCDNs = [
        'cdnjs.cloudflare.com',
        'cdn.jsdelivr.net',
        'unpkg.com',
        'cdn.skypack.dev',
        'esm.sh',
        'pixelprodigy',
        'eugeneous.dev',
        'eugeneous.com'
      ];
      
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          mutation.addedNodes.forEach(function(node) {
            if (node.tagName === 'SCRIPT' && node.src) {
              // Check if script is from trusted source
              const isTrusted = trustedCDNs.some(cdn => node.src.includes(cdn));
              if (!isTrusted) {
                console.error('üö® Unauthorized script injection detected:', node.src);
                node.remove();
              }
            }
          });
        });
      });
      observer.observe(document.documentElement, { childList: true, subtree: true });
      
      // 9. WATERMARK VERIFICATION - Ensure authentic build
      window._ppBuildFingerprint = 'PPG-HUMAN-SCULPT-' + Date.now();
      Object.defineProperty(window, '_ppBuildFingerprint', {
        writable: false,
        configurable: false
      });
      
      // 10. ANTI-CHEAT: Monitor critical variables
      window._ppWatchdog = new Proxy({}, {
        set: function(target, property, value) {
          console.warn(`üö® Attempted to modify protected property: ${property}`);
          return false;
        },
        get: function(target, property) {
          if (property === 'tampered') return false;
          return target[property];
        }
      });
      
      console.log('‚úÖ PixelProdigy Security Layer Active - Code integrity protected');
    })();
  </script>
  
  <!-- 
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    PIXELPRODIGY HUMAN SCULPT WINDOW - MANUAL 3D CREATION PLATFORM
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    Copyright ¬© 2025 Jeremy (EugeNEOusXR / PixelProdigy)
    All Rights Reserved.
    
    PROPRIETARY AND CONFIDENTIAL
    
    This software and associated documentation files (the "Software") contain
    proprietary and confidential information belonging to Jeremy/PixelProdigy.
    
    RESTRICTIONS:
    - No unauthorized copying, modification, or distribution
    - No reverse engineering or decompilation
    - Commercial use requires explicit written permission
    - AI training/scraping prohibited without written consent
    
    LEGAL NOTICES:
    - Patent Pending (Provisional filing in progress)
    - Trademark: PixelProdigy‚Ñ¢ (Registration pending)
    - Git Repository: Timestamped commits serve as proof of authorship
    - Build Version: 1.0.0-alpha
    - Build Date: October 17, 2025
    
    UNIQUE INNOVATIONS:
    1. Box/Circle/Lasso selection with real-time modification
    2. Selection utilities (Invert/Grow/Shrink/Clear/SelectAll)
    3. Lasso-guided laser cutting system (Patent Pending)
    4. Physics-based destruction with object binding
    5. Dual-window Human/AI collaboration architecture
    6. Real-time vertex manipulation with layer modification
    
    For licensing inquiries: contact@pixelprodigy.ai
    
    BUILD FINGERPRINT: PPG-HUMAN-SCULPT-${Date.now()}
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  -->
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #0a0e14;
      color: #d4dce6;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Top Toolbar */
    #toolbar {
      background: linear-gradient(135deg, #141b24 0%, #1a2332 100%);
      border-bottom: 1px solid #2a3848;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .toolbar-section {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 12px;
      border-right: 1px solid #2a3848;
    }

    .toolbar-section:last-child {
      border-right: none;
    }

    .toolbar-section label {
      font-size: 12px;
      color: #8a9aad;
      font-weight: 500;
    }

    .toolbar-section input[type="range"],
    .toolbar-section input[type="number"],
    .toolbar-section select {
      background: #1e2836;
      border: 1px solid #2e3b4e;
      border-radius: 4px;
      color: #d4dce6;
      padding: 4px 8px;
      font-size: 12px;
      outline: none;
    }

    .toolbar-section input[type="range"] {
      width: 90px;
    }

    .toolbar-section input[type="number"] {
      width: 60px;
    }

    .toolbar-section select {
      padding: 4px 6px;
    }

    .toolbar-section button {
      background: #2563eb;
      border: none;
      color: #fff;
      padding: 6px 14px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: background 0.2s;
    }

    .toolbar-section button:hover {
      background: #1d4ed8;
    }

    /* Main Layout */
    #main {
      flex: 1;
      display: flex;
      position: relative;
      overflow: hidden;
    }

    /* Left Panel: Brush & Layer Controls */
    #leftPanel {
      width: 280px;
      background: #0f1419;
      border-right: 1px solid #2a3848;
      overflow-y: auto;
      padding: 16px;
    }

    .panel-section {
      margin-bottom: 24px;
    }

    .panel-section h3 {
      font-size: 13px;
      color: #7dd3fc;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .control-row label {
      font-size: 12px;
      color: #8a9aad;
    }

    .control-row input[type="range"] {
      flex: 1;
      margin-left: 12px;
    }

    .control-row input[type="number"] {
      width: 55px;
      margin-left: 8px;
    }

    .brush-shape-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 8px;
    }

    .brush-shape-btn {
      background: #1e2836;
      border: 2px solid #2e3b4e;
      color: #d4dce6;
      padding: 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      text-align: center;
      transition: all 0.2s;
    }

    .brush-shape-btn.active {
      background: #2563eb;
      border-color: #3b82f6;
      color: #fff;
    }

    .brush-shape-btn:hover {
      border-color: #3b82f6;
    }

    .layer-list {
      background: #1e2836;
      border: 1px solid #2e3b4e;
      border-radius: 6px;
      padding: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .layer-item {
      background: #141b24;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: background 0.2s;
    }

    .layer-item.active {
      background: #1e3a8a;
      border-left: 3px solid #3b82f6;
    }

    .layer-item:hover {
      background: #1a2332;
    }

    .layer-name {
      font-size: 12px;
      color: #d4dce6;
    }

    .layer-controls {
      display: flex;
      gap: 6px;
    }

    .layer-btn {
      background: transparent;
      border: 1px solid #2e3b4e;
      color: #8a9aad;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
    }

    .layer-btn:hover {
      background: #2e3b4e;
      color: #d4dce6;
    }

    /* Center: 3D Viewport */
    #viewport {
      flex: 1;
      position: relative;
      background: #000;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Transform Gizmo Controls */
    #transformControls {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(10, 14, 20, 0.85);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid rgba(42, 56, 72, 0.6);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #transformControls h4 {
      margin: 0 0 8px 0;
      font-size: 12px;
      color: #7dd3fc;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .transform-btn-group {
      display: flex;
      gap: 4px;
    }

    .transform-btn {
      background: #1e2836;
      border: 2px solid #2e3b4e;
      color: #8a9aad;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.2s;
      flex: 1;
      text-align: center;
    }

    .transform-btn:hover {
      border-color: #3b82f6;
      color: #d4dce6;
    }

    .transform-btn.active {
      background: #2563eb;
      border-color: #3b82f6;
      color: #fff;
    }

    .axis-input-group {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .axis-label {
      font-size: 11px;
      font-weight: 600;
      width: 16px;
      text-align: center;
    }

    .axis-label.x { color: #ef4444; }
    .axis-label.y { color: #22c55e; }
    .axis-label.z { color: #3b82f6; }

    .axis-input {
      flex: 1;
      background: #1e2836;
      border: 1px solid #2e3b4e;
      color: #d4dce6;
      padding: 4px 6px;
      border-radius: 3px;
      font-size: 11px;
      width: 60px;
    }

    #viewportOverlay {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(10, 14, 20, 0.85);
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid rgba(42, 56, 72, 0.6);
      font-size: 12px;
      line-height: 1.6;
      pointer-events: none;
      max-width: 300px;
    }

    #viewportOverlay h4 {
      color: #7dd3fc;
      margin-bottom: 6px;
      font-size: 13px;
    }

    #viewportOverlay div {
      color: #8a9aad;
    }

    /* CAM-003: Flight Mode Indicator */
    #flightModeIndicator {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(10, 14, 20, 0.9);
      padding: 12px 18px;
      border-radius: 8px;
      border: 2px solid #3b82f6;
      font-size: 14px;
      font-weight: 600;
      color: #7dd3fc;
      pointer-events: none;
      display: none;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      transition: opacity 0.3s ease;
    }

    #flightModeIndicator.visible {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    #flightModeIndicator .speed-display {
      color: #fff;
      font-size: 16px;
      margin-top: 4px;
    }

    #flightModeIndicator .speed-fast {
      color: #22c55e;
    }

    #flightModeIndicator .speed-slow {
      color: #fbbf24;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* SEL-001: Box Selection Canvas */
    #selectionCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    .selection-box {
      position: absolute;
      border: 2px solid rgba(59, 130, 246, 0.8);
      background: rgba(59, 130, 246, 0.1);
      pointer-events: none;
      display: none;
    }

    .selection-box.active {
      display: block;
    }

    /* Right Panel: AI Guidance & Environment */
    #rightPanel {
      width: 320px;
      background: #0f1419;
      border-left: 1px solid #2a3848;
      overflow-y: auto;
      padding: 16px;
    }

    .ai-suggestion-box {
      background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
      border: 1px solid #3b82f6;
      border-radius: 8px;
      padding: 14px;
      margin-bottom: 16px;
    }

    .ai-suggestion-box h4 {
      font-size: 13px;
      color: #93c5fd;
      margin-bottom: 8px;
    }

    .ai-suggestion-box p {
      font-size: 12px;
      color: #dbeafe;
      line-height: 1.5;
      margin-bottom: 10px;
    }

    .ai-suggestion-box button {
      background: #3b82f6;
      border: none;
      color: #fff;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      margin-right: 6px;
      transition: background 0.2s;
    }

    .ai-suggestion-box button:hover {
      background: #2563eb;
    }

    .env-control-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 10px;
    }

    /* Bottom Timeline */
    #timeline {
      height: 100px;
      background: #0f1419;
      border-top: 1px solid #2a3848;
      padding: 12px 16px;
      overflow-x: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .timeline-frame {
      min-width: 60px;
      height: 60px;
      background: #1e2836;
      border: 2px solid #2e3b4e;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: #8a9aad;
    }

    .timeline-frame.active {
      border-color: #3b82f6;
      background: #1e3a8a;
      color: #93c5fd;
    }

    .timeline-frame:hover {
      border-color: #3b82f6;
    }

    /* Status Bar */
    #statusBar {
      background: #0a0e14;
      border-top: 1px solid #2a3848;
      padding: 6px 16px;
      font-size: 11px;
      color: #8a9aad;
      display: flex;
      justify-content: space-between;
    }

    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #0f1419;
    }

    ::-webkit-scrollbar-thumb {
      background: #2e3b4e;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #3b4e6e;
    }

    /* Radial Transform Menu */
    #radialMenu {
      position: fixed;
      display: none;
      z-index: 10000;
      pointer-events: none;
    }

    #radialMenu.active {
      display: block;
      pointer-events: all;
    }

    .radial-menu-center {
      position: absolute;
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, #1e3a8a 0%, #2563eb 100%);
      border: 3px solid #3b82f6;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 20px;
      font-weight: bold;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      cursor: pointer;
    }

    .radial-menu-item {
      position: absolute;
      width: 70px;
      height: 70px;
      background: linear-gradient(135deg, #1e2836 0%, #2e3b4e 100%);
      border: 2px solid #3b82f6;
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #d4dce6;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
    }

    .radial-menu-item:hover {
      background: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%);
      transform: translate(-50%, -50%) scale(1.15);
      border-color: #60a5fa;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.6);
    }

    .radial-menu-item .icon {
      font-size: 24px;
      margin-bottom: 2px;
    }

    .radial-menu-item .label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* ENV-002: Fog Preset Button Styles */
    .fog-preset-btn:hover {
      background: #252f3d !important;
      border-color: #3d5066 !important;
      transform: translateY(-1px);
    }

    .fog-preset-btn:active {
      transform: translateY(0);
    }

    /* ENV-005: Camera Preset Button Styles */
    .camera-preset-btn:hover {
      background: #252f3d !important;
      border-color: #3d5066 !important;
      transform: translateY(-1px);
    }

    .camera-preset-btn:active {
      transform: translateY(0);
    }
  </style>
</head>
<body>
  <!-- Top Toolbar -->
  <div id="toolbar">
    <div class="toolbar-section">
      <button onclick="newProject()">New</button>
      <button onclick="saveProject()">Save</button>
      <button onclick="loadProject()">Load</button>
      <button onclick="exportModel()">Export</button>
    </div>

    <div class="toolbar-section">
      <label>Project:</label>
      <input type="text" id="projectId" value="untitled" style="width: 120px;">
    </div>

    <div class="toolbar-section">
      <label>Autosave:</label>
      <input type="number" id="autosaveInterval" value="30" min="10" max="300">
      <span style="font-size: 11px; color: #8a9aad;">s</span>
    </div>

    <div class="toolbar-section">
      <label>Export:</label>
      <select id="exportFormat">
        <option value="gltf">glTF</option>
        <option value="obj">OBJ</option>
        <option value="stl">STL</option>
      </select>
    </div>

    <div class="toolbar-section">
      <label>Grid:</label>
      <input type="number" id="snapToGrid" value="0.5" min="0" max="5" step="0.1">
    </div>

    <div class="toolbar-section" style="margin-left: auto;">
      <button onclick="undo()">Undo</button>
      <button onclick="redo()">Redo</button>
    </div>
  </div>

  <!-- Main Layout -->
  <div id="main">
    <!-- Left Panel -->
    <div id="leftPanel">
      <div class="panel-section">
        <h3>üñåÔ∏è Brush Controls</h3>
        <div class="control-row">
          <label>Radius</label>
          <input type="range" id="brushRadius" min="0.1" max="2.0" step="0.05" value="0.35">
          <input type="number" id="brushRadiusValue" min="0.1" max="2.0" step="0.05" value="0.35">
        </div>
        <div class="control-row">
          <label>Strength</label>
          <input type="range" id="brushStrength" min="0.02" max="0.5" step="0.01" value="0.15">
          <input type="number" id="brushStrengthValue" min="0.02" max="0.5" step="0.01" value="0.15">
        </div>
        <div class="control-row">
          <label>Hardness</label>
          <input type="range" id="brushHardness" min="0" max="1" step="0.05" value="0.7">
          <input type="number" id="brushHardnessValue" min="0" max="1" step="0.05" value="0.7">
        </div>
        <div class="control-row">
          <label>Falloff</label>
          <select id="brushFalloff">
            <option value="smooth">Smooth</option>
            <option value="linear">Linear</option>
            <option value="sharp">Sharp</option>
          </select>
        </div>
        <div class="control-row">
          <label>Symmetry</label>
          <select id="symmetryAxis">
            <option value="none">None</option>
            <option value="x">X-Axis</option>
            <option value="y">Y-Axis</option>
            <option value="z">Z-Axis</option>
            <option value="xy">XY</option>
            <option value="xz">XZ</option>
            <option value="xyz">XYZ</option>
          </select>
        </div>
        <div class="control-row">
          <label>Pressure</label>
          <input type="range" id="pressureResponse" min="0" max="1" step="0.1" value="0.5">
        </div>
        <div class="control-row">
          <label>Spacing</label>
          <input type="range" id="strokeSpacing" min="0.01" max="0.5" step="0.01" value="0.1">
        </div>

        <h3 style="margin-top: 16px;">Shape</h3>
        <div class="brush-shape-grid">
          <div class="brush-shape-btn active" data-shape="circle">Circle</div>
          <div class="brush-shape-btn" data-shape="triangle">Triangle</div>
          <div class="brush-shape-btn" data-shape="leaf">Leaf</div>
          <div class="brush-shape-btn" data-shape="square">Square</div>
          <div class="brush-shape-btn" data-shape="star">Star</div>
          <div class="brush-shape-btn" data-shape="custom">Custom</div>
        </div>
      </div>

      <div class="panel-section">
        <h3>üìö Layers</h3>
        <div class="layer-list" id="layerList">
          <div class="layer-item active">
            <span class="layer-name">Layer 1</span>
            <div class="layer-controls">
              <button class="layer-btn">üëÅÔ∏è</button>
              <button class="layer-btn">üîí</button>
            </div>
          </div>
        </div>
        <div style="display: flex; gap: 4px; margin-top: 8px;">
          <button style="flex: 1; padding: 8px; background: #16a34a; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-weight: 500;" onclick="incrementLayer()">+ Increment</button>
          <button style="flex: 1; padding: 8px; background: #dc2626; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-weight: 500;" onclick="decrementLayer()">‚àí Decrement</button>
        </div>
        <button style="margin-top: 4px; width: 100%; padding: 8px; background: #2563eb; border: none; color: #fff; border-radius: 4px; cursor: pointer;" onclick="addLayer()">+ New Layer</button>
        
        <div class="control-row" style="margin-top: 12px;">
          <label>Layer Isolation</label>
          <button id="isolateLayerBtn" style="width: 100%; padding: 6px; background: #7c3aed; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px;" onclick="toggleLayerIsolation()">üîç Isolate Active Layer</button>
        </div>
        <div class="control-row">
          <label>Capture Frame</label>
          <button style="width: 100%; padding: 6px; background: #0891b2; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px;" onclick="captureLayerFrame()">üì∏ Freeze as Image</button>
        </div>
      </div>

      <div class="panel-section">
        <h3>üé≤ Objects on Board</h3>
        <p style="font-size: 10px; color: #8a9aad; margin-bottom: 12px;">Place 3D objects on the board</p>
        
        <h4 style="font-size: 11px; color: #7dd3fc; margin-bottom: 8px;">PRIMITIVE SHAPES</h4>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 12px;">
          <button class="object-spawn-btn" onclick="spawnObject('sphere')" style="padding: 10px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 11px;">
            ‚ö™ Sphere
          </button>
          <button class="object-spawn-btn" onclick="spawnObject('cube')" style="padding: 10px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 11px;">
            üî≤ Cube
          </button>
          <button class="object-spawn-btn" onclick="spawnObject('cylinder')" style="padding: 10px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 11px;">
            ü•´ Cylinder
          </button>
          <button class="object-spawn-btn" onclick="spawnObject('cone')" style="padding: 10px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 11px;">
            üî∫ Cone
          </button>
          <button class="object-spawn-btn" onclick="spawnObject('torus')" style="padding: 10px; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 11px;">
            üç© Torus
          </button>
          <button class="object-spawn-btn" onclick="spawnObject('plane')" style="padding: 10px; background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 11px;">
            üìÑ Plane
          </button>
        </div>

        <h4 style="font-size: 11px; color: #7dd3fc; margin-bottom: 8px;">OBJECT CONTROLS</h4>
        <div class="control-row">
          <label style="font-size: 10px;">Transform Mode</label>
          <select id="objectTransformMode" style="width: 100%; padding: 6px; background: #1e2836; border: 1px solid #2e3b4e; border-radius: 4px; color: #d4dce6; font-size: 11px;">
            <option value="translate">Move (G)</option>
            <option value="rotate">Rotate (R)</option>
            <option value="scale">Scale (S)</option>
          </select>
        </div>
        <div class="control-row">
          <label style="font-size: 10px;">Possession Mode</label>
          <button id="possessionBtn" style="width: 100%; padding: 8px; background: #dc2626; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;" onclick="togglePossession()">
            üëª Possess Object (WASD)
          </button>
        </div>
        <div class="control-row">
          <label style="font-size: 10px;">Flip & Position</label>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px;">
            <button onclick="flipObject('x')" style="padding: 6px; background: #374151; border: 1px solid #4b5563; color: #ef4444; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600;">‚ÜîÔ∏è X</button>
            <button onclick="flipObject('y')" style="padding: 6px; background: #374151; border: 1px solid #4b5563; color: #22c55e; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600;">‚ÜïÔ∏è Y</button>
            <button onclick="flipObject('z')" style="padding: 6px; background: #374151; border: 1px solid #4b5563; color: #3b82f6; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600;">‚§¥Ô∏è Z</button>
          </div>
        </div>
        <div class="control-row">
          <label style="font-size: 10px;">Quick Actions</label>
          <div style="display: flex; gap: 4px;">
            <button onclick="duplicateObject()" style="flex: 1; padding: 6px; background: #0891b2; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px;">üìã Duplicate</button>
            <button onclick="deleteObject()" style="flex: 1; padding: 6px; background: #dc2626; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px;">üóëÔ∏è Delete</button>
          </div>
        </div>
      </div>

      <!-- NEW: BINDING SYSTEM PANEL -->
      <div class="panel-section">
        <h3>üîó Object Binding</h3>
        <p style="font-size: 10px; color: #8a9aad; margin-bottom: 12px;">Connect objects with constraints</p>
        
        <div class="control-row">
          <label style="font-size: 10px;">Activation</label>
          <button style="width: 100%; padding: 8px; background: #10b981; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;" onclick="startBinding()">
            üîó Start Binding (Alt+L)
          </button>
        </div>
        
        <h4 style="font-size: 11px; color: #7dd3fc; margin: 12px 0 8px 0;">BINDING TYPES</h4>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 12px;">
          <button onclick="setBindingType('rigid')" style="padding: 8px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 10px;">
            üî¥ Rigid (1)
          </button>
          <button onclick="setBindingType('elastic')" style="padding: 8px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 10px;">
            üü¢ Elastic (2)
          </button>
          <button onclick="setBindingType('chain')" style="padding: 8px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 10px;">
            üü† Chain (3)
          </button>
          <button onclick="setBindingType('weld')" style="padding: 8px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 10px;">
            üîµ Weld (4)
          </button>
        </div>

        <div class="control-row">
          <label>Binding Strength</label>
          <input type="range" id="bindingStrength" min="0.1" max="2.0" step="0.1" value="1.0">
          <input type="number" id="bindingStrengthValue" min="0.1" max="2.0" step="0.1" value="1.0" style="width: 60px;">
        </div>

        <div class="control-row">
          <label style="font-size: 10px;">Active Bindings</label>
          <div style="padding: 6px 10px; background: #1e2836; border: 1px solid #2e3b4e; border-radius: 4px; font-size: 11px; color: #7dd3fc;">
            <span id="bindingCount">0</span> connections
          </div>
        </div>

        <div class="control-row">
          <label style="font-size: 10px;">Quick Actions</label>
          <button style="width: 100%; padding: 6px; background: #dc2626; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px;" onclick="breakAllBindings()">
            ‚ùå Break All Bindings (Ctrl+Shift+X)
          </button>
        </div>
      </div>

      <!-- NEW: FRAGMENTATION SYSTEM PANEL -->
      <div class="panel-section">
        <h3>üí• Fragmentation</h3>
        <p style="font-size: 10px; color: #8a9aad; margin-bottom: 12px;">Shatter objects into pieces</p>
        
        <div class="control-row">
          <label style="font-size: 10px;">Activation</label>
          <button style="width: 100%; padding: 8px; background: #dc2626; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;" onclick="startFragmentation()">
            üí• Activate Fragment Mode (Alt+F)
          </button>
        </div>
        
        <h4 style="font-size: 11px; color: #7dd3fc; margin: 12px 0 8px 0;">ALGORITHMS</h4>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 12px;">
          <button onclick="setFragmentAlgorithm('voronoi')" style="padding: 8px; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 10px;">
            üîÆ Voronoi (5)
          </button>
          <button onclick="setFragmentAlgorithm('voxel')" style="padding: 8px; background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 10px;">
            üì¶ Voxel (6)
          </button>
          <button onclick="setFragmentAlgorithm('radial')" style="padding: 8px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 10px;">
            ‚≠ê Radial (7)
          </button>
          <button onclick="setFragmentAlgorithm('slice')" style="padding: 8px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 10px;">
            üî™ Slice (8)
          </button>
        </div>

        <div class="control-row">
          <label>Fragment Count</label>
          <input type="range" id="fragmentCount" min="5" max="100" step="5" value="20">
          <input type="number" id="fragmentCountValue" min="5" max="100" step="5" value="20" style="width: 60px;">
        </div>

        <div class="control-row">
          <label>Scatter Velocity</label>
          <input type="range" id="scatterVelocity" min="0" max="10" step="0.5" value="3.0">
          <input type="number" id="scatterVelocityValue" min="0" max="10" step="0.5" value="3.0" style="width: 60px;">
        </div>

        <div class="control-row">
          <label style="font-size: 10px;">Quick Actions</label>
          <div style="display: flex; gap: 4px;">
            <button onclick="applyFragmentation()" style="flex: 1; padding: 6px; background: #10b981; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px;">‚ú® Apply (Space)</button>
            <button onclick="clearFragments()" style="flex: 1; padding: 6px; background: #dc2626; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px;">üóëÔ∏è Clear</button>
          </div>
        </div>
      </div>

      <!-- NEW: PARTICLE SYSTEM PANEL -->
      <div class="panel-section">
        <h3>‚ú® Particle Effects</h3>
        <p style="font-size: 10px; color: #8a9aad; margin-bottom: 12px;">Add dynamic visual effects</p>
        
        <div class="control-row">
          <label style="font-size: 10px;">Emission</label>
          <button style="width: 100%; padding: 8px; background: #f59e0b; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;" onclick="emitParticles()">
            ‚ú® Emit Particles (Alt+P)
          </button>
        </div>
        
        <h4 style="font-size: 11px; color: #7dd3fc; margin: 12px 0 8px 0;">PARTICLE TYPES</h4>
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; margin-bottom: 12px;">
          <button onclick="setParticleType('smoke')" style="padding: 6px; background: #6b7280; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 9px;">
            üí® Smoke
          </button>
          <button onclick="setParticleType('sparks')" style="padding: 6px; background: #fbbf24; border: none; color: #000; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 9px;">
            ‚ö° Sparks
          </button>
          <button onclick="setParticleType('embers')" style="padding: 6px; background: #f97316; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 9px;">
            üî• Embers
          </button>
          <button onclick="setParticleType('debris')" style="padding: 6px; background: #78716c; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 9px;">
            ü™® Debris
          </button>
          <button onclick="setParticleType('fire')" style="padding: 6px; background: #dc2626; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 9px;">
            üî• Fire
          </button>
        </div>

        <div class="control-row">
          <label>Emission Rate</label>
          <input type="range" id="emissionRate" min="10" max="1000" step="10" value="100">
          <input type="number" id="emissionRateValue" min="10" max="1000" step="10" value="100" style="width: 60px;">
        </div>

        <div class="control-row">
          <label>Particle Size</label>
          <input type="range" id="particleSize" min="0.05" max="0.5" step="0.05" value="0.1">
          <input type="number" id="particleSizeValue" min="0.05" max="0.5" step="0.05" value="0.1" style="width: 60px;">
        </div>

        <div class="control-row">
          <label>Particle Lifetime</label>
          <input type="range" id="particleLifetime" min="0.5" max="5" step="0.5" value="2.0">
          <input type="number" id="particleLifetimeValue" min="0.5" max="5" step="0.5" value="2.0" style="width: 60px;">
        </div>

        <div class="control-row">
          <label>Emitter Type</label>
          <div style="display: flex; gap: 4px;">
            <button onclick="setEmitterType('point')" style="flex: 1; padding: 6px; background: #374151; border: 1px solid #4b5563; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 10px;">üìç Point</button>
            <button onclick="setEmitterType('area')" style="flex: 1; padding: 6px; background: #374151; border: 1px solid #4b5563; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 10px;">‚¨ú Area</button>
            <button onclick="setEmitterType('trail')" style="flex: 1; padding: 6px; background: #374151; border: 1px solid #4b5563; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 10px;">„Ä∞Ô∏è Trail</button>
          </div>
        </div>

        <div class="control-row">
          <label style="font-size: 10px;">Quick Actions</label>
          <div style="display: flex; gap: 4px;">
            <button onclick="toggleParticles()" style="flex: 1; padding: 6px; background: #3b82f6; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px;">‚èØÔ∏è Toggle (9)</button>
            <button onclick="clearParticles()" style="flex: 1; padding: 6px; background: #dc2626; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px;">üóëÔ∏è Clear</button>
          </div>
        </div>
      </div>

      <div class="panel-section">
        <h3>üéõÔ∏è Layer Settings</h3>
          <select id="layerBlendMode">
            <option value="normal">Normal</option>
            <option value="add">Add</option>
            <option value="multiply">Multiply</option>
            <option value="overlay">Overlay</option>
          </select>
        </div>
        <div class="control-row">
          <label>Opacity</label>
          <input type="range" id="layerOpacity" min="0" max="1" step="0.05" value="1.0">
        </div>
      </div>

      <div class="panel-section">
        <h3>üé® Material</h3>
        <div class="control-row">
          <label>Preset</label>
          <select id="materialPreset">
            <option value="standard">Standard</option>
            <option value="metallic">Metallic</option>
            <option value="rough">Rough Stone</option>
            <option value="wood">Wood</option>
            <option value="bark">Fine Bark</option>
            <option value="chunky">Chunky Rock</option>
            <option value="waves">Layered Waves</option>
            <option value="plastic">Plastic</option>
            <option value="glass">Glass</option>
          </select>
        </div>
        <div class="control-row">
          <label>Displacement</label>
          <input type="range" id="displacementDepth" min="0" max="2" step="0.1" value="0.5">
        </div>
        <div class="control-row">
          <label>Detail Level</label>
          <input type="range" id="detailLevel" min="0.1" max="5" step="0.1" value="1.0">
        </div>
        <div class="control-row">
          <label>Color Tint</label>
          <input type="color" id="colorTint" value="#6f513a">
        </div>
        <div class="control-row">
          <label>Auto-Normal</label>
          <input type="checkbox" id="autoNormalRefresh" checked>
        </div>
        <button style="width: 100%; margin-top: 8px; padding: 8px; background: #1e40af; border: none; color: #fff; border-radius: 4px; cursor: pointer;" onclick="applyProceduralPattern()">Apply Procedural Pattern</button>
      </div>
    </div>

    <!-- Center Viewport -->
    <div id="viewport">
      <canvas id="canvas3d"></canvas>
      
      <!-- Transform Controls Widget -->
      <div id="transformControls">
        <h4>üéØ Transform</h4>
        <div class="transform-btn-group">
          <button class="transform-btn" id="orbitModeBtn" onclick="setTransformMode('orbit')">Orbit</button>
          <button class="transform-btn" id="translateModeBtn" onclick="setTransformMode('translate')">Move</button>
        </div>
        <div id="positionInputs" style="display: none;">
          <div class="axis-input-group">
            <span class="axis-label x">X</span>
            <input type="number" class="axis-input" id="posX" step="0.1" value="0">
          </div>
          <div class="axis-input-group">
            <span class="axis-label y">Y</span>
            <input type="number" class="axis-input" id="posY" step="0.1" value="1">
          </div>
          <div class="axis-input-group">
            <span class="axis-label z">Z</span>
            <input type="number" class="axis-input" id="posZ" step="0.1" value="0">
          </div>
        </div>
      </div>

      <div id="viewportOverlay">
        <h4>üéØ Quick Guide</h4>
        <div><strong>B/C/L Keys:</strong> Box/Circle/Lasso Select</div>
        <div><strong>I/G/H Keys:</strong> Invert/Grow/Shrink Selection</div>
        <div><strong>Escape:</strong> Clear Selection</div>
        <div><strong>Ctrl+A:</strong> Select All</div>
        <div><strong>+ / -:</strong> Build / Carve Layers</div>
        <div><strong>F Key:</strong> Flight Mode (WASD)</div>
      </div>
      
      <!-- Copyright & IP Protection UI -->
      <div style="position: fixed; bottom: 10px; right: 10px; font-size: 10px; color: rgba(255,255,255,0.3); pointer-events: none; z-index: 10000;" id="buildWatermark">
        PPG-HUMAN-${Date.now()} | Patent Pending | ¬© 2025 Jeremy
      </div>
      
      <div style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 6px 10px; border-radius: 4px; font-size: 10px; color: #0ff; border: 1px solid #0ff; z-index: 10000; pointer-events: none;">
        PixelProdigy‚Ñ¢ Human Sculpt v1.0.0-alpha<br>
        ¬© 2025 Jeremy/EugeNEOusXR - Proprietary
      </div>

      <!-- CAM-003: Flight Mode Indicator -->
      <div id="flightModeIndicator">
        <div>‚úàÔ∏è FLIGHT MODE</div>
        <div class="speed-display" id="flightSpeedDisplay">Speed: 1.0x</div>
      </div>

      <!-- SEL-001: Box Selection Overlay -->
      <div id="selectionCanvas">
        <div id="selectionBox" class="selection-box"></div>
      </div>

      <!-- Radial Transform Menu -->
      <div id="radialMenu">
        <div class="radial-menu-center">‚ö°</div>
        <div class="radial-menu-item" data-transform="move" style="top: -90px; left: 0;">
          <div class="icon">‚ÜïÔ∏è</div>
          <div class="label">Move</div>
        </div>
        <div class="radial-menu-item" data-transform="rotate" style="top: -64px; left: 64px;">
          <div class="icon">üîÑ</div>
          <div class="label">Rotate</div>
        </div>
        <div class="radial-menu-item" data-transform="scale" style="top: 0; left: 90px;">
          <div class="icon">üìê</div>
          <div class="label">Scale</div>
        </div>
        <div class="radial-menu-item" data-transform="stretch" style="top: 64px; left: 64px;">
          <div class="icon">‚ÜîÔ∏è</div>
          <div class="label">Stretch</div>
        </div>
        <div class="radial-menu-item" data-transform="sharpen" style="top: 90px; left: 0;">
          <div class="icon">üî∫</div>
          <div class="label">Sharpen</div>
        </div>
        <div class="radial-menu-item" data-transform="smooth" style="top: 64px; left: -64px;">
          <div class="icon">„Ä∞Ô∏è</div>
          <div class="label">Smooth</div>
        </div>
        <div class="radial-menu-item" data-transform="extend" style="top: 0; left: -90px;">
          <div class="icon">‚û°Ô∏è</div>
          <div class="label">Extend</div>
        </div>
        <div class="radial-menu-item" data-transform="shrink" style="top: -64px; left: -64px;">
          <div class="icon">‚¨ÖÔ∏è</div>
          <div class="label">Shrink</div>
        </div>
      </div>
    </div>

    <!-- Right Panel -->
    <div id="rightPanel">
      <div class="panel-section">
        <h3>ü§ñ AI Guidance</h3>
        
        <div class="ai-suggestion-box">
          <h4>üí° Suggestion</h4>
          <p id="aiSuggestionText">Click "Ask AI" to get sculpting suggestions based on your current scene.</p>
          <button onclick="applyAISuggestion()">Apply</button>
          <button onclick="dismissAISuggestion()">Dismiss</button>
        </div>

        <div class="control-row">
          <label>Model</label>
          <select id="aiModel">
            <option value="openai">OpenAI GPT-4</option>
            <option value="gemini">Google Gemini Pro</option>
          </select>
        </div>

        <div class="control-row">
          <label>Template</label>
          <select id="promptTemplate">
            <option value="organic">Organic Forms</option>
            <option value="architectural">Architectural</option>
            <option value="natural">Natural Terrain</option>
            <option value="character">Character</option>
            <option value="custom">Custom</option>
          </select>
        </div>

        <div class="control-row">
          <label>Pattern Seed</label>
          <input type="number" id="patternSeed" value="42" min="0">
        </div>

        <div class="control-row">
          <label>Guidance Strength</label>
          <input type="range" id="guidanceStrength" min="0" max="1" step="0.1" value="0.7">
        </div>

        <div class="control-row">
          <label>Refresh Rate</label>
          <input type="number" id="suggestionRefreshRate" value="5" min="1" max="60">
          <span style="font-size: 11px; color: #8a9aad;">s</span>
        </div>

        <div class="control-row">
          <label>Auto-Apply</label>
          <input type="checkbox" id="autoApplyThreshold">
        </div>

        <div class="control-row">
          <label>Overlay</label>
          <input type="checkbox" id="feedbackOverlay" checked>
        </div>

        <button style="width: 100%; margin-top: 12px; padding: 10px; background: #2563eb; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-weight: 500;" onclick="askAI()">Ask AI</button>
      </div>

      <div class="panel-section">
        <h3>üåç Environment</h3>
        
        <div class="env-control-grid">
          <div class="control-row">
            <label>Theme</label>
            <select id="sceneTheme">
              <option value="studio">Studio</option>
              <option value="outdoor">Outdoor</option>
              <option value="sunset">Sunset</option>
              <option value="night">Night</option>
              <option value="underwater">Underwater</option>
            </select>
          </div>

          <div class="control-row">
            <label>Lighting</label>
            <select id="lightingRig">
              <option value="three-point">Three-Point</option>
              <option value="natural">Natural</option>
              <option value="dramatic">Dramatic</option>
              <option value="soft">Soft</option>
            </select>
          </div>

          <div class="control-row">
            <label>Time of Day</label>
            <input type="range" id="timeOfDay" min="0" max="24" step="0.5" value="12">
            <span id="timeOfDayValue" style="font-size: 11px; color: #8a9aad;">12:00</span>
          </div>

          <div class="control-row">
            <label>Fog Density</label>
            <input type="range" id="fogDensity" min="0" max="0.1" step="0.005" value="0.05">
            <span id="fogDensityValue" style="font-size: 11px; color: #8a9aad;">0.05</span>
          </div>

          <!-- ENV-002: Fog Preset Buttons -->
          <div class="control-row" style="display: flex; gap: 6px; flex-wrap: wrap;">
            <button class="fog-preset-btn" data-preset="none" style="flex: 1; min-width: 60px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;" onclick="applyFogPreset('none')">None</button>
            <button class="fog-preset-btn" data-preset="light" style="flex: 1; min-width: 60px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;" onclick="applyFogPreset('light')">Light</button>
            <button class="fog-preset-btn" data-preset="medium" style="flex: 1; min-width: 60px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;" onclick="applyFogPreset('medium')">Medium</button>
            <button class="fog-preset-btn" data-preset="heavy" style="flex: 1; min-width: 60px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;" onclick="applyFogPreset('heavy')">Heavy</button>
          </div>

          <div class="control-row">
            <label>Ground Size</label>
            <input type="number" id="groundPlaneSize" value="30" min="10" max="100" step="5" style="width: 70px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; padding: 6px 8px; border-radius: 4px; font-size: 12px;">
            <span style="font-size: 11px; color: #8a9aad; margin-left: 4px;">m</span>
          </div>

          <!-- ENV-003: Ground Size Preset Buttons -->
          <div class="control-row" style="display: flex; gap: 6px; flex-wrap: wrap;">
            <button style="flex: 1; min-width: 50px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;" onmouseover="this.style.background='#252f3d'" onmouseout="this.style.background='#1e2836'" onclick="updateGroundPlane(10)">10m</button>
            <button style="flex: 1; min-width: 50px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;" onmouseover="this.style.background='#252f3d'" onmouseout="this.style.background='#1e2836'" onclick="updateGroundPlane(30)">30m</button>
            <button style="flex: 1; min-width: 50px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;" onmouseover="this.style.background='#252f3d'" onmouseout="this.style.background='#1e2836'" onclick="updateGroundPlane(50)">50m</button>
            <button style="flex: 1; min-width: 50px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;" onmouseover="this.style.background='#252f3d'" onmouseout="this.style.background='#1e2836'" onclick="updateGroundPlane(100)">100m</button>
          </div>

          <!-- ENV-004: Ground Material Preset Buttons -->
          <div class="control-row">
            <label style="margin-bottom: 6px; display: block;">Material</label>
            <div style="display: flex; gap: 6px; flex-wrap: wrap;">
              <button class="material-preset-btn" data-material="grass" style="flex: 1; min-width: 70px; padding: 8px 6px; background: linear-gradient(135deg, #2d5016 0%, #3a6b1e 100%); border: 1px solid #4a7f2a; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.2s; text-shadow: 0 1px 2px rgba(0,0,0,0.3);" onclick="applyGroundMaterial('grass')">üåø Grass</button>
              <button class="material-preset-btn" data-material="concrete" style="flex: 1; min-width: 70px; padding: 8px 6px; background: linear-gradient(135deg, #555555 0%, #666666 100%); border: 1px solid #777777; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.2s; text-shadow: 0 1px 2px rgba(0,0,0,0.3);" onclick="applyGroundMaterial('concrete')">üèóÔ∏è Concrete</button>
              <button class="material-preset-btn" data-material="sand" style="flex: 1; min-width: 70px; padding: 8px 6px; background: linear-gradient(135deg, #c2a569 0%, #d4b778 100%); border: 1px solid #e0c889; color: #2a2520; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.2s; text-shadow: 0 1px 2px rgba(255,255,255,0.2);" onclick="applyGroundMaterial('sand')">üèñÔ∏è Sand</button>
              <button class="material-preset-btn" data-material="water" style="flex: 1; min-width: 70px; padding: 8px 6px; background: linear-gradient(135deg, #1e90ff 0%, #4da6ff 100%); border: 1px solid #6bb8ff; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.2s; text-shadow: 0 1px 2px rgba(0,0,0,0.3);" onclick="applyGroundMaterial('water')">üíß Water</button>
              <button class="material-preset-btn" data-material="metal" style="flex: 1; min-width: 70px; padding: 8px 6px; background: linear-gradient(135deg, #888888 0%, #aaaaaa 100%); border: 1px solid #bbbbbb; color: #1a1a1a; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.2s; text-shadow: 0 1px 2px rgba(255,255,255,0.2);" onclick="applyGroundMaterial('metal')">‚öôÔ∏è Metal</button>
            </div>
          </div>

          <div class="control-row">
            <label>Gravity</label>
            <select id="gravityAxis">
              <option value="-y">-Y (Down)</option>
              <option value="+y">+Y (Up)</option>
              <option value="-z">-Z</option>
              <option value="none">None</option>
            </select>
          </div>

          <div class="control-row">
            <label>Orbit Speed</label>
            <input type="range" id="cameraOrbitSpeed" min="0.1" max="2" step="0.1" value="0.5">
            <span id="cameraOrbitSpeedValue" style="font-size: 11px; color: #8a9aad;">0.5x</span>
          </div>

          <!-- ENV-005: Camera Position Presets -->
          <div class="control-row">
            <label style="margin-bottom: 6px; display: block;">Camera View</label>
            <div style="display: flex; gap: 6px; flex-wrap: wrap;">
              <button class="camera-preset-btn" data-view="top" style="flex: 1; min-width: 60px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.2s;" onclick="setCameraView('top')">‚¨ÜÔ∏è Top</button>
              <button class="camera-preset-btn" data-view="front" style="flex: 1; min-width: 60px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.2s;" onclick="setCameraView('front')">üëÅÔ∏è Front</button>
              <button class="camera-preset-btn" data-view="side" style="flex: 1; min-width: 60px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.2s;" onclick="setCameraView('side')">‚û°Ô∏è Side</button>
              <button class="camera-preset-btn" data-view="isometric" style="flex: 1; min-width: 60px; padding: 8px 6px; background: #1e2836; border: 1px solid #2e3b4e; color: #d4dce6; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.2s;" onclick="setCameraView('isometric')">üìê Iso</button>
            </div>
          </div>
        </div>

        <button style="width: 100%; margin-top: 12px; padding: 8px; background: #1e40af; border: none; color: #fff; border-radius: 4px; cursor: pointer;" onclick="loadHDRI()">Load HDRI</button>
      </div>
    </div>
  </div>

  <!-- Timeline -->
  <div id="timeline">
    <div class="timeline-frame active">Frame 1</div>
    <div class="timeline-frame">Frame 2</div>
    <div class="timeline-frame">Frame 3</div>
    <div class="timeline-frame">Frame 4</div>
    <div class="timeline-frame">+ Add</div>
  </div>

  <!-- Status Bar -->
  <div id="statusBar">
    <span id="statusLeft">Ready</span>
    <span id="aiSyncStatus" style="color: #666666;">‚ö™ AI Studio Offline</span>
    <span id="statusRight">Vertices: 0 | Triangles: 0</span>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
    }
  }
  </script>
  
  <!-- PHYS-001: Cannon.js Physics Engine (UMD version for global CANNON) -->
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BUILD FINGERPRINT & COPYRIGHT ENFORCEMENT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const BUILD_INFO = {
      version: '1.0.0-alpha',
      buildDate: new Date().toISOString(),
      fingerprint: `PPG-HUMAN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      copyright: '¬© 2025 Jeremy (EugeNEOusXR/PixelProdigy)',
      license: 'PROPRIETARY',
      patentStatus: 'Pending',
      uniqueInnovations: [
        'Lasso-guided laser cutting',
        'Dual-window architecture',
        'Selection utilities (SEL-004)',
        'Physics-based destruction'
      ]
    };

    // Log build info to console (forensic tracking)
    console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color: #0ff; font-weight: bold;');
    console.log('%cPixelProdigy Human Sculpt Window', 'color: #0ff; font-size: 18px; font-weight: bold;');
    console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color: #0ff; font-weight: bold;');
    console.log('Build Info:', BUILD_INFO);
    console.log('%cPROPRIETARY & CONFIDENTIAL', 'color: #f00; font-weight: bold; font-size: 14px;');
    console.log('%cUnauthorized use, copying, or distribution prohibited', 'color: #ff0;');
    console.log('%cPatent Pending | Trademark: PixelProdigy‚Ñ¢', 'color: #0f0;');
    console.log('Innovations:', BUILD_INFO.uniqueInnovations);
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

    // Store build fingerprint in session
    sessionStorage.setItem('ppg_build_fingerprint', BUILD_INFO.fingerprint);
    sessionStorage.setItem('ppg_session_start', Date.now());
    
    // Send heartbeat to AI window (for inter-window communication)
    setInterval(() => {
      localStorage.setItem('ppg_human_heartbeat', Date.now().toString());
    }, 1000);
    
    // Update watermark with actual build fingerprint
    const watermark = document.getElementById('buildWatermark');
    if (watermark) {
      watermark.textContent = `${BUILD_INFO.fingerprint} | Patent Pending | ${BUILD_INFO.copyright}`;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // THREE.JS SCENE SETUP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117); // Slightly lighter background for showcase
    scene.fog = new THREE.Fog(0x0d1117, 15, 45); // Add atmospheric depth

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(7, 6, 9); // Better showcase angle - higher and angled

    const canvas = document.getElementById('canvas3d');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer, more realistic shadows
    renderer.toneMapping = THREE.ACESFilmicToneMapping; // Cinematic tone mapping
    renderer.toneMappingExposure = 1.2; // Slightly brighter exposure

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.rotateSpeed = 0.5; // ENV-006: Initialize orbit speed
    controls.target.set(0, 1.5, 0); // Look at the cylinder center

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INTER-WINDOW COMMUNICATION SYSTEM
    // Real-time sync between Human Sculpt Window and AI Studio Window
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const WINDOW_ID = 'human-sculpt-' + Date.now();
    const SYNC_KEY = 'pixelprodigy-sync';
    const HEARTBEAT_KEY = 'pixelprodigy-heartbeat';
    
    // Window state
    const windowState = {
      id: WINDOW_ID,
      type: 'human-sculpt',
      lastUpdate: Date.now(),
      geometry: null,
      selection: [],
      camera: { position: [0, 0, 5], target: [0, 0, 0] }
    };

    // Send geometry to AI Studio
    function sendGeometryToAI() {
      if (!sculptGeometry) {
        console.log('‚ö†Ô∏è No geometry to send');
        return;
      }
      
      const positions = Array.from(sculptGeometry.attributes.position.array);
      const normals = Array.from(sculptGeometry.attributes.normal.array);
      
      const geometryData = {
        type: 'geometry-update',
        source: WINDOW_ID,
        timestamp: Date.now(),
        positions: positions,
        normals: normals,
        vertexCount: sculptGeometry.attributes.position.count,
        selectedVertices: Array.from(selectedVertices)
      };
      
      localStorage.setItem(SYNC_KEY, JSON.stringify(geometryData));
      console.log(`üì§ Sent geometry to AI Studio | ${geometryData.vertexCount} vertices`);
    }

    // Receive geometry from AI Studio
    function receiveGeometryFromAI() {
      const syncData = localStorage.getItem(SYNC_KEY);
      if (!syncData) {
        console.log('‚ö†Ô∏è No geometry data from AI Studio');
        return;
      }
      
      try {
        const data = JSON.parse(syncData);
        
        // Ignore our own messages
        if (data.source === WINDOW_ID) return;
        
        if (data.type === 'geometry-update' && sculptGeometry) {
          // Update geometry
          const positions = new Float32Array(data.positions);
          sculptGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          
          if (data.normals) {
            const normals = new Float32Array(data.normals);
            sculptGeometry.setAttribute('normals', new THREE.BufferAttribute(normals, 3));
          } else {
            sculptGeometry.computeVertexNormals();
          }
          
          sculptGeometry.attributes.position.needsUpdate = true;
          
          console.log(`üì• Received geometry from AI Studio | ${data.vertexCount} vertices`);
          updateStatus(`Received AI geometry: ${data.vertexCount} vertices`);
        }
      } catch (e) {
        console.error('Error receiving geometry:', e);
      }
    }

    // Heartbeat to show window is active
    function sendHeartbeat() {
      windowState.lastUpdate = Date.now();
      localStorage.setItem(HEARTBEAT_KEY + '-human', JSON.stringify(windowState));
    }

    // Check for AI Studio window
    function checkAIStudioConnection() {
      const aiHeartbeat = localStorage.getItem(HEARTBEAT_KEY + '-ai');
      if (aiHeartbeat) {
        try {
          const data = JSON.parse(aiHeartbeat);
          const age = Date.now() - data.lastUpdate;
          return age < 5000; // Active if updated within 5 seconds
        } catch (e) {
          return false;
        }
      }
      return false;
    }

    // Sync status indicator
    function updateSyncStatus() {
      const aiConnected = checkAIStudioConnection();
      const statusEl = document.getElementById('aiSyncStatus');
      if (statusEl) {
        statusEl.textContent = aiConnected ? 'üü¢ AI Studio Connected' : '‚ö™ AI Studio Offline';
        statusEl.style.color = aiConnected ? '#00ff00' : '#666666';
      }
    }

    // Start heartbeat and sync check
    setInterval(sendHeartbeat, 1000);
    setInterval(updateSyncStatus, 1000);
    setInterval(() => {
      // Auto-receive if AI Studio is active
      if (checkAIStudioConnection()) {
        const syncData = localStorage.getItem(SYNC_KEY);
        if (syncData) {
          try {
            const data = JSON.parse(syncData);
            if (data.source !== WINDOW_ID && Date.now() - data.timestamp < 2000) {
              receiveGeometryFromAI();
            }
          } catch (e) {}
        }
      }
    }, 2000);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHYS-001: PHYSICS ENGINE INITIALIZATION
    // Cannon.js rigid body physics with gravity simulation
    // Foundation for: BIND-001, DESTRUCT-001, FRAG-001, LASER-001, BURN-001, SCENE-001
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Create physics world
    const physicsWorld = new CANNON.World({
      gravity: new CANNON.Vec3(0, -9.82, 0) // Earth gravity
    });
    
    // Configure physics solver for better stability
    physicsWorld.solver.iterations = 10;
    physicsWorld.solver.tolerance = 0.001;
    
    // Broadphase for collision detection optimization
    physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);
    
    // Material for default physics objects
    const defaultMaterial = new CANNON.Material('default');
    const defaultContactMaterial = new CANNON.ContactMaterial(
      defaultMaterial,
      defaultMaterial,
      {
        friction: 0.4,
        restitution: 0.3 // Bounciness
      }
    );
    physicsWorld.addContactMaterial(defaultContactMaterial);
    
    // Ground plane for physics simulation
    const groundBody = new CANNON.Body({
      type: CANNON.Body.STATIC,
      shape: new CANNON.Plane()
    });
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Rotate to be horizontal
    physicsWorld.addBody(groundBody);
    
    // Visual representation of ground plane
    const groundGeometry = new THREE.PlaneGeometry(50, 50);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x222222, 
      roughness: 0.8,
      metalness: 0.2 
    });
    const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
    groundMesh.rotation.x = -Math.PI / 2;
    groundMesh.position.y = 0;
    groundMesh.receiveShadow = true;
    scene.add(groundMesh);
    
    // Physics enabled flag
    let physicsEnabled = false;
    
    // Rigid body for sculpt mesh (will be created when needed)
    let sculptBody = null;
    
    // Helper function to convert THREE.js position to CANNON.js
    function toCannon(vec3) {
      return new CANNON.Vec3(vec3.x, vec3.y, vec3.z);
    }
    
    // Helper function to convert CANNON.js position to THREE.js
    function toThree(vec3) {
      return new THREE.Vector3(vec3.x, vec3.y, vec3.z);
    }
    
    // Update physics simulation
    function updatePhysics(deltaTime) {
      if (!physicsEnabled) return;
      
      physicsWorld.step(1/60, deltaTime, 3);
      
      // Update sculpt mesh from physics body
      if (sculptBody && sculptMesh) {
        sculptMesh.position.copy(toThree(sculptBody.position));
        sculptMesh.quaternion.copy(sculptBody.quaternion);
      }
    }
    
    // Create physics body for sculpt mesh
    function createSculptPhysicsBody() {
      if (sculptBody) {
        physicsWorld.removeBody(sculptBody);
      }
      
      // Use bounding box for collision shape
      const bbox = new THREE.Box3().setFromObject(sculptMesh);
      const size = new THREE.Vector3();
      bbox.getSize(size);
      
      const shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
      
      sculptBody = new CANNON.Body({
        mass: 1, // 1kg
        shape: shape,
        material: defaultMaterial
      });
      
      sculptBody.position.copy(toCannon(sculptMesh.position));
      sculptBody.quaternion.copy(sculptMesh.quaternion);
      
      physicsWorld.addBody(sculptBody);
      
      console.log('‚öõÔ∏è Physics body created for sculpt mesh');
    }
    
    // Toggle physics simulation
    function togglePhysics() {
      physicsEnabled = !physicsEnabled;
      
      if (physicsEnabled) {
        if (!sculptBody && sculptMesh) {
          createSculptPhysicsBody();
        }
        console.log('‚öõÔ∏è Physics ENABLED');
        updateStatus('‚öõÔ∏è Physics simulation active');
      } else {
        console.log('‚öõÔ∏è Physics DISABLED');
        updateStatus('‚öõÔ∏è Physics simulation paused');
      }
    }
    
    console.log('‚úÖ PHYS-001: Physics engine initialized with Cannon.js');
    console.log('   - Gravity: -9.82 m/s¬≤');
    console.log('   - Ground plane added');
    console.log('   - Press P to toggle physics simulation');

    // CAM-001: Key tracking for WASD flight controls
    const keyState = {
      w: false,
      a: false,
      s: false,
      d: false,
      q: false,
      e: false,
      shift: false,
      ctrl: false
    };
    let flyMode = false;

    // SEL-001: Box selection state
    let selectionMode = false;
    let selectionStart = { x: 0, y: 0 };
    let selectionEnd = { x: 0, y: 0 };
    let isSelecting = false;
    const selectedVertices = new Set();
    const selectionBox = document.getElementById('selectionBox');

    // SEL-002: Circle selection state
    let circleSelectMode = false;
    let circleRadius = 50; // pixels
    let circleCenter = { x: 0, y: 0 };
    let circleModifyMode = null; // null, 'build', or 'carve'
    const circleSelectOverlay = document.createElement('div');
    circleSelectOverlay.id = 'circleSelectOverlay';
    circleSelectOverlay.style.position = 'absolute';
    circleSelectOverlay.style.border = '2px solid cyan';
    circleSelectOverlay.style.borderRadius = '50%';
    circleSelectOverlay.style.pointerEvents = 'none';
    circleSelectOverlay.style.display = 'none';
    circleSelectOverlay.style.zIndex = '1000';
    document.getElementById('selectionCanvas').appendChild(circleSelectOverlay);

    // SEL-003: Lasso selection state
    let lassoSelectMode = false;
    let lassoPath = []; // Array of {x, y} points
    let lassoActive = false; // Currently drawing lasso
    const lassoCanvas = document.createElement('canvas');
    lassoCanvas.id = 'lassoCanvas';
    lassoCanvas.style.position = 'absolute';
    lassoCanvas.style.top = '0';
    lassoCanvas.style.left = '0';
    lassoCanvas.style.pointerEvents = 'none';
    lassoCanvas.style.display = 'none';
    lassoCanvas.style.zIndex = '1000';
    document.getElementById('selectionCanvas').appendChild(lassoCanvas);
    const lassoCtx = lassoCanvas.getContext('2d');

    // Helper function to check if any selection tool is active
    function isAnySelectionToolActive() {
      return selectionMode || circleSelectMode || lassoSelectMode;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BIND-001: OBJECT BINDING SYSTEM
    // Lasso-based object binding with physics constraints
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let bindingMode = false;
    let bindingStep = 0; // 0 = not binding, 1 = first object selected, 2 = second object selected
    let firstBoundObject = null;
    let secondBoundObject = null;
    const boundObjects = []; // Array of bound object pairs
    const bindings = []; // Array of { obj1, obj2, type, constraint, visual }
    let bindingType = 'rigid'; // 'rigid', 'elastic', 'chain', 'weld'
    let bindingStrength = 1.0; // 0.1 to 2.0
    let breakThreshold = 1000; // Force required to break binding
    
    // Visual tether lines for bindings
    const tetherLines = [];
    
    // Create a binding between two objects
    function createBinding(obj1, obj2, type = 'rigid') {
      if (!obj1.body || !obj2.body) {
        console.warn('‚ö†Ô∏è Both objects must have physics bodies for binding');
        return null;
      }
      
      let constraint = null;
      
      switch (type) {
        case 'rigid':
          // Lock constraint - objects move as rigid unit
          constraint = new CANNON.LockConstraint(obj1.body, obj2.body);
          break;
          
        case 'elastic':
          // Spring constraint - objects connected by spring
          const restLength = obj1.body.position.distanceTo(obj2.body.position);
          constraint = new CANNON.Spring(obj1.body, obj2.body, {
            restLength: restLength,
            stiffness: 50 * bindingStrength,
            damping: 5
          });
          break;
          
        case 'chain':
          // Point-to-point constraint - allows rotation
          constraint = new CANNON.PointToPointConstraint(
            obj1.body,
            new CANNON.Vec3(0, 0, 0),
            obj2.body,
            new CANNON.Vec3(0, 0, 0),
            breakThreshold
          );
          break;
          
        case 'weld':
          // Merge geometry (no physics constraint needed)
          console.log('üîó Weld binding: merging geometry');
          // TODO: Implement geometry merging
          return null;
      }
      
      if (constraint) {
        if (type === 'elastic') {
          // Springs are updated per frame, not added to world
          obj1.body.spring = constraint;
        } else {
          physicsWorld.addConstraint(constraint);
        }
        
        // Create visual tether line
        const tetherGeometry = new THREE.BufferGeometry();
        const tetherMaterial = new THREE.LineBasicMaterial({
          color: type === 'rigid' ? 0x00ff00 : type === 'elastic' ? 0xffff00 : 0xff8800,
          linewidth: 2,
          transparent: true,
          opacity: 0.6
        });
        const tetherLine = new THREE.Line(tetherGeometry, tetherMaterial);
        scene.add(tetherLine);
        tetherLines.push(tetherLine);
        
        const binding = {
          obj1: obj1,
          obj2: obj2,
          type: type,
          constraint: constraint,
          visual: tetherLine,
          strength: bindingStrength,
          breakThreshold: breakThreshold
        };
        
        bindings.push(binding);
        
        console.log(`üîó Binding created: ${type} constraint between objects`);
        updateStatus(`üîó Binding created: ${type.toUpperCase()} link (strength: ${bindingStrength})`);
        
        return binding;
      }
      
      return null;
    }
    
    // Update visual tethers each frame
    function updateBindingVisuals() {
      bindings.forEach((binding, index) => {
        if (binding.visual && binding.obj1.mesh && binding.obj2.mesh) {
          const positions = new Float32Array(6);
          positions[0] = binding.obj1.mesh.position.x;
          positions[1] = binding.obj1.mesh.position.y;
          positions[2] = binding.obj1.mesh.position.z;
          positions[3] = binding.obj2.mesh.position.x;
          positions[4] = binding.obj2.mesh.position.y;
          positions[5] = binding.obj2.mesh.position.z;
          
          binding.visual.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          binding.visual.geometry.attributes.position.needsUpdate = true;
          
          // Animate opacity (pulsing effect)
          const time = Date.now() * 0.001;
          binding.visual.material.opacity = 0.4 + Math.sin(time * 2) * 0.2;
        }
      });
      
      // Update elastic springs (they're not in physics world, need manual update)
      bindings.forEach(binding => {
        if (binding.type === 'elastic' && binding.constraint) {
          binding.constraint.applyForce();
        }
      });
    }
    
    // Remove a binding
    function removeBinding(binding) {
      if (binding.constraint && binding.type !== 'elastic') {
        physicsWorld.removeConstraint(binding.constraint);
      }
      
      if (binding.visual) {
        scene.remove(binding.visual);
        const index = tetherLines.indexOf(binding.visual);
        if (index > -1) tetherLines.splice(index, 1);
      }
      
      const index = bindings.indexOf(binding);
      if (index > -1) bindings.splice(index, 1);
      
      console.log(`üîì Binding removed: ${binding.type}`);
      updateStatus(`üîì Binding removed`);
    }
    
    // Clear all bindings
    function clearAllBindings() {
      while (bindings.length > 0) {
        removeBinding(bindings[0]);
      }
      console.log('üîì All bindings cleared');
      updateStatus('üîì All bindings cleared');
    }
    
    // Toggle binding mode
    function toggleBindingMode() {
      bindingMode = !bindingMode;
      bindingStep = 0;
      firstBoundObject = null;
      secondBoundObject = null;
      
      if (bindingMode) {
        console.log('üîó Binding mode ENABLED');
        console.log('   Step 1: Lasso select first object (will highlight GREEN)');
        console.log('   Step 2: Lasso select second object (will highlight YELLOW)');
        console.log('   Binding type: ' + bindingType.toUpperCase());
        console.log('   Press 1-4 to change binding type:');
        console.log('     1 = RIGID (move as unit)');
        console.log('     2 = ELASTIC (spring physics)');
        console.log('     3 = CHAIN (allows rotation)');
        console.log('     4 = WELD (merge geometry)');
        updateStatus(`üîó Binding mode: Select first object with lasso (L)`);
      } else {
        console.log('üîó Binding mode DISABLED');
        updateStatus('üîó Binding mode disabled');
      }
    }
    
    console.log('‚úÖ BIND-001: Object binding system initialized');
    console.log('   - Press Alt+L to enter binding mode');
    console.log('   - Lasso two objects to bind them');
    console.log('   - Press 1-4 to change binding type');
    console.log('   - Bindings: Rigid, Elastic, Chain, Weld');

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // FRAG-001: FRAGMENTATION SYSTEM
    // Break objects into realistic pieces with physics
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let fragmentationMode = false;
    let fragmentationType = 'smart-chunk'; // 'smart-chunk', 'voxel', 'radial', 'slice'
    const fragments = []; // Array of fragment meshes
    let fragmentCount = 12; // Default number of fragments (8-15)
    let showFragmentPreview = false;
    
    // Fragment a mesh into pieces
    function fragmentMesh(mesh, type = 'smart-chunk', options = {}) {
      if (!mesh || !mesh.geometry) {
        console.warn('‚ö†Ô∏è Invalid mesh for fragmentation');
        return [];
      }
      
      const geometry = mesh.geometry;
      const material = mesh.material.clone(); // Clone material for fragments
      const newFragments = [];
      
      console.log(`üí• Fragmenting mesh with ${type} algorithm...`);
      
      switch (type) {
        case 'smart-chunk':
          newFragments.push(...createSmartChunkFragments(geometry, material, mesh, options));
          break;
        case 'voxel':
          newFragments.push(...createVoxelFragments(geometry, material, mesh, options));
          break;
        case 'radial':
          newFragments.push(...createRadialFragments(geometry, material, mesh, options));
          break;
        case 'slice':
          newFragments.push(...createSliceFragments(geometry, material, mesh, options));
          break;
        default:
          console.warn('‚ö†Ô∏è Unknown fragmentation type:', type);
          return [];
      }
      
      // Add fragments to scene and physics world
      newFragments.forEach((fragment, index) => {
        // Set position relative to original mesh
        fragment.mesh.position.copy(mesh.position);
        fragment.mesh.quaternion.copy(mesh.quaternion);
        fragment.mesh.castShadow = true;
        fragment.mesh.receiveShadow = true;
        
        scene.add(fragment.mesh);
        
        // Create physics body for fragment
        if (physicsEnabled) {
          createFragmentPhysicsBody(fragment);
        }
        
        fragments.push(fragment);
      });
      
      console.log(`‚úÖ Created ${newFragments.length} fragments`);
      updateStatus(`üí• Fragmented into ${newFragments.length} pieces`);
      
      return newFragments;
    }
    
    // SMART CHUNK: Analyzes geometry and creates 8-15 realistic break pieces
    function createSmartChunkFragments(geometry, material, mesh, options = {}) {
      const numFragments = options.count || fragmentCount;
      const fragments = [];
      
      // Get bounding box
      geometry.computeBoundingBox();
      const bbox = geometry.boundingBox;
      const size = new THREE.Vector3();
      bbox.getSize(size);
      const center = new THREE.Vector3();
      bbox.getCenter(center);
      
      // Create seed points for Voronoi-like subdivision
      const seedPoints = [];
      for (let i = 0; i < numFragments; i++) {
        seedPoints.push(new THREE.Vector3(
          center.x + (Math.random() - 0.5) * size.x * 0.8,
          center.y + (Math.random() - 0.5) * size.y * 0.8,
          center.z + (Math.random() - 0.5) * size.z * 0.8
        ));
      }
      
      // Assign vertices to nearest seed point
      const positions = geometry.attributes.position;
      const vertexGroups = Array.from({ length: numFragments }, () => []);
      
      for (let i = 0; i < positions.count; i++) {
        const vertex = new THREE.Vector3(
          positions.getX(i),
          positions.getY(i),
          positions.getZ(i)
        );
        
        // Find nearest seed point
        let minDist = Infinity;
        let nearestSeed = 0;
        
        seedPoints.forEach((seed, seedIndex) => {
          const dist = vertex.distanceTo(seed);
          if (dist < minDist) {
            minDist = dist;
            nearestSeed = seedIndex;
          }
        });
        
        vertexGroups[nearestSeed].push(i);
      }
      
      // Create fragment meshes from vertex groups
      vertexGroups.forEach((group, groupIndex) => {
        if (group.length < 3) return; // Skip empty groups
        
        // Create new geometry for this fragment
        const fragmentPositions = [];
        const fragmentNormals = [];
        
        group.forEach(vertexIndex => {
          fragmentPositions.push(
            positions.getX(vertexIndex),
            positions.getY(vertexIndex),
            positions.getZ(vertexIndex)
          );
          
          if (geometry.attributes.normal) {
            const normals = geometry.attributes.normal;
            fragmentNormals.push(
              normals.getX(vertexIndex),
              normals.getY(vertexIndex),
              normals.getZ(vertexIndex)
            );
          }
        });
        
        if (fragmentPositions.length > 0) {
          const fragmentGeometry = new THREE.BufferGeometry();
          fragmentGeometry.setAttribute('position', 
            new THREE.BufferAttribute(new Float32Array(fragmentPositions), 3)
          );
          
          if (fragmentNormals.length > 0) {
            fragmentGeometry.setAttribute('normal',
              new THREE.BufferAttribute(new Float32Array(fragmentNormals), 3)
            );
          } else {
            fragmentGeometry.computeVertexNormals();
          }
          
          const fragmentMesh = new THREE.Mesh(fragmentGeometry, material.clone());
          
          // Darken fragment edges slightly
          fragmentMesh.material.color.multiplyScalar(0.95);
          
          fragments.push({
            mesh: fragmentMesh,
            seed: seedPoints[groupIndex].clone(),
            index: groupIndex,
            vertexCount: group.length
          });
        }
      });
      
      console.log(`üß© Smart chunk: Created ${fragments.length} fragments`);
      return fragments;
    }
    
    // VOXEL: Converts geometry to cubic voxels (Minecraft-style)
    function createVoxelFragments(geometry, material, mesh, options = {}) {
      const voxelSize = options.voxelSize || 0.3;
      const fragments = [];
      
      // Get bounding box
      geometry.computeBoundingBox();
      const bbox = geometry.boundingBox;
      
      // Create voxel grid
      const voxelGrid = new Map();
      const positions = geometry.attributes.position;
      
      for (let i = 0; i < positions.count; i++) {
        const x = Math.floor(positions.getX(i) / voxelSize);
        const y = Math.floor(positions.getY(i) / voxelSize);
        const z = Math.floor(positions.getZ(i) / voxelSize);
        const key = `${x},${y},${z}`;
        
        if (!voxelGrid.has(key)) {
          voxelGrid.set(key, {
            x, y, z,
            vertices: []
          });
        }
        
        voxelGrid.get(key).vertices.push(i);
      }
      
      // Create cube mesh for each voxel
      voxelGrid.forEach((voxel, key) => {
        const cubeGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
        const cubeMesh = new THREE.Mesh(cubeGeometry, material.clone());
        
        cubeMesh.position.set(
          voxel.x * voxelSize,
          voxel.y * voxelSize,
          voxel.z * voxelSize
        );
        
        // Color variation
        cubeMesh.material.color.multiplyScalar(0.9 + Math.random() * 0.2);
        
        fragments.push({
          mesh: cubeMesh,
          voxel: voxel,
          index: fragments.length
        });
      });
      
      console.log(`üé≤ Voxel: Created ${fragments.length} voxel fragments`);
      return fragments;
    }
    
    // RADIAL: Glass/ceramic style shattering with crack patterns
    function createRadialFragments(geometry, material, mesh, options = {}) {
      const impactPoint = options.impactPoint || new THREE.Vector3(0, 0, 0);
      const numCracks = options.cracks || 8;
      const fragments = [];
      
      geometry.computeBoundingBox();
      const bbox = geometry.boundingBox;
      const center = new THREE.Vector3();
      bbox.getCenter(center);
      
      // Create radial crack lines from impact point
      const crackAngles = [];
      for (let i = 0; i < numCracks; i++) {
        crackAngles.push((Math.PI * 2 * i) / numCracks + (Math.random() - 0.5) * 0.3);
      }
      
      // Assign vertices to sectors between cracks
      const positions = geometry.attributes.position;
      const vertexGroups = Array.from({ length: numCracks }, () => []);
      
      for (let i = 0; i < positions.count; i++) {
        const vertex = new THREE.Vector3(
          positions.getX(i),
          positions.getY(i),
          positions.getZ(i)
        );
        
        // Calculate angle from impact point
        const direction = vertex.clone().sub(impactPoint);
        const angle = Math.atan2(direction.z, direction.x);
        
        // Find which sector this vertex belongs to
        let sectorIndex = 0;
        let minAngleDiff = Infinity;
        
        crackAngles.forEach((crackAngle, index) => {
          let angleDiff = Math.abs(angle - crackAngle);
          if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
          
          if (angleDiff < minAngleDiff) {
            minAngleDiff = angleDiff;
            sectorIndex = index;
          }
        });
        
        vertexGroups[sectorIndex].push(i);
      }
      
      // Create shard meshes
      vertexGroups.forEach((group, groupIndex) => {
        if (group.length < 3) return;
        
        const fragmentPositions = [];
        const fragmentNormals = [];
        
        group.forEach(vertexIndex => {
          fragmentPositions.push(
            positions.getX(vertexIndex),
            positions.getY(vertexIndex),
            positions.getZ(vertexIndex)
          );
          
          if (geometry.attributes.normal) {
            const normals = geometry.attributes.normal;
            fragmentNormals.push(
              normals.getX(vertexIndex),
              normals.getY(vertexIndex),
              normals.getZ(vertexIndex)
            );
          }
        });
        
        if (fragmentPositions.length > 0) {
          const fragmentGeometry = new THREE.BufferGeometry();
          fragmentGeometry.setAttribute('position',
            new THREE.BufferAttribute(new Float32Array(fragmentPositions), 3)
          );
          
          if (fragmentNormals.length > 0) {
            fragmentGeometry.setAttribute('normal',
              new THREE.BufferAttribute(new Float32Array(fragmentNormals), 3)
            );
          } else {
            fragmentGeometry.computeVertexNormals();
          }
          
          const fragmentMesh = new THREE.Mesh(fragmentGeometry, material.clone());
          
          // Sharp jagged edges
          fragmentMesh.material.color.multiplyScalar(0.9);
          
          fragments.push({
            mesh: fragmentMesh,
            angle: crackAngles[groupIndex],
            index: groupIndex
          });
        }
      });
      
      console.log(`üíé Radial: Created ${fragments.length} shard fragments`);
      return fragments;
    }
    
    // SLICE: Clean planar cuts (for laser cutting)
    function createSliceFragments(geometry, material, mesh, options = {}) {
      const slicePlane = options.plane || new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const fragments = [];
      
      const positions = geometry.attributes.position;
      const aboveVertices = [];
      const belowVertices = [];
      
      // Separate vertices by plane
      for (let i = 0; i < positions.count; i++) {
        const vertex = new THREE.Vector3(
          positions.getX(i),
          positions.getY(i),
          positions.getZ(i)
        );
        
        const distance = slicePlane.distanceToPoint(vertex);
        
        if (distance >= 0) {
          aboveVertices.push(i);
        } else {
          belowVertices.push(i);
        }
      }
      
      // Create two fragment meshes (above and below plane)
      [aboveVertices, belowVertices].forEach((group, groupIndex) => {
        if (group.length < 3) return;
        
        const fragmentPositions = [];
        const fragmentNormals = [];
        
        group.forEach(vertexIndex => {
          fragmentPositions.push(
            positions.getX(vertexIndex),
            positions.getY(vertexIndex),
            positions.getZ(vertexIndex)
          );
          
          if (geometry.attributes.normal) {
            const normals = geometry.attributes.normal;
            fragmentNormals.push(
              normals.getX(vertexIndex),
              normals.getY(vertexIndex),
              normals.getZ(vertexIndex)
            );
          }
        });
        
        if (fragmentPositions.length > 0) {
          const fragmentGeometry = new THREE.BufferGeometry();
          fragmentGeometry.setAttribute('position',
            new THREE.BufferAttribute(new Float32Array(fragmentPositions), 3)
          );
          
          if (fragmentNormals.length > 0) {
            fragmentGeometry.setAttribute('normal',
              new THREE.BufferAttribute(new Float32Array(fragmentNormals), 3)
            );
          } else {
            fragmentGeometry.computeVertexNormals();
          }
          
          const fragmentMesh = new THREE.Mesh(fragmentGeometry, material.clone());
          
          fragments.push({
            mesh: fragmentMesh,
            side: groupIndex === 0 ? 'above' : 'below',
            index: groupIndex
          });
        }
      });
      
      console.log(`‚úÇÔ∏è Slice: Created ${fragments.length} cut fragments`);
      return fragments;
    }
    
    // Create physics body for fragment
    function createFragmentPhysicsBody(fragment) {
      if (!fragment.mesh) return;
      
      // Calculate bounding box for collision shape
      fragment.mesh.geometry.computeBoundingBox();
      const bbox = fragment.mesh.geometry.boundingBox;
      const size = new THREE.Vector3();
      bbox.getSize(size);
      
      // Create box collision shape
      const shape = new CANNON.Box(new CANNON.Vec3(
        Math.max(size.x / 2, 0.1),
        Math.max(size.y / 2, 0.1),
        Math.max(size.z / 2, 0.1)
      ));
      
      // Create rigid body
      const body = new CANNON.Body({
        mass: 0.5, // Lighter than main object
        shape: shape,
        material: defaultMaterial
      });
      
      body.position.copy(toCannon(fragment.mesh.position));
      body.quaternion.copy(fragment.mesh.quaternion);
      
      // Add random initial velocity for scatter effect
      body.velocity.set(
        (Math.random() - 0.5) * 2,
        Math.random() * 3,
        (Math.random() - 0.5) * 2
      );
      
      // Add random angular velocity for tumbling
      body.angularVelocity.set(
        (Math.random() - 0.5) * 5,
        (Math.random() - 0.5) * 5,
        (Math.random() - 0.5) * 5
      );
      
      physicsWorld.addBody(body);
      fragment.body = body;
      
      return body;
    }
    
    // Update fragment physics
    function updateFragments() {
      fragments.forEach(fragment => {
        if (fragment.body && fragment.mesh) {
          fragment.mesh.position.copy(toThree(fragment.body.position));
          fragment.mesh.quaternion.copy(fragment.body.quaternion);
        }
      });
    }
    
    // Remove all fragments
    function clearFragments() {
      fragments.forEach(fragment => {
        if (fragment.mesh) {
          scene.remove(fragment.mesh);
        }
        if (fragment.body) {
          physicsWorld.removeBody(fragment.body);
        }
      });
      
      fragments.length = 0;
      console.log('üßπ All fragments cleared');
      updateStatus('üßπ Fragments cleared');
    }
    
    // Toggle fragmentation mode
    function toggleFragmentationMode() {
      fragmentationMode = !fragmentationMode;
      
      if (fragmentationMode) {
        console.log('üí• Fragmentation mode ENABLED');
        console.log(`   Type: ${fragmentationType.toUpperCase()}`);
        console.log('   Press 5-8 to change fragmentation type:');
        console.log('     5 = SMART CHUNK (realistic break)');
        console.log('     6 = VOXEL (Minecraft-style)');
        console.log('     7 = RADIAL (glass shatter)');
        console.log('     8 = SLICE (clean cut)');
        console.log('   Press SPACE to fragment selected object');
        console.log('   Press [ ] to adjust fragment count (8-20)');
        updateStatus(`üí• Fragmentation: ${fragmentationType.toUpperCase()} (Space to break)`);
      } else {
        console.log('üí• Fragmentation mode DISABLED');
        updateStatus('üí• Fragmentation disabled');
      }
    }
    
    console.log('‚úÖ FRAG-001: Fragmentation system initialized');
    console.log('   - Press Alt+F to enter fragmentation mode');
    console.log('   - Press 5-8 to change fragmentation type');
    console.log('   - Press Space to fragment object');
    console.log('   - Types: Smart Chunk, Voxel, Radial, Slice');

    // =================================================================
    // VFX-001: PARTICLE SYSTEM
    // =================================================================
    // GPU-accelerated particle system with 100k capacity
    // Supports smoke, sparks, embers, debris, fire, laser effects
    
    // Particle system state
    let particleSystems = [];
    let particleEmitters = [];
    let particleMode = false;
    let currentEmitterType = 'point'; // point, area, trail
    let currentParticleType = 'smoke'; // smoke, sparks, embers, debris, fire
    
    // Particle class - Represents single particle in system
    class Particle {
      constructor() {
        this.position = new THREE.Vector3();
        this.velocity = new THREE.Vector3();
        this.acceleration = new THREE.Vector3();
        this.life = 1.0; // 1.0 = born, 0.0 = dead
        this.lifespan = 1.0; // Total lifetime in seconds
        this.age = 0; // Current age in seconds
        this.size = 1.0;
        this.color = new THREE.Color(1, 1, 1);
        this.alpha = 1.0;
        this.rotation = 0;
        this.rotationSpeed = 0;
        this.active = false;
      }
      
      reset() {
        this.position.set(0, 0, 0);
        this.velocity.set(0, 0, 0);
        this.acceleration.set(0, 0, 0);
        this.life = 1.0;
        this.age = 0;
        this.size = 1.0;
        this.alpha = 1.0;
        this.rotation = 0;
        this.active = false;
      }
      
      update(deltaTime, gravity, wind) {
        if (!this.active) return;
        
        // Age the particle
        this.age += deltaTime;
        this.life = 1.0 - (this.age / this.lifespan);
        
        // Die if old
        if (this.life <= 0) {
          this.active = false;
          return;
        }
        
        // Apply forces
        this.acceleration.copy(gravity);
        this.acceleration.add(wind);
        
        // Update velocity and position
        this.velocity.add(this.acceleration.clone().multiplyScalar(deltaTime));
        this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
        
        // Update rotation
        this.rotation += this.rotationSpeed * deltaTime;
      }
    }
    
    // GPUParticleSystem - High-performance particle rendering
    class GPUParticleSystem {
      constructor(maxParticles = 10000) {
        this.maxParticles = maxParticles;
        this.particles = [];
        this.aliveCount = 0;
        
        // Initialize particle pool
        for (let i = 0; i < maxParticles; i++) {
          this.particles.push(new Particle());
        }
        
        // Create geometry for GPU instancing
        this.geometry = new THREE.BufferGeometry();
        
        // Position buffer (xyz per particle)
        this.positions = new Float32Array(maxParticles * 3);
        
        // Color buffer (rgb per particle)
        this.colors = new Float32Array(maxParticles * 3);
        
        // Size buffer (size per particle)
        this.sizes = new Float32Array(maxParticles);
        
        // Alpha buffer (alpha per particle)
        this.alphas = new Float32Array(maxParticles);
        
        // Set attributes
        this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
        this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
        this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
        this.geometry.setAttribute('alpha', new THREE.BufferAttribute(this.alphas, 1));
        
        // Create shader material
        this.material = new THREE.ShaderMaterial({
          uniforms: {
            pointTexture: { value: this.createParticleTexture() }
          },
          vertexShader: `
            attribute float size;
            attribute float alpha;
            attribute vec3 color;
            
            varying vec3 vColor;
            varying float vAlpha;
            
            void main() {
              vColor = color;
              vAlpha = alpha;
              
              vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
              gl_PointSize = size * (300.0 / -mvPosition.z);
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            uniform sampler2D pointTexture;
            
            varying vec3 vColor;
            varying float vAlpha;
            
            void main() {
              vec4 texColor = texture2D(pointTexture, gl_PointCoord);
              gl_FragColor = vec4(vColor, vAlpha * texColor.a);
            }
          `,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          transparent: true,
          vertexColors: true
        });
        
        // Create points mesh
        this.points = new THREE.Points(this.geometry, this.material);
        scene.add(this.points);
      }
      
      // Create circular particle texture
      createParticleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        // Create radial gradient (bright center, fades out)
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
      }
      
      // Spawn a new particle
      spawn(config) {
        // Find dead particle to reuse
        for (let i = 0; i < this.maxParticles; i++) {
          const p = this.particles[i];
          if (!p.active) {
            // Reset and configure particle
            p.reset();
            p.active = true;
            
            // Set properties from config
            p.position.copy(config.position || new THREE.Vector3());
            p.velocity.copy(config.velocity || new THREE.Vector3());
            p.lifespan = config.lifespan || 1.0;
            p.size = config.size || 1.0;
            p.color.copy(config.color || new THREE.Color(1, 1, 1));
            p.alpha = config.alpha !== undefined ? config.alpha : 1.0;
            p.rotationSpeed = config.rotationSpeed || 0;
            
            this.aliveCount++;
            return p;
          }
        }
        
        // Pool exhausted
        return null;
      }
      
      // Update all particles
      update(deltaTime, gravity, wind) {
        let aliveCount = 0;
        
        for (let i = 0; i < this.maxParticles; i++) {
          const p = this.particles[i];
          
          if (p.active) {
            p.update(deltaTime, gravity, wind);
            
            if (p.active) {
              aliveCount++;
            }
          }
          
          // Update GPU buffers
          const i3 = i * 3;
          this.positions[i3] = p.position.x;
          this.positions[i3 + 1] = p.position.y;
          this.positions[i3 + 2] = p.position.z;
          
          this.colors[i3] = p.color.r;
          this.colors[i3 + 1] = p.color.g;
          this.colors[i3 + 2] = p.color.b;
          
          this.sizes[i] = p.active ? p.size : 0;
          this.alphas[i] = p.active ? p.alpha * p.life : 0;
        }
        
        this.aliveCount = aliveCount;
        
        // Mark buffers for GPU update
        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.color.needsUpdate = true;
        this.geometry.attributes.size.needsUpdate = true;
        this.geometry.attributes.alpha.needsUpdate = true;
      }
      
      // Clear all particles
      clear() {
        for (let i = 0; i < this.maxParticles; i++) {
          this.particles[i].reset();
        }
        this.aliveCount = 0;
      }
      
      // Destroy system
      destroy() {
        scene.remove(this.points);
        this.geometry.dispose();
        this.material.dispose();
      }
    }
    
    // ParticleEmitter - Spawns particles continuously
    class ParticleEmitter {
      constructor(particleSystem, config = {}) {
        this.particleSystem = particleSystem;
        this.type = config.type || 'point'; // point, area, trail
        this.particleType = config.particleType || 'smoke';
        
        this.position = config.position || new THREE.Vector3();
        this.direction = config.direction || new THREE.Vector3(0, 1, 0);
        this.spread = config.spread !== undefined ? config.spread : 0.5;
        
        this.rate = config.rate || 10; // Particles per second
        this.accumulator = 0;
        
        this.active = true;
        this.lifetime = config.lifetime || Infinity; // Auto-deactivate after N seconds
        this.age = 0;
      }
      
      update(deltaTime) {
        if (!this.active) return;
        
        // Age emitter
        this.age += deltaTime;
        if (this.age >= this.lifetime) {
          this.active = false;
          return;
        }
        
        // Spawn particles based on rate
        this.accumulator += deltaTime * this.rate;
        
        while (this.accumulator >= 1.0) {
          this.spawnParticle();
          this.accumulator -= 1.0;
        }
      }
      
      spawnParticle() {
        const config = this.getParticleConfig();
        this.particleSystem.spawn(config);
      }
      
      getParticleConfig() {
        // Base config varies by particle type
        let config = {};
        
        switch (this.particleType) {
          case 'smoke':
            config = {
              position: this.position.clone(),
              velocity: new THREE.Vector3(
                (Math.random() - 0.5) * this.spread,
                1 + Math.random() * 2,
                (Math.random() - 0.5) * this.spread
              ),
              lifespan: 2 + Math.random() * 2,
              size: 0.5 + Math.random() * 1.5,
              color: new THREE.Color(0.3 + Math.random() * 0.2, 0.3 + Math.random() * 0.2, 0.3 + Math.random() * 0.2),
              alpha: 0.3 + Math.random() * 0.3,
              rotationSpeed: (Math.random() - 0.5) * 2
            };
            break;
            
          case 'sparks':
            config = {
              position: this.position.clone(),
              velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                Math.random() * 5,
                (Math.random() - 0.5) * 5
              ),
              lifespan: 0.3 + Math.random() * 0.5,
              size: 0.1 + Math.random() * 0.2,
              color: new THREE.Color(1, 0.8 + Math.random() * 0.2, 0.3 + Math.random() * 0.3),
              alpha: 1.0,
              rotationSpeed: 0
            };
            break;
            
          case 'embers':
            config = {
              position: this.position.clone(),
              velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                0.5 + Math.random() * 1.5,
                (Math.random() - 0.5) * 0.5
              ),
              lifespan: 1.5 + Math.random() * 2,
              size: 0.2 + Math.random() * 0.3,
              color: new THREE.Color(1, 0.3 + Math.random() * 0.3, 0),
              alpha: 0.8,
              rotationSpeed: (Math.random() - 0.5) * 4
            };
            break;
            
          case 'debris':
            config = {
              position: this.position.clone(),
              velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 8,
                Math.random() * 8,
                (Math.random() - 0.5) * 8
              ),
              lifespan: 2 + Math.random() * 3,
              size: 0.3 + Math.random() * 0.5,
              color: new THREE.Color(0.4 + Math.random() * 0.2, 0.3 + Math.random() * 0.2, 0.2 + Math.random() * 0.2),
              alpha: 1.0,
              rotationSpeed: (Math.random() - 0.5) * 8
            };
            break;
            
          case 'fire':
            config = {
              position: this.position.clone(),
              velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 0.3,
                2 + Math.random() * 2,
                (Math.random() - 0.5) * 0.3
              ),
              lifespan: 0.5 + Math.random() * 1,
              size: 0.4 + Math.random() * 0.6,
              color: new THREE.Color(1, 0.5 + Math.random() * 0.5, 0),
              alpha: 0.8,
              rotationSpeed: (Math.random() - 0.5) * 3
            };
            break;
        }
        
        return config;
      }
    }
    
    // Create main particle system (10k particles for performance)
    const mainParticleSystem = new GPUParticleSystem(10000);
    particleSystems.push(mainParticleSystem);
    
    // Physics constants for particles
    const particleGravity = new THREE.Vector3(0, -2, 0); // Lighter than objects
    const particleWind = new THREE.Vector3(0, 0, 0);
    
    // Create particle emitter at point
    function createPointEmitter(position, particleType, lifetime = 2) {
      const emitter = new ParticleEmitter(mainParticleSystem, {
        type: 'point',
        particleType: particleType,
        position: position.clone(),
        rate: 50, // 50 particles/sec
        lifetime: lifetime,
        spread: 1.0
      });
      
      particleEmitters.push(emitter);
      return emitter;
    }
    
    // Create particle emitter at area
    function createAreaEmitter(position, radius, particleType, lifetime = Infinity) {
      const emitter = new ParticleEmitter(mainParticleSystem, {
        type: 'area',
        particleType: particleType,
        position: position.clone(),
        rate: 100,
        lifetime: lifetime,
        spread: radius
      });
      
      particleEmitters.push(emitter);
      return emitter;
    }
    
    // Create particle trail emitter
    function createTrailEmitter(position, direction, particleType, lifetime = 0.5) {
      const emitter = new ParticleEmitter(mainParticleSystem, {
        type: 'trail',
        particleType: particleType,
        position: position.clone(),
        direction: direction.clone(),
        rate: 200, // Dense trail
        lifetime: lifetime,
        spread: 0.2
      });
      
      particleEmitters.push(emitter);
      return emitter;
    }
    
    // Update all particle systems and emitters
    function updateParticles(deltaTime) {
      // Update emitters
      for (let i = particleEmitters.length - 1; i >= 0; i--) {
        const emitter = particleEmitters[i];
        emitter.update(deltaTime);
        
        // Remove dead emitters
        if (!emitter.active) {
          particleEmitters.splice(i, 1);
        }
      }
      
      // Update particle systems
      for (const system of particleSystems) {
        system.update(deltaTime, particleGravity, particleWind);
      }
    }
    
    // Clear all particles and emitters
    function clearAllParticles() {
      particleEmitters = [];
      for (const system of particleSystems) {
        system.clear();
      }
      console.log('‚ú® All particles cleared');
    }
    
    // Toggle particle mode
    function toggleParticleMode() {
      particleMode = !particleMode;
      
      if (particleMode) {
        console.log('‚ú® Particle mode ENABLED');
        console.log(`   Type: ${currentParticleType.toUpperCase()}`);
        console.log('   Press 9 to spawn particles at cursor');
        console.log('   Press Shift+9/0 to change particle type');
        console.log('   Types: smoke, sparks, embers, debris, fire');
        updateStatus(`‚ú® Particles: ${currentParticleType.toUpperCase()} (9 to spawn)`);
      } else {
        console.log('‚ú® Particle mode DISABLED');
        updateStatus('‚ú® Particle mode disabled');
      }
    }
    
    console.log('‚úÖ VFX-001: Particle system initialized');
    console.log('   - Press Alt+P to enter particle mode');
    console.log('   - Press 9 to spawn particles');
    console.log('   - Press Shift+9/0 to cycle particle types');
    console.log('   - Types: Smoke, Sparks, Embers, Debris, Fire');

    // Axis helper
    const axisHelper = new THREE.AxesHelper(3);
    scene.add(axisHelper);

    // Grid helper
    const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
    gridHelper.position.y = -2;
    scene.add(gridHelper);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SHOWCASE LIGHTING - Professional Studio Setup
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Ambient light - soft fill
    scene.add(new THREE.AmbientLight(0x6b8cae, 0.55));
    
    // Key light - main directional light
    const dirLight = new THREE.DirectionalLight(0xffffff, 2.2);
    dirLight.position.set(10, 18, 12);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 50;
    scene.add(dirLight);
    
    // Rim light - orange/warm accent from back
    const rimLight = new THREE.DirectionalLight(0xff8844, 1.5);
    rimLight.position.set(-8, 8, -10);
    scene.add(rimLight);
    
    // Fill light - soft blue from left
    const fillLight = new THREE.DirectionalLight(0x4488ff, 0.8);
    fillLight.position.set(-10, 5, 5);
    scene.add(fillLight);

    // Ground (ENV-003: Professional showcase floor with reflections)
    window.ground = new THREE.Mesh(
      new THREE.CylinderGeometry(30, 30, 0.4, 48),
      new THREE.MeshStandardMaterial({ 
        color: 0x0f1419, 
        roughness: 0.25,
        metalness: 0.65,
        envMapIntensity: 0.5
      })
    );
    window.ground.position.y = -2.2;
    window.ground.receiveShadow = true;
    scene.add(window.ground);

    // Sample sculpt target - SHOWCASE CYLINDER with beautiful material
    const sculptGeometry = new THREE.CylinderGeometry(1.2, 1.5, 8, 256, 192, false);
    sculptGeometry.translate(0, 1.5, 0);
    const sculptMaterial = new THREE.MeshStandardMaterial({
      color: 0x3a88d6,
      roughness: 0.35,
      metalness: 0.75,
      emissive: 0x0a2040,
      emissiveIntensity: 0.15,
      envMapIntensity: 1.2
    });
    const sculptMesh = new THREE.Mesh(sculptGeometry, sculptMaterial);
    sculptMesh.castShadow = true;
    sculptMesh.receiveShadow = true;
    scene.add(sculptMesh);

    // Store base positions for layer system
    const basePositions = sculptGeometry.attributes.position.array.slice();
    const vertexCount = sculptGeometry.attributes.position.count;

    // Raycaster and pointer for sculpting
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    let isSculpting = false;
    let lastStrokePoint = null;

    // Brush indicator - create different geometries for each shape
    const brushGeometries = {
      circle: new THREE.RingGeometry(0.95, 1, 64),
      triangle: new THREE.BufferGeometry(),
      leaf: new THREE.BufferGeometry(),
      square: new THREE.BufferGeometry(),
      star: new THREE.BufferGeometry()
    };

    // Build triangle brush shape
    const triVertices = new Float32Array([
      0, 1, 0,
      -0.866, -0.5, 0,
      0.866, -0.5, 0,
      0, 1, 0
    ]);
    brushGeometries.triangle.setAttribute('position', new THREE.BufferAttribute(triVertices, 3));

    // Build leaf brush shape (curved teardrop)
    const leafPoints = [];
    for (let i = 0; i <= 32; i++) {
      const t = i / 32;
      const angle = t * Math.PI * 2;
      const r = 0.3 + Math.sin(t * Math.PI) * 0.7;
      leafPoints.push(new THREE.Vector3(Math.cos(angle) * r, Math.sin(angle) * r * 1.2, 0));
    }
    brushGeometries.leaf.setFromPoints(leafPoints);

    // Build square brush shape
    const squareVertices = new Float32Array([
      -1, -1, 0,
      1, -1, 0,
      1, 1, 0,
      -1, 1, 0,
      -1, -1, 0
    ]);
    brushGeometries.square.setAttribute('position', new THREE.BufferAttribute(squareVertices, 3));

    // Build star brush shape (5-pointed)
    const starPoints = [];
    for (let i = 0; i <= 10; i++) {
      const angle = (i / 10) * Math.PI * 2 - Math.PI / 2;
      const r = i % 2 === 0 ? 1 : 0.4;
      starPoints.push(new THREE.Vector3(Math.cos(angle) * r, Math.sin(angle) * r, 0));
    }
    starPoints.push(starPoints[0]); // close the shape
    brushGeometries.star.setFromPoints(starPoints);

    const brushIndicator = new THREE.Line(
      brushGeometries.circle,
      new THREE.LineBasicMaterial({ 
        color: 0x5dd4fc, 
        transparent: true, 
        opacity: 0.75,
        linewidth: 2
      })
    );
    brushIndicator.visible = false;
    scene.add(brushIndicator);

    function updateBrushShape() {
      const shape = state.brushShape;
      if (brushGeometries[shape]) {
        brushIndicator.geometry = brushGeometries[shape];
      } else {
        // fallback to circle for custom
        brushIndicator.geometry = brushGeometries.circle;
      }
    }

    // Undo/Redo system
    const undoStack = [];
    const redoStack = [];
    const MAX_UNDO_STEPS = 50;
    
    let currentAISuggestion = null;
    let transformMode = 'orbit'; // 'orbit' or 'translate'

    // State
    const state = {
      brushRadius: 0.35,
      brushStrength: 0.15,
      brushHardness: 0.7,
      brushFalloff: 'smooth',
      brushShape: 'circle',
      symmetryAxis: 'none',
      pressureResponse: 0.5,
      strokeSpacing: 0.1,
      activeLayer: 0,
      layers: [new Float32Array(sculptGeometry.attributes.position.array.length)],
      layerBlendMode: 'normal',
      layerOpacity: 1.0,
      materialPreset: 'standard',
      displacementDepth: 0.5,
      detailLevel: 1.0,
      colorTint: '#6f513a',
      autoNormalRefresh: true,
      projectId: 'untitled',
      autosaveInterval: 30,
      exportFormat: 'gltf',
      snapToGrid: 0.5,
      aiModel: 'openai',
      promptTemplate: 'organic',
      patternSeed: 42,
      guidanceStrength: 0.7,
      suggestionRefreshRate: 5,
      autoApplyThreshold: false,
      feedbackOverlay: true,
      sceneTheme: 'studio',
      lightingRig: 'three-point',
      timeOfDay: 12,
      fogDensity: 0.05,
      groundPlaneSize: 30,
      gravityAxis: '-y',
      cameraOrbitSpeed: 0.5
    };

    // UI synchronization
    function syncUI() {
      document.getElementById('brushRadius').value = state.brushRadius;
      document.getElementById('brushRadiusValue').value = state.brushRadius;
      document.getElementById('brushStrength').value = state.brushStrength;
      document.getElementById('brushStrengthValue').value = state.brushStrength;
      document.getElementById('brushHardness').value = state.brushHardness;
      document.getElementById('brushHardnessValue').value = state.brushHardness;
      document.getElementById('brushFalloff').value = state.brushFalloff;
      document.getElementById('symmetryAxis').value = state.symmetryAxis;
      document.getElementById('pressureResponse').value = state.pressureResponse;
      document.getElementById('strokeSpacing').value = state.strokeSpacing;
      document.getElementById('layerBlendMode').value = state.layerBlendMode;
      document.getElementById('layerOpacity').value = state.layerOpacity;
      document.getElementById('materialPreset').value = state.materialPreset;
      document.getElementById('displacementDepth').value = state.displacementDepth;
      document.getElementById('detailLevel').value = state.detailLevel;
      document.getElementById('colorTint').value = state.colorTint;
      document.getElementById('autoNormalRefresh').checked = state.autoNormalRefresh;
      document.getElementById('projectId').value = state.projectId;
      document.getElementById('autosaveInterval').value = state.autosaveInterval;
      document.getElementById('exportFormat').value = state.exportFormat;
      document.getElementById('snapToGrid').value = state.snapToGrid;
      document.getElementById('aiModel').value = state.aiModel;
      document.getElementById('promptTemplate').value = state.promptTemplate;
      document.getElementById('patternSeed').value = state.patternSeed;
      document.getElementById('guidanceStrength').value = state.guidanceStrength;
      document.getElementById('suggestionRefreshRate').value = state.suggestionRefreshRate;
      document.getElementById('autoApplyThreshold').checked = state.autoApplyThreshold;
      document.getElementById('feedbackOverlay').checked = state.feedbackOverlay;
      document.getElementById('sceneTheme').value = state.sceneTheme;
      document.getElementById('lightingRig').value = state.lightingRig;
      document.getElementById('timeOfDay').value = state.timeOfDay;
      document.getElementById('timeOfDayValue').textContent = `${Math.floor(state.timeOfDay)}:${String(Math.round((state.timeOfDay % 1) * 60)).padStart(2, '0')}`;
      document.getElementById('fogDensity').value = state.fogDensity;
      document.getElementById('fogDensityValue').textContent = state.fogDensity.toFixed(3);
      document.getElementById('groundPlaneSize').value = state.groundPlaneSize;
      document.getElementById('gravityAxis').value = state.gravityAxis;
      document.getElementById('cameraOrbitSpeed').value = state.cameraOrbitSpeed;
      document.getElementById('cameraOrbitSpeedValue').textContent = `${state.cameraOrbitSpeed.toFixed(1)}x`;
    }

    // Bind UI events
    document.getElementById('brushRadius').addEventListener('input', (e) => {
      state.brushRadius = parseFloat(e.target.value);
      document.getElementById('brushRadiusValue').value = state.brushRadius;
    });
    document.getElementById('brushRadiusValue').addEventListener('input', (e) => {
      state.brushRadius = parseFloat(e.target.value);
      document.getElementById('brushRadius').value = state.brushRadius;
    });
    document.getElementById('brushStrength').addEventListener('input', (e) => {
      state.brushStrength = parseFloat(e.target.value);
      document.getElementById('brushStrengthValue').value = state.brushStrength;
    });
    document.getElementById('brushStrengthValue').addEventListener('input', (e) => {
      state.brushStrength = parseFloat(e.target.value);
      document.getElementById('brushStrength').value = state.brushStrength;
    });
    document.getElementById('brushHardness').addEventListener('input', (e) => {
      state.brushHardness = parseFloat(e.target.value);
      document.getElementById('brushHardnessValue').value = state.brushHardness;
    });
    document.getElementById('brushHardnessValue').addEventListener('input', (e) => {
      state.brushHardness = parseFloat(e.target.value);
      document.getElementById('brushHardness').value = state.brushHardness;
    });
    document.getElementById('brushFalloff').addEventListener('change', (e) => state.brushFalloff = e.target.value);
    document.getElementById('symmetryAxis').addEventListener('change', (e) => state.symmetryAxis = e.target.value);
    document.getElementById('pressureResponse').addEventListener('input', (e) => state.pressureResponse = parseFloat(e.target.value));
    document.getElementById('strokeSpacing').addEventListener('input', (e) => state.strokeSpacing = parseFloat(e.target.value));
    document.getElementById('layerBlendMode').addEventListener('change', (e) => state.layerBlendMode = e.target.value);
    document.getElementById('layerOpacity').addEventListener('input', (e) => state.layerOpacity = parseFloat(e.target.value));
    document.getElementById('materialPreset').addEventListener('change', (e) => state.materialPreset = e.target.value);
    document.getElementById('displacementDepth').addEventListener('input', (e) => state.displacementDepth = parseFloat(e.target.value));
    document.getElementById('detailLevel').addEventListener('input', (e) => state.detailLevel = parseFloat(e.target.value));
    document.getElementById('colorTint').addEventListener('input', (e) => {
      state.colorTint = e.target.value;
      sculptMaterial.color.set(e.target.value);
    });
    document.getElementById('autoNormalRefresh').addEventListener('change', (e) => state.autoNormalRefresh = e.target.checked);
    document.getElementById('projectId').addEventListener('input', (e) => state.projectId = e.target.value);
    document.getElementById('autosaveInterval').addEventListener('input', (e) => state.autosaveInterval = parseInt(e.target.value));
    document.getElementById('exportFormat').addEventListener('change', (e) => state.exportFormat = e.target.value);
    document.getElementById('snapToGrid').addEventListener('input', (e) => state.snapToGrid = parseFloat(e.target.value));
    document.getElementById('aiModel').addEventListener('change', (e) => state.aiModel = e.target.value);
    document.getElementById('promptTemplate').addEventListener('change', (e) => state.promptTemplate = e.target.value);
    document.getElementById('patternSeed').addEventListener('input', (e) => state.patternSeed = parseInt(e.target.value));
    document.getElementById('guidanceStrength').addEventListener('input', (e) => state.guidanceStrength = parseFloat(e.target.value));
    document.getElementById('suggestionRefreshRate').addEventListener('input', (e) => state.suggestionRefreshRate = parseInt(e.target.value));
    document.getElementById('autoApplyThreshold').addEventListener('change', (e) => state.autoApplyThreshold = e.target.checked);
    document.getElementById('feedbackOverlay').addEventListener('change', (e) => state.feedbackOverlay = e.target.checked);
    document.getElementById('sceneTheme').addEventListener('change', (e) => state.sceneTheme = e.target.value);
    document.getElementById('lightingRig').addEventListener('change', (e) => state.lightingRig = e.target.value);
    document.getElementById('timeOfDay').addEventListener('input', (e) => {
      state.timeOfDay = parseFloat(e.target.value);
      document.getElementById('timeOfDayValue').textContent = `${Math.floor(state.timeOfDay)}:${String(Math.round((state.timeOfDay % 1) * 60)).padStart(2, '0')}`;
    });
    document.getElementById('fogDensity').addEventListener('input', (e) => {
      state.fogDensity = parseFloat(e.target.value);
      document.getElementById('fogDensityValue').textContent = state.fogDensity.toFixed(3);
      applyFog(state.fogDensity, true); // ENV-001: Wire fog slider
    });
    document.getElementById('groundPlaneSize').addEventListener('change', (e) => {
      const newSize = parseFloat(e.target.value);
      updateGroundPlane(newSize); // ENV-003: Dynamic ground plane (use 'change' to avoid recreating while typing)
    });
    document.getElementById('gravityAxis').addEventListener('change', (e) => state.gravityAxis = e.target.value);
    document.getElementById('cameraOrbitSpeed').addEventListener('input', (e) => {
      const speed = parseFloat(e.target.value);
      state.cameraOrbitSpeed = speed;
      controls.rotateSpeed = speed; // ENV-006: Wire orbit speed
      document.getElementById('cameraOrbitSpeedValue').textContent = `${speed.toFixed(1)}x`;
      console.log(`üîÑ Orbit speed: ${speed.toFixed(1)}x`);
    });

    // CAM-001: Keyboard event listeners for flight controls
    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      
      // Track WASD keys
      if (key === 'w') keyState.w = true;
      if (key === 'a') keyState.a = true;
      if (key === 's') keyState.s = true;
      if (key === 'd') keyState.d = true;
      if (key === 'q') keyState.q = true;
      if (key === 'e') keyState.e = true;
      
      // Track modifiers
      if (e.shiftKey) keyState.shift = true;
      if (e.ctrlKey) keyState.ctrl = true;
      
      // Toggle flight mode with 'F' key
      if (key === 'f' && !e.repeat) {
        flyMode = !flyMode;
        controls.enabled = !flyMode; // CAM-002: Disable orbit controls in flight mode
        console.log(`‚úàÔ∏è Flight mode: ${flyMode ? 'ENABLED' : 'DISABLED'}`);
        if (flyMode) {
          console.log('üéÆ Controls: WASD (move), Q/E (down/up), Shift (fast), Ctrl (slow), F (toggle off)');
        } else {
          console.log('üåç OrbitControls re-enabled (mouse drag to rotate)');
        }
      }

      // SEL-001: Toggle box select mode with 'B' key
      if (key === 'b' && !e.repeat) {
        selectionMode = !selectionMode;
        console.log(`üì¶ Box Select mode: ${selectionMode ? 'ENABLED (click-drag to select)' : 'DISABLED'}`);
        if (selectionMode) {
          console.log('üéØ Hold Shift to ADD, Ctrl to REMOVE from selection');
          canvas.style.cursor = 'crosshair';
        } else {
          canvas.style.cursor = 'default';
        }
      }

      // SEL-002: Toggle circle select mode with 'C' key
      if (key === 'c' && !e.repeat) {
        // Disable other selection modes
        if (selectionMode) {
          selectionMode = false;
          selectionBox.style.display = 'none';
        }
        if (lassoSelectMode) {
          lassoSelectMode = false;
          lassoCanvas.style.display = 'none';
          lassoActive = false;
          lassoPath = [];
        }
        
        circleSelectMode = !circleSelectMode;
        console.log(`‚≠ï Circle Select mode: ${circleSelectMode ? 'ENABLED' : 'DISABLED'}`);
        if (circleSelectMode) {
          console.log('üéØ Move mouse to select | Scroll to change radius | Hold Shift=ADD, Ctrl=REMOVE');
          console.log('üí° Press + to BUILD, - to CARVE within circle');
          circleSelectOverlay.style.display = 'block';
          canvas.style.cursor = 'none';
        } else {
          circleSelectOverlay.style.display = 'none';
          canvas.style.cursor = 'default';
          circleModifyMode = null;
        }
      }

      // SEL-003: Toggle lasso select mode with 'L' key
      if (key === 'l' && !e.repeat) {
        // Disable other selection modes
        if (selectionMode) {
          selectionMode = false;
          selectionBox.style.display = 'none';
        }
        if (circleSelectMode) {
          circleSelectMode = false;
          circleSelectOverlay.style.display = 'none';
          circleModifyMode = null;
        }
        
        lassoSelectMode = !lassoSelectMode;
        console.log(`üé® Lasso Select mode: ${lassoSelectMode ? 'ENABLED' : 'DISABLED'}`);
        if (lassoSelectMode) {
          console.log('üéØ Click to start path | Move to draw | Click to add points | Double-click or Enter to complete');
          console.log('üí° Hold Shift=ADD, Ctrl=REMOVE from selection | Escape=Cancel');
          lassoCanvas.style.display = 'block';
          lassoCanvas.width = canvas.width;
          lassoCanvas.height = canvas.height;
          canvas.style.cursor = 'crosshair';
        } else {
          lassoCanvas.style.display = 'none';
          canvas.style.cursor = 'default';
          lassoActive = false;
          lassoPath = [];
        }
      }

      // SEL-003: Complete or cancel lasso selection
      if (lassoSelectMode) {
        if (key === 'enter' && lassoPath.length > 2) {
          // Complete lasso selection
          performLassoSelection(e.shiftKey, e.ctrlKey);
          lassoActive = false;
          lassoPath = [];
          clearLassoCanvas();
        } else if (key === 'escape') {
          // Cancel lasso
          lassoActive = false;
          lassoPath = [];
          clearLassoCanvas();
          console.log('üö´ Lasso selection cancelled');
        }
      }

      // Apply layer modification to selection with +/- keys
      if (key === '=' || key === '+') {
        if (circleSelectMode) {
          // Circle select mode: toggle build mode
          circleModifyMode = (circleModifyMode === 'build') ? null : 'build';
          circleSelectOverlay.style.borderColor = circleModifyMode === 'build' ? '#00ff00' : 'cyan';
          console.log(`üü¢ Circle BUILD mode: ${circleModifyMode === 'build' ? 'ACTIVE' : 'OFF'}`);
        } else if (selectedVertices.size > 0) {
          applyLayerModification(selectedVertices, 0.1); // Build up
          console.log(`‚ûï BUILT UP ${selectedVertices.size} vertices | +0.10 layer`);
        } else {
          console.log('‚ö†Ô∏è No vertices selected. Use Box Select (B) or Circle Select (C) first!');
        }
      }
      if (key === '-' || key === '_') {
        if (circleSelectMode) {
          // Circle select mode: toggle carve mode
          circleModifyMode = (circleModifyMode === 'carve') ? null : 'carve';
          circleSelectOverlay.style.borderColor = circleModifyMode === 'carve' ? '#ff0000' : 'cyan';
          console.log(`üî¥ Circle CARVE mode: ${circleModifyMode === 'carve' ? 'ACTIVE' : 'OFF'}`);
        } else if (selectedVertices.size > 0) {
          applyLayerModification(selectedVertices, -0.1); // Carve away
          console.log(`‚ûñ CARVED ${selectedVertices.size} vertices | -0.10 layer`);
        } else {
          console.log('‚ö†Ô∏è No vertices selected. Use Box Select (B) or Circle Select (C) first!');
        }
      }

      // SEL-004: Selection Utilities
      if (key === 'i' && !e.repeat) {
        // Invert Selection
        invertSelection();
      }
      if (key === 'g' && !e.repeat && !isAnySelectionToolActive()) {
        // Grow Selection (expand to neighbors)
        growSelection();
      }
      if (key === 'h' && !e.repeat && !isAnySelectionToolActive()) {
        // Shrink Selection (contract inward)
        shrinkSelection();
      }
      if (key === 'escape') {
        // Clear Selection or cancel selection mode
        if (lassoSelectMode && lassoActive) {
          lassoActive = false;
          lassoPath = [];
          clearLassoCanvas();
          console.log('üö´ Lasso cancelled');
        } else if (selectedVertices.size > 0) {
          clearSelection();
        }
      }
      // Ctrl+A: Select All
      if (e.ctrlKey && key === 'a') {
        e.preventDefault();
        selectAll();
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // PHYS-001: PHYSICS TOGGLE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      
      // P key: Toggle physics simulation
      if (key === 'p' && !e.repeat) {
        togglePhysics();
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // BIND-001: OBJECT BINDING KEYBOARD SHORTCUTS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      
      // Alt+L: Toggle binding mode
      if (e.altKey && key === 'l' && !e.repeat) {
        e.preventDefault();
        toggleBindingMode();
      }
      
      // Binding type selection (when in binding mode)
      if (bindingMode && !e.repeat) {
        if (key === '1') {
          bindingType = 'rigid';
          console.log('üîó Binding type: RIGID (move as unit)');
          updateStatus('üîó Binding type: RIGID');
        }
        if (key === '2') {
          bindingType = 'elastic';
          console.log('üîó Binding type: ELASTIC (spring physics)');
          updateStatus('üîó Binding type: ELASTIC');
        }
        if (key === '3') {
          bindingType = 'chain';
          console.log('üîó Binding type: CHAIN (allows rotation)');
          updateStatus('üîó Binding type: CHAIN');
        }
        if (key === '4') {
          bindingType = 'weld';
          console.log('üîó Binding type: WELD (merge geometry)');
          updateStatus('üîó Binding type: WELD');
        }
      }
      
      // Clear all bindings (Ctrl+Shift+X)
      if (e.ctrlKey && e.shiftKey && key === 'x' && !e.repeat) {
        e.preventDefault();
        clearAllBindings();
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // FRAG-001: FRAGMENTATION KEYBOARD SHORTCUTS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      
      // Alt+F: Toggle fragmentation mode
      if (e.altKey && key === 'f' && !e.repeat) {
        e.preventDefault();
        toggleFragmentationMode();
      }
      
      // Fragmentation type selection (when in fragmentation mode)
      if (fragmentationMode && !e.repeat) {
        if (key === '5') {
          fragmentationType = 'smart-chunk';
          console.log('üí• Fragmentation: SMART CHUNK (realistic break)');
          updateStatus('üí• Fragmentation: SMART CHUNK');
        }
        if (key === '6') {
          fragmentationType = 'voxel';
          console.log('üí• Fragmentation: VOXEL (Minecraft-style)');
          updateStatus('üí• Fragmentation: VOXEL');
        }
        if (key === '7') {
          fragmentationType = 'radial';
          console.log('üí• Fragmentation: RADIAL (glass shatter)');
          updateStatus('üí• Fragmentation: RADIAL');
        }
        if (key === '8') {
          fragmentationType = 'slice';
          console.log('üí• Fragmentation: SLICE (clean cut)');
          updateStatus('üí• Fragmentation: SLICE');
        }
        
        // Adjust fragment count
        if (key === '[') {
          fragmentCount = Math.max(5, fragmentCount - 1);
          console.log(`üí• Fragment count: ${fragmentCount}`);
          updateStatus(`üí• Fragment count: ${fragmentCount}`);
        }
        if (key === ']') {
          fragmentCount = Math.min(20, fragmentCount + 1);
          console.log(`üí• Fragment count: ${fragmentCount}`);
          updateStatus(`üí• Fragment count: ${fragmentCount}`);
        }
        
        // Space: Fragment the object!
        if (key === ' ') {
          e.preventDefault();
          if (sculptMesh) {
            // Hide original mesh
            sculptMesh.visible = false;
            
            // Fragment it
            const newFragments = fragmentMesh(sculptMesh, fragmentationType, {
              count: fragmentCount,
              impactPoint: camera.position.clone() // Use camera position as impact
            });
            
            console.log(`üí• Fragmented! Created ${newFragments.length} pieces`);
            updateStatus(`üí• BOOM! ${newFragments.length} fragments created`);
          } else {
            console.warn('‚ö†Ô∏è No mesh to fragment');
            updateStatus('‚ö†Ô∏è No mesh to fragment');
          }
        }
      }
      
      // Clear fragments (Ctrl+Shift+C)
      if (e.ctrlKey && e.shiftKey && key === 'c' && !e.repeat) {
        e.preventDefault();
        clearFragments();
        if (sculptMesh) sculptMesh.visible = true; // Show original mesh again
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // VFX-001: PARTICLE SYSTEM KEYBOARD SHORTCUTS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      
      // Alt+P: Toggle particle mode
      if (e.altKey && key === 'p' && !e.repeat) {
        e.preventDefault();
        toggleParticleMode();
      }
      
      // 9: Spawn particles at cursor (when in particle mode)
      if (key === '9' && particleMode && !e.repeat) {
        e.preventDefault();
        
        // Raycast to find spawn position
        raycaster.setFromCamera(mouse, camera);
        
        // Check intersection with ground
        const groundIntersect = raycaster.intersectObject(window.ground);
        if (groundIntersect.length > 0) {
          const position = groundIntersect[0].point;
          createPointEmitter(position, currentParticleType, 2.0);
          console.log(`‚ú® Spawned ${currentParticleType} emitter at`, position);
          updateStatus(`‚ú® ${currentParticleType.toUpperCase()} spawned!`);
        }
      }
      
      // Shift+9: Previous particle type
      if (e.shiftKey && key === '9' && !e.repeat) {
        e.preventDefault();
        const types = ['smoke', 'sparks', 'embers', 'debris', 'fire'];
        const currentIndex = types.indexOf(currentParticleType);
        currentParticleType = types[(currentIndex - 1 + types.length) % types.length];
        console.log(`‚ú® Particle type: ${currentParticleType.toUpperCase()}`);
        updateStatus(`‚ú® Particles: ${currentParticleType.toUpperCase()}`);
      }
      
      // Shift+0: Next particle type
      if (e.shiftKey && key === '0' && !e.repeat) {
        e.preventDefault();
        const types = ['smoke', 'sparks', 'embers', 'debris', 'fire'];
        const currentIndex = types.indexOf(currentParticleType);
        currentParticleType = types[(currentIndex + 1) % types.length];
        console.log(`‚ú® Particle type: ${currentParticleType.toUpperCase()}`);
        updateStatus(`‚ú® Particles: ${currentParticleType.toUpperCase()}`);
      }
      
      // Ctrl+Shift+P: Clear all particles
      if (e.ctrlKey && e.shiftKey && key === 'p' && !e.repeat) {
        e.preventDefault();
        clearAllParticles();
        updateStatus('‚ú® Particles cleared');
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // INTER-WINDOW SYNC KEYBOARD SHORTCUTS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      
      // Ctrl+Shift+S: Send geometry to AI Studio
      if (e.ctrlKey && e.shiftKey && key === 's') {
        e.preventDefault();
        sendGeometryToAI();
        updateStatus('üì§ Geometry sent to AI Studio');
      }
      
      // Ctrl+Shift+R: Receive geometry from AI Studio
      if (e.ctrlKey && e.shiftKey && key === 'r') {
        e.preventDefault();
        receiveGeometryFromAI();
      }
      
      // Ctrl+Shift+O: Open AI Studio window
      if (e.ctrlKey && e.shiftKey && key === 'o') {
        e.preventDefault();
        const aiWindow = window.open('ai_studio_window.html', 'AIStudio', 'width=1200,height=800');
        if (aiWindow) {
          updateStatus('üöÄ AI Studio window opened');
        }
      }
    });

    window.addEventListener('keyup', (e) => {
      const key = e.key.toLowerCase();
      
      // Release WASD keys
      if (key === 'w') keyState.w = false;
      if (key === 'a') keyState.a = false;
      if (key === 's') keyState.s = false;
      if (key === 'd') keyState.d = false;
      if (key === 'q') keyState.q = false;
      if (key === 'e') keyState.e = false;
      
      // Release modifiers
      if (!e.shiftKey) keyState.shift = false;
      if (!e.ctrlKey) keyState.ctrl = false;
    });

    // SEL-001: Box selection mouse handlers
    canvas.addEventListener('mousedown', (e) => {
      // SEL-003: Lasso selection click
      if (lassoSelectMode) {
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        // Check for double-click to complete
        if (lassoActive && lassoPath.length > 0) {
          const lastPoint = lassoPath[lassoPath.length - 1];
          const dist = Math.sqrt(Math.pow(clickX - lastPoint.x, 2) + Math.pow(clickY - lastPoint.y, 2));
          
          // If click near start point or double-click, complete selection
          if (lassoPath.length > 2 && dist < 15) {
            performLassoSelection(e.shiftKey, e.ctrlKey);
            lassoActive = false;
            lassoPath = [];
            clearLassoCanvas();
            return;
          }
        }
        
        // Start or add point to lasso path
        lassoActive = true;
        lassoPath.push({ x: clickX, y: clickY });
        drawLassoPath();
        console.log(`üé® Lasso point ${lassoPath.length} added`);
        return;
      }
      
      if (!selectionMode) return;

      isSelecting = true;
      const rect = canvas.getBoundingClientRect();
      selectionStart.x = e.clientX - rect.left;
      selectionStart.y = e.clientY - rect.top;
      selectionEnd.x = selectionStart.x;
      selectionEnd.y = selectionStart.y;

      // Show selection box
      selectionBox.classList.add('active');
      updateSelectionBox();
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // SEL-003: Lasso path preview
      if (lassoSelectMode && lassoActive && lassoPath.length > 0) {
        drawLassoPath(mouseX, mouseY);
        return;
      }

      // SEL-002: Circle select updates
      if (circleSelectMode) {
        circleCenter.x = mouseX;
        circleCenter.y = mouseY;
        updateCircleSelectOverlay();
        
        // Perform live circle selection or modification
        performCircleSelection(e.shiftKey, e.ctrlKey);
        return;
      }

      // SEL-001: Box select updates
      if (!isSelecting) return;
      selectionEnd.x = mouseX;
      selectionEnd.y = mouseY;
      updateSelectionBox();
    });

    canvas.addEventListener('mouseup', (e) => {
      if (!isSelecting) return;

      isSelecting = false;
      selectionBox.classList.remove('active');

      // Perform vertex selection
      performBoxSelection(e.shiftKey, e.ctrlKey);
    });

    // SEL-002: Mouse wheel for circle radius adjustment
    canvas.addEventListener('wheel', (e) => {
      if (!circleSelectMode) return;
      
      e.preventDefault();
      const delta = e.deltaY > 0 ? -5 : 5;
      circleRadius = Math.max(10, Math.min(200, circleRadius + delta));
      updateCircleSelectOverlay();
      console.log(`‚≠ï Circle radius: ${circleRadius}px`);
    }, { passive: false });

    // Update selection box visual
    function updateSelectionBox() {
      const left = Math.min(selectionStart.x, selectionEnd.x);
      const top = Math.min(selectionStart.y, selectionEnd.y);
      const width = Math.abs(selectionEnd.x - selectionStart.x);
      const height = Math.abs(selectionEnd.y - selectionStart.y);

      selectionBox.style.left = `${left}px`;
      selectionBox.style.top = `${top}px`;
      selectionBox.style.width = `${width}px`;
      selectionBox.style.height = `${height}px`;
    }

    // Perform vertex selection based on box bounds
    function performBoxSelection(addToSelection, removeFromSelection) {
      const positions = sculptGeometry.attributes.position;
      const vertexCount = positions.count;
      const tempVec = new THREE.Vector3();
      
      // Get selection bounds
      const minX = Math.min(selectionStart.x, selectionEnd.x);
      const maxX = Math.max(selectionStart.x, selectionEnd.x);
      const minY = Math.min(selectionStart.y, selectionEnd.y);
      const maxY = Math.max(selectionStart.y, selectionEnd.y);

      // Clear selection if not adding/removing
      if (!addToSelection && !removeFromSelection) {
        selectedVertices.clear();
      }

      let newSelections = 0;

      // Test each vertex
      for (let i = 0; i < vertexCount; i++) {
        tempVec.fromBufferAttribute(positions, i);
        
        // Transform to world space
        tempVec.applyMatrix4(sculptMesh.matrixWorld);
        
        // Project to screen space
        tempVec.project(camera);
        
        // Convert to canvas coordinates
        const canvas = renderer.domElement;
        const screenX = (tempVec.x * 0.5 + 0.5) * canvas.width;
        const screenY = (-tempVec.y * 0.5 + 0.5) * canvas.height;

        // Check if within selection box
        const inBox = screenX >= minX && screenX <= maxX && screenY >= minY && screenY <= maxY;

        if (inBox) {
          if (removeFromSelection) {
            selectedVertices.delete(i);
          } else {
            selectedVertices.add(i);
            newSelections++;
          }
        }
      }

      // Log selection results (NO automatic modification)
      if (removeFromSelection) {
        console.log(`‚ûñ Removed from selection | Total: ${selectedVertices.size}`);
      } else if (addToSelection) {
        console.log(`‚ûï Added to selection | Total: ${selectedVertices.size}`);
      } else {
        // Clear previous selection and select new
        console.log(`üì¶ Selected ${selectedVertices.size} vertices`);
      }

      // Just highlight selection - no automatic layer changes
      highlightSelectedVertices(selectedVertices);
      updateStatus(`Selected: ${selectedVertices.size} vertices | Press + or - to modify layers`);
    }

    // SEL-002: Update circle select overlay position and size
    function updateCircleSelectOverlay() {
      const diameter = circleRadius * 2;
      circleSelectOverlay.style.left = `${circleCenter.x - circleRadius}px`;
      circleSelectOverlay.style.top = `${circleCenter.y - circleRadius}px`;
      circleSelectOverlay.style.width = `${diameter}px`;
      circleSelectOverlay.style.height = `${diameter}px`;
    }

    // SEL-002: Circle selection logic
    function performCircleSelection(addToSelection, removeFromSelection) {
      if (!sculptGeometry) return;

      const positions = sculptGeometry.attributes.position;
      const verticesInCircle = new Set();

      // Project vertices to screen space and check if within circle
      for (let i = 0; i < positions.count; i++) {
        const vertex = new THREE.Vector3(
          positions.getX(i),
          positions.getY(i),
          positions.getZ(i)
        );

        // Convert to screen space
        const projected = vertex.clone().project(camera);
        const screenX = (projected.x * 0.5 + 0.5) * canvas.width;
        const screenY = ((-projected.y * 0.5) + 0.5) * canvas.height;

        // Check if within circle (distance from center)
        const dx = screenX - circleCenter.x;
        const dy = screenY - circleCenter.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance <= circleRadius) {
          verticesInCircle.add(i);
        }
      }

      // Apply modification mode if active
      if (circleModifyMode === 'build') {
        applyLayerModification(verticesInCircle, 0.1);
        highlightSelectedVertices(verticesInCircle);
        return;
      } else if (circleModifyMode === 'carve') {
        applyLayerModification(verticesInCircle, -0.1);
        highlightSelectedVertices(verticesInCircle);
        return;
      }

      // Otherwise, just update selection
      if (removeFromSelection) {
        verticesInCircle.forEach(v => selectedVertices.delete(v));
      } else if (addToSelection) {
        verticesInCircle.forEach(v => selectedVertices.add(v));
      } else {
        selectedVertices.clear();
        verticesInCircle.forEach(v => selectedVertices.add(v));
      }

      highlightSelectedVertices(selectedVertices);
      updateStatus(`Selected: ${selectedVertices.size} vertices | Radius: ${circleRadius}px`);
    }

    // SEL-003: Draw lasso path on canvas
    function drawLassoPath(previewX, previewY) {
      clearLassoCanvas();
      
      if (lassoPath.length === 0) return;
      
      lassoCtx.strokeStyle = '#00ffff';
      lassoCtx.lineWidth = 2;
      lassoCtx.setLineDash([5, 5]);
      lassoCtx.lineCap = 'round';
      lassoCtx.lineJoin = 'round';
      
      // Draw path
      lassoCtx.beginPath();
      lassoCtx.moveTo(lassoPath[0].x, lassoPath[0].y);
      
      for (let i = 1; i < lassoPath.length; i++) {
        lassoCtx.lineTo(lassoPath[i].x, lassoPath[i].y);
      }
      
      // Draw preview line to cursor
      if (previewX !== undefined && previewY !== undefined) {
        lassoCtx.lineTo(previewX, previewY);
        // Line back to start to show closure
        lassoCtx.lineTo(lassoPath[0].x, lassoPath[0].y);
      } else if (lassoPath.length > 2) {
        // Close the path
        lassoCtx.lineTo(lassoPath[0].x, lassoPath[0].y);
      }
      
      lassoCtx.stroke();
      
      // Draw points
      lassoCtx.fillStyle = '#00ffff';
      lassoPath.forEach(point => {
        lassoCtx.beginPath();
        lassoCtx.arc(point.x, point.y, 4, 0, Math.PI * 2);
        lassoCtx.fill();
      });
      
      // Draw start point larger
      if (lassoPath.length > 0) {
        lassoCtx.fillStyle = '#00ff00';
        lassoCtx.beginPath();
        lassoCtx.arc(lassoPath[0].x, lassoPath[0].y, 6, 0, Math.PI * 2);
        lassoCtx.fill();
      }
    }

    // SEL-003: Clear lasso canvas
    function clearLassoCanvas() {
      lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
    }

    // SEL-003: Point-in-polygon test
    function pointInPolygon(x, y, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        
        const intersect = ((yi > y) !== (yj > y))
          && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // SEL-003: Lasso selection logic
    function performLassoSelection(addToSelection, removeFromSelection) {
      if (!sculptGeometry || lassoPath.length < 3) {
        console.log('‚ö†Ô∏è Need at least 3 points to complete lasso');
        return;
      }

      const positions = sculptGeometry.attributes.position;
      const verticesInLasso = new Set();

      // Project vertices to screen space and check if within lasso polygon
      for (let i = 0; i < positions.count; i++) {
        const vertex = new THREE.Vector3(
          positions.getX(i),
          positions.getY(i),
          positions.getZ(i)
        );

        // Convert to screen space
        const projected = vertex.clone().project(camera);
        const screenX = (projected.x * 0.5 + 0.5) * canvas.width;
        const screenY = ((-projected.y * 0.5) + 0.5) * canvas.height;

        // Check if within lasso polygon
        if (pointInPolygon(screenX, screenY, lassoPath)) {
          verticesInLasso.add(i);
        }
      }

      // Update selection based on modifiers
      if (removeFromSelection) {
        verticesInLasso.forEach(v => selectedVertices.delete(v));
        console.log(`‚ûñ Removed from selection | Total: ${selectedVertices.size}`);
      } else if (addToSelection) {
        verticesInLasso.forEach(v => selectedVertices.add(v));
        console.log(`‚ûï Added to selection | Total: ${selectedVertices.size}`);
      } else {
        selectedVertices.clear();
        verticesInLasso.forEach(v => selectedVertices.add(v));
        console.log(`üé® Lasso selected ${selectedVertices.size} vertices`);
      }

      highlightSelectedVertices(selectedVertices);
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // BIND-001: Handle binding mode lasso selection
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      if (bindingMode) {
        if (bindingStep === 0 && selectedVertices.size > 0) {
          // First object selected
          bindingStep = 1;
          firstBoundObject = {
            mesh: sculptMesh,
            body: sculptBody,
            vertices: new Set(selectedVertices)
          };
          
          // Highlight first object in GREEN
          const positions = sculptGeometry.attributes.position;
          const colors = new Float32Array(positions.count * 3);
          for (let i = 0; i < positions.count; i++) {
            if (selectedVertices.has(i)) {
              colors[i * 3] = 0;     // R
              colors[i * 3 + 1] = 1; // G (green)
              colors[i * 3 + 2] = 0; // B
            } else {
              colors[i * 3] = 0.5;
              colors[i * 3 + 1] = 0.5;
              colors[i * 3 + 2] = 0.5;
            }
          }
          sculptGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          sculptMaterial.vertexColors = true;
          sculptGeometry.attributes.color.needsUpdate = true;
          
          console.log('üü¢ First object selected (GREEN) - Now select second object with lasso');
          updateStatus('üü¢ Step 1/2: First object selected (GREEN) - Select second object');
          
        } else if (bindingStep === 1 && selectedVertices.size > 0) {
          // Second object selected
          bindingStep = 2;
          secondBoundObject = {
            mesh: sculptMesh,
            body: sculptBody,
            vertices: new Set(selectedVertices)
          };
          
          // Highlight second object in YELLOW (keep first GREEN)
          const positions = sculptGeometry.attributes.position;
          const colors = sculptGeometry.attributes.color || new Float32Array(positions.count * 3);
          
          for (let i = 0; i < positions.count; i++) {
            if (selectedVertices.has(i)) {
              colors[i * 3] = 1;     // R
              colors[i * 3 + 1] = 1; // G (yellow)
              colors[i * 3 + 2] = 0; // B
            }
          }
          sculptGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          sculptMaterial.vertexColors = true;
          sculptGeometry.attributes.color.needsUpdate = true;
          
          console.log('üü° Second object selected (YELLOW) - Creating binding...');
          updateStatus('üü° Step 2/2: Second object selected (YELLOW) - Creating binding...');
          
          // Create the binding
          if (!physicsEnabled) {
            console.warn('‚ö†Ô∏è Physics must be enabled (press P) to create bindings!');
            updateStatus('‚ö†Ô∏è Enable physics (P key) first!');
          } else if (!sculptBody) {
            console.warn('‚ö†Ô∏è Creating physics body for sculpt mesh...');
            createSculptPhysicsBody();
            
            // Create binding after physics body created
            setTimeout(() => {
              const binding = createBinding(firstBoundObject, secondBoundObject, bindingType);
              if (binding) {
                console.log(`‚úÖ ${bindingType.toUpperCase()} binding created!`);
                updateStatus(`‚úÖ ${bindingType.toUpperCase()} binding created! Alt+L to bind more, Ctrl+Shift+X to clear`);
              }
              
              // Reset binding mode but stay active for more bindings
              bindingStep = 0;
              firstBoundObject = null;
              secondBoundObject = null;
              
              // Clear vertex colors
              if (sculptGeometry.attributes.color) {
                sculptGeometry.deleteAttribute('color');
                sculptMaterial.vertexColors = false;
              }
            }, 100);
            
          } else {
            const binding = createBinding(firstBoundObject, secondBoundObject, bindingType);
            if (binding) {
              console.log(`‚úÖ ${bindingType.toUpperCase()} binding created!`);
              updateStatus(`‚úÖ ${bindingType.toUpperCase()} binding created! Alt+L to bind more, Ctrl+Shift+X to clear`);
            }
            
            // Reset binding mode but stay active for more bindings
            bindingStep = 0;
            firstBoundObject = null;
            secondBoundObject = null;
            
            // Clear vertex colors
            if (sculptGeometry.attributes.color) {
              sculptGeometry.deleteAttribute('color');
              sculptMaterial.vertexColors = false;
            }
          }
        }
      } else {
        // Normal selection mode (not binding)
        updateStatus(`Selected: ${selectedVertices.size} vertices | Press + or - to modify layers`);
      }
    }

    // SEL-004: Selection Utilities

    // Invert Selection
    function invertSelection() {
      if (!sculptGeometry) return;
      
      const totalVertices = sculptGeometry.attributes.position.count;
      const newSelection = new Set();
      
      for (let i = 0; i < totalVertices; i++) {
        if (!selectedVertices.has(i)) {
          newSelection.add(i);
        }
      }
      
      selectedVertices.clear();
      newSelection.forEach(v => selectedVertices.add(v));
      
      highlightSelectedVertices(selectedVertices);
      updateStatus(`Inverted selection: ${selectedVertices.size} vertices`);
      console.log(`üîÑ Inverted selection | Now selected: ${selectedVertices.size} vertices`);
    }

    // Grow Selection (expand to neighboring vertices)
    function growSelection() {
      if (!sculptGeometry || selectedVertices.size === 0) {
        console.log('‚ö†Ô∏è No vertices selected to grow');
        return;
      }
      
      const positions = sculptGeometry.attributes.position;
      const neighbors = new Set();
      
      // Find neighboring vertices (within threshold distance)
      const threshold = 0.3; // Distance threshold for neighbors
      
      selectedVertices.forEach(selectedIndex => {
        const sx = positions.getX(selectedIndex);
        const sy = positions.getY(selectedIndex);
        const sz = positions.getZ(selectedIndex);
        
        // Check all vertices for proximity
        for (let i = 0; i < positions.count; i++) {
          if (selectedVertices.has(i)) continue; // Skip already selected
          
          const dx = positions.getX(i) - sx;
          const dy = positions.getY(i) - sy;
          const dz = positions.getZ(i) - sz;
          const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
          
          if (distance < threshold) {
            neighbors.add(i);
          }
        }
      });
      
      // Add neighbors to selection
      const beforeCount = selectedVertices.size;
      neighbors.forEach(v => selectedVertices.add(v));
      const grownCount = selectedVertices.size - beforeCount;
      
      highlightSelectedVertices(selectedVertices);
      updateStatus(`Grown selection: +${grownCount} vertices (${selectedVertices.size} total)`);
      console.log(`üìà Grown selection | Added: ${grownCount} | Total: ${selectedVertices.size}`);
    }

    // Shrink Selection (contract inward, remove edge vertices)
    function shrinkSelection() {
      if (!sculptGeometry || selectedVertices.size === 0) {
        console.log('‚ö†Ô∏è No vertices selected to shrink');
        return;
      }
      
      const positions = sculptGeometry.attributes.position;
      const edgeVertices = new Set();
      
      // Find edge vertices (those with unselected neighbors)
      const threshold = 0.3;
      
      selectedVertices.forEach(selectedIndex => {
        const sx = positions.getX(selectedIndex);
        const sy = positions.getY(selectedIndex);
        const sz = positions.getZ(selectedIndex);
        
        // Check if any nearby vertex is NOT selected
        let hasUnselectedNeighbor = false;
        
        for (let i = 0; i < positions.count; i++) {
          if (selectedVertices.has(i)) continue;
          
          const dx = positions.getX(i) - sx;
          const dy = positions.getY(i) - sy;
          const dz = positions.getZ(i) - sz;
          const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
          
          if (distance < threshold) {
            hasUnselectedNeighbor = true;
            break;
          }
        }
        
        if (hasUnselectedNeighbor) {
          edgeVertices.add(selectedIndex);
        }
      });
      
      // Remove edge vertices from selection
      const beforeCount = selectedVertices.size;
      edgeVertices.forEach(v => selectedVertices.delete(v));
      const shrunkCount = beforeCount - selectedVertices.size;
      
      highlightSelectedVertices(selectedVertices);
      updateStatus(`Shrunk selection: -${shrunkCount} vertices (${selectedVertices.size} total)`);
      console.log(`üìâ Shrunk selection | Removed: ${shrunkCount} | Total: ${selectedVertices.size}`);
    }

    // Clear Selection
    function clearSelection() {
      const count = selectedVertices.size;
      selectedVertices.clear();
      highlightSelectedVertices(selectedVertices);
      updateStatus('Selection cleared');
      console.log(`üóëÔ∏è Cleared selection | Removed: ${count} vertices`);
    }

    // Select All
    function selectAll() {
      if (!sculptGeometry) return;
      
      const totalVertices = sculptGeometry.attributes.position.count;
      selectedVertices.clear();
      
      for (let i = 0; i < totalVertices; i++) {
        selectedVertices.add(i);
      }
      
      highlightSelectedVertices(selectedVertices);
      updateStatus(`Selected all: ${selectedVertices.size} vertices`);
      console.log(`‚úÖ Selected all vertices | Total: ${selectedVertices.size}`);
    }

    // Apply layer modification to selected vertices (called separately)
    function applyLayerModification(vertices, intensity) {
      if (vertices.size === 0) {
        console.log('‚ö†Ô∏è No vertices selected');
        return;
      }
      
      const positions = sculptGeometry.attributes.position;
      const normals = sculptGeometry.attributes.normal;
      
      vertices.forEach(i => {
        // Get vertex normal (direction to push/pull)
        const nx = normals.getX(i);
        const ny = normals.getY(i);
        const nz = normals.getZ(i);

        // Move vertex along its normal
        positions.setX(i, positions.getX(i) + nx * intensity);
        positions.setY(i, positions.getY(i) + ny * intensity);
        positions.setZ(i, positions.getZ(i) + nz * intensity);
      });

      // Update geometry
      positions.needsUpdate = true;
      sculptGeometry.computeVertexNormals();
      
      console.log(`üé® Modified ${vertices.size} vertices | Intensity: ${intensity > 0 ? '+' : ''}${intensity.toFixed(2)}`);
    }

    // Highlight selected vertices visually
    function highlightSelectedVertices(vertices) {
      // Add color attribute if not exists
      if (!sculptGeometry.attributes.color) {
        const colors = new Float32Array(sculptGeometry.attributes.position.count * 3);
        // Set default white color for all vertices
        for (let i = 0; i < colors.length; i += 3) {
          colors[i] = 1.0;     // R
          colors[i + 1] = 1.0; // G
          colors[i + 2] = 1.0; // B
        }
        sculptGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        // Update material to use vertex colors
        sculptMesh.material.vertexColors = true;
        sculptMesh.material.needsUpdate = true;
      }

      const colors = sculptGeometry.attributes.color;
      
      // Reset all vertices to white first
      for (let i = 0; i < colors.count; i++) {
        colors.setXYZ(i, 1.0, 1.0, 1.0); // White
      }

      // Highlight selected vertices in cyan
      vertices.forEach(index => {
        colors.setXYZ(index, 0.0, 1.0, 1.0); // Cyan highlight
      });

      colors.needsUpdate = true;
      console.log(`‚ú® Highlighted ${vertices.size} vertices in cyan`);
    }

    // Brush shape selector
    document.querySelectorAll('.brush-shape-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.brush-shape-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.brushShape = btn.getAttribute('data-shape');
        updateBrushShape(); // Update cursor shape
        updateStatus(`Brush shape: ${state.brushShape}`);
      });
    });

    // Global functions (toolbar)
    window.newProject = () => {
      if (confirm('Start a new project? Unsaved changes will be lost.')) {
        state.projectId = 'untitled';
        state.layers = [new Float32Array(sculptGeometry.attributes.position.array.length)];
        state.activeLayer = 0;
        syncUI();
        updateStatus('New project created');
      }
    };

    window.saveProject = () => {
      const data = JSON.stringify(state);
      localStorage.setItem(`pixelprodigy3d_${state.projectId}`, data);
      updateStatus(`Project "${state.projectId}" saved`);
    };

    window.loadProject = () => {
      const id = prompt('Enter project ID:');
      if (!id) return;
      const data = localStorage.getItem(`pixelprodigy3d_${id}`);
      if (data) {
        Object.assign(state, JSON.parse(data));
        syncUI();
        updateStatus(`Project "${id}" loaded`);
      } else {
        alert('Project not found');
      }
    };

    window.exportModel = () => {
      updateStatus(`Exporting as ${state.exportFormat.toUpperCase()}...`);
      // TODO: export logic
    };

    // ==================== UNDO/REDO SYSTEM ====================
    
    function captureState() {
      // Deep clone current layer state
      const snapshot = {
        layers: state.layers.map(layer => new Float32Array(layer)),
        activeLayer: state.activeLayer
      };
      return snapshot;
    }

    function restoreState(snapshot) {
      state.layers = snapshot.layers.map(layer => new Float32Array(layer));
      state.activeLayer = snapshot.activeLayer;
      recomposeGeometry();
    }

    function pushUndo() {
      const snapshot = captureState();
      undoStack.push(snapshot);
      
      // Limit stack size
      if (undoStack.length > MAX_UNDO_STEPS) {
        undoStack.shift();
      }
      
      // Clear redo stack on new action
      redoStack.length = 0;
    }

    window.undo = () => {
      if (undoStack.length === 0) {
        updateStatus('Nothing to undo');
        return;
      }
      
      // Push current state to redo before undoing
      const currentSnapshot = captureState();
      redoStack.push(currentSnapshot);
      
      // Restore previous state
      const previousSnapshot = undoStack.pop();
      restoreState(previousSnapshot);
      
      updateStatus(`Undo (${undoStack.length} steps remaining)`);
    };

    window.redo = () => {
      if (redoStack.length === 0) {
        updateStatus('Nothing to redo');
        return;
      }
      
      // Push current state to undo before redoing
      const currentSnapshot = captureState();
      undoStack.push(currentSnapshot);
      
      // Restore next state
      const nextSnapshot = redoStack.pop();
      restoreState(nextSnapshot);
      
      updateStatus(`Redo (${redoStack.length} steps remaining)`);
    };

    // ==================== END UNDO/REDO SYSTEM ====================

    // ==================== TRANSFORM & LAYER SYSTEM ====================
    
    window.setTransformMode = (mode) => {
      transformMode = mode;
      
      const orbitBtn = document.getElementById('orbitModeBtn');
      const translateBtn = document.getElementById('translateModeBtn');
      const posInputs = document.getElementById('positionInputs');
      
      if (mode === 'orbit') {
        orbitBtn.classList.add('active');
        translateBtn.classList.remove('active');
        posInputs.style.display = 'none';
        controls.enabled = true;
        axisHelper.visible = true;
        gridHelper.visible = true;
        updateStatus('Orbit mode - rotate camera');
      } else if (mode === 'translate') {
        orbitBtn.classList.remove('active');
        translateBtn.classList.add('active');
        posInputs.style.display = 'block';
        controls.enabled = false;
        axisHelper.visible = true;
        gridHelper.visible = true;
        syncPositionInputs();
        updateStatus('Translate mode - move object');
      }
    };

    function syncPositionInputs() {
      document.getElementById('posX').value = sculptMesh.position.x.toFixed(2);
      document.getElementById('posY').value = sculptMesh.position.y.toFixed(2);
      document.getElementById('posZ').value = sculptMesh.position.z.toFixed(2);
    }

    function updateObjectPosition() {
      const x = parseFloat(document.getElementById('posX').value);
      const y = parseFloat(document.getElementById('posY').value);
      const z = parseFloat(document.getElementById('posZ').value);
      
      sculptMesh.position.set(x, y, z);
      updateStatus(`Position: (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`);
    }

    // Position input listeners
    document.getElementById('posX').addEventListener('input', updateObjectPosition);
    document.getElementById('posY').addEventListener('input', updateObjectPosition);
    document.getElementById('posZ').addEventListener('input', updateObjectPosition);

    window.addLayer = () => {
      state.layers.push(new Float32Array(sculptGeometry.attributes.position.array.length));
      state.activeLayer = state.layers.length - 1;
      updateLayerUI();
      updateStatus(`Layer ${state.activeLayer + 1} added`);
    };

    function updateLayerUI() {
      const layerList = document.getElementById('layerList');
      layerList.innerHTML = '';
      
      state.layers.forEach((layer, index) => {
        const layerItem = document.createElement('div');
        layerItem.className = 'layer-item' + (index === state.activeLayer ? ' active' : '');
        layerItem.onclick = () => selectLayer(index);
        
        layerItem.innerHTML = `
          <span class="layer-name">Layer ${index + 1}</span>
          <div class="layer-controls">
            <button class="layer-btn" onclick="event.stopPropagation(); toggleLayerVisibility(${index})">üëÅÔ∏è</button>
            <button class="layer-btn" onclick="event.stopPropagation(); deleteLayer(${index})">üóëÔ∏è</button>
          </div>
        `;
        
        layerList.appendChild(layerItem);
      });
    }

    window.selectLayer = (index) => {
      state.activeLayer = index;
      updateLayerUI();
      updateStatus(`Layer ${index + 1} selected`);
    };

    window.toggleLayerVisibility = (index) => {
      // TODO: implement layer visibility toggle
      updateStatus(`Layer ${index + 1} visibility toggled`);
    };

    window.deleteLayer = (index) => {
      if (state.layers.length <= 1) {
        updateStatus('Cannot delete last layer');
        return;
      }
      
      if (confirm(`Delete Layer ${index + 1}?`)) {
        pushUndo();
        state.layers.splice(index, 1);
        if (state.activeLayer >= state.layers.length) {
          state.activeLayer = state.layers.length - 1;
        }
        updateLayerUI();
        recomposeGeometry();
        updateStatus(`Layer ${index + 1} deleted`);
      }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // OBJECT PLACEMENT & MANIPULATION SYSTEM
    // Full scene composition with objects on "the board"
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const boardObjects = []; // All objects placed on the board
    let selectedObject = null; // Currently selected object
    let possessedObject = null; // Object being controlled with WASD
    let layerIsolationMode = false; // Show only active layer
    let objectTransformMode = 'translate'; // 'translate', 'rotate', 'scale'
    
    // Layer frame captures (frozen images of previous builds)
    const layerFrames = new Map(); // layerIndex -> THREE.Texture
    const layerFramePlanes = new Map(); // layerIndex -> THREE.Mesh
    
    // Spawn object on the board
    window.spawnObject = (objectType) => {
      let geometry;
      
      switch(objectType) {
        case 'sphere':
          geometry = new THREE.SphereGeometry(1, 32, 32);
          break;
        case 'cube':
          geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
          break;
        case 'cylinder':
          geometry = new THREE.CylinderGeometry(0.7, 0.7, 2, 32);
          break;
        case 'cone':
          geometry = new THREE.ConeGeometry(1, 2, 32);
          break;
        case 'torus':
          geometry = new THREE.TorusGeometry(0.8, 0.3, 16, 100);
          break;
        case 'plane':
          geometry = new THREE.PlaneGeometry(2, 2, 10, 10);
          break;
        default:
          geometry = new THREE.SphereGeometry(1, 32, 32);
      }
      
      // Create material (inherit from current settings or use default)
      const material = new THREE.MeshStandardMaterial({
        color: Math.random() * 0xffffff,
        roughness: 0.4,
        metalness: 0.6,
        emissive: 0x000000,
        emissiveIntensity: 0.1
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(
        (Math.random() - 0.5) * 5,
        Math.random() * 3 + 1,
        (Math.random() - 0.5) * 5
      );
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      // Store metadata
      mesh.userData = {
        objectType: objectType,
        layerIndex: state.activeLayer,
        spawnedTime: Date.now(),
        objectId: `obj_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
      };
      
      scene.add(mesh);
      boardObjects.push(mesh);
      selectedObject = mesh;
      
      console.log(`‚úÖ Spawned ${objectType} on board (Layer ${state.activeLayer + 1})`);
      updateStatus(`üé≤ ${objectType.toUpperCase()} placed on board`);
      
      // Add physics body if physics enabled
      if (physicsEnabled && world) {
        const body = createPhysicsBody(mesh);
        mesh.userData.physicsBody = body;
      }
      
      return mesh;
    };
    
    // Create physics body for object
    function createPhysicsBody(mesh) {
      let shape;
      const userData = mesh.userData;
      
      switch(userData.objectType) {
        case 'sphere':
          shape = new CANNON.Sphere(1);
          break;
        case 'cube':
          shape = new CANNON.Box(new CANNON.Vec3(0.75, 0.75, 0.75));
          break;
        case 'cylinder':
        case 'cone':
          shape = new CANNON.Cylinder(0.7, 0.7, 2, 8);
          break;
        default:
          shape = new CANNON.Sphere(1);
      }
      
      const body = new CANNON.Body({
        mass: 1,
        shape: shape,
        position: new CANNON.Vec3(mesh.position.x, mesh.position.y, mesh.position.z)
      });
      
      world.addBody(body);
      return body;
    }
    
    // Toggle layer isolation (show only active layer)
    window.toggleLayerIsolation = () => {
      layerIsolationMode = !layerIsolationMode;
      
      boardObjects.forEach(obj => {
        if (layerIsolationMode) {
          obj.visible = (obj.userData.layerIndex === state.activeLayer);
        } else {
          obj.visible = true;
        }
      });
      
      // Also hide/show the main sculpt mesh
      if (sculptMesh) {
        sculptMesh.visible = !layerIsolationMode || state.activeLayer === 0;
      }
      
      // Show/hide layer frame planes
      layerFramePlanes.forEach((plane, layerIndex) => {
        if (layerIsolationMode) {
          plane.visible = (layerIndex === state.activeLayer);
        } else {
          plane.visible = true;
        }
      });
      
      const btn = document.getElementById('isolateLayerBtn');
      if (layerIsolationMode) {
        btn.style.background = '#a855f7';
        btn.textContent = `üîç Showing Layer ${state.activeLayer + 1} Only`;
        updateStatus(`üîç Isolated Layer ${state.activeLayer + 1}`);
      } else {
        btn.style.background = '#7c3aed';
        btn.textContent = 'üîç Isolate Active Layer';
        updateStatus('üîç All layers visible');
      }
    };
    
    // Capture current scene as frozen frame for layer
    window.captureLayerFrame = () => {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      
      // Render current scene to texture
      const renderTarget = new THREE.WebGLRenderTarget(width, height);
      renderer.setRenderTarget(renderTarget);
      renderer.render(scene, camera);
      renderer.setRenderTarget(null);
      
      // Store texture for this layer
      const texture = renderTarget.texture;
      layerFrames.set(state.activeLayer, texture);
      
      // Create plane to display the frozen frame
      const planeGeometry = new THREE.PlaneGeometry(15, 10);
      const planeMaterial = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide
      });
      
      const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
      planeMesh.position.set(0, 0, -10); // Behind the main scene
      planeMesh.rotation.x = 0;
      planeMesh.userData = {
        isLayerFrame: true,
        layerIndex: state.activeLayer
      };
      
      scene.add(planeMesh);
      layerFramePlanes.set(state.activeLayer, planeMesh);
      
      console.log(`üì∏ Captured frame for Layer ${state.activeLayer + 1}`);
      updateStatus(`üì∏ Layer ${state.activeLayer + 1} frozen as background image`);
    };
    
    // Object transformation controls
    window.flipObject = (axis) => {
      if (!selectedObject) {
        updateStatus('‚ö†Ô∏è No object selected');
        return;
      }
      
      switch(axis) {
        case 'x':
          selectedObject.scale.x *= -1;
          break;
        case 'y':
          selectedObject.scale.y *= -1;
          break;
        case 'z':
          selectedObject.scale.z *= -1;
          break;
      }
      
      updateStatus(`‚ÜîÔ∏è Flipped object on ${axis.toUpperCase()} axis`);
    };
    
    window.duplicateObject = () => {
      if (!selectedObject) {
        updateStatus('‚ö†Ô∏è No object selected');
        return;
      }
      
      const original = selectedObject;
      const clonedGeometry = original.geometry.clone();
      const clonedMaterial = original.material.clone();
      const cloned = new THREE.Mesh(clonedGeometry, clonedMaterial);
      
      cloned.position.copy(original.position);
      cloned.position.x += 2; // Offset slightly
      cloned.rotation.copy(original.rotation);
      cloned.scale.copy(original.scale);
      cloned.castShadow = true;
      cloned.receiveShadow = true;
      
      cloned.userData = {
        ...original.userData,
        objectId: `obj_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
      };
      
      scene.add(cloned);
      boardObjects.push(cloned);
      selectedObject = cloned;
      
      updateStatus(`üìã Object duplicated`);
    };
    
    window.deleteObject = () => {
      if (!selectedObject) {
        updateStatus('‚ö†Ô∏è No object selected');
        return;
      }
      
      scene.remove(selectedObject);
      const index = boardObjects.indexOf(selectedObject);
      if (index > -1) {
        boardObjects.splice(index, 1);
      }
      
      // Remove physics body if exists
      if (selectedObject.userData.physicsBody && world) {
        world.removeBody(selectedObject.userData.physicsBody);
      }
      
      selectedObject = null;
      updateStatus(`üóëÔ∏è Object deleted`);
    };
    
    // Possession mode - control object with WASD
    window.togglePossession = () => {
      if (!selectedObject) {
        updateStatus('‚ö†Ô∏è Select an object first');
        return;
      }
      
      const btn = document.getElementById('possessionBtn');
      
      if (possessedObject === selectedObject) {
        possessedObject = null;
        btn.style.background = '#dc2626';
        btn.textContent = 'üëª Possess Object (WASD)';
        updateStatus('üëª Possession mode OFF');
      } else {
        possessedObject = selectedObject;
        btn.style.background = '#16a34a';
        btn.textContent = 'üéÆ Possessing! (WASD to move)';
        updateStatus(`üéÆ Possessing ${selectedObject.userData.objectType} - Use WASD to move!`);
      }
    };
    
    // WASD possession controls
    const possessionKeys = { w: false, a: false, s: false, d: false, q: false, e: false };
    
    window.addEventListener('keydown', (event) => {
      const key = event.key.toLowerCase();
      if (possessionKeys.hasOwnProperty(key)) {
        possessionKeys[key] = true;
      }
    });
    
    window.addEventListener('keyup', (event) => {
      const key = event.key.toLowerCase();
      if (possessionKeys.hasOwnProperty(key)) {
        possessionKeys[key] = false;
      }
    });
    
    // Update possessed object position
    function updatePossessedObject() {
      if (!possessedObject) return;
      
      const speed = 0.15;
      const upSpeed = 0.1;
      
      if (possessionKeys.w) possessedObject.position.z -= speed;
      if (possessionKeys.s) possessedObject.position.z += speed;
      if (possessionKeys.a) possessedObject.position.x -= speed;
      if (possessionKeys.d) possessedObject.position.x += speed;
      if (possessionKeys.q) possessedObject.position.y -= upSpeed;
      if (possessionKeys.e) possessedObject.position.y += upSpeed;
      
      // Sync physics body if exists
      if (possessedObject.userData.physicsBody) {
        const body = possessedObject.userData.physicsBody;
        body.position.copy(possessedObject.position);
        body.velocity.set(0, 0, 0); // Cancel physics while possessing
      }
    }
    
    // Mouse click to select objects
    canvas.addEventListener('click', (event) => {
      if (bindingMode || fragmentationMode || particleMode) return; // Don't interfere with other modes
      
      const rect = canvas.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(boardObjects);
      
      if (intersects.length > 0) {
        selectedObject = intersects[0].object;
        updateStatus(`‚úÖ Selected ${selectedObject.userData.objectType} (Layer ${selectedObject.userData.layerIndex + 1})`);
        
        // Highlight selected object
        boardObjects.forEach(obj => {
          if (obj === selectedObject) {
            obj.material.emissive.setHex(0x4488ff);
            obj.material.emissiveIntensity = 0.3;
          } else {
            obj.material.emissive.setHex(0x000000);
            obj.material.emissiveIntensity = 0.1;
          }
        });
      }
    });
    
    // Transform mode keyboard shortcuts
    window.addEventListener('keydown', (event) => {
      if (event.target.tagName === 'INPUT') return; // Don't interfere with input fields
      
      if (event.key.toLowerCase() === 'g' && !event.ctrlKey && !event.altKey) {
        objectTransformMode = 'translate';
        document.getElementById('objectTransformMode').value = 'translate';
        updateStatus('üéØ Transform: MOVE mode (G)');
      } else if (event.key.toLowerCase() === 'r' && !event.ctrlKey && !event.altKey) {
        objectTransformMode = 'rotate';
        document.getElementById('objectTransformMode').value = 'rotate';
        updateStatus('üîÑ Transform: ROTATE mode (R)');
      } else if (event.key.toLowerCase() === 's' && !event.ctrlKey && !event.altKey) {
        objectTransformMode = 'scale';
        document.getElementById('objectTransformMode').value = 'scale';
        updateStatus('üìè Transform: SCALE mode (S)');
      }
    });
    
    console.log('‚úÖ Object placement system initialized');
    console.log('   - Click objects to select');
    console.log('   - Press G (move), R (rotate), S (scale)');
    console.log('   - Use WASD in possession mode');
    console.log('   - Layer isolation: show only active layer');
    console.log('   - Capture frame: freeze layer as background image');

    // Material preset application
    function applyMaterialPreset() {
      const preset = state.materialPreset;
      
      switch(preset) {
        case 'metallic':
          sculptMaterial.color.setHex(0x888888);
          sculptMaterial.metalness = 0.95;
          sculptMaterial.roughness = 0.15;
          break;
        case 'rough':
          sculptMaterial.color.setHex(0x7a7a7a);
          sculptMaterial.metalness = 0.05;
          sculptMaterial.roughness = 0.98;
          break;
        case 'wood':
          sculptMaterial.color.setHex(0x6f513a);
          sculptMaterial.metalness = 0.0;
          sculptMaterial.roughness = 0.85;
          break;
        case 'bark':
          sculptMaterial.color.setHex(0x4a3828);
          sculptMaterial.metalness = 0.0;
          sculptMaterial.roughness = 0.95;
          break;
        case 'chunky':
          sculptMaterial.color.setHex(0x6b6b6b);
          sculptMaterial.metalness = 0.02;
          sculptMaterial.roughness = 0.92;
          break;
        case 'waves':
          sculptMaterial.color.setHex(0x5a7a8a);
          sculptMaterial.metalness = 0.15;
          sculptMaterial.roughness = 0.6;
          break;
        case 'plastic':
          sculptMaterial.color.setHex(0x5588ff);
          sculptMaterial.metalness = 0.1;
          sculptMaterial.roughness = 0.4;
          break;
        case 'glass':
          sculptMaterial.color.setHex(0xaaccff);
          sculptMaterial.metalness = 0.1;
          sculptMaterial.roughness = 0.05;
          sculptMaterial.transparent = true;
          sculptMaterial.opacity = 0.6;
          break;
        default: // standard
          sculptMaterial.color.setHex(0x6f513a);
          sculptMaterial.metalness = 0.05;
          sculptMaterial.roughness = 0.82;
          sculptMaterial.transparent = false;
          sculptMaterial.opacity = 1.0;
      }
      
      sculptMaterial.needsUpdate = true;
      updateStatus(`Material: ${preset}`);
    }

    // Procedural pattern generators based on material type
    window.applyProceduralPattern = () => {
      pushUndo();
      const preset = state.materialPreset;
      
      switch(preset) {
        case 'bark':
          applyBarkPattern();
          break;
        case 'chunky':
          applyChunkyPattern();
          break;
        case 'waves':
          applyWavePattern();
          break;
        case 'rough':
          applyRoughPattern();
          break;
        default:
          updateStatus('No procedural pattern for this material');
          return;
      }
      
      updateStatus(`Applied ${preset} procedural pattern`);
    };

    function applyBarkPattern() {
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = state.displacementDepth * 0.015;
      const detail = state.detailLevel;
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const x = posAttr.array[idx];
        const y = posAttr.array[idx + 1];
        const z = posAttr.array[idx + 2];
        
        // Vertical bark ridges with fine detail
        const angle = Math.atan2(z, x);
        const ridgeCount = 16 * detail;
        const ridge = Math.sin(angle * ridgeCount);
        
        // Fine grain texture
        const fineGrain = Math.sin(y * 50 * detail) * Math.cos(angle * 30 * detail);
        
        // Vertical cracks
        const crack = Math.abs(Math.sin(angle * 8)) < 0.1 ? -0.3 : 0;
        
        const displacement = (ridge * 0.6 + fineGrain * 0.3 + crack) * strength;
        const radial = Math.sqrt(x * x + z * z) + 0.001;
        
        activeLayer[idx]     += (x / radial) * displacement;
        activeLayer[idx + 2] += (z / radial) * displacement;
      }
      
      recomposeGeometry();
    }

    function applyChunkyPattern() {
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = state.displacementDepth * 0.025;
      const detail = state.detailLevel;
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const x = posAttr.array[idx];
        const y = posAttr.array[idx + 1];
        const z = posAttr.array[idx + 2];
        
        // Large chunky blocks
        const chunkX = Math.floor((x + y) * 3 * detail);
        const chunkY = Math.floor(y * 2.5 * detail);
        const chunkZ = Math.floor((z + y) * 3 * detail);
        
        // Hash function for randomness
        const hash = Math.sin(chunkX * 12.9898 + chunkY * 78.233 + chunkZ * 37.719) * 43758.5453;
        const noise = (hash - Math.floor(hash)) * 2 - 1;
        
        // Sharp edges between chunks
        const edgeX = Math.abs(Math.sin((x + y) * 3 * detail * Math.PI));
        const edgeZ = Math.abs(Math.sin((z + y) * 3 * detail * Math.PI));
        const edgeFactor = Math.min(edgeX, edgeZ) < 0.2 ? -0.5 : 1;
        
        const displacement = noise * edgeFactor * strength;
        const radial = Math.sqrt(x * x + z * z) + 0.001;
        
        activeLayer[idx]     += (x / radial) * displacement;
        activeLayer[idx + 1] += displacement * 0.3;
        activeLayer[idx + 2] += (z / radial) * displacement;
      }
      
      recomposeGeometry();
    }

    function applyWavePattern() {
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = state.displacementDepth * 0.02;
      const detail = state.detailLevel;
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const x = posAttr.array[idx];
        const y = posAttr.array[idx + 1];
        const z = posAttr.array[idx + 2];
        
        // Horizontal layered waves
        const wave1 = Math.sin(y * 4 * detail) * 0.5;
        const wave2 = Math.sin(y * 8 * detail + Math.atan2(z, x) * 2) * 0.3;
        const wave3 = Math.cos(y * 16 * detail) * 0.2;
        
        // Radial modulation
        const radial = Math.sqrt(x * x + z * z) + 0.001;
        const radialWave = Math.sin(radial * 10 * detail) * 0.15;
        
        const displacement = (wave1 + wave2 + wave3 + radialWave) * strength;
        
        activeLayer[idx]     += (x / radial) * displacement;
        activeLayer[idx + 2] += (z / radial) * displacement;
      }
      
      recomposeGeometry();
    }

    function applyRoughPattern() {
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = state.displacementDepth * 0.012;
      const detail = state.detailLevel;
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const x = posAttr.array[idx];
        const y = posAttr.array[idx + 1];
        const z = posAttr.array[idx + 2];
        
        // Multi-scale noise for rough texture
        const noise1 = Math.sin(x * 20 * detail + y * 15 * detail) * 0.4;
        const noise2 = Math.cos(y * 40 * detail + z * 30 * detail) * 0.3;
        const noise3 = Math.sin((x + z) * 60 * detail) * 0.2;
        
        // Hash-based micro detail
        const hash = Math.sin(i * 0.1 + y * 10) * 43758.5453;
        const microDetail = ((hash - Math.floor(hash)) * 2 - 1) * 0.1;
        
        const displacement = (noise1 + noise2 + noise3 + microDetail) * strength;
        const radial = Math.sqrt(x * x + z * z) + 0.001;
        
        activeLayer[idx]     += (x / radial) * displacement;
        activeLayer[idx + 1] += displacement * 0.2;
        activeLayer[idx + 2] += (z / radial) * displacement;
      }
      
      recomposeGeometry();
    }

    // Material preset listener
    document.getElementById('materialPreset').addEventListener('change', (e) => {
      state.materialPreset = e.target.value;
      applyMaterialPreset();
    });

    // ==================== END TRANSFORM & LAYER SYSTEM ====================

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // WEB-BASED AI SUGGESTION SYSTEM
    // Zero backend required - intelligent procedural suggestions
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const aiSuggestionDatabase = {
      organic: [
        "Try adding flowing, natural curves using smooth strokes. Focus on the upper regions and create wave-like patterns.",
        "Create organic asymmetry by varying stroke strength. Apply softer touches to one side for natural-looking imperfections.",
        "Add subtle noise patterns across the surface. Use smaller brush radius (0.2-0.3) for fine detail work.",
        "Build up layers gradually with low strength (0.1-0.15). Nature doesn't create perfect shapes - embrace randomness!",
        "Focus on creating rhythm with your strokes. Alternate between push and pull motions for organic depth."
      ],
      geometric: [
        "Create sharp, angular features using higher strength (0.3-0.4). Focus on crisp edges and clean facets.",
        "Try symmetry mode to create perfectly mirrored geometric patterns. Use X-axis for bilateral symmetry.",
        "Build geometric terracing with consistent stroke spacing. Each layer should have uniform depth.",
        "Add architectural precision with grid-aligned strokes. Imagine building blocks, not sculptures.",
        "Use square brush shape for more geometric results. Apply with high hardness (0.8-1.0) for sharp transitions."
      ],
      smooth: [
        "Lower your brush strength to 0.05-0.1 for subtle, smooth transitions. Patience creates perfection.",
        "Use larger brush radius (0.5-0.7) with low hardness (0.3-0.4) for soft, gradual changes.",
        "Build up smooth curves with overlapping circular strokes. Think of polishing, not carving.",
        "Try the smooth falloff mode for buttery transitions between heights. Avoid harsh edges.",
        "Create rolling hills with gentle, sweeping motions. Long strokes create better flow than short jabs."
      ],
      detailed: [
        "Zoom in and use tiny brush radius (0.1-0.15) for micro-detail work. Details sell realism!",
        "Layer different detail scales: macro shape first, then mid-level features, finally fine texture.",
        "Use high pressure response (0.7-0.9) to get varying detail based on stroke speed.",
        "Add surface noise with custom brush shapes. Triangle or star shapes create interesting patterns.",
        "Focus detail on focal points - not everything needs equal complexity. Guide the eye."
      ],
      experimental: [
        "Try extreme values! Set strength to 0.5+ and see what chaos creates. Happy accidents are valuable.",
        "Combine different brush shapes in rapid succession. Chaos mode can yield unexpected beauty.",
        "Use possession mode to view your work from unusual angles. New perspectives reveal new possibilities.",
        "Layer multiple transparent captures and build depth through overlapping frozen frames.",
        "Spawn random objects as references, then sculpt around them. Let accidents guide creativity."
      ],
      beginner: [
        "Start with medium brush (0.3-0.4 radius) and low strength (0.1-0.15). Build confidence gradually.",
        "Practice circular motions first - they're forgiving and create pleasing results quickly.",
        "Don't fear the undo button! Experimentation is learning. Press Ctrl+Z liberally.",
        "Focus on one technique per session. Master smooth strokes before attempting complex patterns.",
        "Save incremental versions with üì∏ Freeze as Image. Track your progress and learn from it!"
      ]
    };
    
    window.askAI = () => {
      updateStatus('ü§ñ Generating intelligent suggestion...');
      
      // Analyze current scene to provide contextual suggestions
      const context = analyzeCurrentScene();
      
      // Select appropriate suggestion category
      let category = 'organic';
      if (context.hasObjects && context.objectCount > 5) category = 'experimental';
      else if (context.geometryComplexity > 0.7) category = 'detailed';
      else if (context.geometryComplexity < 0.3) category = 'beginner';
      else if (state.brushStrength > 0.3) category = 'geometric';
      else category = 'smooth';
      
      // Get random suggestion from category
      const suggestions = aiSuggestionDatabase[category];
      const randomIndex = Math.floor(Math.random() * suggestions.length);
      const suggestion = suggestions[randomIndex];
      
      // Add context-aware prefix
      const prefix = generateContextPrefix(context, category);
      const fullSuggestion = `${prefix}\n\n${suggestion}\n\nüí° Current scene: ${context.objectCount} objects, Layer ${state.activeLayer + 1}/${state.layers.length}`;
      
      // Store for apply function
      currentAISuggestion = {
        category: category,
        suggestion: suggestion,
        context: context
      };
      
      // Display with typing effect (makes it feel more AI-like)
      typewriterEffect(fullSuggestion, 'aiSuggestionText', 30);
      
      updateStatus(`ü§ñ AI Suggestion: ${category.toUpperCase()} approach`);
      
      // Log AI interaction
      logAIIteration('aiSuggestion', { 
        category: category,
        objectCount: context.objectCount,
        complexity: context.geometryComplexity,
        layer: state.activeLayer
      });
      
      console.log(`‚úÖ AI Suggestion generated (${category})`);
      console.log(`   Context: ${context.objectCount} objects, complexity ${context.geometryComplexity.toFixed(2)}`);
    };
    
    function analyzeCurrentScene() {
      return {
        hasObjects: boardObjects.length > 0,
        objectCount: boardObjects.length,
        geometryComplexity: calculateGeometryComplexity(),
        layerCount: state.layers.length,
        currentLayer: state.activeLayer,
        particleActive: particleMode,
        physicsActive: physicsEnabled
      };
    }
    
    function calculateGeometryComplexity() {
      // Analyze vertex positions to determine how complex the geometry is
      const posAttr = sculptGeometry.attributes.position;
      let variance = 0;
      
      for (let i = 0; i < Math.min(100, vertexCount); i++) {
        const idx = i * 3;
        const y = posAttr.array[idx + 1];
        variance += Math.abs(y);
      }
      
      return Math.min(1.0, variance / 100); // Normalize to 0-1
    }
    
    function generateContextPrefix(context, category) {
      const prefixes = {
        organic: [
          "üåø For a more natural, flowing look:",
          "üçÉ To create organic, nature-inspired forms:",
          "üåä Let's add some fluid, living motion:"
        ],
        geometric: [
          "üìê For crisp, architectural precision:",
          "üèóÔ∏è To build structured, geometric forms:",
          "‚¨õ Let's create sharp, angular features:"
        ],
        smooth: [
          "‚ú® For silky-smooth, polished surfaces:",
          "üåô To achieve gentle, flowing transitions:",
          "üíé Let's create refined, elegant curves:"
        ],
        detailed: [
          "üîç Time for intricate detail work:",
          "‚ö° To add fine, captivating details:",
          "üé® Let's enhance with micro-level refinement:"
        ],
        experimental: [
          "üöÄ Ready to explore creative chaos?",
          "üí• Let's push boundaries and experiment:",
          "üé≤ Time to break rules and discover:"
        ],
        beginner: [
          "üå± Perfect starting point for learning:",
          "üìö Let's build foundational skills:",
          "üéØ Here's a confidence-building technique:"
        ]
      };
      
      const categoryPrefixes = prefixes[category] || prefixes.organic;
      return categoryPrefixes[Math.floor(Math.random() * categoryPrefixes.length)];
    }
    
    function typewriterEffect(text, elementId, speed = 30) {
      const element = document.getElementById(elementId);
      element.textContent = '';
      
      let index = 0;
      const interval = setInterval(() => {
        if (index < text.length) {
          element.textContent += text[index];
          index++;
        } else {
          clearInterval(interval);
        }
      }, speed);
    }

    window.applyAISuggestion = () => {
      if (!currentAISuggestion) {
        updateStatus('‚ö†Ô∏è No AI suggestion to apply - click "Ask AI" first');
        return;
      }
      
      pushUndo(); // Save state before applying
      
      const category = currentAISuggestion.category;
      
      // Apply pattern based on suggestion category
      switch(category) {
        case 'organic':
          applyAIPatternOrganic();
          updateStatus('üåø Applied organic pattern suggestion');
          break;
        case 'geometric':
          applyAIPatternGeometric();
          updateStatus('üìê Applied geometric pattern suggestion');
          break;
        case 'smooth':
          applyAIPatternSmooth();
          updateStatus('‚ú® Applied smooth pattern suggestion');
          break;
        case 'detailed':
          applyAIPatternDetailed();
          updateStatus('üîç Applied detailed pattern suggestion');
          break;
        case 'experimental':
          applyAIPatternExperimental();
          updateStatus('üöÄ Applied experimental pattern suggestion');
          break;
        default:
          applyAIPatternSubtle();
          updateStatus('üí´ Applied subtle pattern suggestion');
      }
      
      logAIIteration('aiPatternApplied', { pattern: category });
      console.log(`‚úÖ Applied AI pattern: ${category}`);
    };
    
    window.dismissAISuggestion = () => {
      document.getElementById('aiSuggestionText').textContent = 
        'Click "Ask AI" to get intelligent suggestions based on your current scene.';
      currentAISuggestion = null;
      updateStatus('AI suggestion dismissed');
    };

    function applyAIPatternOrganic() {
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = 0.03 * state.guidanceStrength;
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const x = posAttr.array[idx];
        const y = posAttr.array[idx + 1];
        const z = posAttr.array[idx + 2];
        
        // Organic noise pattern
        const noise = Math.sin(x * 3 + y * 2) * Math.cos(z * 4 + y) * strength;
        const radial = Math.sqrt(x * x + z * z);
        const weight = Math.exp(-radial * 0.5); // Falloff from center
        
        activeLayer[idx]     += (x / (radial + 0.1)) * noise * weight;
        activeLayer[idx + 1] += noise * weight * 0.5;
        activeLayer[idx + 2] += (z / (radial + 0.1)) * noise * weight;
      }
      
      recomposeGeometry();
    }

    function applyAIPatternGeometric() {
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = 0.04 * state.guidanceStrength;
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const x = posAttr.array[idx];
        const y = posAttr.array[idx + 1];
        const z = posAttr.array[idx + 2];
        
        // Geometric facets
        const angle = Math.atan2(z, x);
        const facets = 8;
        const facetAngle = Math.floor(angle / (Math.PI * 2 / facets)) * (Math.PI * 2 / facets);
        const displacement = Math.cos(y * 5) * strength;
        
        activeLayer[idx]     += Math.cos(facetAngle) * displacement;
        activeLayer[idx + 2] += Math.sin(facetAngle) * displacement;
      }
      
      recomposeGeometry();
    }

    function applyAIPatternSmooth() {
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = 0.02 * state.guidanceStrength;
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const y = posAttr.array[idx + 1];
        
        // Smooth waves
        const wave = Math.sin(y * 2.5) * strength;
        const radial = Math.sqrt(
          posAttr.array[idx] * posAttr.array[idx] + 
          posAttr.array[idx + 2] * posAttr.array[idx + 2]
        );
        
        activeLayer[idx]     += (posAttr.array[idx] / (radial + 0.1)) * wave;
        activeLayer[idx + 2] += (posAttr.array[idx + 2] / (radial + 0.1)) * wave;
      }
      
      recomposeGeometry();
    }

    function applyAIPatternSubtle() {
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = 0.015 * state.guidanceStrength;
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const hash = Math.sin(i * 12.9898 + i * 78.233) * 43758.5453;
        const noise = (hash - Math.floor(hash)) * 2 - 1;
        
        activeLayer[idx]     += noise * strength * 0.3;
        activeLayer[idx + 1] += noise * strength * 0.5;
        activeLayer[idx + 2] += noise * strength * 0.3;
      }
      
      recomposeGeometry();
    }

    function applyAIPatternDetailed() {
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = 0.025 * state.guidanceStrength;
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const x = posAttr.array[idx];
        const y = posAttr.array[idx + 1];
        const z = posAttr.array[idx + 2];
        
        // Multi-scale detail
        const detail1 = Math.sin(x * 10 + y * 8) * Math.cos(z * 12);
        const detail2 = Math.sin(x * 20 - z * 15) * 0.5;
        const detail3 = Math.cos(y * 25 + x * 18) * 0.25;
        const combined = (detail1 + detail2 + detail3) * strength;
        
        const radial = Math.sqrt(x * x + z * z);
        const weight = Math.exp(-radial * 0.3);
        
        activeLayer[idx]     += (x / (radial + 0.1)) * combined * weight;
        activeLayer[idx + 1] += combined * weight * 0.7;
        activeLayer[idx + 2] += (z / (radial + 0.1)) * combined * weight;
      }
      
      recomposeGeometry();
    }

    function applyAIPatternExperimental() {
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = 0.05 * state.guidanceStrength;
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const x = posAttr.array[idx];
        const y = posAttr.array[idx + 1];
        const z = posAttr.array[idx + 2];
        
        // Chaotic experimental pattern
        const chaos1 = Math.sin(x * 7.3 + y * 4.1) * Math.cos(z * 9.7);
        const chaos2 = Math.tan((x + y + z) * 2.1) * 0.1;
        const chaos3 = Math.sin(i * 0.1) * Math.cos(i * 0.07);
        const combined = (chaos1 + chaos2 + chaos3) * strength;
        
        const radial = Math.sqrt(x * x + y * y + z * z);
        const weight = Math.exp(-radial * 0.4);
        
        activeLayer[idx]     += Math.cos(y * 3) * combined * weight;
        activeLayer[idx + 1] += Math.sin(x * 4) * combined * weight;
        activeLayer[idx + 2] += Math.sin(z * 5) * combined * weight;
      }
      
      recomposeGeometry();
    }

    window.dismissAISuggestion = () => {
      document.getElementById('aiSuggestionText').textContent = 'Click "Ask AI" to get sculpting suggestions.';
      updateStatus('AI suggestion dismissed');
    };

    window.loadHDRI = () => {
      updateStatus('HDRI loader (not yet implemented)');
      // TODO: file picker + HDR loader
    };

    function updateStatus(msg) {
      document.getElementById('statusLeft').textContent = msg;
    }

    // ==================== BRUSH SYSTEM ====================
    
    // Falloff functions
    function falloffSmooth(t) {
      return t * t * (3 - 2 * t);
    }

    function falloffLinear(t) {
      return t;
    }

    function falloffSharp(t) {
      return t * t * t;
    }

    function getFalloff(distance, radius, hardness) {
      if (distance > radius) return 0;
      const t = 1 - (distance / radius);
      const hardnessFactor = Math.pow(t, 1 + (1 - hardness) * 3);
      
      switch (state.brushFalloff) {
        case 'linear': return hardnessFactor * falloffLinear(t);
        case 'sharp': return hardnessFactor * falloffSharp(t);
        default: return hardnessFactor * falloffSmooth(t);
      }
    }

    // Brush shape masks
    function maskCircle(u, v, radius) {
      const dist = Math.hypot(u, v);
      if (dist > radius) return 0;
      return getFalloff(dist, radius, state.brushHardness);
    }

    function maskTriangle(u, v, radius) {
      const nv = v / radius;
      if (nv < -0.35 || nv > 1.05) return 0;
      const halfWidth = (1 - nv) * radius * 0.9;
      if (Math.abs(u) > halfWidth) return 0;
      const dist = Math.max(Math.abs(u) / (halfWidth + 1e-6), nv);
      const t = Math.max(0, 1 - dist);
      return t * getFalloff(Math.hypot(u, v), radius, state.brushHardness);
    }

    function maskLeaf(u, v, radius) {
      const along = v / (radius * 1.1);
      if (along < -0.3 || along > 1.1) return 0;
      const width = radius * (0.15 + (1 - along) * 0.95);
      const leftCurve = (Math.sin(along * Math.PI) * 0.4 + 0.6);
      const rightCurve = (Math.cos(along * Math.PI * 0.6) * 0.35 + 0.65);
      const uNorm = u / width;
      const limit = u < 0 ? leftCurve : rightCurve;
      if (Math.abs(uNorm) > limit) return 0;
      const dist = Math.max(Math.abs(uNorm) / limit, along);
      const t = Math.max(0, 1 - dist);
      return t * getFalloff(Math.hypot(u, v), radius, state.brushHardness);
    }

    function maskSquare(u, v, radius) {
      if (Math.abs(u) > radius || Math.abs(v) > radius) return 0;
      const dist = Math.max(Math.abs(u), Math.abs(v));
      return getFalloff(dist, radius, state.brushHardness);
    }

    function maskStar(u, v, radius) {
      const angle = Math.atan2(v, u);
      const dist = Math.hypot(u, v);
      const points = 5;
      const innerRadius = radius * 0.4;
      const spike = Math.abs(Math.sin(angle * points)) * (radius - innerRadius) + innerRadius;
      if (dist > spike) return 0;
      return getFalloff(dist, radius, state.brushHardness);
    }

    function getBrushMask(u, v, radius) {
      switch (state.brushShape) {
        case 'triangle': return maskTriangle(u, v, radius);
        case 'leaf': return maskLeaf(u, v, radius);
        case 'square': return maskSquare(u, v, radius);
        case 'star': return maskStar(u, v, radius);
        case 'custom': return maskCircle(u, v, radius); // TODO: custom texture
        default: return maskCircle(u, v, radius);
      }
    }

    // Recompose geometry from base + layers
    function recomposeGeometry() {
      const posAttr = sculptGeometry.attributes.position;
      const targetArray = posAttr.array;
      targetArray.set(basePositions);

      for (const layer of state.layers) {
        for (let i = 0; i < targetArray.length; i++) {
          targetArray[i] += layer[i];
        }
      }

      posAttr.needsUpdate = true;
      sculptGeometry.computeBoundingBox();
      sculptGeometry.computeBoundingSphere();
      
      if (state.autoNormalRefresh) {
        sculptGeometry.computeVertexNormals();
        sculptGeometry.attributes.normal.needsUpdate = true;
      }
    }

    // Apply brush stroke at hit point
    function applyBrush(hitPoint, hitNormal, invert = false) {
      const posAttr = sculptGeometry.attributes.position;
      const normAttr = sculptGeometry.attributes.normal;
      const activeLayer = state.layers[state.activeLayer];

      // Transform hit point to local space
      const localPoint = sculptMesh.worldToLocal(hitPoint.clone());
      
      // Build local tangent frame
      const normalMatrix = new THREE.Matrix3().getNormalMatrix(sculptMesh.matrixWorld);
      const localNormal = hitNormal.clone().applyMatrix3(normalMatrix).normalize();
      
      const up = Math.abs(localNormal.y) > 0.9 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 1, 0);
      const tangent = new THREE.Vector3().crossVectors(up, localNormal).normalize();
      const bitangent = new THREE.Vector3().crossVectors(localNormal, tangent).normalize();

      const sign = invert ? -1 : 1;
      const strength = state.brushStrength * sign * (1 + state.pressureResponse * 0.2); // TODO: real pressure
      const radius = state.brushRadius;

      const tempVec = new THREE.Vector3();
      const tempNorm = new THREE.Vector3();

      // Apply symmetry
      const symmetryPoints = [localPoint.clone()];
      
      if (state.symmetryAxis !== 'none') {
        const axes = state.symmetryAxis.split('');
        const mirrorCount = Math.pow(2, axes.length);
        
        for (let i = 1; i < mirrorCount; i++) {
          const mirrored = localPoint.clone();
          if (axes.includes('x') && (i & 1)) mirrored.x = -mirrored.x;
          if (axes.includes('y') && (i & 2)) mirrored.y = -mirrored.y;
          if (axes.includes('z') && (i & 4)) mirrored.z = -mirrored.z;
          symmetryPoints.push(mirrored);
        }
      }

      // Apply brush to each symmetry point
      for (const anchor of symmetryPoints) {
        for (let i = 0; i < vertexCount; i++) {
          const idx = i * 3;
          tempVec.set(
            posAttr.array[idx],
            posAttr.array[idx + 1],
            posAttr.array[idx + 2]
          );

          tempVec.sub(anchor);
          const u = tempVec.dot(tangent);
          const v = tempVec.dot(bitangent);

          const weight = getBrushMask(u, v, radius);
          if (weight <= 0) continue;

          tempNorm.set(
            normAttr.array[idx],
            normAttr.array[idx + 1],
            normAttr.array[idx + 2]
          ).normalize();

          const delta = strength * weight;
          activeLayer[idx]     += tempNorm.x * delta;
          activeLayer[idx + 1] += tempNorm.y * delta;
          activeLayer[idx + 2] += tempNorm.z * delta;
        }
      }

      recomposeGeometry();
    }

    // Update brush indicator position
    function updateBrushIndicator(hitPoint, hitNormal) {
      brushIndicator.position.copy(hitPoint);
      brushIndicator.lookAt(hitPoint.clone().add(hitNormal));
      brushIndicator.scale.set(state.brushRadius, state.brushRadius, state.brushRadius);
      brushIndicator.visible = true;
    }

    // Pointer move handler
    canvas.addEventListener('pointermove', (event) => {
      const rect = canvas.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObject(sculptMesh, false);

      if (hits.length > 0) {
        const hit = hits[0];
        const worldNormal = hit.face.normal.clone()
          .applyMatrix3(new THREE.Matrix3().getNormalMatrix(sculptMesh.matrixWorld))
          .normalize();
        
        updateBrushIndicator(hit.point, worldNormal);

        // Stroke spacing check
        if (isSculpting) {
          if (!lastStrokePoint || hit.point.distanceTo(lastStrokePoint) >= state.strokeSpacing) {
            applyBrush(hit.point, worldNormal, event.shiftKey);
            lastStrokePoint = hit.point.clone();
          }
        }
      } else {
        brushIndicator.visible = false;
      }
    });

    // Pointer down handler
    canvas.addEventListener('pointerdown', (event) => {
      if (event.button === 0) {
        // Don't sculpt if any selection tool is active
        if (isAnySelectionToolActive()) return;
        
        // Only sculpt in orbit mode, not in translate mode
        if (transformMode !== 'orbit') return;
        
        const rect = canvas.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(pointer, camera);
        const hits = raycaster.intersectObject(sculptMesh, false);

        if (hits.length > 0) {
          // Capture undo state before starting stroke
          pushUndo();
          
          isSculpting = true;
          controls.enabled = false;
          const hit = hits[0];
          const worldNormal = hit.face.normal.clone()
            .applyMatrix3(new THREE.Matrix3().getNormalMatrix(sculptMesh.matrixWorld))
            .normalize();
          
          applyBrush(hit.point, worldNormal, event.shiftKey);
          lastStrokePoint = hit.point.clone();
        }
      }
    });

    // Pointer up handler
    canvas.addEventListener('pointerup', () => {
      isSculpting = false;
      if (transformMode === 'orbit') {
        controls.enabled = true;
      }
      lastStrokePoint = null;
    });

    // Mouse wheel: adjust radius (or strength with Ctrl)
    canvas.addEventListener('wheel', (event) => {
      event.preventDefault();
      const delta = event.deltaY > 0 ? -0.04 : 0.04;

      if (event.ctrlKey) {
        state.brushStrength = Math.max(0.02, Math.min(0.5, state.brushStrength + delta * 0.5));
        document.getElementById('brushStrength').value = state.brushStrength;
        document.getElementById('brushStrengthValue').value = state.brushStrength;
        updateStatus(`Strength: ${state.brushStrength.toFixed(2)}`);
      } else {
        state.brushRadius = Math.max(0.1, Math.min(2.0, state.brushRadius + delta));
        document.getElementById('brushRadius').value = state.brushRadius;
        document.getElementById('brushRadiusValue').value = state.brushRadius;
        updateStatus(`Radius: ${state.brushRadius.toFixed(2)}`);
      }
    }, { passive: false });

    // Keyboard shortcuts
    window.addEventListener('keydown', (event) => {
      const key = event.key.toLowerCase();
      
      if (key === 'tab') {
        event.preventDefault();
        state.activeLayer = (state.activeLayer + 1) % state.layers.length;
        updateStatus(`Layer ${state.activeLayer + 1}/${state.layers.length}`);
      }
      
      if (key === 'r') {
        sculptGeometry.computeVertexNormals();
        sculptGeometry.attributes.normal.needsUpdate = true;
        updateStatus('Normals rebuilt');
      }
      
      if (key === 'backspace') {
        state.layers[state.activeLayer].fill(0);
        recomposeGeometry();
        updateStatus(`Layer ${state.activeLayer + 1} cleared`);
      }

      // Quick shape select
      if (key === '1') {
        state.brushShape = 'circle';
        document.querySelectorAll('.brush-shape-btn').forEach(b => b.classList.remove('active'));
        document.querySelector('[data-shape="circle"]').classList.add('active');
        updateBrushShape();
        updateStatus('Brush: Circle');
      }
      if (key === '2') {
        state.brushShape = 'triangle';
        document.querySelectorAll('.brush-shape-btn').forEach(b => b.classList.remove('active'));
        document.querySelector('[data-shape="triangle"]').classList.add('active');
        updateBrushShape();
        updateStatus('Brush: Triangle');
      }
      if (key === '3') {
        state.brushShape = 'leaf';
        document.querySelectorAll('.brush-shape-btn').forEach(b => b.classList.remove('active'));
        document.querySelector('[data-shape="leaf"]').classList.add('active');
        updateBrushShape();
        updateStatus('Brush: Leaf');
      }
      if (key === '4') {
        state.brushShape = 'square';
        document.querySelectorAll('.brush-shape-btn').forEach(b => b.classList.remove('active'));
        document.querySelector('[data-shape="square"]').classList.add('active');
        updateBrushShape();
        updateStatus('Brush: Square');
      }
      if (key === '5') {
        state.brushShape = 'star';
        document.querySelectorAll('.brush-shape-btn').forEach(b => b.classList.remove('active'));
        document.querySelector('[data-shape="star"]').classList.add('active');
        updateBrushShape();
        updateStatus('Brush: Star');
      }
      
      // Undo/Redo shortcuts
      if ((event.ctrlKey || event.metaKey) && key === 'z' && !event.shiftKey) {
        event.preventDefault();
        window.undo();
      }
      if ((event.ctrlKey || event.metaKey) && (key === 'y' || (key === 'z' && event.shiftKey))) {
        event.preventDefault();
        window.redo();
      }
      
      // Transform mode shortcuts
      if (key === 'o') {
        window.setTransformMode('orbit');
      }
      if (key === 'm') {
        window.setTransformMode('translate');
      }
    });

    // ==================== END BRUSH SYSTEM ====================

    // ==================== INCREMENT/DECREMENT LAYER SYSTEM ====================
    
    window.incrementLayer = () => {
      pushUndo();
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      const strength = 0.05; // Build up strength
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const x = posAttr.array[idx];
        const y = posAttr.array[idx + 1];
        const z = posAttr.array[idx + 2];
        
        // Radial expansion pattern
        const radial = Math.sqrt(x * x + z * z);
        const normalizedDist = radial / 2.0;
        const buildUp = strength * (1 - normalizedDist * 0.3);
        
        activeLayer[idx]     += (x / (radial + 0.1)) * buildUp;
        activeLayer[idx + 1] += buildUp * 0.5;
        activeLayer[idx + 2] += (z / (radial + 0.1)) * buildUp;
      }
      
      recomposeGeometry();
      updateStatus('Layer incremented - building up');
      
      // Log for AI tracking
      logAIIteration('increment', { strength, vertexCount, layerIndex: state.activeLayer });
    };

    window.decrementLayer = () => {
      pushUndo();
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      
      // DISSOLVE EFFECT: Each click progressively dissolves vertices
      const dissolveStrength = 0.35; // How much to dissolve per click
      
      for (let i = 0; i < vertexCount; i++) {
        const idx = i * 3;
        const x = posAttr.array[idx];
        const y = posAttr.array[idx + 1];
        const z = posAttr.array[idx + 2];
        
        // Calculate distance from center (radial pattern)
        const radial = Math.sqrt(x * x + z * z);
        const normalizedDist = radial / 3.0;
        
        // Vertices dissolve from outside-in with randomization
        const randomFactor = Math.random() * 0.4 + 0.8; // 0.8 to 1.2
        const heightFactor = (y + 2) / 10; // Top dissolves faster
        const dissolveFactor = dissolveStrength * normalizedDist * randomFactor * heightFactor;
        
        // Pull vertices toward center and down (imploding/dissolving effect)
        activeLayer[idx]     -= x * dissolveFactor * 0.15; // Pull inward X
        activeLayer[idx + 1] -= dissolveFactor * 0.25;     // Pull down Y
        activeLayer[idx + 2] -= z * dissolveFactor * 0.15; // Pull inward Z
        
        // Add chaotic noise to make it look like disintegration
        const noise = (Math.random() - 0.5) * dissolveFactor * 0.08;
        activeLayer[idx]     += noise;
        activeLayer[idx + 1] += noise * 0.5;
        activeLayer[idx + 2] += noise;
      }
      
      recomposeGeometry();
      updateStatus('üåÄ Vertices dissolving - mesh disintegrating');
      
      // Log for AI tracking
      logAIIteration('decrement', { 
        effect: 'vertex-dissolution', 
        strength: dissolveStrength, 
        vertexCount, 
        layerIndex: state.activeLayer 
      });
    };

    // ==================== LIGHTING & THEME SYSTEM ====================
    
    window.applyLightingRig = (rig) => {
      state.lightingRig = rig;
      
      switch(rig) {
        case 'three-point':
          dirLight.intensity = 1.6;
          dirLight.position.set(6, 14, 10);
          dirLight.color.setHex(0x9dcfff);
          scene.add(new THREE.AmbientLight(0x4a6073, 0.45));
          break;
        case 'natural':
          dirLight.intensity = 2.0;
          dirLight.position.set(10, 20, 5);
          dirLight.color.setHex(0xfff4e6);
          scene.add(new THREE.AmbientLight(0x7a9cc6, 0.35));
          break;
        case 'dramatic':
          dirLight.intensity = 2.5;
          dirLight.position.set(-8, 12, -8);
          dirLight.color.setHex(0xff9966);
          scene.add(new THREE.AmbientLight(0x1a1a2e, 0.2));
          break;
        case 'soft':
          dirLight.intensity = 1.2;
          dirLight.position.set(5, 15, 8);
          dirLight.color.setHex(0xf0f0f0);
          scene.add(new THREE.AmbientLight(0x8fa3b0, 0.6));
          break;
      }
      
      updateStatus(`Lighting: ${rig}`);
      logAIIteration('lightingChange', { rig });
    };

    // ENV-001: Wire Fog Density Slider
    window.applyFog = (density = state.fogDensity, useExponential = true) => {
      if (density === 0) {
        scene.fog = null;
        console.log('üå´Ô∏è Fog disabled');
      } else {
        const fogColor = scene.background || new THREE.Color(0x87ceeb);
        
        if (useExponential) {
          // THREE.FogExp2: exponential fog (density: 0-0.1)
          scene.fog = new THREE.FogExp2(fogColor, density);
          console.log(`üå´Ô∏è Exponential fog applied | Density: ${density.toFixed(3)} | Color: #${fogColor.getHexString()}`);
        } else {
          // THREE.Fog: linear fog (near: 20, far: 20-100)
          const far = 20 + (density * 800); // Map 0-0.1 to 20-100
          scene.fog = new THREE.Fog(fogColor, 20, far);
          console.log(`üå´Ô∏è Linear fog applied | Near: 20 | Far: ${far.toFixed(1)} | Color: #${fogColor.getHexString()}`);
        }
      }
      
      updateStatus(`Fog density: ${density.toFixed(2)}`);
      logAIIteration('fogChange', { density, type: useExponential ? 'exponential' : 'linear' });
    };

    // ENV-002: Fog Preset Buttons
    window.applyFogPreset = (preset) => {
      const presets = {
        none: 0,
        light: 0.02,
        medium: 0.05,
        heavy: 0.1
      };

      const density = presets[preset];
      if (density === undefined) {
        console.error(`‚ùå Invalid fog preset: ${preset}`);
        return;
      }

      // Update state and slider
      state.fogDensity = density;
      document.getElementById('fogDensity').value = density;
      document.getElementById('fogDensityValue').textContent = density.toFixed(3);

      // Apply fog
      applyFog(density, true);

      // Visual feedback: highlight active button
      document.querySelectorAll('.fog-preset-btn').forEach(btn => {
        if (btn.getAttribute('data-preset') === preset) {
          btn.style.background = '#2563eb';
          btn.style.borderColor = '#3b82f6';
        } else {
          btn.style.background = '#1e2836';
          btn.style.borderColor = '#2e3b4e';
        }
      });

      console.log(`üéöÔ∏è Fog preset applied: ${preset} (${density.toFixed(3)})`);
      updateStatus(`Fog preset: ${preset.charAt(0).toUpperCase() + preset.slice(1)}`);
      logAIIteration('fogPreset', { preset, density });
    };

    // ENV-003: Dynamic Ground Plane Size
    window.updateGroundPlane = (newSize) => {
      if (!newSize || newSize < 10 || newSize > 100) {
        console.error(`‚ùå Invalid ground size: ${newSize} (must be 10-100)`);
        return;
      }

      console.log(`üèóÔ∏è Recreating ground plane | Old size: ${state.groundPlaneSize} | New size: ${newSize}`);

      // Step 1: Remove old ground from scene
      scene.remove(ground);

      // Step 2: Dispose old geometry and material (memory cleanup)
      if (ground.geometry) {
        ground.geometry.dispose();
        console.log('‚ôªÔ∏è Old ground geometry disposed');
      }
      if (ground.material) {
        ground.material.dispose();
        console.log('‚ôªÔ∏è Old ground material disposed');
      }

      // Step 3: Create new ground mesh with new size
      ground = new THREE.Mesh(
        new THREE.CylinderGeometry(newSize, newSize, 0.4, 48),
        new THREE.MeshStandardMaterial({ color: 0x101a24, roughness: 0.95 })
      );
      ground.position.y = -2.2;
      ground.receiveShadow = true;

      // Step 4: Add new ground to scene
      scene.add(ground);

      // Step 5: Update state and input field
      state.groundPlaneSize = newSize;
      document.getElementById('groundPlaneSize').value = newSize;

      console.log(`‚úÖ Ground plane recreated | Size: ${newSize} | Vertices: ${ground.geometry.attributes.position.count}`);
      updateStatus(`Ground size: ${newSize}m`);
      logAIIteration('groundResize', { size: newSize });
    };

    // ENV-004: Ground Material Presets
    window.applyGroundMaterial = (material) => {
      const materials = {
        grass: {
          color: 0x2d5016,
          roughness: 0.95,
          metalness: 0,
          name: 'Grass',
          emoji: 'üåø'
        },
        concrete: {
          color: 0x555555,
          roughness: 0.8,
          metalness: 0,
          name: 'Concrete',
          emoji: 'üèóÔ∏è'
        },
        sand: {
          color: 0xc2a569,
          roughness: 0.9,
          metalness: 0,
          name: 'Sand',
          emoji: 'üèñÔ∏è'
        },
        water: {
          color: 0x1e90ff,
          roughness: 0.1,
          metalness: 0.3,
          name: 'Water',
          emoji: 'üíß'
        },
        metal: {
          color: 0x888888,
          roughness: 0.3,
          metalness: 0.9,
          name: 'Metal',
          emoji: '‚öôÔ∏è'
        }
      };

      const mat = materials[material];
      if (!mat) {
        console.error(`‚ùå Invalid material: ${material}`);
        return;
      }

      console.log(`üé® Applying ground material: ${mat.emoji} ${mat.name}`);
      console.log(`   Color: #${mat.color.toString(16).padStart(6, '0')} | Roughness: ${mat.roughness} | Metalness: ${mat.metalness}`);

      // Update ground material properties
      window.ground.material.color.setHex(mat.color);
      window.ground.material.roughness = mat.roughness;
      window.ground.material.metalness = mat.metalness;
      window.ground.material.needsUpdate = true;

      // Visual feedback: add glow effect to active button
      document.querySelectorAll('.material-preset-btn').forEach(btn => {
        if (btn.getAttribute('data-material') === material) {
          btn.style.transform = 'scale(1.05)';
          btn.style.boxShadow = '0 0 12px rgba(59, 130, 246, 0.6)';
        } else {
          btn.style.transform = 'scale(1)';
          btn.style.boxShadow = 'none';
        }
      });

      console.log(`‚úÖ Material applied: ${mat.emoji} ${mat.name}`);
      updateStatus(`Ground material: ${mat.name}`);
      logAIIteration('materialChange', { material, color: mat.color, roughness: mat.roughness, metalness: mat.metalness });
    };

    // ENV-005: Camera Position Presets with Smooth Transitions
    let cameraTransition = {
      active: false,
      startPos: new THREE.Vector3(),
      targetPos: new THREE.Vector3(),
      frame: 0,
      totalFrames: 60 // 1 second at 60fps
    };

    window.setCameraView = (view) => {
      const views = {
        top: { x: 0, y: 10, z: 0, name: 'Top', emoji: '‚¨ÜÔ∏è' },
        front: { x: 0, y: 0, z: 10, name: 'Front', emoji: 'üëÅÔ∏è' },
        side: { x: 10, y: 0, z: 0, name: 'Side', emoji: '‚û°Ô∏è' },
        isometric: { x: 7, y: 7, z: 7, name: 'Isometric', emoji: 'üìê' }
      };

      const targetView = views[view];
      if (!targetView) {
        console.error(`‚ùå Invalid camera view: ${view}`);
        return;
      }

      console.log(`üìπ Setting camera view: ${targetView.emoji} ${targetView.name}`);
      console.log(`   Target position: (${targetView.x}, ${targetView.y}, ${targetView.z})`);

      // Store start and target positions
      cameraTransition.startPos.copy(camera.position);
      cameraTransition.targetPos.set(targetView.x, targetView.y, targetView.z);
      cameraTransition.frame = 0;
      cameraTransition.active = true;

      // Visual feedback: highlight active button
      document.querySelectorAll('.camera-preset-btn').forEach(btn => {
        if (btn.getAttribute('data-view') === view) {
          btn.style.background = '#2563eb';
          btn.style.borderColor = '#3b82f6';
        } else {
          btn.style.background = '#1e2836';
          btn.style.borderColor = '#2e3b4e';
        }
      });

      updateStatus(`Camera: ${targetView.name} view`);
      logAIIteration('cameraView', { view, position: targetView });
    };

    // Update camera transition in animate loop (will be added in next step)
    function updateCameraTransition() {
      if (!cameraTransition.active) return;

      cameraTransition.frame++;
      const t = cameraTransition.frame / cameraTransition.totalFrames;

      // Smooth easing function (ease-in-out)
      const easeT = t < 0.5 
        ? 2 * t * t 
        : -1 + (4 - 2 * t) * t;

      // Lerp camera position
      camera.position.lerpVectors(
        cameraTransition.startPos,
        cameraTransition.targetPos,
        easeT
      );

      // Update orbit controls target to look at origin
      controls.target.set(0, 0, 0);
      controls.update();

      // End transition
      if (cameraTransition.frame >= cameraTransition.totalFrames) {
        cameraTransition.active = false;
        console.log(`‚úÖ Camera transition complete | Final position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})`);
      }
    }

    // CAM-002: Camera Movement Function (Flight Controls)
    function updateCameraMovement() {
      // CAM-003: Update flight mode indicator visibility
      const indicator = document.getElementById('flightModeIndicator');
      const speedDisplay = document.getElementById('flightSpeedDisplay');
      
      if (!flyMode) {
        indicator.classList.remove('visible');
        return;
      }

      // Show indicator when in flight mode
      indicator.classList.add('visible');

      // Base movement speed
      const baseSpeed = 0.1;
      let speedMultiplier = 1;

      // Apply speed modifiers
      if (keyState.shift) speedMultiplier = 3;   // Fast mode (Shift)
      if (keyState.ctrl) speedMultiplier = 0.25; // Slow mode (Ctrl)

      const speed = baseSpeed * speedMultiplier;

      // CAM-003: Update speed display with color coding
      speedDisplay.textContent = `Speed: ${(speed / baseSpeed).toFixed(2)}x`;
      speedDisplay.className = 'speed-display';
      if (speedMultiplier > 1) {
        speedDisplay.classList.add('speed-fast');
      } else if (speedMultiplier < 1) {
        speedDisplay.classList.add('speed-slow');
      }

      // Calculate direction vectors from camera orientation
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();
      const up = new THREE.Vector3(0, 1, 0); // World up

      // Get camera's forward direction (negative Z in camera space)
      camera.getWorldDirection(forward);
      
      // Get camera's right direction (cross product of up and forward)
      right.crossVectors(forward, up).normalize();

      // Movement vectors
      const movement = new THREE.Vector3();

      // WASD movement (horizontal plane + forward/back)
      if (keyState.w) movement.add(forward.multiplyScalar(speed));
      if (keyState.s) movement.add(forward.multiplyScalar(-speed));
      if (keyState.a) movement.add(right.multiplyScalar(-speed));
      if (keyState.d) movement.add(right.multiplyScalar(speed));

      // QE vertical movement (world up/down)
      if (keyState.q) movement.y -= speed; // Q = down
      if (keyState.e) movement.y += speed; // E = up

      // Apply movement to camera
      camera.position.add(movement);

      // Disable OrbitControls while in flight mode
      controls.enabled = !flyMode;
    }

    window.applySceneTheme = (theme) => {
      state.sceneTheme = theme;
      
      switch(theme) {
        case 'studio':
          scene.background = new THREE.Color(0x0a0e14);
          applyFog(0); // No fog in studio
          applyLightingRig('three-point');
          break;
        case 'outdoor':
          scene.background = new THREE.Color(0x87ceeb);
          state.fogDensity = 0.02;
          applyFog(0.02, false); // Linear fog for outdoor
          applyLightingRig('natural');
          break;
        case 'sunset':
          scene.background = new THREE.Color(0xff6b35);
          state.fogDensity = 0.015;
          applyFog(0.015, true); // Exponential fog for sunset
          applyLightingRig('dramatic');
          break;
        case 'night':
          scene.background = new THREE.Color(0x0a0a1a);
          state.fogDensity = 0.02;
          applyFog(0.02, true); // Exponential fog for night
          dirLight.intensity = 0.8;
          dirLight.color.setHex(0x6688ff);
          break;
        case 'underwater':
          scene.background = new THREE.Color(0x004466);
          state.fogDensity = 0.025;
          applyFog(0.025, true); // Exponential fog for underwater
          dirLight.intensity = 1.0;
          dirLight.color.setHex(0x44aaff);
          break;
      }
      
      // Sync slider with theme fog
      document.getElementById('fogDensity').value = state.fogDensity;
      
      updateStatus(`Theme: ${theme}`);
      logAIIteration('themeChange', { theme });
    };

    // Wire lighting and theme controls
    document.getElementById('lightingRig').addEventListener('change', (e) => {
      applyLightingRig(e.target.value);
    });

    document.getElementById('sceneTheme').addEventListener('change', (e) => {
      applySceneTheme(e.target.value);
    });

    // ==================== AI PATTERN TRACING SYSTEM ====================
    
    const aiIterationLog = [];
    const MAX_LOG_ENTRIES = 1000;

    function logAIIteration(toolType, data) {
      const entry = {
        timestamp: Date.now(),
        toolType,
        data,
        vertexSnapshot: null, // Could store partial snapshot for pattern analysis
        brushState: {
          shape: state.brushShape,
          radius: state.brushRadius,
          strength: state.brushStrength,
          hardness: state.brushHardness
        },
        materialState: {
          preset: state.materialPreset,
          displacement: state.displacementDepth,
          detail: state.detailLevel
        }
      };
      
      aiIterationLog.push(entry);
      
      // Keep log size manageable
      if (aiIterationLog.length > MAX_LOG_ENTRIES) {
        aiIterationLog.shift();
      }
      
      // Analyze patterns every 10 iterations
      if (aiIterationLog.length % 10 === 0) {
        analyzePatterns();
      }
    }

    function analyzePatterns() {
      // Pattern analysis for AI learning
      const recentEntries = aiIterationLog.slice(-50);
      const toolUsage = {};
      const avgBrushRadius = recentEntries.reduce((sum, e) => sum + (e.brushState?.radius || 0), 0) / recentEntries.length;
      const avgStrength = recentEntries.reduce((sum, e) => sum + (e.brushState?.strength || 0), 0) / recentEntries.length;
      
      recentEntries.forEach(entry => {
        toolUsage[entry.toolType] = (toolUsage[entry.toolType] || 0) + 1;
      });
      
      const patterns = {
        toolUsageFrequency: toolUsage,
        averageBrushRadius: avgBrushRadius,
        averageStrength: avgStrength,
        mostUsedTool: Object.entries(toolUsage).sort((a, b) => b[1] - a[1])[0]?.[0],
        sessionLength: aiIterationLog.length
      };
      
      // Store patterns for AI to reference
      window.aiPatterns = patterns;
      
      console.log('AI Pattern Analysis:', patterns);
    }

    window.getAIIterationLog = () => {
      return {
        log: aiIterationLog,
        patterns: window.aiPatterns || {}
      };
    };

    // ==================== RADIAL TRANSFORM MENU SYSTEM ====================
    
    const radialMenu = document.getElementById('radialMenu');
    let currentTransformTool = null;

    canvas.addEventListener('contextmenu', (event) => {
      event.preventDefault();
      
      // Position radial menu at cursor
      radialMenu.style.left = `${event.clientX}px`;
      radialMenu.style.top = `${event.clientY}px`;
      radialMenu.classList.add('active');
      
      updateStatus('Transform menu open - select a tool');
    });

    // Close radial menu on click outside or escape
    document.addEventListener('click', (event) => {
      if (!radialMenu.contains(event.target) && radialMenu.classList.contains('active')) {
        radialMenu.classList.remove('active');
      }
    });

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && radialMenu.classList.contains('active')) {
        radialMenu.classList.remove('active');
      }
    });

    // Radial menu item selection
    document.querySelectorAll('.radial-menu-item').forEach(item => {
      item.addEventListener('click', () => {
        const transform = item.getAttribute('data-transform');
        currentTransformTool = transform;
        radialMenu.classList.remove('active');
        applyTransformTool(transform);
      });
    });

    function applyTransformTool(tool) {
      pushUndo();
      const posAttr = sculptGeometry.attributes.position;
      const activeLayer = state.layers[state.activeLayer];
      
      switch(tool) {
        case 'move':
          updateStatus('Move tool active - use axis handles');
          window.setTransformMode('translate');
          break;
          
        case 'rotate':
          updateStatus('Rotate applied');
          for (let i = 0; i < vertexCount; i++) {
            const idx = i * 3;
            const x = posAttr.array[idx];
            const z = posAttr.array[idx + 2];
            const angle = Math.PI / 12; // 15 degrees
            activeLayer[idx]     += x * (Math.cos(angle) - 1) - z * Math.sin(angle);
            activeLayer[idx + 2] += x * Math.sin(angle) + z * (Math.cos(angle) - 1);
          }
          recomposeGeometry();
          break;
          
        case 'scale':
          updateStatus('Scale applied - uniform grow');
          for (let i = 0; i < vertexCount; i++) {
            const idx = i * 3;
            const scaleFactor = 0.05;
            activeLayer[idx]     += posAttr.array[idx] * scaleFactor;
            activeLayer[idx + 1] += posAttr.array[idx + 1] * scaleFactor;
            activeLayer[idx + 2] += posAttr.array[idx + 2] * scaleFactor;
          }
          recomposeGeometry();
          break;
          
        case 'stretch':
          updateStatus('Stretch applied - elongate Y');
          for (let i = 0; i < vertexCount; i++) {
            const idx = i * 3;
            activeLayer[idx + 1] += posAttr.array[idx + 1] * 0.1;
          }
          recomposeGeometry();
          break;
          
        case 'sharpen':
          updateStatus('Sharpen applied - enhance edges');
          for (let i = 0; i < vertexCount; i++) {
            const idx = i * 3;
            const x = posAttr.array[idx];
            const y = posAttr.array[idx + 1];
            const z = posAttr.array[idx + 2];
            const radial = Math.sqrt(x * x + z * z);
            
            // Move vertices away from center, creating sharper angles
            const sharpness = 0.02;
            activeLayer[idx]     += (x / (radial + 0.1)) * sharpness * Math.abs(Math.sin(y * 8));
            activeLayer[idx + 2] += (z / (radial + 0.1)) * sharpness * Math.abs(Math.sin(y * 8));
          }
          recomposeGeometry();
          break;
          
        case 'smooth':
          updateStatus('Smooth applied - softening edges');
          // Simple Laplacian smoothing
          const tempLayer = new Float32Array(activeLayer.length);
          for (let i = 0; i < vertexCount; i++) {
            const idx = i * 3;
            // Average with neighboring vertices (simplified)
            const neighbors = 4;
            let sumX = 0, sumY = 0, sumZ = 0;
            for (let n = -neighbors; n <= neighbors; n++) {
              const nIdx = ((i + n + vertexCount) % vertexCount) * 3;
              sumX += activeLayer[nIdx];
              sumY += activeLayer[nIdx + 1];
              sumZ += activeLayer[nIdx + 2];
            }
            const count = neighbors * 2 + 1;
            tempLayer[idx]     = sumX / count;
            tempLayer[idx + 1] = sumY / count;
            tempLayer[idx + 2] = sumZ / count;
          }
          activeLayer.set(tempLayer);
          recomposeGeometry();
          break;
          
        case 'extend':
          updateStatus('Extend applied - push outward');
          for (let i = 0; i < vertexCount; i++) {
            const idx = i * 3;
            const x = posAttr.array[idx];
            const z = posAttr.array[idx + 2];
            const radial = Math.sqrt(x * x + z * z);
            const extend = 0.05;
            activeLayer[idx]     += (x / (radial + 0.1)) * extend;
            activeLayer[idx + 2] += (z / (radial + 0.1)) * extend;
          }
          recomposeGeometry();
          break;
          
        case 'shrink':
          updateStatus('Shrink applied - pull inward');
          for (let i = 0; i < vertexCount; i++) {
            const idx = i * 3;
            const x = posAttr.array[idx];
            const z = posAttr.array[idx + 2];
            const radial = Math.sqrt(x * x + z * z);
            const shrink = -0.05;
            activeLayer[idx]     += (x / (radial + 0.1)) * shrink;
            activeLayer[idx + 2] += (z / (radial + 0.1)) * shrink;
          }
          recomposeGeometry();
          break;
      }
      
      logAIIteration(tool, { vertexCount, layerIndex: state.activeLayer });
    }

    // ==================== INTERACTIVE AXIS GIZMO SYSTEM ====================
    
    // Create interactive axis handles (arrows for dragging)
    let axisArrows = null;
    let isDraggingAxis = false;
    let dragStartPoint = null;
    let dragAxis = null;

    function createAxisArrows() {
      const arrowGroup = new THREE.Group();
      
      const arrowLength = 1.5;
      const arrowColor = {
        x: 0xef4444,
        y: 0x22c55e,
        z: 0x3b82f6
      };
      
      // X axis arrow
      const xArrow = new THREE.ArrowHelper(
        new THREE.Vector3(1, 0, 0),
        new THREE.Vector3(0, 0, 0),
        arrowLength,
        arrowColor.x,
        0.3,
        0.2
      );
      xArrow.userData = { axis: 'x' };
      arrowGroup.add(xArrow);
      
      // Y axis arrow
      const yArrow = new THREE.ArrowHelper(
        new THREE.Vector3(0, 1, 0),
        new THREE.Vector3(0, 0, 0),
        arrowLength,
        arrowColor.y,
        0.3,
        0.2
      );
      yArrow.userData = { axis: 'y' };
      arrowGroup.add(yArrow);
      
      // Z axis arrow
      const zArrow = new THREE.ArrowHelper(
        new THREE.Vector3(0, 0, 1),
        new THREE.Vector3(0, 0, 0),
        arrowLength,
        arrowColor.z,
        0.3,
        0.2
      );
      zArrow.userData = { axis: 'z' };
      arrowGroup.add(zArrow);
      
      arrowGroup.visible = false;
      return arrowGroup;
    }

    axisArrows = createAxisArrows();
    scene.add(axisArrows);

    // Update arrow position to follow object
    function updateAxisArrows() {
      if (transformMode === 'translate') {
        axisArrows.position.copy(sculptMesh.position);
        axisArrows.visible = true;
      } else {
        axisArrows.visible = false;
      }
    }

    // Axis dragging logic
    canvas.addEventListener('pointerdown', (event) => {
      if (transformMode === 'translate' && event.button === 0) {
        const rect = canvas.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(pointer, camera);
        
        // Check if clicking on axis arrows
        const arrowIntersects = [];
        axisArrows.children.forEach(arrow => {
          // Create invisible larger cone for easier clicking
          const hits = raycaster.intersectObject(arrow, true);
          if (hits.length > 0) {
            arrowIntersects.push({ arrow, distance: hits[0].distance });
          }
        });
        
        if (arrowIntersects.length > 0) {
          // Sort by distance and pick closest
          arrowIntersects.sort((a, b) => a.distance - b.distance);
          const closest = arrowIntersects[0].arrow;
          dragAxis = closest.userData.axis;
          isDraggingAxis = true;
          dragStartPoint = sculptMesh.position.clone();
          controls.enabled = false;
          updateStatus(`Dragging ${dragAxis.toUpperCase()} axis`);
        }
      }
    });

    canvas.addEventListener('pointermove', (event) => {
      if (isDraggingAxis && dragAxis) {
        const rect = canvas.getBoundingClientRect();
        const moveX = (event.clientX - rect.left) / rect.width;
        const moveY = (event.clientY - rect.top) / rect.height;
        
        const sensitivity = 5.0;
        
        if (dragAxis === 'x') {
          sculptMesh.position.x = dragStartPoint.x + (moveX - 0.5) * sensitivity;
        } else if (dragAxis === 'y') {
          sculptMesh.position.y = dragStartPoint.y - (moveY - 0.5) * sensitivity;
        } else if (dragAxis === 'z') {
          sculptMesh.position.z = dragStartPoint.z + (moveX - 0.5) * sensitivity;
        }
        
        syncPositionInputs();
        updateAxisArrows();
      }
    });

    canvas.addEventListener('pointerup', () => {
      if (isDraggingAxis) {
        isDraggingAxis = false;
        dragAxis = null;
        dragStartPoint = null;
        updateStatus('Axis drag complete');
      }
    });

    // ==================== END NEW SYSTEMS ====================

    // Initialize UI
    window.setTransformMode('orbit');
    updateLayerUI();

    // ==================== BINDING SYSTEM FUNCTIONS ====================
    
    // Variables already declared earlier in the file
    // bindingMode, bindingType, activeBindings
    
    window.startBinding = function() {
      bindingMode = true;
      updateStatus('üîó BINDING MODE: Select first object...');
      console.log('‚úÖ Binding mode activated');
    };
    
    window.setBindingType = function(type) {
      bindingType = type;
      const names = { rigid: 'Rigid', elastic: 'Elastic', chain: 'Chain', weld: 'Weld' };
      updateStatus(`Binding type set to: ${names[type]}`);
      console.log(`‚úÖ Binding type: ${type}`);
    };
    
    window.breakAllBindings = function() {
      const count = activeBindings.length;
      activeBindings.forEach(binding => {
        if (binding.visual) scene.remove(binding.visual);
      });
      activeBindings = [];
      document.getElementById('bindingCount').textContent = '0';
      updateStatus(`‚ùå Broke ${count} bindings`);
      console.log(`‚úÖ Cleared ${count} bindings`);
    };
    
    // Note: updateBindingVisuals() already defined at line 1845
    
    // Sync slider with number input
    document.getElementById('bindingStrength').addEventListener('input', (e) => {
      document.getElementById('bindingStrengthValue').value = e.target.value;
    });
    document.getElementById('bindingStrengthValue').addEventListener('input', (e) => {
      document.getElementById('bindingStrength').value = e.target.value;
    });

    // ==================== FRAGMENTATION SYSTEM FUNCTIONS ====================
    
    // Variables already declared earlier in the file
    // fragmentationMode, fragments
    let fragmentAlgorithm = 'voronoi';
    
    window.startFragmentation = function() {
      fragmentationMode = true;
      updateStatus('üí• FRAGMENTATION MODE: Select object to fragment...');
      console.log('‚úÖ Fragmentation mode activated');
    };
    
    window.setFragmentAlgorithm = function(algorithm) {
      fragmentAlgorithm = algorithm;
      const names = { voronoi: 'Voronoi', voxel: 'Voxel Grid', radial: 'Radial Shatter', slice: 'Planar Slice' };
      updateStatus(`Fragment algorithm: ${names[algorithm]}`);
      console.log(`‚úÖ Fragment algorithm: ${algorithm}`);
    };
    
    window.applyFragmentation = function() {
      if (!selectedObject) {
        updateStatus('‚ö†Ô∏è Select an object to fragment first');
        return;
      }
      
      const count = parseInt(document.getElementById('fragmentCount').value);
      const velocity = parseFloat(document.getElementById('scatterVelocity').value);
      
      updateStatus(`üí• Fragmenting into ${count} pieces with algorithm: ${fragmentAlgorithm}`);
      console.log(`‚úÖ Applying fragmentation: ${fragmentAlgorithm}, count: ${count}, velocity: ${velocity}`);
      
      // TODO: Implement actual fragmentation algorithm
      // For now, show success message
      setTimeout(() => {
        updateStatus(`‚ú® Created ${count} fragments!`);
      }, 500);
    };
    
    // Note: updateFragments() already defined at line 2530
    
    // Sync sliders with number inputs
    document.getElementById('fragmentCount').addEventListener('input', (e) => {
      document.getElementById('fragmentCountValue').value = e.target.value;
    });
    document.getElementById('fragmentCountValue').addEventListener('input', (e) => {
      document.getElementById('fragmentCount').value = e.target.value;
    });
    document.getElementById('scatterVelocity').addEventListener('input', (e) => {
      document.getElementById('scatterVelocityValue').value = e.target.value;
    });
    document.getElementById('scatterVelocityValue').addEventListener('input', (e) => {
      document.getElementById('scatterVelocity').value = e.target.value;
    });

    // ==================== PARTICLE SYSTEM FUNCTIONS ====================
    
    // Variables already declared earlier in the file
    // currentParticleType, currentEmitterType
    let particlesEnabled = true;
    let particles = [];
    
    window.emitParticles = function() {
      const rate = parseInt(document.getElementById('emissionRate').value);
      const size = parseFloat(document.getElementById('particleSize').value);
      const lifetime = parseFloat(document.getElementById('particleLifetime').value);
      
      updateStatus(`‚ú® Emitting ${currentParticleType} particles (rate: ${rate}/s, size: ${size}, lifetime: ${lifetime}s)`);
      console.log(`‚úÖ Particle emission: type=${currentParticleType}, emitter=${currentEmitterType}`);
      
      // TODO: Implement actual particle emission with GPU system
    };
    
    window.setParticleType = function(type) {
      currentParticleType = type;
      const names = { smoke: 'üí® Smoke', sparks: '‚ö° Sparks', embers: 'üî• Embers', debris: 'ü™® Debris', fire: 'üî• Fire' };
      updateStatus(`Particle type: ${names[type]}`);
      console.log(`‚úÖ Particle type: ${type}`);
    };
    
    window.toggleParticles = function() {
      particlesEnabled = !particlesEnabled;
      updateStatus(particlesEnabled ? '‚ñ∂Ô∏è Particles enabled' : '‚è∏Ô∏è Particles paused');
      console.log(`‚úÖ Particles ${particlesEnabled ? 'enabled' : 'disabled'}`);
    };
    
    window.clearParticles = function() {
      particles.forEach(p => {
        if (p.mesh) scene.remove(p.mesh);
      });
      particles = [];
      updateStatus('üóëÔ∏è Cleared all particles');
      console.log('‚úÖ Particles cleared');
    };
    
    window.setEmitterType = function(type) {
      currentEmitterType = type;
      const names = { point: 'üìç Point', area: '‚¨ú Area', trail: '„Ä∞Ô∏è Trail' };
      updateStatus(`Emitter type: ${names[type]}`);
      console.log(`‚úÖ Emitter type: ${type}`);
    };
    
    function updateParticles(deltaTime) {
      // Update particle simulation (called each frame)
      if (!particlesEnabled) return;
      
      particles.forEach((particle, index) => {
        if (particle.lifetime <= 0) {
          if (particle.mesh) scene.remove(particle.mesh);
          particles.splice(index, 1);
          return;
        }
        
        particle.lifetime -= deltaTime;
        
        if (particle.mesh) {
          // Simple gravity + velocity
          particle.velocity.y -= 9.8 * deltaTime;
          particle.mesh.position.add(particle.velocity.clone().multiplyScalar(deltaTime));
          
          // Fade out
          const alpha = particle.lifetime / particle.maxLifetime;
          particle.mesh.material.opacity = alpha;
        }
      });
    }
    
    // Sync sliders with number inputs
    document.getElementById('emissionRate').addEventListener('input', (e) => {
      document.getElementById('emissionRateValue').value = e.target.value;
    });
    document.getElementById('emissionRateValue').addEventListener('input', (e) => {
      document.getElementById('emissionRate').value = e.target.value;
    });
    document.getElementById('particleSize').addEventListener('input', (e) => {
      document.getElementById('particleSizeValue').value = e.target.value;
    });
    document.getElementById('particleSizeValue').addEventListener('input', (e) => {
      document.getElementById('particleSize').value = e.target.value;
    });
    document.getElementById('particleLifetime').addEventListener('input', (e) => {
      document.getElementById('particleLifetimeValue').value = e.target.value;
    });
    document.getElementById('particleLifetimeValue').addEventListener('input', (e) => {
      document.getElementById('particleLifetime').value = e.target.value;
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MOBILE TOUCH CONTROLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let touchState = {
      active: false,
      touches: [],
      initialDistance: 0,
      initialRotation: 0,
      lastTouchPos: { x: 0, y: 0 },
      pinching: false,
      rotating: false,
      sculpting: false,
      holdTimer: null,
      virtualJoystickActive: false
    };
    
    // Virtual joystick for WASD movement on mobile
    let virtualJoystick = {
      active: false,
      baseX: 0,
      baseY: 0,
      stickX: 0,
      stickY: 0,
      touchId: null
    };
    
    // Create virtual joystick UI element
    const joystickContainer = document.createElement('div');
    joystickContainer.id = 'virtual-joystick';
    joystickContainer.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 120px;
      height: 120px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 215, 0, 0.5);
      border-radius: 50%;
      display: none;
      z-index: 1000;
      touch-action: none;
    `;
    
    const joystickStick = document.createElement('div');
    joystickStick.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      width: 50px;
      height: 50px;
      background: rgba(255, 215, 0, 0.7);
      border: 2px solid #ffd700;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    `;
    joystickContainer.appendChild(joystickStick);
    document.body.appendChild(joystickContainer);
    
    // Detect if device is mobile/tablet
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    if (isMobile || isTouch) {
      console.log('üì± Mobile device detected - Touch controls enabled');
      updateStatus('üì± Touch controls active: 1 finger = sculpt, 2 fingers = rotate/zoom');
      
      // Show virtual joystick hint
      joystickContainer.style.display = 'block';
      joystickContainer.style.opacity = '0.3'; // Dim when not in use
    }
    
    // Touch start handler
    renderer.domElement.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchState.active = true;
      touchState.touches = Array.from(e.touches);
      
      // Single touch - sculpting or camera orbit
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        touchState.lastTouchPos = { x: touch.clientX, y: touch.clientY };
        touchState.sculpting = true;
        
        // Check if touch is in viewport (not on UI)
        const rect = renderer.domElement.getBoundingClientRect();
        if (touch.clientX > rect.left && touch.clientX < rect.right &&
            touch.clientY > rect.top && touch.clientY < rect.bottom) {
          
          // Raycast for sculpting
          mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
          
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(sculptMesh);
          
          if (intersects.length > 0 && currentBrush && brushSize > 0) {
            isMouseDown = true;
            applySculptBrush(intersects[0]);
          }
        }
        
        // Touch and hold for context menu (after 500ms)
        touchState.holdTimer = setTimeout(() => {
          // Show context menu (future implementation)
          updateStatus('üìã Context menu (coming soon)');
          navigator.vibrate && navigator.vibrate(50); // Haptic feedback
        }, 500);
        
      }
      
      // Two fingers - pinch to zoom and rotate
      else if (e.touches.length === 2) {
        touchState.pinching = true;
        touchState.sculpting = false;
        clearTimeout(touchState.holdTimer);
        
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        
        // Calculate initial distance for pinch zoom
        const dx = touch2.clientX - touch1.clientX;
        const dy = touch2.clientY - touch1.clientY;
        touchState.initialDistance = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate initial rotation angle
        touchState.initialRotation = Math.atan2(dy, dx);
        
        updateStatus('ü§è Pinch to zoom, twist to rotate');
      }
      
      // Three fingers - pan camera
      else if (e.touches.length === 3) {
        touchState.sculpting = false;
        clearTimeout(touchState.holdTimer);
        updateStatus('‚úã Three fingers: Pan camera');
      }
    }, { passive: false });
    
    // Touch move handler
    renderer.domElement.addEventListener('touchmove', (e) => {
      e.preventDefault();
      
      if (!touchState.active) return;
      
      // Single touch - sculpting or orbit
      if (e.touches.length === 1 && touchState.sculpting) {
        const touch = e.touches[0];
        const deltaX = touch.clientX - touchState.lastTouchPos.x;
        const deltaY = touch.clientY - touchState.lastTouchPos.y;
        
        // If moving slowly, treat as sculpting
        const movementSpeed = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (movementSpeed < 10 && currentBrush) {
          // Continue sculpting
          const rect = renderer.domElement.getBoundingClientRect();
          mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
          
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(sculptMesh);
          
          if (intersects.length > 0 && isMouseDown) {
            applySculptBrush(intersects[0]);
          }
        } else {
          // Fast movement = camera orbit
          controls.enabled = true;
          // OrbitControls will handle it automatically
        }
        
        touchState.lastTouchPos = { x: touch.clientX, y: touch.clientY };
        clearTimeout(touchState.holdTimer); // Cancel hold if moving
      }
      
      // Two fingers - pinch zoom and twist rotate
      else if (e.touches.length === 2 && touchState.pinching) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        
        // Calculate current distance
        const dx = touch2.clientX - touch1.clientX;
        const dy = touch2.clientY - touch1.clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Pinch zoom
        const zoomDelta = (distance - touchState.initialDistance) * 0.01;
        camera.position.multiplyScalar(1 - zoomDelta);
        camera.position.clampLength(5, 100); // Keep camera in bounds
        
        touchState.initialDistance = distance;
        
        // Twist rotate
        const angle = Math.atan2(dy, dx);
        const rotationDelta = angle - touchState.initialRotation;
        
        if (Math.abs(rotationDelta) > 0.1) {
          // Rotate camera around Y axis
          const pivot = new THREE.Vector3(0, 0, 0);
          const offset = camera.position.clone().sub(pivot);
          offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationDelta * 0.5);
          camera.position.copy(pivot).add(offset);
          camera.lookAt(pivot);
          
          touchState.initialRotation = angle;
        }
      }
      
      // Three fingers - pan camera
      else if (e.touches.length === 3) {
        const touch = e.touches[0];
        const deltaX = (touch.clientX - touchState.lastTouchPos.x) * 0.01;
        const deltaY = (touch.clientY - touchState.lastTouchPos.y) * 0.01;
        
        controls.target.x += deltaX;
        controls.target.z += deltaY;
        
        touchState.lastTouchPos = { x: touch.clientX, y: touch.clientY };
      }
      
    }, { passive: false });
    
    // Touch end handler
    renderer.domElement.addEventListener('touchend', (e) => {
      e.preventDefault();
      
      clearTimeout(touchState.holdTimer);
      
      if (e.touches.length === 0) {
        touchState.active = false;
        touchState.sculpting = false;
        touchState.pinching = false;
        isMouseDown = false;
      } else if (e.touches.length === 1) {
        // Went from 2+ touches to 1 touch
        touchState.pinching = false;
        const touch = e.touches[0];
        touchState.lastTouchPos = { x: touch.clientX, y: touch.clientY };
      }
    }, { passive: false });
    
    // Virtual joystick touch handlers (for WASD movement on mobile)
    joystickContainer.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      if (e.touches.length > 0) {
        virtualJoystick.active = true;
        virtualJoystick.touchId = e.touches[0].identifier;
        
        const rect = joystickContainer.getBoundingClientRect();
        virtualJoystick.baseX = rect.left + rect.width / 2;
        virtualJoystick.baseY = rect.top + rect.height / 2;
        
        joystickContainer.style.opacity = '1'; // Full opacity when active
        updateStatus('üïπÔ∏è Virtual joystick active');
      }
    }, { passive: false });
    
    joystickContainer.addEventListener('touchmove', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      if (!virtualJoystick.active) return;
      
      const touch = Array.from(e.touches).find(t => t.identifier === virtualJoystick.touchId);
      if (!touch) return;
      
      const rect = joystickContainer.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // Calculate stick position (clamped to circle)
      let deltaX = touch.clientX - centerX;
      let deltaY = touch.clientY - centerY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const maxDistance = 35; // Max stick movement
      
      if (distance > maxDistance) {
        const angle = Math.atan2(deltaY, deltaX);
        deltaX = Math.cos(angle) * maxDistance;
        deltaY = Math.sin(angle) * maxDistance;
      }
      
      virtualJoystick.stickX = deltaX;
      virtualJoystick.stickY = deltaY;
      
      // Update visual stick position
      joystickStick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
      
      // Convert to WASD input (if possessing object)
      if (possessedMesh) {
        const moveX = deltaX / maxDistance; // -1 to 1
        const moveZ = deltaY / maxDistance; // -1 to 1
        
        // Update WASD state based on joystick
        wasd.a = moveX < -0.3;
        wasd.d = moveX > 0.3;
        wasd.w = moveZ < -0.3;
        wasd.s = moveZ > 0.3;
      }
    }, { passive: false });
    
    joystickContainer.addEventListener('touchend', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      virtualJoystick.active = false;
      virtualJoystick.stickX = 0;
      virtualJoystick.stickY = 0;
      
      // Reset stick visual position
      joystickStick.style.transform = 'translate(-50%, -50%)';
      joystickContainer.style.opacity = '0.3'; // Dim when inactive
      
      // Clear WASD state
      wasd.w = false;
      wasd.a = false;
      wasd.s = false;
      wasd.d = false;
      
      updateStatus('üïπÔ∏è Virtual joystick released');
    }, { passive: false });
    
    // Prevent default touch behaviors on the canvas
    renderer.domElement.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      touchState.active = false;
      touchState.sculpting = false;
      touchState.pinching = false;
      isMouseDown = false;
      clearTimeout(touchState.holdTimer);
    }, { passive: false });
    
    // Double-tap to reset camera
    let lastTapTime = 0;
    renderer.domElement.addEventListener('touchend', (e) => {
      const currentTime = Date.now();
      const tapGap = currentTime - lastTapTime;
      
      if (tapGap < 300 && tapGap > 0 && e.touches.length === 0) {
        // Double-tap detected!
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);
        controls.target.set(0, 0, 0);
        updateStatus('üì∑ Camera reset to default view');
        navigator.vibrate && navigator.vibrate([50, 50, 50]); // Triple vibrate
      }
      
      lastTapTime = currentTime;
    });
    
    // Responsive UI adjustments for mobile
    if (isMobile) {
      // Make panels collapsible by default on mobile
      document.querySelectorAll('.panel').forEach(panel => {
        panel.style.maxHeight = '40px'; // Collapsed
        
        const header = panel.querySelector('h3');
        if (header) {
          header.style.cursor = 'pointer';
          header.style.userSelect = 'none';
          
          header.addEventListener('click', () => {
            if (panel.style.maxHeight === '40px') {
              panel.style.maxHeight = '500px'; // Expanded
            } else {
              panel.style.maxHeight = '40px'; // Collapsed
            }
          });
        }
      });
      
      // Increase button sizes for touch targets
      document.querySelectorAll('button').forEach(btn => {
        btn.style.minHeight = '44px'; // iOS touch target minimum
        btn.style.fontSize = '14px';
      });
      
      // Make sliders easier to use on mobile
      document.querySelectorAll('input[type="range"]').forEach(slider => {
        slider.style.height = '30px';
      });
    }
    
    console.log('‚úÖ Mobile touch controls initialized');

    // Animation loop
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ANIMATION LOOP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let lastTime = performance.now();
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Calculate delta time
      const currentTime = performance.now();
      const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;
      
      // PHYS-001: Update physics simulation
      updatePhysics(deltaTime);
      
      // BIND-001: Update binding visual tethers
      updateBindingVisuals();
      
      // FRAG-001: Update fragment physics
      updateFragments();
      
      // VFX-001: Update particle systems
      updateParticles(deltaTime);
      
      // OBJECT-001: Update possessed object movement (WASD controls)
      updatePossessedObject();
      
      controls.update();
      updateAxisArrows(); // Update interactive axis gizmo
      updateCameraTransition(); // ENV-005: Smooth camera transitions
      updateCameraMovement(); // CAM-002: Flight controls
      
      // Update stats
      const verts = sculptGeometry.attributes.position.count;
      const tris = sculptGeometry.index ? sculptGeometry.index.count / 3 : verts / 3;
      document.getElementById('statusRight').textContent = `Vertices: ${verts} | Triangles: ${Math.floor(tris)}`;
      
      renderer.render(scene, camera);
    }

    // Window resize
    window.addEventListener('resize', () => {
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    });

    syncUI();
    applyFog(state.fogDensity, true); // ENV-001: Initialize fog on load
    animate();
    updateStatus('Ready ‚Äì start sculpting!');
  </script>
</body>
</html>
