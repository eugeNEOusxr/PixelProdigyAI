<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PixelProdigy Unified - 3D Grid Universe</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000000;
      color: #ffffff;
      overflow: hidden;
      height: 100vh;
      position: relative;
    }

    /* 3D Universe Background */
    #universeCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: all;
      cursor: crosshair;
    }
    
    /* 3D Traversable Grid Canvas */
    #gridCanvas3D {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: all;
    }
    
    /* Navigation HUD */
    .nav-hud {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(10, 20, 30, 0.95);
      backdrop-filter: blur(20px);
      border: 2px solid rgba(0, 255, 255, 0.4);
      border-radius: 12px;
      padding: 16px 24px;
      z-index: 10;
      font-size: 12px;
      color: #00ffff;
      text-align: center;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      transition: opacity 0.3s ease;
    }
    
    /* Explorer Mode HUD */
    .explorer-hud {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(30px);
      border: 3px solid rgba(255, 0, 255, 0.6);
      border-radius: 20px;
      padding: 40px 60px;
      z-index: 1000;
      text-align: center;
      box-shadow: 0 0 60px rgba(255, 0, 255, 0.8), inset 0 0 40px rgba(255, 0, 255, 0.2);
      animation: explorerPulse 2s ease-in-out infinite;
    }
    
    @keyframes explorerPulse {
      0%, 100% { box-shadow: 0 0 60px rgba(255, 0, 255, 0.8), inset 0 0 40px rgba(255, 0, 255, 0.2); }
      50% { box-shadow: 0 0 80px rgba(255, 0, 255, 1), inset 0 0 60px rgba(255, 0, 255, 0.4); }
    }
    
    .explorer-hud h2 {
      font-size: 32px;
      color: #ff00ff;
      margin: 0 0 20px 0;
      text-shadow: 0 0 20px rgba(255, 0, 255, 1);
      font-weight: 900;
    }
    
    .explorer-hud p {
      font-size: 16px;
      color: #ffaaff;
      margin: 10px 0;
      line-height: 1.6;
    }
    
    .explorer-hud .secret-code {
      font-family: 'Courier New', monospace;
      font-size: 24px;
      color: #00ffff;
      background: rgba(0, 255, 255, 0.1);
      padding: 10px 20px;
      border-radius: 8px;
      margin: 20px 0;
      border: 1px solid rgba(0, 255, 255, 0.5);
    }
    
    /* Explorer Mode Active */
    .explorer-mode-active #unifiedContainer {
      opacity: 0;
      pointer-events: none;
    }
    
    .explorer-mode-active .holographic-background {
      opacity: 0;
    }
    
    /* Explorer Position Display */
    .explorer-position {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 0, 255, 0.2);
      border: 2px solid rgba(255, 0, 255, 0.5);
      border-radius: 10px;
      padding: 15px;
      font-family: 'Courier New', monospace;
      color: #ff00ff;
      font-size: 14px;
      z-index: 10;
      backdrop-filter: blur(15px);
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
    }
    
    .explorer-position div {
      margin: 3px 0;
    }
    
    /* Exploration Grid Points */
    .grid-point {
      color: #00ffff;
      font-weight: 700;
    }
    
    /* Room Navigator */
    .room-navigator {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(10, 20, 30, 0.95);
      backdrop-filter: blur(20px);
      border: 2px solid rgba(0, 255, 255, 0.4);
      border-radius: 12px;
      padding: 20px;
      z-index: 10;
      color: #00ffff;
      min-width: 250px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
    }
    
    .room-navigator h3 {
      margin: 0 0 15px 0;
      font-size: 16px;
      text-align: center;
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      padding-bottom: 10px;
    }
    
    .room-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .room-btn {
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 6px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      color: #7dd3fc;
    }
    
    .room-btn:hover {
      background: rgba(0, 255, 255, 0.2);
      border-color: rgba(0, 255, 255, 0.5);
      transform: translateX(5px);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
    }
    
    .room-btn.active {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(14, 165, 233, 0.3) 100%);
      border-color: #00ffff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
    }
    
    .room-icon {
      font-size: 24px;
    }
    
    .room-info {
      flex: 1;
    }
    
    .room-name {
      font-weight: 700;
      margin-bottom: 2px;
    }
    
    .room-desc {
      font-size: 10px;
      opacity: 0.7;
    }
    
    /* Portal Effect */
    .portal-transition {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, transparent 0%, rgba(0, 255, 255, 0.8) 100%);
      z-index: 9999;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    .portal-transition.active {
      opacity: 1;
    }
    
    .nav-hud h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 700;
    }
    
    .nav-controls {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    
    .nav-key {
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 4px;
      padding: 8px;
      font-family: 'Courier New', monospace;
      font-weight: 700;
    }

    /* Holographic CSS Buttons Background Layer */
    .holographic-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      overflow: hidden;
    }

    .floating-css-button {
      position: absolute;
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(138, 43, 226, 0.1) 100%);
      border: 2px solid rgba(0, 255, 255, 0.3);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      animation: floatAround 20s ease-in-out infinite;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      transform-style: preserve-3d;
    }

    @keyframes floatAround {
      0%, 100% {
        transform: translate(0, 0) rotateY(0deg);
        opacity: 0.6;
      }
      25% {
        transform: translate(50px, -30px) rotateY(90deg);
        opacity: 0.8;
      }
      50% {
        transform: translate(0, -60px) rotateY(180deg);
        opacity: 1;
      }
      75% {
        transform: translate(-50px, -30px) rotateY(270deg);
        opacity: 0.8;
      }
    }

    /* Main Grid Layout - Single Screen */
    #unifiedContainer {
      position: relative;
      z-index: 2;
      display: grid;
      grid-template-columns: 60px 1fr 320px;
      grid-template-rows: 48px 1fr 40px;
      height: 100vh;
      gap: 1px;
      background: transparent;
    }

    /* Top Bar */
    #topBar {
      grid-column: 1 / -1;
      background: linear-gradient(135deg, rgba(10, 25, 41, 0.95) 0%, rgba(26, 35, 50, 0.95) 100%);
      backdrop-filter: blur(20px);
      border-bottom: 2px solid rgba(0, 255, 255, 0.3);
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 16px;
    }

    .top-logo {
      font-size: 16px;
      font-weight: 800;
      background: linear-gradient(135deg, #00FFFF 0%, #FFD700 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .top-tabs {
      display: flex;
      gap: 4px;
      flex: 1;
    }

    .top-tab {
      padding: 6px 16px;
      background: rgba(0, 255, 255, 0.05);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      color: #7dd3fc;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .top-tab:hover {
      background: rgba(0, 255, 255, 0.15);
      border-color: rgba(0, 255, 255, 0.4);
    }

    .top-tab.active {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(14, 165, 233, 0.3) 100%);
      border-color: #00FFFF;
      color: #00FFFF;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
    }

    /* Left Tool Strip - Vertical Icons */
    #toolStrip {
      background: rgba(15, 20, 25, 0.85);
      backdrop-filter: blur(20px);
      border-right: 1px solid rgba(0, 255, 255, 0.2);
      display: flex;
      flex-direction: column;
      padding: 8px 0;
      gap: 4px;
    }

    .tool-icon {
      width: 44px;
      height: 44px;
      margin: 0 auto;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .tool-icon:hover {
      background: rgba(0, 255, 255, 0.2);
      border-color: rgba(0, 255, 255, 0.5);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
    }

    .tool-icon.active {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(14, 165, 233, 0.3) 100%);
      border-color: #00FFFF;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
    }

    .tool-icon::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 60px;
      background: rgba(10, 20, 30, 0.95);
      border: 1px solid rgba(0, 255, 255, 0.4);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 11px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 1000;
    }

    .tool-icon:hover::after {
      opacity: 1;
    }

    /* Center Viewport */
    #centerViewport {
      background: transparent;
      position: relative;
      overflow: hidden;
    }

    #viewportCanvas {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* 3D Grid Overlay - Can toggle 2D/3D */
    .viewport-grid {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        linear-gradient(0deg, transparent 24%, rgba(0, 255, 255, 0.05) 25%, rgba(0, 255, 255, 0.05) 26%, transparent 27%),
        linear-gradient(90deg, transparent 24%, rgba(0, 255, 255, 0.05) 25%, rgba(0, 255, 255, 0.05) 26%, transparent 27%);
      background-size: 40px 40px;
      pointer-events: none;
      transition: all 0.5s ease;
    }

    .viewport-grid.mode-3d {
      transform: perspective(800px) rotateX(60deg);
      transform-origin: center center;
    }

    /* Right Panel - 3D Grid Controls */
    #rightPanel {
      background: rgba(15, 20, 25, 0.85);
      backdrop-filter: blur(20px);
      border-left: 1px solid rgba(0, 255, 255, 0.2);
      overflow-y: auto;
      overflow-x: hidden;
      padding: 12px;
    }

    /* 3D Grid Button System */
    .control-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-bottom: 16px;
      perspective: 1000px;
    }

    .control-grid.mode-3d {
      transform-style: preserve-3d;
    }

    .control-grid.mode-3d .grid-control-btn {
      transform: translateZ(20px);
      transition: transform 0.3s ease;
    }

    .control-grid.mode-3d .grid-control-btn:hover {
      transform: translateZ(40px) scale(1.1);
    }

    .grid-control-btn {
      aspect-ratio: 1;
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.15) 0%, rgba(14, 165, 233, 0.1) 100%);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
      transform-style: preserve-3d;
    }

    .grid-control-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.3), transparent);
      transition: left 0.3s ease;
    }

    .grid-control-btn:hover::before {
      left: 100%;
    }

    .grid-control-btn:hover {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(14, 165, 233, 0.15) 100%);
      border-color: rgba(0, 255, 255, 0.5);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
      transform: translateY(-2px);
    }

    .grid-control-btn.active {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.4) 0%, rgba(14, 165, 233, 0.3) 100%);
      border-color: #00FFFF;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.6), inset 0 0 10px rgba(0, 255, 255, 0.2);
    }

    .grid-control-btn .label {
      font-size: 9px;
      font-weight: 600;
      color: #7dd3fc;
      margin-top: 4px;
      text-align: center;
      line-height: 1;
    }

    /* Section Headers */
    .section-header {
      font-size: 11px;
      font-weight: 700;
      color: #00FFFF;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 16px 0 8px 0;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(0, 255, 255, 0.2);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Compact Sliders */
    .compact-slider {
      margin-bottom: 10px;
    }

    .compact-slider label {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #7dd3fc;
      margin-bottom: 4px;
      font-weight: 600;
    }

    .compact-slider input[type="range"] {
      width: 100%;
      height: 4px;
      background: rgba(30, 40, 60, 0.8);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
    }

    .compact-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: linear-gradient(135deg, #00FFFF 0%, #0ea5e9 100%);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
    }

    .compact-slider input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px rgba(0, 255, 255, 1);
    }

    /* Bottom Status Bar */
    #statusBar {
      grid-column: 1 / -1;
      background: #0a0e14;
      border-top: 1px solid rgba(0, 255, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.5);
    }

    .status-left, .status-right {
      display: flex;
      gap: 16px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-indicator {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #00FF00;
      box-shadow: 0 0 8px #00FF00;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Viewport HUD */
    .viewport-hud {
      position: absolute;
      top: 16px;
      left: 16px;
      background: rgba(10, 20, 30, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 6px;
      padding: 12px;
      font-size: 11px;
      color: #7dd3fc;
      min-width: 200px;
    }

    .hud-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
    }

    .hud-item:last-child {
      margin-bottom: 0;
    }

    .hud-label {
      color: #7dd3fc;
      font-weight: 600;
    }

    .hud-value {
      color: #00FFFF;
      font-family: 'Courier New', monospace;
    }

    /* Quick Actions - Bottom Right Radial Menu */
    .quick-actions {
      position: absolute;
      bottom: 16px;
      right: 16px;
      width: 60px;
      height: 60px;
    }

    .quick-action-center {
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(14, 165, 233, 0.3) 100%);
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
    }

    .quick-action-center:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(10, 15, 25, 0.5);
    }

    ::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(14, 165, 233, 0.3) 100%);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.6) 0%, rgba(14, 165, 233, 0.6) 100%);
    }

    /* Color Swatch Grid */
    .color-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 4px;
      margin-bottom: 12px;
    }

    .color-swatch {
      aspect-ratio: 1;
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .color-swatch:hover {
      transform: scale(1.1);
      border-color: #00FFFF;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .color-swatch.active {
      border: 2px solid #00FFFF;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
    }

    /* Compact Toggle */
    .compact-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      background: rgba(0, 255, 255, 0.05);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 4px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .compact-toggle:hover {
      background: rgba(0, 255, 255, 0.1);
      border-color: rgba(0, 255, 255, 0.4);
    }

    .compact-toggle label {
      font-size: 10px;
      font-weight: 600;
      color: #7dd3fc;
      cursor: pointer;
    }

    .toggle-switch {
      width: 32px;
      height: 16px;
      background: rgba(30, 40, 60, 0.8);
      border-radius: 8px;
      position: relative;
      transition: all 0.2s ease;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 12px;
      height: 12px;
      background: #7dd3fc;
      border-radius: 50%;
      transition: all 0.2s ease;
    }

    .compact-toggle.active .toggle-switch {
      background: rgba(0, 255, 255, 0.3);
    }

    .compact-toggle.active .toggle-switch::after {
      left: 18px;
      background: #00FFFF;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
    }

    /* Workspace Mode Selector */
    .workspace-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 16px;
    }

    .workspace-btn {
      padding: 10px;
      background: rgba(0, 255, 255, 0.05);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 6px;
      font-size: 10px;
      font-weight: 600;
      color: #7dd3fc;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .workspace-btn:hover {
      background: rgba(0, 255, 255, 0.15);
      border-color: rgba(0, 255, 255, 0.4);
    }

    .workspace-btn.active {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(14, 165, 233, 0.3) 100%);
      border-color: #00FFFF;
      color: #00FFFF;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
    }

    /* AI Assistant Panel */
    .ai-panel {
      background: linear-gradient(135deg, rgba(138, 43, 226, 0.1) 0%, rgba(75, 0, 130, 0.1) 100%);
      border: 1px solid rgba(138, 43, 226, 0.3);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 16px;
    }

    .ai-panel h4 {
      font-size: 11px;
      color: #ba68c8;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .ai-suggestion {
      font-size: 10px;
      color: #dda0dd;
      line-height: 1.4;
      margin-bottom: 8px;
    }

    .ai-action-btn {
      width: 100%;
      padding: 6px;
      background: rgba(138, 43, 226, 0.2);
      border: 1px solid rgba(138, 43, 226, 0.4);
      border-radius: 4px;
      color: #ba68c8;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .ai-action-btn:hover {
      background: rgba(138, 43, 226, 0.3);
      box-shadow: 0 0 15px rgba(138, 43, 226, 0.4);
    }
  </style>
</head>
<body>
  <!-- 3D Universe Background Canvas -->
  <canvas id="universeCanvas"></canvas>
  
  <!-- 3D Traversable Grid Canvas -->
  <canvas id="gridCanvas3D"></canvas>
  
  <!-- Holographic CSS Buttons Background Layer -->
  <div class="holographic-background" id="holoBg"></div>
  
  <!-- Navigation HUD -->
  <div class="nav-hud" id="navHud" style="display: none;">
    <h3>🎮 3D GRID NAVIGATION</h3>
    <div>WASD = Move | Mouse = Look | Space = Up | Shift = Down</div>
    <div class="nav-controls">
      <div class="nav-key">W</div>
      <div class="nav-key">↑</div>
      <div class="nav-key">A</div>
      <div class="nav-key">←</div>
      <div class="nav-key">S</div>
      <div class="nav-key">↓</div>
      <div class="nav-key">D</div>
      <div class="nav-key">→</div>
      <div class="nav-key">SPACE</div>
    </div>
    <div style="margin-top: 8px; font-size: 10px; opacity: 0.7;">Click canvas to activate | ESC to exit</div>
  </div>
  
  <!-- Explorer Mode HUD (Hidden until activated) -->
  <div class="explorer-hud" id="explorerHud" style="display: none;">
    <h2>🌌 EXPLORER MODE ACTIVATED 🌌</h2>
    <p>You have entered the <strong>Secret Exploration Zone</strong></p>
    <p>This is your private 3D grid universe</p>
    <div class="secret-code">ACCESS GRANTED</div>
    <p style="font-size: 14px; margin-top: 20px;">
      WASD = Navigate | Mouse = Look Around | Space = Ascend | Shift = Descend<br>
      E = Boost Speed | Q = Slow Motion | R = Reset Position<br>
      ESC = Exit Explorer Mode
    </p>
    <p style="font-size: 12px; opacity: 0.6; margin-top: 20px;">
      Click anywhere to begin exploration...
    </p>
  </div>
  
  <!-- Explorer Position Display -->
  <div class="explorer-position" id="explorerPos" style="display: none;">
    <div><span class="grid-point">X:</span> <span id="posX">0.00</span></div>
    <div><span class="grid-point">Y:</span> <span id="posY">0.00</span></div>
    <div><span class="grid-point">Z:</span> <span id="posZ">0.00</span></div>
    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255, 0, 255, 0.3);">
      <div><span class="grid-point">Speed:</span> <span id="explorerSpeed">Normal</span></div>
      <div><span class="grid-point">Mode:</span> <span id="explorerMode">FREE ROAM</span></div>
    </div>
  </div>
  
  <!-- Room Navigator -->
  <div class="room-navigator" id="roomNavigator" style="display: none;">
    <h3>🚪 ROOM NAVIGATOR</h3>
    <div class="room-list">
      <div class="room-btn active" onclick="teleportToRoom('studio')">
        <div class="room-icon">🎨</div>
        <div class="room-info">
          <div class="room-name">3D Studio</div>
          <div class="room-desc">Main workspace</div>
        </div>
      </div>
      <div class="room-btn" onclick="teleportToRoom('css')">
        <div class="room-icon">💅</div>
        <div class="room-info">
          <div class="room-name">CSS Designer</div>
          <div class="room-desc">Style laboratory</div>
        </div>
      </div>
      <div class="room-btn" onclick="teleportToRoom('word')">
        <div class="room-icon">📝</div>
        <div class="room-info">
          <div class="room-name">WordWeaver</div>
          <div class="room-desc">Writing space</div>
        </div>
      </div>
      <div class="room-btn" onclick="teleportToRoom('campus')">
        <div class="room-icon">🎓</div>
        <div class="room-info">
          <div class="room-name">Campus</div>
          <div class="room-desc">Learning zone</div>
        </div>
      </div>
      <div class="room-btn" onclick="teleportToRoom('perfect')">
        <div class="room-icon">✨</div>
        <div class="room-info">
          <div class="room-name">Perfect</div>
          <div class="room-desc">Polish realm</div>
        </div>
      </div>
      <div class="room-btn" onclick="teleportToRoom('universe')">
        <div class="room-icon">🌌</div>
        <div class="room-info">
          <div class="room-name">Universe Hub</div>
          <div class="room-desc">Central nexus</div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Portal Transition Effect -->
  <div class="portal-transition" id="portalEffect"></div>

  <div id="unifiedContainer">
    <!-- Top Bar -->
    <div id="topBar">
      <div class="top-logo">⚡ PixelProdigy Universe</div>
      <div class="top-tabs">
        <div class="top-tab active" onclick="switchWorkspace('modeling', this)">3D Studio</div>
        <div class="top-tab" onclick="switchWorkspace('css', this)">CSS Designer</div>
        <div class="top-tab" onclick="switchWorkspace('wordweaver', this)">WordWeaver</div>
        <div class="top-tab" onclick="switchWorkspace('campus', this)">Campus</div>
        <div class="top-tab" onclick="switchWorkspace('perfect', this)">Perfect</div>
        <div class="top-tab" onclick="switchWorkspace('universe', this)">🌌 UI Grids</div>
      </div>
      <button class="top-tab" onclick="toggleGridMode()">🔲 2D/3D Grid</button>
      <button class="top-tab" onclick="exportProject()">💾 Export</button>
    </div>

    <!-- Left Tool Strip -->
    <div id="toolStrip">
      <div class="tool-icon active" data-tooltip="Select" onclick="selectTool('select', this)">🎯</div>
      <div class="tool-icon" data-tooltip="Sculpt" onclick="selectTool('sculpt', this)">🖌️</div>
      <div class="tool-icon" data-tooltip="Transform" onclick="selectTool('transform', this)">🔄</div>
      <div class="tool-icon" data-tooltip="Paint" onclick="selectTool('paint', this)">🎨</div>
      <div class="tool-icon" data-tooltip="Add Object" onclick="selectTool('add', this)">➕</div>
      <div class="tool-icon" data-tooltip="Camera" onclick="selectTool('camera', this)">📷</div>
      <div class="tool-icon" data-tooltip="Light" onclick="selectTool('light', this)">💡</div>
      <div class="tool-icon" data-tooltip="Render" onclick="selectTool('render', this)">✨</div>
      <div style="flex: 1;"></div>
      <div class="tool-icon" data-tooltip="Settings" onclick="selectTool('settings', this)">⚙️</div>
    </div>

    <!-- Center Viewport -->
    <div id="centerViewport">
      <div class="viewport-grid"></div>
      <canvas id="viewportCanvas"></canvas>
      
      <!-- Viewport HUD -->
      <div class="viewport-hud">
        <div class="hud-item">
          <span class="hud-label">Mode:</span>
          <span class="hud-value" id="currentMode">SCULPT</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">Tool:</span>
          <span class="hud-value" id="currentTool">DRAW</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">Vertices:</span>
          <span class="hud-value" id="vertexCount">24,576</span>
        </div>
        <div class="hud-item">
          <span class="hud-label">FPS:</span>
          <span class="hud-value" id="fpsCounter">60</span>
        </div>
      </div>

      <!-- Quick Actions -->
      <div class="quick-actions">
        <div class="quick-action-center" onclick="showQuickMenu()">⚡</div>
      </div>
    </div>

    <!-- Right Panel - 3D Grid Controls -->
    <div id="rightPanel">
      <!-- Workspace Mode -->
      <div class="section-header">
        🏢 WORKSPACE
      </div>
      <div class="workspace-selector">
        <div class="workspace-btn active">Studio</div>
        <div class="workspace-btn">CSS</div>
        <div class="workspace-btn">Word</div>
        <div class="workspace-btn">Campus</div>
      </div>

      <!-- AI Assistant -->
      <div class="ai-panel">
        <h4>🤖 AI Assistant</h4>
        <div class="ai-suggestion">
          Suggestion: Add ambient occlusion to enhance depth. Current scene would benefit from softer shadows.
        </div>
        <button class="ai-action-btn">Apply Suggestion</button>
      </div>

      <!-- Main Tool Grid -->
      <div class="section-header">
        � MODELING MODE
      </div>
      <div class="control-grid" style="grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 16px;">
        <div class="grid-control-btn active" onclick="selectMode('additive', this)" style="background: rgba(0, 255, 100, 0.1); border: 1px solid #0f8;">
          ➕
          <span class="label">ADD</span>
        </div>
        <div class="grid-control-btn" onclick="selectMode('subtractive', this)" style="background: rgba(255, 50, 50, 0.1); border: 1px solid #f44;">
          ➖
          <span class="label">SUBTRACT</span>
        </div>
      </div>
      
      <div class="section-header">
        🎯 3D PRIMITIVES (Click to Place)
      </div>
      <div class="control-grid">
        <div class="grid-control-btn" onclick="selectPrimitive('cylinder', this)">
          🔵
          <span class="label">Cylinder</span>
        </div>
        <div class="grid-control-btn" onclick="selectPrimitive('pyramid', this)">
          🔺
          <span class="label">Pyramid</span>
        </div>
        <div class="grid-control-btn" onclick="selectPrimitive('cube', this)">
          ⬛
          <span class="label">Cube</span>
        </div>
        <div class="grid-control-btn" onclick="selectPrimitive('sphere', this)">
          ⚪
          <span class="label">Sphere</span>
        </div>
        <div class="grid-control-btn" onclick="selectPrimitive('cone', this)">
          🔻
          <span class="label">Cone</span>
        </div>
        <div class="grid-control-btn" onclick="selectPrimitive('torus', this)">
          🍩
          <span class="label">Torus</span>
        </div>
      </div>
      
      <div class="section-header">
        📐 PLACEMENT ANGLE (Right-Click to Set)
      </div>
      <div class="control-grid" style="grid-template-columns: repeat(4, 1fr); gap: 6px;">
        <div class="grid-control-btn active" onclick="selectAngle(0, this)" style="font-size: 11px; padding: 8px 4px;">0°</div>
        <div class="grid-control-btn" onclick="selectAngle(5, this)" style="font-size: 11px; padding: 8px 4px;">5°</div>
        <div class="grid-control-btn" onclick="selectAngle(10, this)" style="font-size: 11px; padding: 8px 4px;">10°</div>
        <div class="grid-control-btn" onclick="selectAngle(15, this)" style="font-size: 11px; padding: 8px 4px;">15°</div>
        <div class="grid-control-btn" onclick="selectAngle(20, this)" style="font-size: 11px; padding: 8px 4px;">20°</div>
        <div class="grid-control-btn" onclick="selectAngle(25, this)" style="font-size: 11px; padding: 8px 4px;">25°</div>
        <div class="grid-control-btn" onclick="selectAngle(30, this)" style="font-size: 11px; padding: 8px 4px;">30°</div>
        <div class="grid-control-btn" onclick="selectAngle(45, this)" style="font-size: 11px; padding: 8px 4px;">45°</div>
        <div class="grid-control-btn" onclick="selectAngle(60, this)" style="font-size: 11px; padding: 8px 4px;">60°</div>
        <div class="grid-control-btn" onclick="selectAngle(90, this)" style="font-size: 11px; padding: 8px 4px;">90°</div>
      </div>
      
      <div class="section-header">
        🖌️ VERTEX TOOLS
      </div>
      <div class="control-grid">
        <div class="grid-control-btn" onclick="selectBrush('carve', this)">
          🔪
          <span class="label">Carve</span>
        </div>
        <div class="grid-control-btn" onclick="selectBrush('cut', this)">
          ✂️
          <span class="label">Cut</span>
        </div>
        <div class="grid-control-btn" onclick="selectBrush('smooth', this)">
          〰️
          <span class="label">Smooth</span>
        </div>
        <div class="grid-control-btn" onclick="selectBrush('flatten', this)">
          ▭
          <span class="label">Flatten</span>
        </div>
      </div>

      <!-- Brush Settings -->
      <div class="section-header">
        ⚙️ BRUSH SETTINGS
      </div>
      <div class="compact-slider">
        <label>
          <span>Radius</span>
          <span id="radiusValue">0.35</span>
        </label>
        <input type="range" min="0.1" max="2" step="0.05" value="0.35" 
               oninput="updateValue('radius', this.value)">
      </div>
      <div class="compact-slider">
        <label>
          <span>Strength</span>
          <span id="strengthValue">0.50</span>
        </label>
        <input type="range" min="0" max="1" step="0.05" value="0.5" 
               oninput="updateValue('strength', this.value)">
      </div>
      <div class="compact-slider">
        <label>
          <span>Hardness</span>
          <span id="hardnessValue">0.70</span>
        </label>
        <input type="range" min="0" max="1" step="0.05" value="0.7" 
               oninput="updateValue('hardness', this.value)">
      </div>

      <!-- Transform Grid -->
      <div class="section-header">
        🔄 TRANSFORM
      </div>
      <div class="control-grid">
        <div class="grid-control-btn" onclick="applyTransform('move')">
          ↕️
          <span class="label">Move</span>
        </div>
        <div class="grid-control-btn" onclick="applyTransform('rotate')">
          🔄
          <span class="label">Rotate</span>
        </div>
        <div class="grid-control-btn" onclick="applyTransform('scale')">
          ⤢
          <span class="label">Scale</span>
        </div>
        <div class="grid-control-btn" onclick="applyTransform('mirror')">
          ⫿
          <span class="label">Mirror</span>
        </div>
      </div>

      <!-- Symmetry Toggles -->
      <div class="section-header">
        🔀 SYMMETRY
      </div>
      <div class="compact-toggle" onclick="toggleSymmetry('x', this)">
        <label>X-Axis</label>
        <div class="toggle-switch"></div>
      </div>
      <div class="compact-toggle" onclick="toggleSymmetry('y', this)">
        <label>Y-Axis</label>
        <div class="toggle-switch"></div>
      </div>
      <div class="compact-toggle" onclick="toggleSymmetry('z', this)">
        <label>Z-Axis</label>
        <div class="toggle-switch"></div>
      </div>

      <!-- Material Colors -->
      <div class="section-header">
        🎨 MATERIALS
      </div>
      <div class="color-grid">
        <div class="color-swatch active" style="background: #667eea;" onclick="selectColor(this)"></div>
        <div class="color-swatch" style="background: #764ba2;" onclick="selectColor(this)"></div>
        <div class="color-swatch" style="background: #f093fb;" onclick="selectColor(this)"></div>
        <div class="color-swatch" style="background: #4facfe;" onclick="selectColor(this)"></div>
        <div class="color-swatch" style="background: #00f2fe;" onclick="selectColor(this)"></div>
        <div class="color-swatch" style="background: #43e97b;" onclick="selectColor(this)"></div>
        <div class="color-swatch" style="background: #38f9d7;" onclick="selectColor(this)"></div>
        <div class="color-swatch" style="background: #fa709a;" onclick="selectColor(this)"></div>
        <div class="color-swatch" style="background: #fee140;" onclick="selectColor(this)"></div>
        <div class="color-swatch" style="background: #30cfd0;" onclick="selectColor(this)"></div>
      </div>

      <!-- Object Actions -->
      <div class="section-header">
        📦 OBJECTS
      </div>
      <div class="control-grid">
        <div class="grid-control-btn" onclick="addObject('sphere')">
          ⚪
          <span class="label">Sphere</span>
        </div>
        <div class="grid-control-btn" onclick="addObject('cube')">
          ◻️
          <span class="label">Cube</span>
        </div>
        <div class="grid-control-btn" onclick="addObject('cylinder')">
          🥫
          <span class="label">Cylinder</span>
        </div>
        <div class="grid-control-btn" onclick="addObject('torus')">
          🍩
          <span class="label">Torus</span>
        </div>
      </div>

      <!-- Effects -->
      <div class="section-header">
        ✨ EFFECTS
      </div>
      <div class="control-grid">
        <div class="grid-control-btn" onclick="applyEffect('bloom')">
          💫
          <span class="label">Bloom</span>
        </div>
        <div class="grid-control-btn" onclick="applyEffect('glow')">
          ✨
          <span class="label">Glow</span>
        </div>
        <div class="grid-control-btn" onclick="applyEffect('outline')">
          🔲
          <span class="label">Outline</span>
        </div>
        <div class="grid-control-btn" onclick="applyEffect('shadow')">
          🌑
          <span class="label">Shadow</span>
        </div>
      </div>

      <!-- Layer Management -->
      <div class="section-header">
        📚 LAYERS
      </div>
      <div class="compact-slider">
        <label>
          <span>Current Layer</span>
          <span id="layerValue">1</span>
        </label>
        <input type="range" min="1" max="10" step="1" value="1" 
               oninput="updateValue('layer', this.value)">
      </div>
      <div class="control-grid">
        <div class="grid-control-btn" onclick="layerAction('add')">
          ➕
          <span class="label">Add</span>
        </div>
        <div class="grid-control-btn" onclick="layerAction('remove')">
          ➖
          <span class="label">Remove</span>
        </div>
        <div class="grid-control-btn" onclick="layerAction('merge')">
          ⬇️
          <span class="label">Merge</span>
        </div>
        <div class="grid-control-btn" onclick="layerAction('duplicate')">
          📋
          <span class="label">Duplicate</span>
        </div>
      </div>

      <!-- CSS Tools (when in CSS mode) -->
      <div class="section-header" id="cssSection" style="display: none;">
        💅 CSS TOOLS
      </div>
      <div class="control-grid" id="cssGrid" style="display: none;">
        <div class="grid-control-btn" onclick="cssAction('gradient')">
          🌈
          <span class="label">Gradient</span>
        </div>
        <div class="grid-control-btn" onclick="cssAction('shadow')">
          🌫️
          <span class="label">Shadow</span>
        </div>
        <div class="grid-control-btn" onclick="cssAction('border')">
          🔲
          <span class="label">Border</span>
        </div>
        <div class="grid-control-btn" onclick="cssAction('animate')">
          🎬
          <span class="label">Animate</span>
        </div>
        <div class="grid-control-btn" onclick="cssAction('transform3d')">
          🔄
          <span class="label">3D Trans</span>
        </div>
        <div class="grid-control-btn" onclick="cssAction('filter')">
          🎭
          <span class="label">Filter</span>
        </div>
        <div class="grid-control-btn" onclick="cssAction('grid')">
          📐
          <span class="label">Grid</span>
        </div>
        <div class="grid-control-btn" onclick="cssAction('flex')">
          📏
          <span class="label">Flex</span>
        </div>
      </div>

      <!-- Advanced Tools -->
      <div class="section-header">
        🚀 ADVANCED TOOLS
      </div>
      <div class="control-grid">
        <div class="grid-control-btn" onclick="advancedTool('physics')">
          🌊
          <span class="label">Physics</span>
        </div>
        <div class="grid-control-btn" onclick="advancedTool('particles')">
          ✨
          <span class="label">Particles</span>
        </div>
        <div class="grid-control-btn" onclick="advancedTool('boolean')">
          ⚡
          <span class="label">Boolean</span>
        </div>
        <div class="grid-control-btn" onclick="advancedTool('array')">
          📋
          <span class="label">Array</span>
        </div>
        <div class="grid-control-btn" onclick="advancedTool('curve')">
          〰️
          <span class="label">Curve</span>
        </div>
        <div class="grid-control-btn" onclick="advancedTool('modifier')">
          🔧
          <span class="label">Modifier</span>
        </div>
        <div class="grid-control-btn" onclick="advancedTool('texture')">
          🎨
          <span class="label">Texture</span>
        </div>
        <div class="grid-control-btn" onclick="advancedTool('bake')">
          🔥
          <span class="label">Bake</span>
        </div>
      </div>

      <!-- UI Grid Universe Selector -->
      <div class="section-header">
        🌌 UI GRID UNIVERSES
      </div>
      <div class="control-grid">
        <div class="grid-control-btn active" onclick="selectUIGrid('main')">
          🏠
          <span class="label">Main</span>
        </div>
        <div class="grid-control-btn" onclick="selectUIGrid('creative')">
          🎨
          <span class="label">Creative</span>
        </div>
        <div class="grid-control-btn" onclick="selectUIGrid('code')">
          💻
          <span class="label">Code</span>
        </div>
        <div class="grid-control-btn" onclick="selectUIGrid('data')">
          📊
          <span class="label">Data</span>
        </div>
        <div class="grid-control-btn" onclick="selectUIGrid('game')">
          🎮
          <span class="label">Game</span>
        </div>
        <div class="grid-control-btn" onclick="selectUIGrid('ar')">
          🥽
          <span class="label">AR/VR</span>
        </div>
        <div class="grid-control-btn" onclick="selectUIGrid('ai')">
          🤖
          <span class="label">AI Lab</span>
        </div>
        <div class="grid-control-btn" onclick="selectUIGrid('custom')">
          ⭐
          <span class="label">Custom</span>
        </div>
      </div>

      <!-- Orbital Controls -->
      <div class="section-header">
        🌐 ORBITAL CONTROLS
      </div>
      <div class="compact-toggle active" onclick="toggleOrbitalControl('rotate', this)">
        <label>Auto Rotate</label>
        <div class="toggle-switch"></div>
      </div>
      <div class="compact-slider">
        <label>
          <span>Rotation Speed</span>
          <span id="rotSpeedValue">1.0</span>
        </label>
        <input type="range" min="0" max="5" step="0.1" value="1" 
               oninput="updateValue('rotSpeed', this.value); updateOrbitalSpeed(this.value)">
      </div>
      <div class="compact-slider">
        <label>
          <span>Zoom Level</span>
          <span id="zoomValue">100</span>
        </label>
        <input type="range" min="50" max="200" step="5" value="100" 
               oninput="updateValue('zoom', this.value); updateOrbitalZoom(this.value)">
      </div>
      <div class="control-grid">
        <div class="grid-control-btn" onclick="resetOrbitalView()">
          🎯
          <span class="label">Reset</span>
        </div>
        <div class="grid-control-btn" onclick="saveOrbitalView()">
          💾
          <span class="label">Save</span>
        </div>
        <div class="grid-control-btn" onclick="orbitalPreset('top')">
          ⬆️
          <span class="label">Top</span>
        </div>
        <div class="grid-control-btn" onclick="orbitalPreset('front')">
          ➡️
          <span class="label">Front</span>
        </div>
      </div>
    </div>

    <!-- Bottom Status Bar -->
    <div id="statusBar">
      <div class="status-left">
        <div class="status-item">
          <div class="status-indicator"></div>
          <span>System Ready</span>
        </div>
        <div class="status-item">
          <span>Mode: <strong id="statusMode">3D Studio</strong></span>
        </div>
        <div class="status-item">
          <span>Tool: <strong id="statusTool">Sculpt Brush</strong></span>
        </div>
      </div>
      <div class="status-right">
        <div class="status-item">
          <span>RAM: 2.4GB / 16GB</span>
        </div>
        <div class="status-item">
          <span>GPU: 45%</span>
        </div>
        <div class="status-item">
          <span>© 2025 PixelProdigy</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global State
    let currentWorkspace = 'modeling';
    let currentTool = 'sculpt';
    let currentBrush = 'carve';
    let currentMode = 'additive'; // 'additive' or 'subtractive'
    let currentPrimitive = 'cylinder'; // Shape to place
    let placementAngle = 0; // Angle in degrees for primitive placement
    let primitiveSize = 0.5; // Size of primitive to place

    // ============================================
    // REAL THREE.JS SCULPTING SETUP
    // ============================================
    let sculptScene, sculptCamera, sculptRenderer, sculptControls;
    let sculptMesh = null;
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let isMouseDown = false;
    let brushSize = 0.5;
    let brushStrength = 0.1;

    // Initialize Three.js for Sculpting
    const canvas = document.getElementById('viewportCanvas');
    
    function initSculptingViewport() {
      // Scene
      sculptScene = new THREE.Scene();
      sculptScene.background = new THREE.Color(0x0a1520);
      
      // Camera
      sculptCamera = new THREE.PerspectiveCamera(75, canvas.offsetWidth / canvas.offsetHeight, 0.1, 1000);
      sculptCamera.position.set(0, 2, 5);
      
      // Renderer
      sculptRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      sculptRenderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
      sculptRenderer.setPixelRatio(window.devicePixelRatio);
      
      // Controls
      sculptControls = new THREE.OrbitControls(sculptCamera, sculptRenderer.domElement);
      sculptControls.enableDamping = true;
      sculptControls.dampingFactor = 0.05;
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      sculptScene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7.5);
      sculptScene.add(directionalLight);
      
      // Grid
      const gridHelper = new THREE.GridHelper(20, 20, 0x00ffff, 0x444444);
      sculptScene.add(gridHelper);
      
      // Add default sphere to sculpt
      createSculptableSphere();
      
      // Mouse events for sculpting
      canvas.addEventListener('mousemove', onSculptMouseMove);
      canvas.addEventListener('mousedown', onSculptMouseDown);
      canvas.addEventListener('mouseup', onSculptMouseUp);
      
      // Start animation
      animateSculpting();
    }

    function createSculptableSphere() {
      const geometry = new THREE.SphereGeometry(1.5, 64, 64);
      const material = new THREE.MeshStandardMaterial({
        color: 0x00d4ff,
        roughness: 0.7,
        metalness: 0.3,
        flatShading: false
      });
      
      sculptMesh = new THREE.Mesh(geometry, material);
      sculptScene.add(sculptMesh);
    }

    function onSculptMouseMove(event) {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      if (isMouseDown && sculptMesh && currentTool === 'sculpt') {
        applySculpting();
      }
    }

    function onSculptMouseDown(event) {
      if (event.button === 0) { // Left click
        isMouseDown = true;
        
        // If we're in primitive placement mode, place a primitive
        if (currentTool === 'sculpt' && ['cylinder', 'pyramid', 'cube', 'sphere', 'cone', 'torus'].includes(currentPrimitive)) {
          raycaster.setFromCamera(mouse, sculptCamera);
          
          // Try to intersect with existing mesh
          const intersects = raycaster.intersectObjects(sculptScene.children, true);
          
          if (intersects.length > 0) {
            placePrimitive(intersects[0].point);
          } else {
            // Place on ground plane if no intersection
            const groundY = 0;
            const dir = new THREE.Vector3();
            raycaster.ray.direction.normalize();
            const distance = (groundY - sculptCamera.position.y) / raycaster.ray.direction.y;
            const position = sculptCamera.position.clone().add(raycaster.ray.direction.multiplyScalar(distance));
            placePrimitive(position);
          }
        }
      }
    }

    function onSculptMouseUp(event) {
      isMouseDown = false;
    }

    function applySculpting() {
      raycaster.setFromCamera(mouse, sculptCamera);
      const intersects = raycaster.intersectObject(sculptMesh);
      
      if (intersects.length > 0) {
        const point = intersects[0].point;
        const geometry = sculptMesh.geometry;
        const positions = geometry.attributes.position;
        
        for (let i = 0; i < positions.count; i++) {
          const vertex = new THREE.Vector3(
            positions.getX(i),
            positions.getY(i),
            positions.getZ(i)
          );
          vertex.applyMatrix4(sculptMesh.matrixWorld);
          
          const distance = vertex.distanceTo(point);
          
          if (distance < brushSize) {
            const falloff = 1 - (distance / brushSize);
            const intensity = brushStrength * falloff * 0.05;
            
            const localVertex = vertex.clone();
            localVertex.applyMatrix4(sculptMesh.matrixWorld.clone().invert());
            
            // Apply brush effect based on current brush type
            switch(currentBrush) {
              case 'draw':
                const normal = new THREE.Vector3();
                normal.copy(localVertex).normalize();
                localVertex.add(normal.multiplyScalar(intensity));
                break;
              case 'carve':
                // Subtract material - push vertices inward
                const carveNormal = new THREE.Vector3();
                carveNormal.copy(localVertex).normalize();
                localVertex.add(carveNormal.multiplyScalar(-intensity * 2)); // Stronger inward push
                break;
              case 'cut':
                // Sharp cut - flatten in direction perpendicular to view
                const cutDir = point.clone().sub(sculptCamera.position).normalize();
                const projection = localVertex.clone().projectOnVector(cutDir);
                localVertex.sub(projection.multiplyScalar(intensity * 0.5));
                break;
              case 'grab':
                // Move vertex towards mouse
                break;
              case 'smooth':
                // Smooth with neighbors
                break;
              case 'pinch':
                localVertex.multiplyScalar(1 - intensity * 0.1);
                break;
              case 'inflate':
                localVertex.multiplyScalar(1 + intensity);
                break;
              case 'flatten':
                localVertex.y *= (1 - intensity * 0.5);
                break;
            }
            
            positions.setXYZ(i, localVertex.x, localVertex.y, localVertex.z);
          }
        }
        
        positions.needsUpdate = true;
        geometry.computeVertexNormals();
      }
    }

    function animateSculpting() {
      requestAnimationFrame(animateSculpting);
      sculptControls.update();
      sculptRenderer.render(sculptScene, sculptCamera);
    }

    function resizeCanvas() {
      if (sculptRenderer) {
        sculptCamera.aspect = canvas.offsetWidth / canvas.offsetHeight;
        sculptCamera.updateProjectionMatrix();
        sculptRenderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
      }
    }

    window.addEventListener('resize', resizeCanvas);
    
    // Initialize sculpting viewport on load
    setTimeout(initSculptingViewport, 100);

    // Switch Workspace
    function switchWorkspace(workspace, buttonElement) {
      currentWorkspace = workspace;
      
      // Update tab UI
      document.querySelectorAll('.top-tabs .top-tab').forEach(tab => tab.classList.remove('active'));
      if (buttonElement) {
        buttonElement.classList.add('active');
      }
      
      // Update mode display
      const modeNames = {
        'modeling': '3D Studio',
        'css': 'CSS Designer',
        'wordweaver': 'WordWeaver',
        'campus': 'Campus',
        'perfect': 'Perfect',
        'universe': 'UI Grids'
      };
      document.getElementById('statusMode').textContent = modeNames[workspace] || workspace;
      document.getElementById('currentMode').textContent = (modeNames[workspace] || workspace).toUpperCase();
      
      // Show/hide relevant controls
      const cssSection = document.getElementById('cssSection');
      const cssGrid = document.getElementById('cssGrid');
      
      if (workspace === 'css') {
        if (cssSection) cssSection.style.display = 'block';
        if (cssGrid) cssGrid.style.display = 'grid';
        // Show CSS designer environment
        document.getElementById('currentTool').textContent = 'CSS TOOLS';
      } else {
        if (cssSection) cssSection.style.display = 'none';
        if (cssGrid) cssGrid.style.display = 'none';
      }
      
      console.log('Switched to workspace:', workspace);
    }
    
    // CSS Designer Actions
    function cssAction(action) {
      console.log('CSS Action:', action);
      
      // Add visual feedback
      event.target.classList.add('active');
      setTimeout(() => {
        event.target.classList.remove('active');
      }, 200);
      
      // Placeholder for actual CSS generation
      switch(action) {
        case 'gradient':
          alert('Gradient Generator - Coming soon!');
          break;
        case 'shadow':
          alert('Shadow Generator - Coming soon!');
          break;
        case 'border':
          alert('Border Designer - Coming soon!');
          break;
        case 'animate':
          alert('Animation Builder - Coming soon!');
          break;
        case 'transform3d':
          alert('3D Transform - Coming soon!');
          break;
        case 'filter':
          alert('Filter Effects - Coming soon!');
          break;
        case 'grid':
          alert('CSS Grid Builder - Coming soon!');
          break;
        case 'flexbox':
          alert('Flexbox Builder - Coming soon!');
          break;
      }
    }

    // Select Tool
    function selectTool(tool, buttonElement) {
      currentTool = tool;
      
      // Update tool strip UI
      document.querySelectorAll('.tool-icon').forEach(icon => icon.classList.remove('active'));
      if (buttonElement) {
        buttonElement.classList.add('active');
      }
      
      // Update status
      const toolNames = {
        'select': 'Select',
        'sculpt': 'Sculpt Brush',
        'transform': 'Transform',
        'paint': 'Paint',
        'add': 'Add Object',
        'camera': 'Camera',
        'light': 'Light',
        'render': 'Render',
        'settings': 'Settings'
      };
      document.getElementById('statusTool').textContent = toolNames[tool];
      document.getElementById('currentTool').textContent = toolNames[tool].toUpperCase();
      
      console.log('Selected tool:', tool);
    }

    // Select Brush
    function selectBrush(brush, buttonElement) {
      currentBrush = brush;
      
      // Update button UI
      document.querySelectorAll('#rightPanel .control-grid .grid-control-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Find the button that was clicked (either passed directly or via event)
      const targetBtn = buttonElement || event.currentTarget;
      if (targetBtn) {
        targetBtn.classList.add('active');
      }
      
      // Update HUD
      document.getElementById('currentTool').textContent = brush.toUpperCase();
      
      console.log('Selected brush:', brush);
    }
    
    // Select Mode (Additive/Subtractive)
    function selectMode(mode, buttonElement) {
      currentMode = mode;
      
      // Update button UI - only for mode buttons
      const modeButtons = buttonElement.parentElement.querySelectorAll('.grid-control-btn');
      modeButtons.forEach(btn => btn.classList.remove('active'));
      buttonElement.classList.add('active');
      
      document.getElementById('currentMode').textContent = mode.toUpperCase();
      console.log('Mode changed to:', mode);
    }
    
    // Select Primitive
    function selectPrimitive(primitive, buttonElement) {
      currentPrimitive = primitive;
      
      // Update button UI - find the primitive section specifically
      const primitiveSection = buttonElement.closest('.control-grid');
      if (primitiveSection) {
        primitiveSection.querySelectorAll('.grid-control-btn').forEach(btn => {
          btn.classList.remove('active');
        });
      }
      buttonElement.classList.add('active');
      
      document.getElementById('currentTool').textContent = primitive.toUpperCase();
      console.log('Primitive selected:', primitive);
    }
    
    // Select Angle
    function selectAngle(angle, buttonElement) {
      placementAngle = angle;
      
      // Update button UI - find the angle section specifically
      const angleSection = buttonElement.closest('.control-grid');
      if (angleSection) {
        angleSection.querySelectorAll('.grid-control-btn').forEach(btn => {
          btn.classList.remove('active');
        });
      }
      buttonElement.classList.add('active');
      
      console.log('Placement angle set to:', angle + '°');
    }
    
    // Place Primitive (called on mouse click)
    function placePrimitive(position) {
      if (!sculptScene) return;
      
      let geometry;
      const angleRad = (placementAngle * Math.PI) / 180;
      
      // Create primitive geometry
      switch(currentPrimitive) {
        case 'cylinder':
          geometry = new THREE.CylinderGeometry(primitiveSize, primitiveSize, primitiveSize * 2, 16);
          break;
        case 'pyramid':
          geometry = new THREE.ConeGeometry(primitiveSize, primitiveSize * 1.5, 4);
          break;
        case 'cube':
          geometry = new THREE.BoxGeometry(primitiveSize, primitiveSize, primitiveSize);
          break;
        case 'sphere':
          geometry = new THREE.SphereGeometry(primitiveSize, 16, 16);
          break;
        case 'cone':
          geometry = new THREE.ConeGeometry(primitiveSize, primitiveSize * 1.5, 16);
          break;
        case 'torus':
          geometry = new THREE.TorusGeometry(primitiveSize, primitiveSize * 0.3, 12, 24);
          break;
      }
      
      // Create material based on mode
      const material = new THREE.MeshStandardMaterial({
        color: currentMode === 'additive' ? 0x00ff66 : 0xff3333,
        transparent: true,
        opacity: 0.7,
        wireframe: false
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.rotation.z = angleRad; // Apply angle rotation
      mesh.userData.mode = currentMode;
      mesh.userData.primitive = currentPrimitive;
      
      sculptScene.add(mesh);
      
      console.log(`Placed ${currentMode} ${currentPrimitive} at`, position, `angle: ${placementAngle}°`);
    }

    // Update Slider Values
    function updateValue(param, value) {
      const displayValue = parseFloat(value).toFixed(2);
      const elementId = param + 'Value';
      const element = document.getElementById(elementId);
      if (element) {
        element.textContent = displayValue;
      }
      
      // Update sculpting parameters
      if (param === 'size') {
        brushSize = parseFloat(value);
      } else if (param === 'strength') {
        brushStrength = parseFloat(value);
      }
      
      console.log(`${param} updated to ${displayValue}`);
    }

    // Apply Transform
    function applyTransform(type) {
      console.log('Apply transform:', type);
      // Add visual feedback
      event.target.classList.add('active');
      setTimeout(() => event.target.classList.remove('active'), 200);
    }

    // Toggle Symmetry
    function toggleSymmetry(axis, element) {
      element.classList.toggle('active');
      const isActive = element.classList.contains('active');
      console.log(`Symmetry ${axis}: ${isActive ? 'ON' : 'OFF'}`);
    }

    // Select Color
    function selectColor(element) {
      document.querySelectorAll('.color-swatch').forEach(swatch => {
        swatch.classList.remove('active');
      });
      element.classList.add('active');
      console.log('Color selected:', element.style.background);
    }

    // Add Object
    function addObject(type) {
      console.log('Add object:', type);
      const currentCount = parseInt(document.getElementById('vertexCount').textContent.replace(',', ''));
      document.getElementById('vertexCount').textContent = (currentCount + 1024).toLocaleString();
    }

    // Apply Effect
    function applyEffect(effect) {
      console.log('Apply effect:', effect);
      event.target.classList.add('active');
      setTimeout(() => event.target.classList.remove('active'), 300);
    }

    // Layer Actions
    function layerAction(action) {
      console.log('Layer action:', action);
      if (action === 'add') {
        const current = parseInt(document.getElementById('layerValue').textContent);
        document.getElementById('layerValue').textContent = current + 1;
      }
    }

    // CSS Actions
    function cssAction(action) {
      console.log('CSS action:', action);
      event.target.classList.add('active');
      setTimeout(() => event.target.classList.remove('active'), 200);
    }

    // Show Quick Menu
    function showQuickMenu() {
      alert('Quick Actions Menu\n\n1. Save Project\n2. Export\n3. Undo\n4. Redo\n5. Reset View');
    }

    // Export Project
    function exportProject() {
      const projectData = {
        workspace: currentWorkspace,
        tool: currentTool,
        brush: currentBrush,
        timestamp: new Date().toISOString()
      };
      console.log('Exporting project:', projectData);
      alert('Project export complete!\nSaved to: pixelprodigy-project.json');
    }

    // FPS Counter
    let frameCount = 0;
    let lastTime = performance.now();
    
    function updateFPS() {
      frameCount++;
      const currentTime = performance.now();
      if (currentTime - lastTime >= 1000) {
        document.getElementById('fpsCounter').textContent = frameCount;
        frameCount = 0;
        lastTime = currentTime;
      }
      requestAnimationFrame(updateFPS);
    }
    updateFPS();

    // ============================================
    // SECRET EXPLORER MODE - HIDDEN ACCESS
    // ============================================
    
    let explorerMode = false;
    let secretKeySequence = [];
    const secretCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA']; // Konami Code + BA
    
    function activateExplorerMode() {
      explorerMode = true;
      document.body.classList.add('explorer-mode-active');
      document.getElementById('explorerHud').style.display = 'block';
      document.getElementById('navHud').style.display = 'none';
      
      // Hide all button cubes
      gridButtons.forEach(btn => {
        btn.visible = false;
      });
      
      // Create infinite grid
      createInfiniteGrid();
      
      console.log('%c🌌 EXPLORER MODE ACTIVATED 🌌', 'color: #ff00ff; font-size: 24px; font-weight: bold;');
      console.log('%cYou now have complete freedom to explore the 3D grid universe', 'color: #ffaaff; font-size: 14px;');
    }
    
    function deactivateExplorerMode() {
      explorerMode = false;
      document.body.classList.remove('explorer-mode-active');
      document.getElementById('explorerHud').style.display = 'none';
      document.getElementById('explorerPos').style.display = 'none';
      document.getElementById('navHud').style.display = 'block';
      
      // Show button cubes again
      gridButtons.forEach(btn => {
        btn.visible = true;
      });
      
      // Remove infinite grid
      if (infiniteGridHelper) {
        gridScene.remove(infiniteGridHelper);
      }
      
      console.log('Explorer Mode Deactivated');
    }
    
    // Click to start exploring
    document.getElementById('explorerHud').addEventListener('click', () => {
      document.getElementById('explorerHud').style.display = 'none';
      document.getElementById('explorerPos').style.display = 'block';
      gridCanvas.requestPointerLock();
    });
    
    // Keyboard Shortcuts
    document.addEventListener('keydown', (e) => {
      // Secret Code Detection
      secretKeySequence.push(e.code);
      if (secretKeySequence.length > secretCode.length) {
        secretKeySequence.shift();
      }
      
      if (JSON.stringify(secretKeySequence) === JSON.stringify(secretCode)) {
        if (!explorerMode) {
          activateExplorerMode();
        }
        secretKeySequence = [];
      }
      
      // Regular shortcuts
      if (e.ctrlKey) {
        switch(e.key) {
          case 's':
            e.preventDefault();
            exportProject();
            break;
          case 'z':
            e.preventDefault();
            console.log('Undo');
            break;
          case 'y':
            e.preventDefault();
            console.log('Redo');
            break;
        }
      }
      
      // Tool shortcuts (only if not in explorer mode)
      if (!explorerMode) {
        switch(e.key) {
          case 'g': console.log('Grab mode'); break;
          case 'r': console.log('Rotate mode'); break;
          case 's': if (!e.ctrlKey) console.log('Scale mode'); break;
          case 'x': console.log('Delete'); break;
        }
      }
    });

    // ============================================
    // THREE.JS 3D TRAVERSABLE GRID UNIVERSE
    // ============================================
    
    // Main 3D Grid Scene
    const gridCanvas = document.getElementById('gridCanvas3D');
    const gridScene = new THREE.Scene();
    const gridCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const gridRenderer = new THREE.WebGLRenderer({ canvas: gridCanvas, alpha: true });
    
    gridRenderer.setSize(window.innerWidth, window.innerHeight);
    gridCamera.position.set(0, 5, 20);
    
    // Universe Background Scene (separate layer)
    const universeCanvas = document.getElementById('universeCanvas');
    const universeScene = new THREE.Scene();
    const universeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const universeRenderer = new THREE.WebGLRenderer({ canvas: universeCanvas, alpha: true });
    
    universeRenderer.setSize(window.innerWidth, window.innerHeight);
    universeCamera.position.z = 30;
    
    // Add Orbital Controls
    const controls = new THREE.OrbitControls(universeCamera, universeRenderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.0;
    controls.minDistance = 10;
    controls.maxDistance = 100;
    
    // Create Starfield
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 3000;
    const starPositions = new Float32Array(starCount * 3);
    const starColors = new Float32Array(starCount * 3);
    
    for (let i = 0; i < starCount * 3; i += 3) {
      starPositions[i] = (Math.random() - 0.5) * 200;
      starPositions[i + 1] = (Math.random() - 0.5) * 200;
      starPositions[i + 2] = (Math.random() - 0.5) * 200;
      
      // Cyan/blue/purple color palette
      const colorType = Math.random();
      if (colorType < 0.33) {
        starColors[i] = 0;
        starColors[i + 1] = 1;
        starColors[i + 2] = 1;
      } else if (colorType < 0.66) {
        starColors[i] = 0.5;
        starColors[i + 1] = 0.5;
        starColors[i + 2] = 1;
      } else {
        starColors[i] = 1;
        starColors[i + 1] = 0;
        starColors[i + 2] = 1;
      }
    }
    
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
    
    const starMaterial = new THREE.PointsMaterial({
      size: 0.5,
      vertexColors: true,
      transparent: true,
      opacity: 0.8
    });
    
    const starField = new THREE.Points(starGeometry, starMaterial);
    universeScene.add(starField);
    
    // Add Grid Cube Frame
    const gridCubeEdges = new THREE.EdgesGeometry(new THREE.BoxGeometry(40, 40, 40));
    const gridCubeLine = new THREE.LineSegments(
      gridCubeEdges,
      new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 })
    );
    universeScene.add(gridCubeLine);
    
    // Render Loop
    function animateUniverse() {
      requestAnimationFrame(animateUniverse);
      controls.update();
      starField.rotation.y += 0.0001;
      gridCubeLine.rotation.x += 0.001;
      gridCubeLine.rotation.y += 0.001;
      universeRenderer.render(universeScene, universeCamera);
    }
    animateUniverse();
    
    // Handle Window Resize
    window.addEventListener('resize', () => {
      const aspect = window.innerWidth / window.innerHeight;
      universeCamera.aspect = aspect;
      universeCamera.updateProjectionMatrix();
      universeRenderer.setSize(window.innerWidth, window.innerHeight);
      
      gridCamera.aspect = aspect;
      gridCamera.updateProjectionMatrix();
      gridRenderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // ============================================
    // 3D ROOMS SYSTEM
    // ============================================
    
    let currentRoom = 'studio';
    const rooms = {};
    
    const roomConfigs = {
      studio: {
        name: '3D Studio',
        icon: '🎨',
        color: 0x00ffff,
        position: { x: 0, y: 0, z: 0 },
        tools: ['🖌️', '✏️', '✋', '〰️', '⬆️', '📍', '▭', '🧱', '⚡', '🎨', '🔄', '📐', '💫', '🎭', '🌟', '💎'],
        gridSize: 4
      },
      css: {
        name: 'CSS Designer',
        icon: '💅',
        color: 0xff00ff,
        position: { x: 100, y: 0, z: 0 },
        tools: ['🌈', '🌫️', '🔲', '🎬', '🔄', '🎭', '📐', '📏', '✨', '💫', '🎨', '🔮', '🌊', '⚡', '🔥', '❄️'],
        gridSize: 4
      },
      word: {
        name: 'WordWeaver',
        icon: '📝',
        color: 0x00ff00,
        position: { x: 0, y: 0, z: 100 },
        tools: ['📝', '✍️', '📖', '📄', '📋', '🔖', '📌', '✂️', '📎', '🔗', '💬', '💭', '🗨️', '📢', '📣', '📡'],
        gridSize: 4
      },
      campus: {
        name: 'Campus',
        icon: '🎓',
        color: 0xffff00,
        position: { x: -100, y: 0, z: 0 },
        tools: ['🎓', '📚', '📖', '🧮', '🔬', '🔭', '🧪', '⚗️', '🧬', '🔍', '📊', '📈', '📉', '💡', '🎯', '🏆'],
        gridSize: 4
      },
      perfect: {
        name: 'Perfect',
        icon: '✨',
        color: 0xff6600,
        position: { x: 0, y: 0, z: -100 },
        tools: ['✨', '💎', '🌟', '⭐', '🔆', '💫', '✴️', '🎆', '🎇', '🌠', '🌌', '🔮', '🎪', '🎭', '🎨', '🖼️'],
        gridSize: 4
      },
      universe: {
        name: 'Universe Hub',
        icon: '🌌',
        color: 0x9900ff,
        position: { x: 0, y: 50, z: 0 },
        tools: ['🌌', '🌠', '🪐', '🌍', '🌙', '☀️', '⭐', '🌟', '💫', '✨', '🔭', '🚀', '🛸', '👽', '🌈', '🔮'],
        gridSize: 4
      }
    };
    
    // ============================================
    // 3D TRAVERSABLE GRID SYSTEM
    // ============================================
    
    const gridButtons = [];
    let isNavigating = false;
    
    // Movement state
    const movement = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      up: false,
      down: false
    };
    
    const velocity = new THREE.Vector3();
    let moveSpeed = 0.15;
    let speedMultiplier = 1;
    let yaw = 0;
    let pitch = 0;
    let infiniteGridHelper = null;
    
    // Create Room with 3D Grid
    function createRoom(roomId) {
      const config = roomConfigs[roomId];
      const roomGroup = new THREE.Group();
      const buttons = [];
      
      const gridSize = config.gridSize;
      const spacing = 8;
      const geometry = new THREE.BoxGeometry(6, 6, 1);
      
      // Create room walls (hollow cube)
      const wallMaterial = new THREE.MeshPhongMaterial({
        color: config.color,
        transparent: true,
        opacity: 0.1,
        side: THREE.DoubleSide
      });
      
      const roomSize = gridSize * spacing + 20;
      
      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(roomSize, roomSize),
        wallMaterial
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -20;
      roomGroup.add(floor);
      
      // Walls with doorways
      const wallGeometry = new THREE.PlaneGeometry(roomSize, 40);
      
      const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
      backWall.position.z = -roomSize / 2;
      roomGroup.add(backWall);
      
      const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.x = -roomSize / 2;
      roomGroup.add(leftWall);
      
      const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.x = roomSize / 2;
      roomGroup.add(rightWall);
      
      // Room name label
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 128;
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, 512, 128);
      ctx.fillStyle = '#' + config.color.toString(16).padStart(6, '0');
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(config.icon + ' ' + config.name, 256, 80);
      
      const texture = new THREE.CanvasTexture(canvas);
      const labelMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      const label = new THREE.Mesh(new THREE.PlaneGeometry(20, 5), labelMaterial);
      label.position.set(0, 15, -roomSize / 2 + 1);
      roomGroup.add(label);
      
      // Create tool grid buttons
      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          const material = new THREE.MeshPhongMaterial({
            color: config.color,
            emissive: new THREE.Color(config.color),
            emissiveIntensity: 0.3,
            shininess: 100,
            transparent: true,
            opacity: 0.85
          });
          
          const cube = new THREE.Mesh(geometry, material);
          
          const posX = (x - gridSize / 2) * spacing + spacing / 2;
          const posY = (y - gridSize / 2) * spacing + spacing / 2;
          const posZ = -15;
          
          cube.position.set(posX, posY, posZ);
          cube.userData = {
            icon: config.tools[(x * gridSize + y) % config.tools.length],
            originalColor: material.color.clone(),
            isHovered: false,
            room: roomId
          };
          
          roomGroup.add(cube);
          buttons.push(cube);
          
          // Add wireframe outline
          const edges = new THREE.EdgesGeometry(geometry);
          const line = new THREE.LineSegments(
            edges,
            new THREE.LineBasicMaterial({ color: config.color, linewidth: 2 })
          );
          cube.add(line);
        }
      }
      
      // Position room in world space
      roomGroup.position.set(config.position.x, config.position.y, config.position.z);
      
      rooms[roomId] = {
        group: roomGroup,
        buttons: buttons,
        config: config
      };
      
      gridScene.add(roomGroup);
      
      return roomGroup;
    }
    
    // Initialize all rooms
    function initializeRooms() {
      Object.keys(roomConfigs).forEach(roomId => {
        createRoom(roomId);
      });
      
      // Update gridButtons to include all buttons from all rooms
      gridButtons.length = 0;
      Object.values(rooms).forEach(room => {
        gridButtons.push(...room.buttons);
      });
    }
    
    // Add Lighting to Grid Scene
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    gridScene.add(ambientLight);
    
    const pointLight1 = new THREE.PointLight(0x00ffff, 1, 100);
    pointLight1.position.set(20, 20, 20);
    gridScene.add(pointLight1);
    
    const pointLight2 = new THREE.PointLight(0xff00ff, 1, 100);
    pointLight2.position.set(-20, -20, 20);
    gridScene.add(pointLight2);
    
    initializeRooms();
    
    // Teleport to Room Function
    function teleportToRoom(roomId) {
      const room = rooms[roomId];
      if (!room) return;
      
    gridCanvas.addEventListener('click', () => {
      if (!isNavigating) {
        gridCanvas.requestPointerLock();
      }
    }); yaw = 0;
        pitch = 0;
        
        // Update active button
        document.querySelectorAll('.room-btn').forEach(btn => btn.classList.remove('active'));
        event?.target?.closest('.room-btn')?.classList.add('active');
        
        // Update lighting to match room color
        pointLight1.color.setHex(room.config.color);
        pointLight2.color.setHex(room.config.color);
        
        portal.classList.remove('active');
        
        console.log('🚪 Teleported to:', room.config.name);
      }, 250);
    }
    
    // Show room navigator when navigating
    document.addEventListener('pointerlockchange', () => {
      isPointerLocked = document.pointerLockElement === gridCanvas;
      isNavigating = isPointerLocked;
      document.getElementById('navHud').style.opacity = isNavigating ? '1' : '0.5';
      document.getElementById('roomNavigator').style.display = isNavigating ? 'block' : 'none';
    });
    
    // Mouse Look Controls
    let mouseX = 0;
    let mouseY = 0;
    let isPointerLocked = false;
    
    gridCanvas.addEventListener('click', () => {
      if (!isNavigating) {
        gridCanvas.requestPointerLock();
      }
    });
    
    document.addEventListener('pointerlockchange', () => {
      isPointerLocked = document.pointerLockElement === gridCanvas;
      isNavigating = isPointerLocked;
      document.getElementById('navHud').style.opacity = isNavigating ? '1' : '0.5';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (isPointerLocked) {
        mouseX += e.movementX * 0.002;
        mouseY += e.movementY * 0.002;
        mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
        
        yaw = mouseX;
        pitch = mouseY;
      }
    });
    
    // Keyboard Controls
    // Create Infinite Grid for Explorer Mode
    function createInfiniteGrid() {
      const size = 500;
      const divisions = 100;
      
      const gridHelper = new THREE.GridHelper(size, divisions, 0xff00ff, 0x00ffff);
      gridHelper.position.y = -10;
      gridScene.add(gridHelper);
      infiniteGridHelper = gridHelper;
      
      // Add vertical grids
      const verticalGrid1 = new THREE.GridHelper(size, divisions, 0xff00ff, 0x00ffff);
      verticalGrid1.rotation.z = Math.PI / 2;
      verticalGrid1.position.x = -10;
      gridScene.add(verticalGrid1);
      
      const verticalGrid2 = new THREE.GridHelper(size, divisions, 0xff00ff, 0x00ffff);
      verticalGrid2.rotation.x = Math.PI / 2;
      verticalGrid2.position.z = -10;
      gridScene.add(verticalGrid2);
      
      // Add ambient particles
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 1000;
      const positions = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 200;
      }
      
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const particleMaterial = new THREE.PointsMaterial({
        color: 0xff00ff,
        size: 0.5,
        transparent: true,
        opacity: 0.6
      });
      
      const particles = new THREE.Points(particleGeometry, particleMaterial);
      gridScene.add(particles);
    }
    
    document.addEventListener('keydown', (e) => {
      if (!isNavigating) return;
      
      switch(e.code) {
        case 'KeyW': movement.forward = true; break;
        case 'KeyS': movement.backward = true; break;
        case 'KeyA': movement.left = true; break;
        case 'KeyD': movement.right = true; break;
        case 'Space': movement.up = true; e.preventDefault(); break;
        case 'ShiftLeft': 
        case 'ShiftRight': movement.down = true; break;
        case 'KeyE': 
          if (explorerMode) {
            speedMultiplier = 3;
            document.getElementById('explorerSpeed').textContent = 'BOOST';
          }
          break;
        case 'KeyQ':
          if (explorerMode) {
            speedMultiplier = 0.3;
            document.getElementById('explorerSpeed').textContent = 'SLOW-MO';
          }
          break;
        case 'KeyR':
          if (explorerMode) {
            gridCamera.position.set(0, 5, 20);
            yaw = 0;
            pitch = 0;
          }
        case 'KeyR':
          if (explorerMode) {
            gridCamera.position.set(0, 5, 20);
            yaw = 0;
            pitch = 0;
          } else {
            // Reset to current room
            teleportToRoom(currentRoom);
          }
          break;
        case 'Digit1': teleportToRoom('studio'); break;
        case 'Digit2': teleportToRoom('css'); break;
        case 'Digit3': teleportToRoom('word'); break;
        case 'Digit4': teleportToRoom('campus'); break;
        case 'Digit5': teleportToRoom('perfect'); break;
        case 'Digit6': teleportToRoom('universe'); break;
      }
    });
    
    document.addEventListener('keyup', (e) => {
      switch(e.code) {
        case 'KeyW': movement.forward = false; break;
        case 'KeyS': movement.backward = false; break;
        case 'KeyA': movement.left = false; break;
        case 'KeyD': movement.right = false; break;
        case 'Space': movement.up = false; break;
        case 'ShiftLeft': movement.down = false; break;
      }
    });
    
    // Raycaster for button interaction (reuse existing one)
    const gridRaycaster = new THREE.Raycaster();
    const rayDirection = new THREE.Vector3(0, 0, -1);
    
    // Update Camera and Movement
    function updateGridNavigation() {
      if (!isNavigating) return;
      
      // Update camera rotation
      gridCamera.rotation.order = 'YXZ';
      gridCamera.rotation.y = -yaw;
      gridCamera.rotation.x = -pitch;
      
      // Calculate movement direction
      const forward = new THREE.Vector3(0, 0, -1);
      forward.applyQuaternion(gridCamera.quaternion);
      velocity.set(0, 0, 0);
      
      const currentSpeed = moveSpeed * speedMultiplier;
      
      if (movement.forward) velocity.add(forward.multiplyScalar(currentSpeed));
      if (movement.backward) velocity.add(forward.multiplyScalar(-currentSpeed));
      if (movement.left) velocity.add(right.multiplyScalar(-currentSpeed));
      if (movement.right) velocity.add(right.multiplyScalar(currentSpeed));
      if (movement.up) velocity.y += currentSpeed;
      if (movement.down) velocity.y -= currentSpeed;
      
      gridCamera.position.add(velocity);
      
      // Update position display in explorer mode
      if (explorerMode) {
        document.getElementById('posX').textContent = gridCamera.position.x.toFixed(2);
        document.getElementById('posY').textContent = gridCamera.position.y.toFixed(2);
        document.getElementById('posZ').textContent = gridCamera.position.z.toFixed(2);
      }
      if (movement.forward) velocity.add(forward.multiplyScalar(moveSpeed));
      if (movement.backward) velocity.add(forward.multiplyScalar(-moveSpeed));
      if (movement.left) velocity.add(right.multiplyScalar(-moveSpeed));
      if (movement.right) velocity.add(right.multiplyScalar(moveSpeed));
      if (movement.up) velocity.y += moveSpeed;
      if (movement.down) velocity.y -= moveSpeed;
      
      gridCamera.position.add(velocity);
      
      // Update raycaster for button hovering
      gridRaycaster.set(gridCamera.position, forward);
      const intersects = gridRaycaster.intersectObjects(gridButtons);
      
      // Reset all buttons
      gridButtons.forEach(btn => {
        if (btn.userData.isHovered) {
          btn.material.emissiveIntensity = 0.2;
          btn.scale.set(1, 1, 1);
          btn.userData.isHovered = false;
        }
      });
      
      // Highlight hovered button
      if (intersects.length > 0) {
        const btn = intersects[0].object;
        btn.userData.isHovered = true;
        btn.material.emissiveIntensity = 0.8;
        btn.scale.set(1.2, 1.2, 1.2);
        
        // Show icon in HUD
        document.getElementById('currentTool').textContent = btn.userData.icon + ' HOVERED';
      }
    }
    
    // Main Grid Animation Loop
    function animateGrid() {
      requestAnimationFrame(animateGrid);
      updateGridNavigation();
      
      // Rotate buttons slightly for visual effect
      gridButtons.forEach((btn, i) => {
        btn.rotation.y += 0.005;
        btn.rotation.z = Math.sin(Date.now() * 0.001 + i) * 0.1;
      });
      
      gridRenderer.render(gridScene, gridCamera);
    }
    animateGrid();
    
    // ============================================
    // HOLOGRAPHIC FLOATING CSS BUTTONS
    // ============================================
    
    const holoBg = document.getElementById('holoBg');
    const cssIcons = [
      { emoji: '🎨', label: 'Color' },
      { emoji: '🌈', label: 'Gradient' },
      { emoji: '✨', label: 'Glow' },
      { emoji: '🔄', label: 'Rotate' },
      { emoji: '📐', label: 'Grid' },
      { emoji: '💫', label: 'Animate' },
      { emoji: '🎭', label: 'Filter' },
      { emoji: '🌟', label: 'Shine' },
      { emoji: '💎', label: 'Gem' },
      { emoji: '🔮', label: 'Magic' },
      { emoji: '🌊', label: 'Wave' },
      { emoji: '⚡', label: 'Bolt' },
      { emoji: '🔥', label: 'Fire' },
      { emoji: '❄️', label: 'Frost' },
      { emoji: '🌌', label: 'Nebula' }
    ];
    
    cssIcons.forEach((item, i) => {
      const btn = document.createElement('div');
      btn.className = 'floating-css-button';
      btn.innerHTML = `<div>${item.emoji}</div><small>${item.label}</small>`;
      btn.style.left = (Math.random() * 80 + 10) + '%';
      btn.style.top = (Math.random() * 80 + 10) + '%';
      btn.style.animationDelay = (i * 1.5) + 's';
      btn.onclick = () => {
        console.log('Holographic button clicked:', item.label);
        btn.style.transform = 'scale(1.5) rotate(360deg)';
        setTimeout(() => btn.style.transform = '', 600);
      };
      holoBg.appendChild(btn);
    });
    
    // ============================================
    // GRID MODE TOGGLE (2D/3D)
    // ============================================
    
    let gridMode = '2d';
    
    function toggleGridMode() {
      gridMode = gridMode === '2d' ? '3d' : '2d';
      
      // Toggle all control grids
      document.querySelectorAll('.control-grid').forEach(grid => {
        grid.classList.toggle('mode-3d');
      });
      
      // Toggle viewport grid
      document.querySelector('.viewport-grid')?.classList.toggle('mode-3d');
      
      // Update button text
      const toggleBtn = event.target;
      toggleBtn.textContent = gridMode === '3d' ? '🔳 2D Grid' : '🔲 3D Grid';
      
      console.log('Grid mode switched to:', gridMode.toUpperCase());
    }
    
    // ============================================
    // ORBITAL CONTROL FUNCTIONS
    // ============================================
    
    function toggleOrbitalControl(type, element) {
      element.classList.toggle('active');
      const isActive = element.classList.contains('active');
      
      if (type === 'rotate') {
        controls.autoRotate = isActive;
        console.log('Auto-rotate:', isActive ? 'ON' : 'OFF');
      }
    }
    
    function updateOrbitalSpeed(value) {
      controls.autoRotateSpeed = parseFloat(value);
      console.log('Rotation speed:', value);
    }
    
    function updateOrbitalZoom(value) {
      const zoomFactor = parseFloat(value) / 100;
      universeCamera.position.z = 30 / zoomFactor;
      console.log('Zoom level:', value + '%');
    }
    
    function resetOrbitalView() {
      universeCamera.position.set(0, 0, 30);
      universeCamera.rotation.set(0, 0, 0);
      controls.reset();
      console.log('Orbital view reset');
    }
    
    function saveOrbitalView() {
      const viewState = {
        position: universeCamera.position.toArray(),
        rotation: universeCamera.rotation.toArray(),
        target: controls.target.toArray()
      };
      localStorage.setItem('orbitalView', JSON.stringify(viewState));
      console.log('Orbital view saved:', viewState);
      alert('Current view saved!');
    }
    
    function orbitalPreset(preset) {
      switch(preset) {
        case 'top':
          universeCamera.position.set(0, 40, 0);
          controls.target.set(0, 0, 0);
          break;
        case 'front':
          universeCamera.position.set(0, 0, 40);
          controls.target.set(0, 0, 0);
          break;
        case 'side':
          universeCamera.position.set(40, 0, 0);
          controls.target.set(0, 0, 0);
          break;
      }
      controls.update();
      console.log('Orbital preset:', preset);
    }
    
    // ============================================
    // UI GRID UNIVERSE SELECTOR
    // ============================================
    
    let currentUIGrid = 'main';
    const uiGridThemes = {
      main: { color: '#00ffff', name: 'Main Studio' },
      creative: { color: '#ff00ff', name: 'Creative Zone' },
      code: { color: '#00ff00', name: 'Code Lab' },
      data: { color: '#ffff00', name: 'Data Realm' },
      game: { color: '#ff6600', name: 'Game World' },
      ar: { color: '#0099ff', name: 'AR/VR Space' },
      ai: { color: '#ff0099', name: 'AI Laboratory' },
      custom: { color: '#ffffff', name: 'Custom Grid' }
    };
    
    function selectUIGrid(gridId) {
      currentUIGrid = gridId;
      const theme = uiGridThemes[gridId];
      
      // Update active button
      document.querySelectorAll('#rightPanel .control-grid .grid-control-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      // Apply theme color to UI elements
      document.documentElement.style.setProperty('--accent-color', theme.color);
      document.querySelectorAll('.grid-control-btn').forEach(btn => {
        btn.style.borderColor = theme.color + '44';
      });
      
      // Update HUD
      document.getElementById('currentMode').textContent = theme.name.toUpperCase();
      
      console.log('Switched to UI Grid:', theme.name);
    }
    
    // ============================================
    // ADVANCED TOOL FUNCTIONS
    // ============================================
    
    function advancedTool(tool) {
      console.log('Advanced tool selected:', tool);
      event.target.classList.add('active');
      setTimeout(() => event.target.classList.remove('active'), 300);
      
      const toolMessages = {
        physics: 'Physics simulation activated',
        particles: 'Particle system ready',
        boolean: 'Boolean operations enabled',
        array: 'Array modifier active',
        curve: 'Curve editor opened',
        modifier: 'Modifier stack updated',
        texture: 'Texture painter ready',
        bake: 'Baking in progress...'
      };
      
      if (toolMessages[tool]) {
        const statusIndicator = document.querySelector('.status-indicator');
        statusIndicator.style.background = '#00ff00';
        setTimeout(() => statusIndicator.style.background = '', 2000);
      }
    }

    console.log('PixelProdigy Unified Interface Loaded ✨');
    console.log('🌌 3D Grid Universe Active');
    console.log('🎮 Orbital Controls Enabled');
    console.log('✨ Holographic UI Loaded');
    console.log('Press Ctrl+S to save, G/R/S for transform modes');
  </script>
</body>
</html>
