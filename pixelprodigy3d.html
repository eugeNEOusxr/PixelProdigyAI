<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PixelProdigy Universe - Multi-Workspace Studio</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      height: 100vh;
    }

    #container {
      display: grid;
      grid-template-columns: 250px 1fr;
      grid-template-rows: 60px 1fr 40px;
      height: 100vh;
    }

    #header {
      grid-column: 1 / -1;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 20px;
    }

    #header h1 {
      font-size: 24px;
      font-weight: 600;
    }

    .workspace-tabs {
      display: flex;
      gap: 4px;
      flex: 1;
    }

    .workspace-tab {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: rgba(255, 255, 255, 0.7);
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 6px 6px 0 0;
      transition: all 0.2s;
      font-size: 13px;
      font-weight: 500;
    }

    .workspace-tab:hover {
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
    }

    .workspace-tab.active {
      background: #1a1a1a;
      color: #fff;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
    }

    #sidebar {
      background: #1a1a1a;
      padding: 20px;
      overflow-y: auto;
      border-right: 2px solid #333;
    }

    #viewport {
      background: #0f0f0f;
      position: relative;
      overflow: hidden;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
    }

    #footer {
      grid-column: 1 / -1;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      border-top: 2px solid #333;
      font-size: 13px;
      color: #888;
    }

    .section {
      margin-bottom: 25px;
    }

    .section-title {
      font-size: 12px;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 12px;
      font-weight: 600;
      letter-spacing: 1px;
    }

    .tool-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .tool-btn {
      background: #2a2a2a;
      border: 2px solid #3a3a3a;
      color: #fff;
      padding: 12px 8px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
      font-size: 13px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .tool-btn:hover {
      background: #3a3a3a;
      border-color: #667eea;
    }

    .tool-btn.active {
      background: #667eea;
      border-color: #764ba2;
      box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
    }

    .tool-icon {
      font-size: 24px;
    }

    .slider-control {
      margin-bottom: 15px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 12px;
      color: #aaa;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      background: #2a2a2a;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #667eea;
      cursor: pointer;
      border-radius: 50%;
      transition: all 0.2s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #764ba2;
      transform: scale(1.2);
    }

    .primitive-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #667eea;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="header">
      <h1>âš¡ PixelProdigy Universe</h1>
      <div class="workspace-tabs">
        <button class="workspace-tab active" onclick="switchWorkspace('sculpt', this)">3D Sculpt</button>
        <button class="workspace-tab" onclick="switchWorkspace('css', this)">CSS Designer</button>
        <button class="workspace-tab" onclick="switchWorkspace('word', this)">WordWeaver</button>
        <button class="workspace-tab" onclick="switchWorkspace('campus', this)">Campus</button>
        <button class="workspace-tab" onclick="switchWorkspace('perfect', this)">Perfect</button>
      </div>
      <div style="color: rgba(255,255,255,0.8); font-size: 14px;">Multi-Workspace Studio</div>
      
      <!-- Camera Controls -->
      <div style="display: flex; gap: 8px; margin-left: auto;">
        <button id="orbitToggle" onclick="toggleOrbitControls()" style="padding: 8px 16px; background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          ğŸ¥ Orbit: ON
        </button>
        <button id="walkModeToggle" onclick="toggleWalkMode()" style="padding: 8px 16px; background: rgba(255,165,0,0.15); border: 2px solid rgba(255,165,0,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          ğŸš¶ Walk Mode: OFF
        </button>
        <button id="thirdPersonToggle" onclick="toggle3rdPersonCamera()" style="padding: 8px 16px; background: rgba(33,150,243,0.15); border: 2px solid rgba(33,150,243,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          ğŸ® 3rd Person: AUTO
        </button>
      </div>
      
      <!-- Movement Info -->
      <div style="position: absolute; top: 70px; left: 20px; background: rgba(0,0,0,0.7); padding: 12px; border-radius: 8px; font-size: 12px; color: #fff; font-family: monospace;">
        <div style="margin-bottom: 4px;">ğŸ® <strong>CONTROLS:</strong></div>
        <div>W/S - Walk Forward/Back</div>
        <div>A/D - Turn Left/Right</div>
        <div><strong>SHIFT - Run (hold)</strong></div>
        <div>SPACE - Jump</div>
        <div>F - Flight Mode (Superman)</div>
        <div style="margin-top: 4px; font-size: 11px; opacity: 0.7;">Flight: SHIFT=Up, CTRL=Down</div>
      </div>
    </div>

    <div id="sidebar">
      <!-- Sculpt Workspace -->
      <div id="workspace-sculpt" class="workspace-content">
        <div class="section">
          <div class="section-title">ğŸ”§ Mode</div>
          <div class="tool-grid">
            <button class="tool-btn active" onclick="setMode('add', this)">
              <span class="tool-icon">â•</span>
              <span>Add</span>
            </button>
            <button class="tool-btn" onclick="setMode('subtract', this)">
              <span class="tool-icon">â–</span>
              <span>Subtract</span>
            </button>
          </div>
        </div>

        <div class="section">
          <div class="section-title">âœ‹ Manipulate</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="setTransformMode('translate')">
              <span class="tool-icon">â†”ï¸</span>
              <span>Move (W)</span>
            </button>
            <button class="tool-btn" onclick="setTransformMode('rotate')">
              <span class="tool-icon">ğŸ”„</span>
              <span>Rotate (E)</span>
            </button>
            <button class="tool-btn" onclick="setTransformMode('scale')">
              <span class="tool-icon">ğŸ“</span>
              <span>Scale (R)</span>
            </button>
          </div>
        </div>

        <div class="section">
          <div class="section-title">ğŸ¨ Primitives</div>
          <div class="primitive-grid">
            <button class="tool-btn active" onclick="setPrimitive('sphere', this)">
              <span class="tool-icon">âšª</span>
              <span>Sphere</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cube', this)">
              <span class="tool-icon">â¬›</span>
              <span>Cube</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cylinder', this)">
              <span class="tool-icon">ğŸ”µ</span>
              <span>Cylinder</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cone', this)">
              <span class="tool-icon">ğŸ”»</span>
              <span>Cone</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('torus', this)">
              <span class="tool-icon">ğŸ©</span>
              <span>Torus</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('pyramid', this)">
              <span class="tool-icon">ğŸ”º</span>
              <span>Pyramid</span>
            </button>
            <button class="tool-btn" onclick="loadHumanAnatomy(this)" style="grid-column: 1 / -1; background: rgba(102, 126, 234, 0.2);">
              <span class="tool-icon">ğŸ¦¾</span>
              <span>Load Arm (86V)</span>
            </button>
            <button class="tool-btn" onclick="loadBothArms(this)" style="grid-column: 1 / -1; background: rgba(63, 81, 181, 0.25); border: 2px solid rgba(63, 81, 181, 0.5);">
              <span class="tool-icon">ğŸ¦¾ğŸ¦¾</span>
              <span>Both Arms (172V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanLeg(this)" style="grid-column: 1 / -1; background: rgba(76, 175, 80, 0.2); border: 2px solid rgba(76, 175, 80, 0.4);">
              <span class="tool-icon">ğŸ¦µ</span>
              <span>Load Leg (86V)</span>
            </button>
            <button class="tool-btn" onclick="loadBothLegs(this)" style="grid-column: 1 / -1; background: rgba(46, 125, 50, 0.25); border: 2px solid rgba(46, 125, 50, 0.5);">
              <span class="tool-icon">ğŸ¦µğŸ¦µ</span>
              <span>Both Legs (172V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanTorso(this)" style="grid-column: 1 / -1; background: rgba(255, 193, 7, 0.2); border: 2px solid rgba(255, 193, 7, 0.4);">
              <span class="tool-icon">ğŸ¦´</span>
              <span>Load Torso (120V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanHead(this)" style="grid-column: 1 / -1; background: rgba(156, 39, 176, 0.2); border: 2px solid rgba(156, 39, 176, 0.4);">
              <span class="tool-icon">ğŸ§ </span>
              <span>Load Head (100V)</span>
            </button>
            <button class="tool-btn" onclick="loadFullBody(this)" style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(255, 64, 129, 0.3), rgba(63, 81, 181, 0.3)); border: 3px solid rgba(255, 255, 255, 0.6); box-shadow: 0 0 15px rgba(255, 64, 129, 0.4); font-weight: bold; font-size: 1.1em;">
              <span class="tool-icon">ğŸ§</span>
              <span>FULL BODY (564V)</span>
            </button>
            <button class="tool-btn" onclick="loadSkeletonBody(this)" style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(200, 200, 200, 0.3), rgba(100, 100, 100, 0.3)); border: 3px solid rgba(200, 200, 200, 0.6); box-shadow: 0 0 15px rgba(200, 200, 200, 0.4); font-weight: bold; font-size: 1.1em;">
              <span class="tool-icon">ğŸ’€</span>
              <span>BONES BODY (564V)</span>
            </button>
            <button class="tool-btn" onclick="openAnatomyEditor()" style="grid-column: 1 / -1; background: rgba(255, 165, 0, 0.2); border: 2px solid rgba(255, 165, 0, 0.4);">
              <span class="tool-icon">âœï¸</span>
              <span>Edit Anatomy (Advanced)</span>
            </button>
            <button class="tool-btn" onclick="toggleVertexEngine()" style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(138, 43, 226, 0.3)); border: 3px solid rgba(0, 255, 255, 0.6); box-shadow: 0 0 15px rgba(138, 43, 226, 0.4); font-weight: bold; font-size: 1.1em;">
              <span class="tool-icon">ğŸ”¬</span>
              <span>VERTEX ENGINE</span>
            </button>
          </div>
        </div>

        <!-- VERTEX ENGINE PANEL -->
        <div class="section" id="vertexEnginePanel" style="display: none;">
          <div class="section-title">ğŸ”¬ Vertex Engine - Microscopic Detail</div>
          
          <div style="background: rgba(0, 255, 255, 0.1); padding: 10px; border-radius: 5px; margin-bottom: 10px;">
            <div style="font-size: 0.9em; color: #0ff; margin-bottom: 5px;">
              <strong>Selected Object:</strong> <span id="vertexObjectName">None</span>
            </div>
            <div style="font-size: 0.9em; color: #0ff;">
              <strong>Total Vertices:</strong> <span id="vertexTotalCount">0</span>
            </div>
            <div style="font-size: 0.9em; color: #0ff;">
              <strong>Selected Vertex:</strong> <span id="vertexSelectedIndex">None</span>
            </div>
          </div>

          <!-- Quick Actions for Bodies -->
          <div style="margin-bottom: 15px;">
            <button onclick="analyzeFullBody()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, rgba(255, 64, 129, 0.3), rgba(63, 81, 181, 0.3)); border: 2px solid rgba(255, 64, 129, 0.5); border-radius: 5px; color: #fff; cursor: pointer; margin-bottom: 8px; font-weight: bold;">
              ğŸ§ Analyze Full Body
            </button>
            <button onclick="analyzeSkeletonBody()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, rgba(200, 200, 200, 0.3), rgba(100, 100, 100, 0.3)); border: 2px solid rgba(200, 200, 200, 0.5); border-radius: 5px; color: #fff; cursor: pointer; font-weight: bold;">
              ğŸ’€ Analyze Skeleton Body
            </button>
          </div>

          <!-- Vertex Visualization -->
          <div style="margin-bottom: 15px;">
            <label style="display: flex; align-items: center; gap: 10px; color: #fff; margin-bottom: 8px;">
              <input type="checkbox" id="showVertexPoints" onchange="toggleVertexVisualization(this.checked)" style="width: 18px; height: 18px;">
              <span>Show All Vertices (as points)</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; color: #fff; margin-bottom: 8px;">
              <input type="checkbox" id="showVertexNumbers" onchange="toggleVertexNumbers(this.checked)" style="width: 18px; height: 18px;">
              <span>Show Vertex Numbers</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; color: #fff;">
              <input type="checkbox" id="showWireframe" onchange="toggleWireframe(this.checked)" style="width: 18px; height: 18px;">
              <span>Wireframe Mode</span>
            </label>
          </div>

          <!-- Vertex Position Editor -->
          <div style="background: rgba(138, 43, 226, 0.2); padding: 12px; border-radius: 5px; margin-bottom: 10px;">
            <div style="color: #fff; font-weight: bold; margin-bottom: 8px;">ğŸ“ Vertex Position (XYZ)</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
              <div>
                <label style="color: #f00; font-size: 0.85em;">X</label>
                <input type="number" id="vertexPosX" step="0.01" onchange="updateVertexPosition()" 
                       style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); color: #f00; border: 1px solid #f00; border-radius: 3px;">
              </div>
              <div>
                <label style="color: #0f0; font-size: 0.85em;">Y</label>
                <input type="number" id="vertexPosY" step="0.01" onchange="updateVertexPosition()" 
                       style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); color: #0f0; border: 1px solid #0f0; border-radius: 3px;">
              </div>
              <div>
                <label style="color: #00f; font-size: 0.85em;">Z</label>
                <input type="number" id="vertexPosZ" step="0.01" onchange="updateVertexPosition()" 
                       style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); color: #00f; border: 1px solid #00f; border-radius: 3px;">
              </div>
            </div>
          </div>

          <!-- Sculpting Tools -->
          <div style="margin-bottom: 10px;">
            <div style="color: #fff; font-weight: bold; margin-bottom: 8px;">ğŸ¨ Sculpt Mode</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <button onclick="setSculptMode('push')" style="padding: 8px; background: rgba(255, 100, 100, 0.3); border: 2px solid rgba(255, 100, 100, 0.5); border-radius: 5px; color: #fff; cursor: pointer;">
                â¬†ï¸ Push
              </button>
              <button onclick="setSculptMode('pull')" style="padding: 8px; background: rgba(100, 100, 255, 0.3); border: 2px solid rgba(100, 100, 255, 0.5); border-radius: 5px; color: #fff; cursor: pointer;">
                â¬‡ï¸ Pull
              </button>
              <button onclick="setSculptMode('smooth')" style="padding: 8px; background: rgba(255, 255, 100, 0.3); border: 2px solid rgba(255, 255, 100, 0.5); border-radius: 5px; color: #fff; cursor: pointer;">
                âœ¨ Smooth
              </button>
              <button onclick="setSculptMode('inflate')" style="padding: 8px; background: rgba(100, 255, 100, 0.3); border: 2px solid rgba(100, 255, 100, 0.5); border-radius: 5px; color: #fff; cursor: pointer;">
                ğŸ’¨ Inflate
              </button>
            </div>
          </div>

          <!-- Brush Settings -->
          <div style="margin-bottom: 10px;">
            <label style="color: #fff; font-size: 0.9em; display: block; margin-bottom: 5px;">
              ğŸ–Œï¸ Brush Size: <span id="brushSizeValue">1.0</span>
            </label>
            <input type="range" id="brushSize" min="0.1" max="5.0" step="0.1" value="1.0" 
                   oninput="document.getElementById('brushSizeValue').textContent = this.value; updateBrushSize(this.value)"
                   style="width: 100%;">
            
            <label style="color: #fff; font-size: 0.9em; display: block; margin-bottom: 5px; margin-top: 8px;">
              ğŸ’ª Strength: <span id="sculptStrengthValue">0.5</span>
            </label>
            <input type="range" id="sculptStrength" min="0.1" max="2.0" step="0.1" value="0.5" 
                   oninput="document.getElementById('sculptStrengthValue').textContent = this.value; updateSculptStrength(this.value)"
                   style="width: 100%;">
          </div>

          <!-- Export Vertex Data -->
          <button onclick="smartExportVertices()" style="width: 100%; padding: 10px; background: rgba(0, 200, 0, 0.3); border: 2px solid rgba(0, 200, 0, 0.5); border-radius: 5px; color: #fff; cursor: pointer; margin-bottom: 8px;">
            ğŸ’¾ Export Vertex Coordinates (JSON)
          </button>
          
          <div style="font-size: 0.8em; color: #888; margin-bottom: 8px; text-align: center;">
            Exports selected object or entire body if body is loaded
          </div>

          <!-- Vertex Info Display -->
          <div id="vertexInfoDisplay" style="background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; font-family: monospace; font-size: 0.75em; color: #0ff; max-height: 200px; overflow-y: auto; display: none;">
            <!-- Vertex data will be displayed here -->
          </div>
        </div>

        <!-- ARM ARTICULATION -->
        <div class="section" id="armArticulation" style="display: none;">
          <div class="section-title">ğŸ’ª Arm Articulation</div>
          <div style="margin-bottom: 15px;">
            <label style="font-size: 12px; color: #888; display: flex; justify-content: space-between; margin-bottom: 5px;">
              <span>Elbow Angle</span>
              <span id="elbowAngleValue" style="color: #00ff88;">180Â°</span>
            </label>
            <input type="range" id="elbowAngle" min="180" max="340" value="180" step="1" 
                   oninput="updateElbowAngle(parseInt(this.value))"
                   style="width: 100%; cursor: pointer;">
            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;">
              <span>180Â° (straight)</span>
              <span>340Â° (bent)</span>
            </div>
          </div>
        </div>

        <!-- NECK SWIVEL -->
        <div class="section" id="neckSwivel" style="display: none;">
          <div class="section-title">ğŸ”„ Neck Swivel</div>
          <div style="margin-bottom: 15px;">
            <label style="font-size: 12px; color: #888; display: flex; justify-content: space-between; margin-bottom: 5px;">
              <span>Head Rotation</span>
              <span id="neckSwivelValue" style="color: #00ff88;">0Â°</span>
            </label>
            <input type="range" id="neckSwivelAngle" min="-180" max="180" value="0" step="1" 
                   oninput="updateNeckSwivel(parseInt(this.value))"
                   style="width: 100%; cursor: pointer;">
            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;">
              <span>-180Â° (left)</span>
              <span>0Â° (center)</span>
              <span>180Â° (right)</span>
            </div>
          </div>
        </div>

        <!-- LEARN MODE TOGGLE -->
        <div class="section">
          <div class="section-title">ğŸ“š Learn Mode</div>
          <button class="tool-btn" id="learnModeToggle" onclick="toggleLearnMode(this)" style="width: 100%; background: rgba(0, 255, 136, 0.1); border: 2px solid rgba(0, 255, 136, 0.3);">
            <span class="tool-icon">ğŸ‘¨â€ğŸ«</span>
            <span>Enable Story Mode</span>
          </button>
          <div id="learnModeInfo" style="display: none; margin-top: 10px; padding: 12px; background: rgba(0, 255, 136, 0.1); border-radius: 8px; font-size: 11px; line-height: 1.5; color: rgba(255, 255, 255, 0.9);">
            <strong>Learn Mode Active!</strong><br>
            Click any Mathematical Method below to see the mathematician's story and how their discovery powers your creations! ğŸ†
          </div>
        </div>

        <!-- MATHEMATICAL METHODS -->
        <div class="section">
          <div class="section-title">ğŸ† Mathematical Methods</div>
          <div class="tool-grid">
            <button class="tool-btn active" onclick="selectMethod('fibonacci', this)">
              <span class="tool-icon">ğŸ‡®ğŸ‡¹</span>
              <span>Fibonacci</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('catmull', this)">
              <span class="tool-icon">ğŸ‡ºğŸ‡¸</span>
              <span>Catmull-Rom</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('bezier', this)">
              <span class="tool-icon">ğŸ‡«ğŸ‡·</span>
              <span>BÃ©zier</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('perlin', this)">
              <span class="tool-icon">ğŸ®</span>
              <span>Perlin Noise</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('quaternion', this)">
              <span class="tool-icon">ğŸ‡®ğŸ‡ª</span>
              <span>Quaternion</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('lsystem', this)">
              <span class="tool-icon">ğŸ‡­ğŸ‡º</span>
              <span>L-System</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('voronoi', this)">
              <span class="tool-icon">ğŸ‡ºğŸ‡¦</span>
              <span>Voronoi</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('phong', this)">
              <span class="tool-icon">ğŸ‡»ğŸ‡³</span>
              <span>Phong</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('delaunay', this)">
              <span class="tool-icon">ğŸ‡·ğŸ‡º</span>
              <span>Delaunay</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('subdivision', this)">
              <span class="tool-icon">ğŸ’</span>
              <span>Subdivision</span>
            </button>
          </div>
        </div>

        <!-- MATHEMATICIAN STORY PANEL -->
        <div id="mathematicianStory" class="section" style="display: none;">
          <div class="section-title" id="storyTitle">ğŸ† Mathematician Story</div>
          <div style="padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 2px solid rgba(102, 126, 234, 0.3);">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
              <span id="storyFlag" style="font-size: 24px;">ğŸ‡®ğŸ‡¹</span>
              <div>
                <div id="storyName" style="font-weight: 700; font-size: 14px; color: #00ff88;">Leonardo Fibonacci</div>
                <div id="storyDates" style="font-size: 11px; opacity: 0.8;">1170-1250</div>
              </div>
            </div>
            <div id="storyDiscovery" style="font-size: 12px; font-weight: 600; color: #667eea; margin-bottom: 8px;">
              Discovery: Fibonacci Sequence
            </div>
            <div id="storyText" style="font-size: 11px; line-height: 1.6; margin-bottom: 10px; color: rgba(255, 255, 255, 0.9);">
              Italian mathematician who discovered the famous sequence (0,1,1,2,3,5,8...) while studying rabbit populations.
            </div>
            <div style="background: rgba(0, 255, 136, 0.1); padding: 8px; border-radius: 6px; border-left: 3px solid #00ff88;">
              <div style="font-size: 10px; font-weight: 700; color: #00ff88; margin-bottom: 4px;">ğŸ’¡ KID FACT:</div>
              <div id="storyKidFact" style="font-size: 11px; line-height: 1.5;">
                He introduced Arabic numerals (0-9) to Europe! Before him, Europeans used Roman numerals.
              </div>
            </div>
          </div>
        </div>

        <div class="section">
          <div class="section-title">âš™ï¸ Settings</div>
          <div class="slider-control">
            <div class="slider-label">
              <span>Size</span>
              <span id="sizeValue">0.5</span>
            </div>
            <input type="range" min="0.1" max="2" step="0.1" value="0.5" oninput="updateSize(this.value)">
          </div>
          <div class="slider-control">
            <div class="slider-label">
              <span>Angle</span>
              <span id="angleValue">0Â°</span>
            </div>
            <input type="range" min="0" max="360" step="15" value="0" oninput="updateAngle(this.value)">
          </div>
        </div>

        <div class="section">
          <div class="section-title">ğŸ¯ Actions</div>
          <button class="tool-btn" onclick="clearScene()" style="width: 100%; grid-column: 1 / -1;">
            <span class="tool-icon">ğŸ—‘ï¸</span>
            <span>Clear All</span>
          </button>
        </div>
      </div>

      <!-- CSS Designer Workspace -->
      <div id="workspace-css" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">ğŸ’… CSS Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Gradient generator coming soon!')">
              <span class="tool-icon">ğŸŒˆ</span>
              <span>Gradient</span>
            </button>
            <button class="tool-btn" onclick="alert('Shadow generator coming soon!')">
              <span class="tool-icon">ğŸŒ«ï¸</span>
              <span>Shadow</span>
            </button>
            <button class="tool-btn" onclick="alert('Border designer coming soon!')">
              <span class="tool-icon">ğŸ”²</span>
              <span>Border</span>
            </button>
            <button class="tool-btn" onclick="alert('Animation builder coming soon!')">
              <span class="tool-icon">ğŸ¬</span>
              <span>Animate</span>
            </button>
          </div>
        </div>
      </div>

      <!-- WordWeaver Workspace -->
      <div id="workspace-word" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">ğŸ“ Writing Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Text editor coming soon!')">
              <span class="tool-icon">âœï¸</span>
              <span>Editor</span>
            </button>
            <button class="tool-btn" onclick="alert('Templates coming soon!')">
              <span class="tool-icon">ğŸ“„</span>
              <span>Templates</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Campus Workspace -->
      <div id="workspace-campus" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">ğŸ« Campus Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Building designer coming soon!')">
              <span class="tool-icon">ğŸ¢</span>
              <span>Buildings</span>
            </button>
            <button class="tool-btn" onclick="alert('Layout planner coming soon!')">
              <span class="tool-icon">ğŸ—ºï¸</span>
              <span>Layout</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Perfect Workspace -->
      <div id="workspace-perfect" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">âœ¨ Perfect Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Perfect system coming soon!')">
              <span class="tool-icon">â­</span>
              <span>Optimize</span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <div id="viewport">
      <canvas id="canvas"></canvas>
      <div class="loading" id="loading">Initializing 3D Engine...</div>
    </div>

    <div id="footer">
      <div>Workspace: <strong id="workspaceDisplay">3D SCULPT</strong> | Mode: <strong id="modeDisplay">ADD</strong> | Primitive: <strong id="primitiveDisplay">SPHERE</strong></div>
      <div>Click viewport to place objects | Drag to rotate view</div>
      <div>Objects: <strong id="objectCount">0</strong> | Vertices: <strong id="vertexCount">0</strong></div>
    </div>
  </div>

  <script src="lib/three.min.js"></script>
  <script src="lib/OrbitControls.js"></script>
  <script src="lib/TransformControls.js"></script>
  <script>
    // State
    let scene, camera, renderer, controls, transformControl;
    let currentMode = 'add';
    let currentPrimitive = 'sphere';
    let primitiveSize = 0.5;
    let rotationAngle = 0;
    let objects = [];
    let selectedObject = null;
    let selectionBox = null; // Visual selection indicator
    let orbitEnabled = true; // Camera orbit control state
    let currentArmGroup = null; // Reference to loaded arm for articulation
    let armForearmPart = null; // Reference to forearm+hand section
    let currentHeadGroup = null; // Reference to loaded head
    let headNeckSwivel = null; // Reference to neck swivel group
    
    // Full body part references (for hierarchical selection)
    let fullBodyGroup = null;
    let bodyPartMap = new Map(); // Maps mesh objects to their body part names and control groups
    let selectedBodyPart = null; // Currently selected body part
    let bodyPartControlMode = null; // 'shoulder', 'elbow', 'wrist', 'hip', 'knee', 'ankle', 'neck'
    
    // Walking/Running animation state
    let walkModeEnabled = false; // Toggle between stationary animation and forward movement
    let thirdPersonCamera = 'auto'; // 'auto', 'always', 'never' - 3rd person camera mode
    let walkCycleSpeed = 0; // 0 = stopped, 1-3 = walking, 4+ = running
    let walkCyclePhase = 0; // Current phase in walk cycle (0 to 2*PI)
    let lastWheelTime = 0;
    let walkDecayRate = 0.95; // How quickly walking slows down
    let leftLegGroup = null; // Reference to left leg for animation
    let rightLegGroup = null; // Reference to right leg for animation
    let leftArmGroupRef = null; // Reference to left arm for swing
    let rightArmGroupRef = null; // Reference to right arm for swing
    let leftForearmGroup = null; // Reference to left forearm for elbow bend
    let rightForearmGroup = null; // Reference to right forearm for elbow bend
    let leftKneeGroup = null; // Reference to left lower leg (for knee flexion)
    let rightKneeGroup = null; // Reference to right lower leg (for knee flexion)
    let leftFootGroup = null; // Reference to left foot (for heel-toe placement)
    let rightFootGroup = null; // Reference to right foot (for heel-toe placement)
    
    // Advanced movement state
    let isJumping = false;
    let jumpVelocity = 0;
    let gravity = -0.02;
    let groundLevel = 0;
    let flightModeEnabled = false;
    let verticalVelocity = 0;
    
    // Movement input state (for smooth controls)
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let moveUp = false;
    let moveDown = false;
    let isRunning = false; // Shift key for running
    
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();

    // Initialize
    function init() {
      const canvas = document.getElementById('canvas');
      
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);
      scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);

      // Camera
      camera = new THREE.PerspectiveCamera(
        75,
        canvas.parentElement.offsetWidth / canvas.parentElement.offsetHeight,
        0.1,
        1000
      );
      camera.position.set(5, 5, 5);

      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.parentElement.offsetWidth, canvas.parentElement.offsetHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 2;
      controls.maxDistance = 50;

      // Transform Controls for object manipulation
      transformControl = new THREE.TransformControls(camera, renderer.domElement);
      transformControl.addEventListener('dragging-changed', function(event) {
        controls.enabled = !event.value;
      });
      scene.add(transformControl);
      
      // Keyboard: W=move, E=rotate, R=scale, Delete=remove
      window.addEventListener('keydown', function(event) {
        switch(event.key.toLowerCase()) {
          case 'w': 
            if (selectedObject) setTransformMode('translate');
            break;
          case 'e': 
            if (selectedObject) setTransformMode('rotate');
            break;
          case 'r': 
            if (selectedObject) setTransformMode('scale');
            break;
          case 'delete':
          case 'backspace':
            if (selectedObject) {
              scene.remove(selectedObject);
              objects = objects.filter(obj => obj !== selectedObject);
              transformControl.detach();
              selectedObject = null;
              
              // Remove selection box
              if (selectionBox) {
                scene.remove(selectionBox);
                selectionBox = null;
              }
              
              updateObjectCount();
            }
            break;
        }
      });

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 10, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0x667eea, 1, 100);
      pointLight.position.set(-5, 5, -5);
      scene.add(pointLight);

      // Ground plane
      const groundGeometry = new THREE.PlaneGeometry(50, 50);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a,
        roughness: 0.8,
        metalness: 0.2
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid
      const gridHelper = new THREE.GridHelper(50, 50, 0x667eea, 0x2a2a2a);
      scene.add(gridHelper);

      // Events
      canvas.addEventListener('click', onCanvasClick);
      canvas.addEventListener('wheel', onMouseWheel, { passive: false });
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);

      // Hide loading
      document.getElementById('loading').style.display = 'none';

      // Start animation
      animate();
    }
    
    // Keyboard controls for body movement
    function onKeyDown(event) {
      if (!window.fullBodyGroup) return;
      
      // Prevent default for space (no page scroll)
      if (event.key === ' ') {
        event.preventDefault();
      }
      
      switch(event.key.toLowerCase()) {
        case 'w':
        case 'arrowup':
          moveForward = true;
          if (!walkModeEnabled) {
            walkModeEnabled = true;
            controls.enabled = false;
            console.log('ğŸš¶ Walk Mode: ENABLED');
          }
          break;
        case 's':
        case 'arrowdown':
          moveBackward = true;
          if (!walkModeEnabled) {
            walkModeEnabled = true;
            controls.enabled = false;
            console.log('ğŸš¶ Walk Mode: ENABLED');
          }
          break;
        case 'a':
        case 'arrowleft':
          moveLeft = true;
          break;
        case 'd':
        case 'arrowright':
          moveRight = true;
          break;
        case ' ':
          // Jump (only if not in flight mode and on ground)
          if (!flightModeEnabled && !isJumping && Math.abs(window.fullBodyGroup.position.y - groundLevel) < 0.1) {
            isJumping = true;
            jumpVelocity = 0.3;
            console.log('â¬†ï¸ JUMP!');
          }
          break;
        case 'f':
          // Toggle flight mode
          flightModeEnabled = !flightModeEnabled;
          if (flightModeEnabled) {
            console.log('âœˆï¸ FLIGHT MODE: ENABLED (Superman pose)');
            isJumping = false;
            jumpVelocity = 0;
          } else {
            console.log('âœˆï¸ FLIGHT MODE: DISABLED');
          }
          break;
        case 'shift':
          // Hold shift for running OR ascend in flight mode
          isRunning = true;
          if (flightModeEnabled) {
            moveUp = true;
          }
          break;
        case 'control':
          // Hold ctrl for descend in flight mode
          if (flightModeEnabled) {
            moveDown = true;
          }
          break;
      }
    }
    
    function onKeyUp(event) {
      switch(event.key.toLowerCase()) {
        case 'w':
        case 'arrowup':
          moveForward = false;
          break;
        case 's':
        case 'arrowdown':
          moveBackward = false;
          break;
        case 'a':
        case 'arrowleft':
          moveLeft = false;
          break;
        case 'd':
        case 'arrowright':
          moveRight = false;
          break;
        case 'shift':
          isRunning = false;
          moveUp = false;
          break;
        case 'control':
          moveDown = false;
          break;
      }
    }

    // Toggle orbit controls on/off
    function toggleOrbitControls() {
      orbitEnabled = !orbitEnabled;
      controls.enabled = orbitEnabled;
      
      const btn = document.getElementById('orbitToggle');
      if (orbitEnabled) {
        btn.textContent = 'ğŸ¥ Orbit: ON';
        btn.style.background = 'rgba(76, 175, 80, 0.3)';
        btn.style.borderColor = 'rgba(76, 175, 80, 0.6)';
      } else {
        btn.textContent = 'ğŸ¥ Orbit: OFF';
        btn.style.background = 'rgba(244, 67, 54, 0.3)';
        btn.style.borderColor = 'rgba(244, 67, 54, 0.6)';
      }
      
      console.log(`ğŸ¥ Orbit controls: ${orbitEnabled ? 'ENABLED' : 'DISABLED'}`);
    }
    
    // Toggle Walk Mode (stationary animation vs. forward movement)
    function toggleWalkMode() {
      walkModeEnabled = !walkModeEnabled;
      
      const btn = document.getElementById('walkModeToggle');
      if (walkModeEnabled) {
        btn.textContent = 'ğŸš¶ Walk Mode: ON';
        btn.style.background = 'rgba(255, 165, 0, 0.3)';
        btn.style.borderColor = 'rgba(255, 165, 0, 0.6)';
        console.log('ğŸš¶ WALK MODE ENABLED: Body will move forward when scrolling!');
        console.log('   â†’ Scroll mouse wheel to walk/run through the scene');
        console.log('   â†’ Camera follows body automatically');
        
        // Disable orbit controls in walk mode
        if (orbitEnabled) {
          toggleOrbitControls();
        }
      } else {
        btn.textContent = 'ğŸš¶ Walk Mode: OFF';
        btn.style.background = 'rgba(255,165,0,0.15)';
        btn.style.borderColor = 'rgba(255,165,0,0.3)';
        console.log('ğŸš¶ Walk Mode DISABLED: Body stays in place (stationary animation)');
        
        // Re-enable orbit controls
        if (!orbitEnabled) {
          toggleOrbitControls();
        }
      }
    }
    
    // Toggle 3rd person camera mode
    function toggle3rdPersonCamera() {
      const modes = ['auto', 'always', 'never'];
      const currentIndex = modes.indexOf(thirdPersonCamera);
      thirdPersonCamera = modes[(currentIndex + 1) % modes.length];
      
      const btn = document.getElementById('thirdPersonToggle');
      if (thirdPersonCamera === 'auto') {
        btn.textContent = 'ğŸ® 3rd Person: AUTO';
        btn.style.background = 'rgba(33,150,243,0.15)';
        btn.style.borderColor = 'rgba(33,150,243,0.3)';
        console.log('ğŸ® 3rd Person: AUTO - Activates in Walk/Flight Mode');
      } else if (thirdPersonCamera === 'always') {
        btn.textContent = 'ğŸ® 3rd Person: ALWAYS';
        btn.style.background = 'rgba(76,175,80,0.3)';
        btn.style.borderColor = 'rgba(76,175,80,0.6)';
        console.log('ğŸ® 3rd Person: ALWAYS ON - Game camera always active');
        controls.enabled = false; // Disable orbit when always on
      } else {
        btn.textContent = 'ğŸ® 3rd Person: NEVER';
        btn.style.background = 'rgba(244,67,54,0.3)';
        btn.style.borderColor = 'rgba(244,67,54,0.6)';
        console.log('ğŸ® 3rd Person: NEVER - Free camera only');
      }
    }
    
    // Procedural walking/running animation with realistic biomechanics + WASD movement + Jump + Flight
    function updateWalkingAnimation() {
      if (!window.fullBodyGroup) return;
      
      // === MOVEMENT PROCESSING ===
      const moveSpeed = 0.1;
      const turnSpeed = 0.03;
      let isMoving = moveForward || moveBackward || moveLeft || moveRight;
      
      // Update rotation based on left/right
      if (moveLeft) {
        window.fullBodyGroup.rotation.y += turnSpeed;
      }
      if (moveRight) {
        window.fullBodyGroup.rotation.y -= turnSpeed;
      }
      
      // === FLIGHT MODE ===
      if (flightModeEnabled) {
        // Superman pose: Arms extended forward, legs straight back
        if (leftArmGroupRef && rightArmGroupRef) {
          leftArmGroupRef.rotation.x = -Math.PI / 2; // Forward
          rightArmGroupRef.rotation.x = -Math.PI / 2;
          
          // Straighten elbows
          if (leftForearmGroup) leftForearmGroup.rotation.x = 0;
          if (rightForearmGroup) rightForearmGroup.rotation.x = 0;
        }
        
        // Legs straight back
        if (leftLegGroup && rightLegGroup) {
          leftLegGroup.rotation.x = Math.PI / 6; // Slight back angle
          rightLegGroup.rotation.x = Math.PI / 6;
          
          // Straight knees
          if (leftKneeGroup) leftKneeGroup.rotation.x = 0;
          if (rightKneeGroup) rightKneeGroup.rotation.x = 0;
          
          // Point toes
          if (leftFootGroup) leftFootGroup.rotation.x = -0.3;
          if (rightFootGroup) rightFootGroup.rotation.x = -0.3;
        }
        
        // Flight movement
        const bodyRotation = window.fullBodyGroup.rotation.y;
        if (moveForward) {
          window.fullBodyGroup.position.x += Math.sin(bodyRotation) * moveSpeed;
          window.fullBodyGroup.position.z += Math.cos(bodyRotation) * moveSpeed;
        }
        if (moveBackward) {
          window.fullBodyGroup.position.x -= Math.sin(bodyRotation) * moveSpeed * 0.5;
          window.fullBodyGroup.position.z -= Math.cos(bodyRotation) * moveSpeed * 0.5;
        }
        if (moveUp) {
          window.fullBodyGroup.position.y += moveSpeed * 0.5;
        }
        if (moveDown) {
          window.fullBodyGroup.position.y -= moveSpeed * 0.5;
          if (window.fullBodyGroup.position.y < groundLevel) {
            window.fullBodyGroup.position.y = groundLevel;
          }
        }
        
        // 3rd person camera for flight (behind and slightly above)
        const bodyPos = window.fullBodyGroup.position.clone();
        const cameraDistance = 10;
        const cameraHeight = 3;
        
        const cameraOffset = new THREE.Vector3(
          -Math.sin(bodyRotation) * cameraDistance,
          cameraHeight,
          -Math.cos(bodyRotation) * cameraDistance
        );
        
        const targetCameraPos = bodyPos.clone().add(cameraOffset);
        camera.position.lerp(targetCameraPos, 0.08);
        camera.lookAt(bodyPos);
        
        return; // Skip walking animation
      }
      
      // === JUMP PHYSICS ===
      if (isJumping) {
        // Squat pose before/during jump
        if (leftLegGroup && rightLegGroup && leftKneeGroup && rightKneeGroup) {
          const squatAmount = Math.max(0, 1 - jumpVelocity * 3); // Squat more at start
          leftKneeGroup.rotation.x = squatAmount * 1.2; // Bend knees back
          rightKneeGroup.rotation.x = squatAmount * 1.2;
          leftLegGroup.rotation.x = -squatAmount * 0.3; // Lean forward slightly
          rightLegGroup.rotation.x = -squatAmount * 0.3;
        }
        
        // Arms swing up during jump
        if (leftArmGroupRef && rightArmGroupRef) {
          const armSwing = -jumpVelocity * 2;
          leftArmGroupRef.rotation.x = armSwing;
          rightArmGroupRef.rotation.x = armSwing;
        }
        
        // Apply jump physics
        window.fullBodyGroup.position.y += jumpVelocity;
        jumpVelocity += gravity;
        
        // Land
        if (window.fullBodyGroup.position.y <= groundLevel) {
          window.fullBodyGroup.position.y = groundLevel;
          isJumping = false;
          jumpVelocity = 0;
          console.log('ğŸ¯ Landed!');
        }
      }
      
      // === WALKING/RUNNING ANIMATION ===
      if (isMoving && !isJumping && !flightModeEnabled) {
        // Gradual acceleration: Start with paced walk, Shift for run
        const targetSpeed = isRunning ? 8 : 3; // Walk: 3, Run: 8
        const acceleration = isRunning ? 0.3 : 0.2; // Run accelerates faster
        
        if (moveForward) {
          walkCycleSpeed = Math.min(walkCycleSpeed + acceleration, targetSpeed);
        } else if (moveBackward) {
          walkCycleSpeed = Math.min(walkCycleSpeed + 0.15, 2); // Slower backward
        }
        lastWheelTime = Date.now();
      }
      
      // Decay walk speed when not moving
      if (!isMoving || isJumping) {
        walkCycleSpeed *= 0.85; // Slower deceleration for smoother stop
        if (walkCycleSpeed < 0.01) {
          walkCycleSpeed = 0;
          walkCyclePhase = 0;
        }
      }
      
      // Only animate walking if speed > 0
      if (walkCycleSpeed > 0 && leftLegGroup && rightLegGroup && leftKneeGroup && rightKneeGroup) {
        // Determine animation speed based on current walk speed
        const isRunningAnim = walkCycleSpeed > 5;
        const cycleSpeedMultiplier = isRunningAnim ? 0.15 : 0.08;
        walkCyclePhase += walkCycleSpeed * cycleSpeedMultiplier;
        
        // === BIOMECHANICAL WALKING CYCLE ===
        const legSwingAmplitude = isRunningAnim ? 0.6 : 0.4;
        const kneeFlexionMax = isRunningAnim ? 1.2 : 0.8;
        const armSwingAmplitude = isRunningAnim ? 0.5 : 0.3;
        
        // === RIGHT LEG CYCLE ===
        const rightPhase = walkCyclePhase % (Math.PI * 2);
        const rightHipSwing = Math.sin(rightPhase) * legSwingAmplitude;
        rightLegGroup.rotation.x = rightHipSwing;
        
        // Right knee flexion
        if (rightPhase < Math.PI) {
          const flexProgress = Math.sin(rightPhase);
          rightKneeGroup.rotation.x = flexProgress * kneeFlexionMax;
        } else {
          const stanceProgress = Math.sin(rightPhase - Math.PI);
          rightKneeGroup.rotation.x = stanceProgress * 0.2;
        }
        
        // Right foot heel-toe (FORWARD) or ball-pivot (BACKWARD)
        if (moveBackward) {
          // BACKWARD WALKING: Ball of foot pivots first, toe stays down, swing back in arc
          if (rightPhase < Math.PI * 0.2) {
            // Initial pivot on ball of foot (toe down, heel starting to lift)
            rightFootGroup.rotation.x = -0.5; // Plantarflexion - toe down
          } else if (rightPhase < Math.PI * 0.5) {
            // Swing phase: foot arcs back with toe pointed
            const swingProgress = (rightPhase - Math.PI * 0.2) / (Math.PI * 0.3);
            rightFootGroup.rotation.x = -0.5 + (swingProgress * 0.3); // Toe gradually comes up
          } else if (rightPhase < Math.PI) {
            // Landing: foot comes down flat for stance
            rightFootGroup.rotation.x = -0.1; // Nearly flat
          } else {
            // Stance phase: foot flat on ground
            rightFootGroup.rotation.x = 0;
          }
        } else {
          // FORWARD WALKING: Normal heel-toe pattern
          if (rightPhase < Math.PI * 0.3) {
            rightFootGroup.rotation.x = 0.3;
          } else if (rightPhase < Math.PI * 0.7) {
            rightFootGroup.rotation.x = 0;
          } else if (rightPhase < Math.PI) {
            rightFootGroup.rotation.x = -0.4;
          } else {
            rightFootGroup.rotation.x = 0.1;
          }
        }
        
        // === LEFT LEG CYCLE ===
        const leftPhase = (walkCyclePhase + Math.PI) % (Math.PI * 2);
        const leftHipSwing = Math.sin(leftPhase) * legSwingAmplitude;
        leftLegGroup.rotation.x = leftHipSwing;
        
        // Left knee flexion
        if (leftPhase < Math.PI) {
          const flexProgress = Math.sin(leftPhase);
          leftKneeGroup.rotation.x = flexProgress * kneeFlexionMax;
        } else {
          const stanceProgress = Math.sin(leftPhase - Math.PI);
          leftKneeGroup.rotation.x = stanceProgress * 0.2;
        }
        
        // Left foot heel-toe (FORWARD) or ball-pivot (BACKWARD)
        if (moveBackward) {
          // BACKWARD WALKING: Ball of foot pivots first, toe stays down, swing back in arc
          if (leftPhase < Math.PI * 0.2) {
            // Initial pivot on ball of foot (toe down, heel starting to lift)
            leftFootGroup.rotation.x = -0.5; // Plantarflexion - toe down
          } else if (leftPhase < Math.PI * 0.5) {
            // Swing phase: foot arcs back with toe pointed
            const swingProgress = (leftPhase - Math.PI * 0.2) / (Math.PI * 0.3);
            leftFootGroup.rotation.x = -0.5 + (swingProgress * 0.3); // Toe gradually comes up
          } else if (leftPhase < Math.PI) {
            // Landing: foot comes down flat for stance
            leftFootGroup.rotation.x = -0.1; // Nearly flat
          } else {
            // Stance phase: foot flat on ground
            leftFootGroup.rotation.x = 0;
          }
        } else {
          // FORWARD WALKING: Normal heel-toe pattern
          if (leftPhase < Math.PI * 0.3) {
            leftFootGroup.rotation.x = 0.3;
          } else if (leftPhase < Math.PI * 0.7) {
            leftFootGroup.rotation.x = 0;
          } else if (leftPhase < Math.PI) {
            leftFootGroup.rotation.x = -0.4;
          } else {
            leftFootGroup.rotation.x = 0.1;
          }
        }
        
        // === ARM SWING ===
        const leftArmSwing = Math.sin(leftPhase) * armSwingAmplitude;
        const rightArmSwing = Math.sin(rightPhase) * armSwingAmplitude;
        
        if (leftArmGroupRef) {
          leftArmGroupRef.rotation.x = leftArmSwing;
          if (leftForearmGroup) {
            const elbowBendAmplitude = isRunningAnim ? 0.4 : 0.25;
            const elbowBend = Math.max(0, -leftArmSwing) * elbowBendAmplitude;
            leftForearmGroup.rotation.x = elbowBend;
          }
        }
        if (rightArmGroupRef) {
          rightArmGroupRef.rotation.x = rightArmSwing;
          if (rightForearmGroup) {
            const elbowBendAmplitude = isRunningAnim ? 0.4 : 0.25;
            const elbowBend = Math.max(0, -rightArmSwing) * elbowBendAmplitude;
            rightForearmGroup.rotation.x = elbowBend;
          }
        }
        
        // === BODY BOB ===
        const bobAmount = isRunningAnim ? 0.15 : 0.08;
        const bodyBob = Math.abs(Math.sin(walkCyclePhase * 2)) * bobAmount;
        window.fullBodyGroup.position.y = groundLevel + bodyBob;
        
        // === FORWARD/BACKWARD MOVEMENT ===
        const bodyRotation = window.fullBodyGroup.rotation.y;
        if (moveForward) {
          const forwardSpeed = isRunningAnim ? 0.08 : 0.04;
          window.fullBodyGroup.position.x += Math.sin(bodyRotation) * walkCycleSpeed * forwardSpeed;
          window.fullBodyGroup.position.z += Math.cos(bodyRotation) * walkCycleSpeed * forwardSpeed;
        }
        if (moveBackward) {
          const backwardSpeed = 0.02; // Slower backward walk
          window.fullBodyGroup.position.x -= Math.sin(bodyRotation) * walkCycleSpeed * backwardSpeed;
          window.fullBodyGroup.position.z -= Math.cos(bodyRotation) * walkCycleSpeed * backwardSpeed;
        }
        
        // === 3RD PERSON CAMERA (Game-style) ===
        const shouldUse3rdPerson = thirdPersonCamera === 'always' || 
                                   (thirdPersonCamera === 'auto' && (walkModeEnabled || flightModeEnabled));
        
        if (shouldUse3rdPerson) {
          const bodyRotation = window.fullBodyGroup.rotation.y;
          const bodyPos = window.fullBodyGroup.position.clone();
          
          // Camera positioned behind and HIGH above character (bird's eye view)
          const cameraDistance = 8; // Distance behind character
          const cameraHeight = 27; // Height above character (MUCH higher - no more staring at ass!)
          const lookAtHeight = 5; // Look at character's head/upper body
          
          // Calculate camera position behind character (rotates with character)
          const cameraOffset = new THREE.Vector3(
            -Math.sin(bodyRotation) * cameraDistance, // Behind (negative forward)
            cameraHeight,
            -Math.cos(bodyRotation) * cameraDistance
          );
          
          const targetCameraPos = bodyPos.clone().add(cameraOffset);
          const lookAtTarget = bodyPos.clone().add(new THREE.Vector3(0, lookAtHeight, 0));
          
          // Smooth camera movement (lerp for cinematic feel)
          camera.position.lerp(targetCameraPos, 0.1);
          camera.lookAt(lookAtTarget);
        }
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      
      // Update walking/running animation
      updateWalkingAnimation();
      
      // Update selection box to follow selected object
      if (selectionBox && selectedObject) {
        selectionBox.update();
      }
      
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const canvas = document.getElementById('canvas');
      camera.aspect = canvas.parentElement.offsetWidth / canvas.parentElement.offsetHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.parentElement.offsetWidth, canvas.parentElement.offsetHeight);
    }

    function onCanvasClick(event) {
      const canvas = document.getElementById('canvas');
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      // Check if clicking existing object to select it
      const intersects = raycaster.intersectObjects(objects, true);
      
      if (intersects.length > 0) {
        // Check if this is a body part (for hierarchical control)
        const clickedMesh = intersects[0].object;
        const bodyPartInfo = getBodyPartFromMesh(clickedMesh);
        
        if (bodyPartInfo) {
          handleBodyPartSelection(bodyPartInfo, clickedMesh);
          return;
        }
        
        // Find the root object (in case of groups like anatomical arm)
        let clickedObject = intersects[0].object;
        while (clickedObject.parent && !objects.includes(clickedObject)) {
          clickedObject = clickedObject.parent;
        }
        
        selectedObject = clickedObject;
        selectedBodyPart = null; // Clear body part selection when selecting whole object
        bodyPartControlMode = null;
        
        // If Vertex Engine is active, analyze this object's vertices
        if (vertexEngineActive) {
          analyzeObjectVertices(clickedObject);
        }
        
        // Don't auto-attach transform, just select
        console.log('âœ… Object selected - Click Move/Rotate/Scale or press W/E/R');
        return;
      }
      
      // Otherwise place new object on ground
      if (currentMode === 'add') {
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(groundPlane, intersectPoint);

        if (intersectPoint) {
          placePrimitive(intersectPoint);
        }
      }
    }
    
    // Detect which body part was clicked
    function getBodyPartFromMesh(mesh) {
      // Traverse up to find labeled groups
      let current = mesh;
      while (current) {
        if (current.userData && current.userData.bodyPart) {
          return {
            part: current.userData.bodyPart,
            group: current.userData.controlGroup || current,
            name: current.userData.partName || current.userData.bodyPart
          };
        }
        current = current.parent;
      }
      return null;
    }
    
    // Handle body part selection and enable specific controls
    function handleBodyPartSelection(bodyPartInfo, mesh) {
      selectedBodyPart = bodyPartInfo.group;
      bodyPartControlMode = bodyPartInfo.part;
      
      console.log(`ğŸ¯ Selected: ${bodyPartInfo.name}`);
      
      // Enable specific controls based on body part
      switch(bodyPartInfo.part) {
        case 'leftArm':
        case 'rightArm':
          console.log('ğŸ’ª ARM CONTROL: Click and drag to rotate at shoulder');
          console.log('   Hold SHIFT + drag for elbow bend');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'leftHand':
        case 'rightHand':
          console.log('âœ‹ HAND CONTROL: Mouse wheel to rotate wrist');
          console.log('   Click and drag to move hand position');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'head':
          console.log('ğŸ§  HEAD CONTROL: Click and drag to swivel neck');
          console.log('   Or use neck swivel slider');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          document.getElementById('neckSwivelControls').style.display = 'block';
          break;
          
        case 'leftLeg':
        case 'rightLeg':
          console.log('ğŸ¦µ LEG CONTROL: Click and drag to rotate at hip');
          console.log('   Hold SHIFT + drag for knee bend');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'torso':
          console.log('ğŸ¦´ TORSO CONTROL: Click and drag to bend/twist spine');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        case 'leftFoot':
        case 'rightFoot':
          console.log('ğŸ‘Ÿ FOOT CONTROL: Click and drag to rotate ankle');
          attachTransformControl(bodyPartInfo.group, 'rotate');
          break;
          
        default:
          console.log('âœ… Body part selected');
          break;
      }
      
      // Select the root object for whole-body movement
      selectedObject = fullBodyGroup || objects.find(obj => obj.children.length > 0);
    }
    
    // Mouse wheel handler for wrist/hand rotation OR walking animation
    function onMouseWheel(event) {
      // If hand is selected, rotate wrist
      if (selectedBodyPart && (bodyPartControlMode === 'leftHand' || bodyPartControlMode === 'rightHand')) {
        event.preventDefault();
        const rotationSpeed = 0.002;
        const delta = event.deltaY * rotationSpeed;
        selectedBodyPart.rotation.z += delta;
        console.log(`âœ‹ Wrist rotation: ${(selectedBodyPart.rotation.z * 180 / Math.PI).toFixed(1)}Â°`);
        return;
      }
      
      // If whole body is selected OR clicking on body triggers walking/running
      // Check if fullBodyGroup exists and either selected or we're in the scene
      if (window.fullBodyGroup && !selectedBodyPart) {
        event.preventDefault();
        
        // Update walk speed based on wheel delta
        const wheelSpeed = Math.abs(event.deltaY) / 100;
        walkCycleSpeed = Math.min(walkCycleSpeed + wheelSpeed, 10); // Cap at 10 (full sprint)
        lastWheelTime = Date.now();
        
        // Log state changes
        if (walkCycleSpeed < 1 && walkCycleSpeed > 0) {
          console.log('ğŸš¶ Starting to walk...');
        } else if (walkCycleSpeed > 4 && walkCycleSpeed < 5) {
          console.log('ğŸƒ Breaking into a run!');
        } else if (walkCycleSpeed > 7) {
          console.log('ğŸ’¨ Full sprint!');
        }
        
        return;
      }
    }

    function placePrimitive(position) {
      let geometry;
      
      switch(currentPrimitive) {
        case 'sphere':
          geometry = new THREE.SphereGeometry(primitiveSize, 32, 32);
          break;
        case 'cube':
          geometry = new THREE.BoxGeometry(primitiveSize, primitiveSize, primitiveSize);
          break;
        case 'cylinder':
          geometry = new THREE.CylinderGeometry(primitiveSize, primitiveSize, primitiveSize * 2, 32);
          break;
        case 'cone':
          geometry = new THREE.ConeGeometry(primitiveSize, primitiveSize * 2, 32);
          break;
        case 'torus':
          geometry = new THREE.TorusGeometry(primitiveSize, primitiveSize * 0.3, 16, 32);
          break;
        case 'pyramid':
          geometry = new THREE.ConeGeometry(primitiveSize, primitiveSize * 1.5, 4);
          break;
      }

      const material = new THREE.MeshStandardMaterial({
        color: currentMode === 'add' ? 0x00ff88 : 0xff3366,
        roughness: 0.7,
        metalness: 0.3,
        transparent: true,
        opacity: 0.9
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.position.y = primitiveSize / 2;
      mesh.rotation.y = (rotationAngle * Math.PI) / 180;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData.mode = currentMode;

      scene.add(mesh);
      objects.push(mesh);
      
      updateObjectCount();
      console.log(`Placed ${currentPrimitive} at`, position);
    }

    function setMode(mode, btn) {
      currentMode = mode;
      document.querySelectorAll('#sidebar .tool-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('modeDisplay').textContent = mode.toUpperCase();
      
      // Detach transform and remove selection box when switching to add mode
      if (mode === 'add' && selectedObject) {
        transformControl.detach();
        selectedObject = null;
        
        if (selectionBox) {
          scene.remove(selectionBox);
          selectionBox = null;
        }
      }
    }

    function setTransformMode(mode) {
      if (!selectedObject) {
        alert('âš ï¸ Click an object first to select it!\n\n1. Click any object in the scene\n2. Then use Move/Rotate/Scale buttons\n3. Or press W/E/R keys');
        return;
      }
      
      // Disable orbit controls when using transform
      if (orbitEnabled) {
        orbitEnabled = false;
        controls.enabled = false;
        const btn = document.getElementById('orbitToggle');
        btn.textContent = 'ğŸ¥ Orbit: OFF';
        btn.style.background = 'rgba(244, 67, 54, 0.3)';
        btn.style.borderColor = 'rgba(244, 67, 54, 0.6)';
      }
      
      transformControl.setMode(mode);
      
      // Show selection box when entering transform mode
      if (!selectionBox && selectedObject) {
        selectionBox = new THREE.BoxHelper(selectedObject, 0x00ff88);
        scene.add(selectionBox);
      }
      console.log(`ğŸ¨ Transform mode: ${mode.toUpperCase()}`);
    }

    function setPrimitive(primitive, btn) {
      currentPrimitive = primitive;
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('primitiveDisplay').textContent = primitive.toUpperCase();
    }

    // ğŸ¦¾ HUMAN ANATOMY LOADER (86-Vertex System)
    function loadHumanAnatomy(btn) {
      console.log('ğŸ¦¾ Loading 86-vertex human anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical arm with 86 vertices
      const armGroup = new THREE.Group();
      const vertexCount = 86;
      
      // Shoulder (origin point)
      const shoulderGeom = new THREE.SphereGeometry(0.3, 8, 8);
      const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
      armGroup.add(shoulder);
      
      // Upper arm (14" / 35cm extended cylinder)
      const upperArmGeom = new THREE.CylinderGeometry(0.2, 0.18, 3.5, 16);
      const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
      upperArm.position.y = -1.75;
      armGroup.add(upperArm);
      
      // Elbow joint (180Â° pivot capability)
      const elbowGeom = new THREE.SphereGeometry(0.22, 8, 8);
      const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const elbow = new THREE.Mesh(elbowGeom, elbowMat);
      elbow.position.y = -3.5;
      armGroup.add(elbow);
      
      // Create forearm group for articulation (rotates at elbow)
      const forearmGroup = new THREE.Group();
      forearmGroup.position.y = -3.5; // At elbow position
      armGroup.add(forearmGroup);
      
      // Forearm (14" / 35cm) - relative to elbow
      const forearmGeom = new THREE.CylinderGeometry(0.18, 0.15, 3.5, 16);
      const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const forearm = new THREE.Mesh(forearmGeom, forearmMat);
      forearm.position.y = -1.75; // Relative to elbow
      forearmGroup.add(forearm);
      
      // Wrist joint
      const wristGeom = new THREE.SphereGeometry(0.16, 8, 8);
      const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const wrist = new THREE.Mesh(wristGeom, wristMat);
      wrist.position.y = -3.5; // Relative to elbow
      forearmGroup.add(wrist);
      
      // Wrist bone protrusion (270-300Â° styloid process)
      const wristBoneGeom = new THREE.SphereGeometry(0.01, 8, 8);
      const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
      wristBone.position.set(0.15, -3.5, 0); // Relative to elbow
      forearmGroup.add(wristBone);
      
      // Hand (oval with 40% growth + curl)
      const handGeom = new THREE.BoxGeometry(0.4, 0.6, 0.15);
      const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const hand = new THREE.Mesh(handGeom, handMat);
      hand.position.y = -4.3; // Relative to elbow
      hand.rotation.x = Math.PI / 8; // 45Â° curl
      forearmGroup.add(hand);
      
      // Thumb (190Â° hump alignment)
      const thumbGeom = new THREE.CylinderGeometry(0.08, 0.06, 0.5, 8);
      const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const thumb = new THREE.Mesh(thumbGeom, thumbMat);
      thumb.position.set(-0.25, -4.1, 0.1); // Relative to elbow
      thumb.rotation.z = -Math.PI / 3;
      forearmGroup.add(thumb);
      
      // 4 Fingers (progressive sizing: 3.5" base, -10% per finger)
      const fingerLengths = [0.875, 0.7875, 0.7, 0.6125];
      for (let i = 0; i < 4; i++) {
        const fingerGeom = new THREE.CylinderGeometry(0.06 * (1 - i * 0.1), 0.04 * (1 - i * 0.1), fingerLengths[i], 8);
        const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const finger = new THREE.Mesh(fingerGeom, fingerMat);
        finger.position.set(-0.15 + (i * 0.1), -4.8, 0); // Relative to elbow
        finger.rotation.x = Math.PI / 12;
        forearmGroup.add(finger);
        
        // Fingertip (spherical)
        const tipGeom = new THREE.SphereGeometry(0.05 * (1 - i * 0.1), 8, 8);
        const tipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const tip = new THREE.Mesh(tipGeom, tipMat);
        tip.position.set(-0.15 + (i * 0.1), -4.8 - fingerLengths[i] / 2, 0); // Relative to elbow
        forearmGroup.add(tip);
      }
      
      // Store references for articulation
      currentArmGroup = armGroup;
      armForearmPart = forearmGroup;
      
      // Position the arm group so hand rests on ground
      armGroup.position.set(0, 8.75, 0);
      scene.add(armGroup);
      objects.push(armGroup);
      
      // Show articulation controls
      document.getElementById('armArticulation').style.display = 'block';
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HUMAN ARM (${vertexCount}V)`;
      
      console.log(`âœ… Anatomical arm loaded: ${vertexCount} vertices - shoulder, upper arm, elbow, forearm, wrist, hand, thumb, 4 fingers - ARTICULATION ENABLED`);
    }
    
    // ğŸ¦¾ğŸ¦¾ DUAL ARMS LOADER (172 Vertices Total)
    function loadBothArms(btn) {
      console.log('ğŸ¦¾ğŸ¦¾ Loading both arms (left + right)...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      const bothArmsGroup = new THREE.Group();
      const totalVertexCount = 172;
      
      // Helper function to create a single arm
      function createArm(xOffset, isRight = false) {
        const armGroup = new THREE.Group();
        
        // Shoulder
        const shoulderGeom = new THREE.SphereGeometry(0.3, 8, 8);
        const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
        armGroup.add(shoulder);
        
        // Upper arm
        const upperArmGeom = new THREE.CylinderGeometry(0.2, 0.18, 3.5, 16);
        const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
        upperArm.position.y = -1.75;
        armGroup.add(upperArm);
        
        // Elbow joint
        const elbowGeom = new THREE.SphereGeometry(0.22, 8, 8);
        const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const elbow = new THREE.Mesh(elbowGeom, elbowMat);
        elbow.position.y = -3.5;
        armGroup.add(elbow);
        
        // Forearm group for articulation
        const forearmGroup = new THREE.Group();
        forearmGroup.position.y = -3.5;
        armGroup.add(forearmGroup);
        
        // Forearm
        const forearmGeom = new THREE.CylinderGeometry(0.18, 0.15, 3.5, 16);
        const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const forearm = new THREE.Mesh(forearmGeom, forearmMat);
        forearm.position.y = -1.75;
        forearmGroup.add(forearm);
        
        // Wrist
        const wristGeom = new THREE.SphereGeometry(0.16, 8, 8);
        const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const wrist = new THREE.Mesh(wristGeom, wristMat);
        wrist.position.y = -3.5;
        forearmGroup.add(wrist);
        
        // Wrist bone (mirror for right arm)
        const wristBoneGeom = new THREE.SphereGeometry(0.01, 8, 8);
        const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
        wristBone.position.set(isRight ? -0.15 : 0.15, -3.5, 0);
        forearmGroup.add(wristBone);
        
        // Hand
        const handGeom = new THREE.BoxGeometry(0.4, 0.6, 0.15);
        const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hand = new THREE.Mesh(handGeom, handMat);
        hand.position.y = -4.3;
        hand.rotation.x = Math.PI / 8;
        forearmGroup.add(hand);
        
        // Thumb (mirror position for right arm)
        const thumbGeom = new THREE.CylinderGeometry(0.08, 0.06, 0.5, 8);
        const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thumb = new THREE.Mesh(thumbGeom, thumbMat);
        thumb.position.set(isRight ? 0.25 : -0.25, -4.1, 0.1);
        thumb.rotation.z = isRight ? Math.PI / 3 : -Math.PI / 3;
        forearmGroup.add(thumb);
        
        // 4 Fingers
        const fingerLengths = [0.875, 0.7875, 0.7, 0.6125];
        for (let i = 0; i < 4; i++) {
          const fingerGeom = new THREE.CylinderGeometry(0.06 * (1 - i * 0.1), 0.04 * (1 - i * 0.1), fingerLengths[i], 8);
          const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const finger = new THREE.Mesh(fingerGeom, fingerMat);
          const xPos = isRight ? 0.15 - (i * 0.1) : -0.15 + (i * 0.1);
          finger.position.set(xPos, -4.8, 0);
          finger.rotation.x = Math.PI / 12;
          forearmGroup.add(finger);
          
          // Fingertip
          const tipGeom = new THREE.SphereGeometry(0.05 * (1 - i * 0.1), 8, 8);
          const tipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const tip = new THREE.Mesh(tipGeom, tipMat);
          tip.position.set(xPos, -4.8 - fingerLengths[i] / 2, 0);
          forearmGroup.add(tip);
        }
        
        // Position arm at shoulder offset
        armGroup.position.set(xOffset, 0, 0);
        
        return { armGroup, forearmGroup };
      }
      
      // Create left arm (negative X)
      const leftArm = createArm(-1.2, false);
      bothArmsGroup.add(leftArm.armGroup);
      
      // Create right arm (positive X)
      const rightArm = createArm(1.2, true);
      bothArmsGroup.add(rightArm.armGroup);
      
      // Position both arms at shoulder height
      bothArmsGroup.position.set(0, 8.75, 0);
      scene.add(bothArmsGroup);
      objects.push(bothArmsGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `BOTH ARMS (${totalVertexCount}V)`;
      
      console.log(`âœ… Both arms loaded: ${totalVertexCount} vertices (86V Ã— 2) - left shoulder at X=-1.2, right shoulder at X=1.2`);
    }
    
    // Update elbow angle (180Â° = straight, 340Â° = fully bent)
    function updateElbowAngle(angle) {
      if (!armForearmPart) {
        console.warn('âš ï¸ No arm loaded for articulation');
        return;
      }
      
      // Convert angle to radians (180Â° = 0 rad, 340Â° = bent forward)
      // Rotate around X axis to bend elbow
      const bendAngle = (angle - 180) * (Math.PI / 180);
      armForearmPart.rotation.x = bendAngle;
      
      // Update display
      document.getElementById('elbowAngleValue').textContent = angle + 'Â°';
      
      console.log(`ğŸ’ª Elbow angle: ${angle}Â° (${bendAngle.toFixed(2)} rad)`);
    }

    // ğŸ¦µ HUMAN LEG LOADER (86-Vertex System)
    function loadHumanLeg(btn) {
      console.log('ğŸ¦µ Loading 86-vertex leg anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical leg with 86 vertices
      const legGroup = new THREE.Group();
      const vertexCount = 86;
      
      // Hip joint (origin point)
      const hipGeom = new THREE.SphereGeometry(0.35, 8, 8);
      const hipMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const hip = new THREE.Mesh(hipGeom, hipMat);
      legGroup.add(hip);
      
      // Thigh (14" / 35cm extended cylinder)
      const thighGeom = new THREE.CylinderGeometry(0.25, 0.22, 3.5, 16);
      const thighMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const thigh = new THREE.Mesh(thighGeom, thighMat);
      thigh.position.y = -1.75;
      legGroup.add(thigh);
      
      // Knee joint (180Â° pivot capability)
      const kneeGeom = new THREE.SphereGeometry(0.24, 8, 8);
      const kneeMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const knee = new THREE.Mesh(kneeGeom, kneeMat);
      knee.position.y = -3.5;
      legGroup.add(knee);
      
      // Calf (14" / 35cm)
      const calfGeom = new THREE.CylinderGeometry(0.22, 0.18, 3.5, 16);
      const calfMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const calf = new THREE.Mesh(calfGeom, calfMat);
      calf.position.y = -5.25;
      legGroup.add(calf);
      
      // Ankle joint
      const ankleGeom = new THREE.SphereGeometry(0.18, 8, 8);
      const ankleMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const ankle = new THREE.Mesh(ankleGeom, ankleMat);
      ankle.position.y = -7;
      legGroup.add(ankle);
      
      // Ankle bone protrusion (malleolus)
      const ankleBoneGeom = new THREE.SphereGeometry(0.012, 8, 8);
      const ankleBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const ankleBone = new THREE.Mesh(ankleBoneGeom, ankleBoneMat);
      ankleBone.position.set(0.18, -7, 0);
      legGroup.add(ankleBone);
      
      // Foot (elongated with 40% growth)
      const footGeom = new THREE.BoxGeometry(0.35, 0.25, 0.8);
      const footMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const foot = new THREE.Mesh(footGeom, footMat);
      foot.position.set(0, -7.3, 0.3);
      foot.rotation.x = -Math.PI / 16; // Slight arch
      legGroup.add(foot);
      
      // Big toe (larger and separate)
      const bigToeGeom = new THREE.CylinderGeometry(0.07, 0.05, 0.35, 8);
      const bigToeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const bigToe = new THREE.Mesh(bigToeGeom, bigToeMat);
      bigToe.position.set(-0.12, -7.5, 0.65);
      bigToe.rotation.x = Math.PI / 2;
      legGroup.add(bigToe);
      
      // 4 Toes (progressive sizing: smaller than big toe, decreasing)
      const toeLengths = [0.28, 0.26, 0.24, 0.22]; // Progressive reduction
      for (let i = 0; i < 4; i++) {
        const toeGeom = new THREE.CylinderGeometry(0.045 * (1 - i * 0.08), 0.03 * (1 - i * 0.08), toeLengths[i], 8);
        const toeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const toe = new THREE.Mesh(toeGeom, toeMat);
        toe.position.set(-0.05 + (i * 0.08), -7.5, 0.65);
        toe.rotation.x = Math.PI / 2;
        legGroup.add(toe);
        
        // Toe tip (spherical)
        const toeTipGeom = new THREE.SphereGeometry(0.035 * (1 - i * 0.08), 8, 8);
        const toeTipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const toeTip = new THREE.Mesh(toeTipGeom, toeTipMat);
        toeTip.position.set(-0.05 + (i * 0.08), -7.5, 0.65 + toeLengths[i] / 2);
        legGroup.add(toeTip);
      }
      
      // Position the leg group so foot rests on ground (foot bottom is at ~Y=-7.5, so lift by 7.5)
      legGroup.position.set(0, 7.5, 0);
      scene.add(legGroup);
      objects.push(legGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HUMAN LEG (${vertexCount}V)`;
      
      console.log(`âœ… Anatomical leg loaded: ${vertexCount} vertices - hip, thigh, knee, calf, ankle, foot, big toe, 4 toes`);
    }

    // ï¿½ğŸ¦µ BOTH LEGS LOADER (172 Vertices Total - 86V each)
    function loadBothLegs(btn) {
      console.log('ğŸ¦µğŸ¦µ Loading both legs with symmetry...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Helper function to create a single leg with mirroring
      function createLeg(xOffset, isRight) {
        const legGroup = new THREE.Group();
        
        // Hip joint (origin point)
        const hipGeom = new THREE.SphereGeometry(0.35, 8, 8);
        const hipMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hip = new THREE.Mesh(hipGeom, hipMat);
        legGroup.add(hip);
        
        // Thigh (14" / 35cm extended cylinder)
        const thighGeom = new THREE.CylinderGeometry(0.25, 0.22, 3.5, 16);
        const thighMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thigh = new THREE.Mesh(thighGeom, thighMat);
        thigh.position.y = -1.75;
        legGroup.add(thigh);
        
        // Knee joint (180Â° pivot capability)
        const kneeGeom = new THREE.SphereGeometry(0.24, 8, 8);
        const kneeMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const knee = new THREE.Mesh(kneeGeom, kneeMat);
        knee.position.y = -3.5;
        legGroup.add(knee);
        
        // Calf (14" / 35cm)
        const calfGeom = new THREE.CylinderGeometry(0.22, 0.18, 3.5, 16);
        const calfMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const calf = new THREE.Mesh(calfGeom, calfMat);
        calf.position.y = -5.25;
        legGroup.add(calf);
        
        // Ankle joint
        const ankleGeom = new THREE.SphereGeometry(0.18, 8, 8);
        const ankleMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const ankle = new THREE.Mesh(ankleGeom, ankleMat);
        ankle.position.y = -7;
        legGroup.add(ankle);
        
        // Ankle bone protrusion (malleolus) - MIRRORED
        const ankleBoneGeom = new THREE.SphereGeometry(0.012, 8, 8);
        const ankleBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const ankleBone = new THREE.Mesh(ankleBoneGeom, ankleBoneMat);
        ankleBone.position.set(isRight ? 0.18 : -0.18, -7, 0); // Mirror X position
        legGroup.add(ankleBone);
        
        // Foot (elongated with 40% growth)
        const footGeom = new THREE.BoxGeometry(0.35, 0.25, 0.8);
        const footMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const foot = new THREE.Mesh(footGeom, footMat);
        foot.position.set(0, -7.3, 0.3);
        foot.rotation.x = -Math.PI / 16; // Slight arch
        legGroup.add(foot);
        
        // Big toe (larger and separate) - MIRRORED
        const bigToeGeom = new THREE.CylinderGeometry(0.07, 0.05, 0.35, 8);
        const bigToeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const bigToe = new THREE.Mesh(bigToeGeom, bigToeMat);
        bigToe.position.set(isRight ? -0.12 : 0.12, -7.5, 0.65); // Mirror X (big toe on inside)
        bigToe.rotation.x = Math.PI / 2;
        legGroup.add(bigToe);
        
        // 4 Toes (progressive sizing) - MIRRORED X positions
        const toeLengths = [0.28, 0.26, 0.24, 0.22]; // Progressive reduction
        for (let i = 0; i < 4; i++) {
          const toeGeom = new THREE.CylinderGeometry(0.045 * (1 - i * 0.08), 0.03 * (1 - i * 0.08), toeLengths[i], 8);
          const toeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const toe = new THREE.Mesh(toeGeom, toeMat);
          const toeXBase = isRight ? -0.05 : 0.05;
          const toeXOffset = isRight ? (i * 0.08) : -(i * 0.08);
          toe.position.set(toeXBase + toeXOffset, -7.5, 0.65);
          toe.rotation.x = Math.PI / 2;
          legGroup.add(toe);
          
          // Toe tip (spherical)
          const toeTipGeom = new THREE.SphereGeometry(0.035 * (1 - i * 0.08), 8, 8);
          const toeTipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const toeTip = new THREE.Mesh(toeTipGeom, toeTipMat);
          toeTip.position.set(toeXBase + toeXOffset, -7.5, 0.65 + toeLengths[i] / 2);
          legGroup.add(toeTip);
        }
        
        // Position leg at specified X offset
        legGroup.position.set(xOffset, 0, 0);
        return legGroup;
      }
      
      // Create container group for both legs
      const bothLegsGroup = new THREE.Group();
      
      // Create left leg (X = -0.4, at left hip)
      const leftLeg = createLeg(-0.4, false);
      bothLegsGroup.add(leftLeg);
      
      // Create right leg (X = 0.4, at right hip)
      const rightLeg = createLeg(0.4, true);
      bothLegsGroup.add(rightLeg);
      
      // Position both legs so feet rest on ground (foot bottom is at ~Y=-7.5, so lift by 7.5)
      bothLegsGroup.position.set(0, 7.5, 0);
      
      scene.add(bothLegsGroup);
      objects.push(bothLegsGroup);
      
      // Update UI
      const totalVertexCount = 172; // 86V Ã— 2 legs
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `BOTH LEGS (${totalVertexCount}V)`;
      
      console.log(`âœ… Both legs loaded: ${totalVertexCount} vertices (86V each) - left at X=-0.4, right at X=0.4`);
    }

    // ï¿½ğŸ¦´ HUMAN TORSO LOADER (120+ Vertices)
    function loadHumanTorso(btn) {
      console.log('ğŸ¦´ Loading torso anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical torso
      const torsoGroup = new THREE.Group();
      let vertexCount = 120;
      
      // Pelvis base (hip connector)
      const pelvisGeom = new THREE.CylinderGeometry(0.45, 0.5, 0.6, 16);
      const pelvisMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const pelvis = new THREE.Mesh(pelvisGeom, pelvisMat);
      pelvis.position.y = 0;
      torsoGroup.add(pelvis);
      
      // Lower spine (L1-L5 lumbar vertebrae)
      const lowerSpineGeom = new THREE.CylinderGeometry(0.12, 0.12, 1.2, 12);
      const spineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const lowerSpine = new THREE.Mesh(lowerSpineGeom, spineMat);
      lowerSpine.position.y = 0.9;
      torsoGroup.add(lowerSpine);
      
      // Mid spine (T7-T12 thoracic vertebrae)
      const midSpineGeom = new THREE.CylinderGeometry(0.13, 0.12, 1.5, 12);
      const midSpine = new THREE.Mesh(midSpineGeom, spineMat);
      midSpine.position.y = 2.25;
      torsoGroup.add(midSpine);
      
      // Upper spine (T1-T6 thoracic vertebrae)
      const upperSpineGeom = new THREE.CylinderGeometry(0.14, 0.13, 1.2, 12);
      const upperSpine = new THREE.Mesh(upperSpineGeom, spineMat);
      upperSpine.position.y = 3.6;
      torsoGroup.add(upperSpine);
      
      // Ribcage (12 ribs on each side)
      for (let i = 0; i < 12; i++) {
        const ribHeight = 2.0 + (i * 0.15);
        const ribWidth = 0.35 + (i * 0.04);
        const ribDepth = 0.25 + (i * 0.03);
        
        // Left rib
        const leftRibGeom = new THREE.TorusGeometry(ribWidth, 0.02, 8, 16, Math.PI);
        const ribMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const leftRib = new THREE.Mesh(leftRibGeom, ribMat);
        leftRib.position.set(-0.15, ribHeight, 0);
        leftRib.rotation.y = Math.PI / 2;
        leftRib.rotation.z = -Math.PI / 12;
        torsoGroup.add(leftRib);
        
        // Right rib
        const rightRib = new THREE.Mesh(leftRibGeom.clone(), ribMat);
        rightRib.position.set(0.15, ribHeight, 0);
        rightRib.rotation.y = -Math.PI / 2;
        rightRib.rotation.z = Math.PI / 12;
        torsoGroup.add(rightRib);
      }
      
      // Chest/sternum
      const chestGeom = new THREE.BoxGeometry(0.4, 1.8, 0.2);
      const chestMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.7 });
      const chest = new THREE.Mesh(chestGeom, chestMat);
      chest.position.set(0, 3.0, 0.35);
      torsoGroup.add(chest);
      
      // Left shoulder socket
      const leftShoulderGeom = new THREE.SphereGeometry(0.25, 8, 8);
      const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.6 });
      const leftShoulder = new THREE.Mesh(leftShoulderGeom, shoulderMat);
      leftShoulder.position.set(-0.6, 4.0, 0);
      torsoGroup.add(leftShoulder);
      
      // Right shoulder socket
      const rightShoulder = new THREE.Mesh(leftShoulderGeom, shoulderMat);
      rightShoulder.position.set(0.6, 4.0, 0);
      torsoGroup.add(rightShoulder);
      
      // Clavicles (collar bones)
      const clavicleGeom = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8);
      const clavicleMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      
      const leftClavicle = new THREE.Mesh(clavicleGeom, clavicleMat);
      leftClavicle.position.set(-0.35, 4.0, 0.1);
      leftClavicle.rotation.z = Math.PI / 6;
      torsoGroup.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(clavicleGeom, clavicleMat);
      rightClavicle.position.set(0.35, 4.0, 0.1);
      rightClavicle.rotation.z = -Math.PI / 6;
      torsoGroup.add(rightClavicle);
      
      // Position torso at ground level (pelvis at Y=0, lift to ground)
      torsoGroup.position.set(0, 0.3, 0);
      scene.add(torsoGroup);
      objects.push(torsoGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `TORSO (${vertexCount}V)`;
      
      console.log(`âœ… Anatomical torso loaded: ${vertexCount}+ vertices - pelvis, spine, 24 ribs, chest, shoulders, clavicles`);
    }

    // ğŸ§  HUMAN HEAD & NECK LOADER (100+ Vertices)
    function loadHumanHead(btn) {
      console.log('ğŸ§  Loading head and neck anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical head & neck group
      const headGroup = new THREE.Group();
      let vertexCount = 100;
      
      // Neck base (C7 vertebra)
      const neckBaseGeom = new THREE.CylinderGeometry(0.14, 0.12, 0.4, 12);
      const neckMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const neckBase = new THREE.Mesh(neckBaseGeom, neckMat);
      neckBase.position.y = 0.2;
      headGroup.add(neckBase);
      
      // Create neck swivel group (rotates for head turning)
      const neckSwivelGroup = new THREE.Group();
      neckSwivelGroup.position.y = 0.4;
      headGroup.add(neckSwivelGroup);
      
      // Neck cylinder (C1-C6 cervical vertebrae)
      const neckGeom = new THREE.CylinderGeometry(0.12, 0.14, 1.0, 12);
      const neck = new THREE.Mesh(neckGeom, neckMat);
      neck.position.y = 0.5;
      neckSwivelGroup.add(neck);
      
      // Skull base (foramen magnum)
      const skullBaseGeom = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 12);
      const boneMat = new THREE.MeshStandardMaterial({ color: 0xfff8e7, roughness: 0.4 });
      const skullBase = new THREE.Mesh(skullBaseGeom, boneMat);
      skullBase.position.y = 1.1;
      neckSwivelGroup.add(skullBase);
      
      // Cranium (main skull sphere)
      const craniumGeom = new THREE.SphereGeometry(0.65, 16, 16);
      const cranium = new THREE.Mesh(craniumGeom, boneMat);
      cranium.position.y = 1.6;
      cranium.scale.set(1, 1.1, 1); // Slightly taller
      neckSwivelGroup.add(cranium);
      
      // Jaw (mandible)
      const jawGeom = new THREE.BoxGeometry(0.5, 0.3, 0.4);
      const skinMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const jaw = new THREE.Mesh(jawGeom, skinMat);
      jaw.position.set(0, 1.0, 0.25);
      neckSwivelGroup.add(jaw);
      
      // Face plane (for features)
      const faceGeom = new THREE.CircleGeometry(0.55, 16);
      const faceMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.6, side: THREE.DoubleSide });
      const face = new THREE.Mesh(faceGeom, faceMat);
      face.position.set(0, 1.6, 0.6);
      neckSwivelGroup.add(face);
      
      // Left eye
      const eyeGeom = new THREE.SphereGeometry(0.08, 12, 12);
      const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const leftEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
      leftEye.position.set(-0.18, 1.7, 0.58);
      neckSwivelGroup.add(leftEye);
      
      // Left pupil
      const pupilGeom = new THREE.SphereGeometry(0.04, 12, 12);
      const pupilMat = new THREE.MeshStandardMaterial({ color: 0x2a4d69, roughness: 0.2 });
      const leftPupil = new THREE.Mesh(pupilGeom, pupilMat);
      leftPupil.position.set(-0.18, 1.7, 0.63);
      neckSwivelGroup.add(leftPupil);
      
      // Right eye
      const rightEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
      rightEye.position.set(0.18, 1.7, 0.58);
      neckSwivelGroup.add(rightEye);
      
      // Right pupil
      const rightPupil = new THREE.Mesh(pupilGeom, pupilMat);
      rightPupil.position.set(0.18, 1.7, 0.63);
      neckSwivelGroup.add(rightPupil);
      
      // Nose
      const noseGeom = new THREE.ConeGeometry(0.08, 0.2, 8);
      const nose = new THREE.Mesh(noseGeom, skinMat);
      nose.position.set(0, 1.5, 0.62);
      nose.rotation.x = Math.PI / 2;
      neckSwivelGroup.add(nose);
      
      // Mouth
      const mouthGeom = new THREE.BoxGeometry(0.25, 0.05, 0.1);
      const mouthMat = new THREE.MeshStandardMaterial({ color: 0xff6b8a, roughness: 0.5 });
      const mouth = new THREE.Mesh(mouthGeom, mouthMat);
      mouth.position.set(0, 1.25, 0.6);
      neckSwivelGroup.add(mouth);
      
      // Left ear
      const earGeom = new THREE.SphereGeometry(0.12, 12, 12);
      const leftEar = new THREE.Mesh(earGeom, skinMat);
      leftEar.position.set(-0.6, 1.6, 0.1);
      leftEar.scale.set(0.5, 1, 0.8);
      neckSwivelGroup.add(leftEar);
      
      // Right ear
      const rightEar = new THREE.Mesh(earGeom, skinMat);
      rightEar.position.set(0.6, 1.6, 0.1);
      rightEar.scale.set(0.5, 1, 0.8);
      neckSwivelGroup.add(rightEar);
      
      // Store reference for neck swivel
      currentHeadGroup = headGroup;
      headNeckSwivel = neckSwivelGroup;
      
      // Position head at appropriate height
      headGroup.position.set(0, 4.5, 0);
      scene.add(headGroup);
      objects.push(headGroup);
      
      // Show neck swivel controls
      document.getElementById('neckSwivel').style.display = 'block';
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HEAD (${vertexCount}V)`;
      
      console.log(`âœ… Anatomical head loaded: ${vertexCount}+ vertices - neck, skull, jaw, eyes, nose, mouth, ears - NECK SWIVEL ENABLED`);
    }
    
    // Update neck swivel angle (-180Â° to 180Â°)
    function updateNeckSwivel(angle) {
      if (!headNeckSwivel) {
        console.warn('âš ï¸ No head loaded for neck swivel');
        return;
      }
      
      // Convert angle to radians and rotate around Y axis
      const swivelAngle = angle * (Math.PI / 180);
      headNeckSwivel.rotation.y = swivelAngle;
      
      // Update display
      document.getElementById('neckSwivelValue').textContent = angle + 'Â°';
      
      console.log(`ğŸ”„ Neck swivel: ${angle}Â° (${swivelAngle.toFixed(2)} rad)`);
    }

    // ğŸ§ FULL BODY LOADER (564+ Vertices Total)
    function loadFullBody(btn) {
      console.log('ğŸ§ Loading complete human body with all parts...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create main body container
      const fullBodyGroup = new THREE.Group();
      let totalVertices = 0;
      
      // ===== LEGS (172V) - Ground Level =====
      const legsGroup = new THREE.Group();
      
      function createLeg(xOffset, isRight) {
        const legGroup = new THREE.Group();
        const sideName = isRight ? 'Right' : 'Left';
        
        // Hip joint (Acetabulum - socket in pelvis)
        const hipGeom = new THREE.SphereGeometry(0.35, 8, 8);
        const hipMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hip = new THREE.Mesh(hipGeom, hipMat);
        hip.name = `${sideName} Hip Joint (Acetabulum)`;
        legGroup.add(hip);
        
        // Thigh (Femur - longest bone in body)
        const thighGeom = new THREE.CylinderGeometry(0.25, 0.22, 3.5, 16);
        const thighMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thigh = new THREE.Mesh(thighGeom, thighMat);
        thigh.name = `${sideName} Femur (Thigh Bone)`;
        thigh.position.y = -1.75;
        legGroup.add(thigh);
        
        // === KNEE GROUP (for flexion/bending) ===
        const kneeGroup = new THREE.Group();
        kneeGroup.position.y = -3.5; // Position at knee joint
        
        // Knee joint (Patella - kneecap)
        const kneeGeom = new THREE.SphereGeometry(0.24, 8, 8);
        const kneeMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const knee = new THREE.Mesh(kneeGeom, kneeMat);
        knee.name = `${sideName} Patella (Kneecap)`;
        knee.position.y = 0; // Relative to kneeGroup
        kneeGroup.add(knee);
        
        // Calf (Tibia - shinbone, Fibula - smaller lateral bone) - part of knee group so it bends with knee
        const calfGeom = new THREE.CylinderGeometry(0.22, 0.18, 3.5, 16);
        const calfMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const calf = new THREE.Mesh(calfGeom, calfMat);
        calf.name = `${sideName} Tibia & Fibula (Shin Bones)`;
        calf.position.y = -1.75; // Relative to knee
        kneeGroup.add(calf);
        
        // Ankle joint (Talus - ankle bone)
        const ankleGeom = new THREE.SphereGeometry(0.18, 8, 8);
        const ankleMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const ankle = new THREE.Mesh(ankleGeom, ankleMat);
        ankle.name = `${sideName} Talus (Ankle Joint)`;
        ankle.position.y = -3.5; // Relative to knee
        kneeGroup.add(ankle);
        
        // Ankle bone protrusion (Medial/Lateral Malleolus) - mirrored
        const ankleBoneGeom = new THREE.SphereGeometry(0.012, 8, 8);
        const ankleBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const ankleBone = new THREE.Mesh(ankleBoneGeom, ankleBoneMat);
        ankleBone.name = `${sideName} ${isRight ? 'Lateral' : 'Medial'} Malleolus`;
        ankleBone.position.set(isRight ? 0.18 : -0.18, -3.5, 0);
        kneeGroup.add(ankleBone);
        
        // === FOOT GROUP (for heel-toe placement) ===
        const footGroup = new THREE.Group();
        footGroup.position.y = -3.8; // Relative to knee
        
        // Foot (Metatarsals & Tarsals - foot bones)
        const footGeom = new THREE.BoxGeometry(0.35, 0.25, 0.8);
        const footMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const foot = new THREE.Mesh(footGeom, footMat);
        foot.name = `${sideName} Metatarsals & Tarsals (Foot Bones)`;
        foot.position.set(0, 0, 0.3);
        foot.rotation.x = -Math.PI / 16;
        footGroup.add(foot);
        
        // Big toe (Hallux - 1st Phalanx) - mirrored
        const bigToeGeom = new THREE.CylinderGeometry(0.07, 0.05, 0.35, 8);
        const bigToeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const bigToe = new THREE.Mesh(bigToeGeom, bigToeMat);
        bigToe.name = `${sideName} Hallux (Big Toe - 1st Phalanx)`;
        bigToe.position.set(isRight ? -0.12 : 0.12, -0.2, 0.65);
        bigToe.rotation.x = Math.PI / 2;
        footGroup.add(bigToe);
        
        // 4 Toes (2nd-5th Phalanges) - mirrored
        const toeLengths = [0.28, 0.26, 0.24, 0.22];
        const toeNames = ['2nd', '3rd', '4th', '5th'];
        for (let i = 0; i < 4; i++) {
          const toeGeom = new THREE.CylinderGeometry(0.045 * (1 - i * 0.08), 0.03 * (1 - i * 0.08), toeLengths[i], 8);
          const toeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const toe = new THREE.Mesh(toeGeom, toeMat);
          toe.name = `${sideName} ${toeNames[i]} Phalanx (Toe)`;
          const toeXBase = isRight ? -0.05 : 0.05;
          const toeXOffset = isRight ? (i * 0.08) : -(i * 0.08);
          toe.position.set(toeXBase + toeXOffset, -0.2, 0.65);
          toe.rotation.x = Math.PI / 2;
          footGroup.add(toe);
          
          // Toe tip
          const toeTipGeom = new THREE.SphereGeometry(0.035 * (1 - i * 0.08), 8, 8);
          const toeTipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const toeTip = new THREE.Mesh(toeTipGeom, toeTipMat);
          toeTip.position.set(toeXBase + toeXOffset, -0.2, 0.65 + toeLengths[i] / 2);
          footGroup.add(toeTip);
        }
        
        kneeGroup.add(footGroup);
        legGroup.add(kneeGroup);
        legGroup.position.set(xOffset, 0, 0);
        
        // Tag leg group for selection
        legGroup.userData.bodyPart = isRight ? 'rightLeg' : 'leftLeg';
        legGroup.userData.partName = isRight ? 'Right Leg' : 'Left Leg';
        legGroup.userData.controlGroup = legGroup;
        
        // Tag foot for separate control
        footGroup.userData.bodyPart = isRight ? 'rightFoot' : 'leftFoot';
        footGroup.userData.partName = isRight ? 'Right Foot' : 'Left Foot';
        
        return { legGroup, kneeGroup, footGroup };
      }
      
      // Create both legs
      const leftLegData = createLeg(-0.4, false);
      const rightLegData = createLeg(0.4, true);
      legsGroup.add(leftLegData.legGroup);
      legsGroup.add(rightLegData.legGroup);
      legsGroup.position.set(0, 7.5, 0); // Feet on ground
      fullBodyGroup.add(legsGroup);
      totalVertices += 172; // 86V Ã— 2
      
      // Store references for walking animation
      leftLegGroup = leftLegData.legGroup;
      rightLegGroup = rightLegData.legGroup;
      leftKneeGroup = leftLegData.kneeGroup;
      rightKneeGroup = rightLegData.kneeGroup;
      leftFootGroup = leftLegData.footGroup;
      rightFootGroup = rightLegData.footGroup;
      
      // ===== TORSO (120V) - Connects legs to arms =====
      const torsoGroup = new THREE.Group();
      
      // Pelvis base
      const pelvisGeom = new THREE.CylinderGeometry(0.45, 0.5, 0.6, 16);
      const pelvisMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const pelvis = new THREE.Mesh(pelvisGeom, pelvisMat);
      pelvis.position.y = 0;
      torsoGroup.add(pelvis);
      
      // Lower spine (L1-L5 lumbar vertebrae)
      const lowerSpineGeom = new THREE.CylinderGeometry(0.12, 0.12, 1.2, 12);
      const spineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const lowerSpine = new THREE.Mesh(lowerSpineGeom, spineMat);
      lowerSpine.position.y = 0.9;
      torsoGroup.add(lowerSpine);
      
      // Mid spine (T7-T12 thoracic vertebrae)
      const midSpineGeom = new THREE.CylinderGeometry(0.13, 0.12, 1.5, 12);
      const midSpine = new THREE.Mesh(midSpineGeom, spineMat);
      midSpine.position.y = 2.25;
      torsoGroup.add(midSpine);
      
      // Upper spine (T1-T6 thoracic vertebrae)
      const upperSpineGeom = new THREE.CylinderGeometry(0.14, 0.13, 1.2, 12);
      const upperSpine = new THREE.Mesh(upperSpineGeom, spineMat);
      upperSpine.position.y = 3.6;
      torsoGroup.add(upperSpine);
      
      // Ribcage (12 ribs on each side)
      for (let i = 0; i < 12; i++) {
        const ribHeight = 2.0 + (i * 0.15);
        const ribWidth = 0.35 + (i * 0.04);
        
        // Left rib
        const leftRibGeom = new THREE.TorusGeometry(ribWidth, 0.02, 8, 16, Math.PI);
        const ribMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const leftRib = new THREE.Mesh(leftRibGeom, ribMat);
        leftRib.position.set(-0.15, ribHeight, 0);
        leftRib.rotation.y = Math.PI / 2;
        leftRib.rotation.z = -Math.PI / 12;
        torsoGroup.add(leftRib);
        
        // Right rib
        const rightRibGeom = new THREE.TorusGeometry(ribWidth, 0.02, 8, 16, Math.PI);
        const rightRib = new THREE.Mesh(rightRibGeom, ribMat);
        rightRib.position.set(0.15, ribHeight, 0);
        rightRib.rotation.y = -Math.PI / 2;
        rightRib.rotation.z = Math.PI / 12;
        torsoGroup.add(rightRib);
      }
      
      // Chest
      const chestGeom = new THREE.CylinderGeometry(0.55, 0.45, 1.5, 16);
      const chestMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const chest = new THREE.Mesh(chestGeom, chestMat);
      chest.position.y = 3.5;
      torsoGroup.add(chest);
      
      // Shoulders
      const shouldersGeom = new THREE.CylinderGeometry(0.65, 0.55, 0.5, 16);
      const shouldersMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const shoulders = new THREE.Mesh(shouldersGeom, shouldersMat);
      shoulders.position.y = 4.5;
      torsoGroup.add(shoulders);
      
      // Clavicles (collarbones)
      const leftClavicleGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
      const clavicleMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const leftClavicle = new THREE.Mesh(leftClavicleGeom, clavicleMat);
      leftClavicle.position.set(-0.5, 4.6, 0);
      leftClavicle.rotation.z = Math.PI / 6;
      torsoGroup.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(leftClavicleGeom, clavicleMat);
      rightClavicle.position.set(0.5, 4.6, 0);
      rightClavicle.rotation.z = -Math.PI / 6;
      torsoGroup.add(rightClavicle);
      
      // Tag torso for selection
      torsoGroup.userData.bodyPart = 'torso';
      torsoGroup.userData.partName = 'Torso';
      torsoGroup.userData.controlGroup = torsoGroup;
      
      torsoGroup.position.set(0, 7.5, 0); // Align with legs at ground level
      fullBodyGroup.add(torsoGroup);
      totalVertices += 120;
      
      // ===== ARMS (172V) - At shoulder height =====
      const armsGroup = new THREE.Group();
      
      function createArm(xOffset, isRight) {
        const armGroup = new THREE.Group();
        const forearmGroup = new THREE.Group(); // For elbow articulation
        
        // Shoulder joint
        const shoulderGeom = new THREE.SphereGeometry(0.25, 8, 8);
        const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
        armGroup.add(shoulder);
        
        // Upper arm (bicep/tricep area)
        const upperArmGeom = new THREE.CylinderGeometry(0.18, 0.15, 2.5, 16);
        const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
        upperArm.position.y = -1.25;
        armGroup.add(upperArm);
        
        // Elbow joint
        const elbowGeom = new THREE.SphereGeometry(0.16, 8, 8);
        const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const elbow = new THREE.Mesh(elbowGeom, elbowMat);
        elbow.position.y = -2.5;
        armGroup.add(elbow);
        
        // === FOREARM GROUP (for articulation) ===
        forearmGroup.position.y = -2.5; // Position at elbow
        
        // Forearm
        const forearmGeom = new THREE.CylinderGeometry(0.14, 0.12, 2.3, 16);
        const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const forearm = new THREE.Mesh(forearmGeom, forearmMat);
        forearm.position.y = -1.15;
        forearmGroup.add(forearm);
        
        // Wrist joint
        const wristGeom = new THREE.SphereGeometry(0.12, 8, 8);
        const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const wrist = new THREE.Mesh(wristGeom, wristMat);
        wrist.position.y = -2.3;
        forearmGroup.add(wrist);
        
        // Wrist bone (styloid process) - mirrored
        const wristBoneGeom = new THREE.SphereGeometry(0.008, 8, 8);
        const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
        wristBone.position.set(isRight ? -0.15 : 0.15, -2.3, 0);
        forearmGroup.add(wristBone);
        
        // Hand (palm)
        const handGeom = new THREE.BoxGeometry(0.3, 0.12, 0.45);
        const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hand = new THREE.Mesh(handGeom, handMat);
        hand.position.y = -2.65;
        forearmGroup.add(hand);
        
        // Thumb - mirrored rotation
        const thumbGeom = new THREE.CylinderGeometry(0.05, 0.04, 0.35, 8);
        const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thumb = new THREE.Mesh(thumbGeom, thumbMat);
        thumb.position.set(isRight ? 0.25 : -0.25, -2.65, 0);
        thumb.rotation.z = isRight ? Math.PI / 3 : -Math.PI / 3;
        forearmGroup.add(thumb);
        
        // 4 Fingers - mirrored X positions
        const fingerLengths = [0.45, 0.48, 0.46, 0.42];
        for (let i = 0; i < 4; i++) {
          const fingerGeom = new THREE.CylinderGeometry(0.035 * (1 - i * 0.05), 0.025 * (1 - i * 0.05), fingerLengths[i], 8);
          const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const finger = new THREE.Mesh(fingerGeom, fingerMat);
          const fingerXBase = isRight ? -0.12 : 0.12;
          const fingerXOffset = isRight ? (i * 0.08) : -(i * 0.08);
          finger.position.set(fingerXBase + fingerXOffset, -3.1, 0);
          forearmGroup.add(finger);
          
          // Fingertip
          const fingertipGeom = new THREE.SphereGeometry(0.03 * (1 - i * 0.05), 8, 8);
          const fingertipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const fingertip = new THREE.Mesh(fingertipGeom, fingertipMat);
          fingertip.position.set(fingerXBase + fingerXOffset, -3.1 - fingerLengths[i] / 2, 0);
          forearmGroup.add(fingertip);
        }
        
        armGroup.add(forearmGroup);
        armGroup.position.set(xOffset, 0, 0);
        
        // Tag arm group for selection
        armGroup.userData.bodyPart = isRight ? 'rightArm' : 'leftArm';
        armGroup.userData.partName = isRight ? 'Right Arm' : 'Left Arm';
        armGroup.userData.controlGroup = armGroup;
        
        // Tag forearm/hand group for wrist control
        forearmGroup.userData.bodyPart = isRight ? 'rightHand' : 'leftHand';
        forearmGroup.userData.partName = isRight ? 'Right Hand' : 'Left Hand';
        forearmGroup.userData.controlGroup = forearmGroup;
        
        return { armGroup, forearmGroup };
      }
      
      // Create both arms
      const leftArmData = createArm(-1.2, false);
      const rightArmData = createArm(1.2, true);
      armsGroup.add(leftArmData.armGroup);
      armsGroup.add(rightArmData.armGroup);
      armsGroup.position.set(0, 12.25, 0); // At shoulder height (torso top ~4.5 + base 7.5)
      fullBodyGroup.add(armsGroup);
      totalVertices += 172; // 86V Ã— 2
      
      // Store references for walking animation (arm swing)
      leftArmGroupRef = leftArmData.armGroup;
      rightArmGroupRef = rightArmData.armGroup;
      leftForearmGroup = leftArmData.forearmGroup;
      rightForearmGroup = rightArmData.forearmGroup;
      
      // ===== HEAD (100V) - Top of torso =====
      const headGroup = new THREE.Group();
      const neckSwivelGroup = new THREE.Group(); // For head rotation
      
      // Cervical spine (C1-C7 vertebrae)
      const cervicalSpineGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 12);
      const cervicalSpineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const cervicalSpine = new THREE.Mesh(cervicalSpineGeom, cervicalSpineMat);
      cervicalSpine.position.y = 0.3;
      headGroup.add(cervicalSpine);
      
      // Neck base
      const neckBaseGeom = new THREE.CylinderGeometry(0.2, 0.18, 0.5, 16);
      const neckBaseMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const neckBase = new THREE.Mesh(neckBaseGeom, neckBaseMat);
      neckBase.position.y = 0.8;
      headGroup.add(neckBase);
      
      // === NECK SWIVEL GROUP (for head rotation) ===
      neckSwivelGroup.position.y = 1.1; // Position at top of neck
      
      // Skull base (occipital bone)
      const skullBaseGeom = new THREE.SphereGeometry(0.25, 12, 12);
      const skullBaseMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const skullBase = new THREE.Mesh(skullBaseGeom, skullBaseMat);
      skullBase.position.y = 0.2;
      neckSwivelGroup.add(skullBase);
      
      // Cranium (skull)
      const craniumGeom = new THREE.SphereGeometry(0.45, 16, 16);
      const craniumMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const cranium = new THREE.Mesh(craniumGeom, craniumMat);
      cranium.position.y = 0.65;
      neckSwivelGroup.add(cranium);
      
      // Jaw (mandible)
      const jawGeom = new THREE.BoxGeometry(0.4, 0.2, 0.35);
      const jawMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const jaw = new THREE.Mesh(jawGeom, jawMat);
      jaw.position.set(0, 0.3, 0.25);
      neckSwivelGroup.add(jaw);
      
      // Eyes
      const eyeGeom = new THREE.SphereGeometry(0.08, 12, 12);
      const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
      leftEye.position.set(-0.15, 0.7, 0.4);
      neckSwivelGroup.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
      rightEye.position.set(0.15, 0.7, 0.4);
      neckSwivelGroup.add(rightEye);
      
      // Pupils
      const pupilGeom = new THREE.SphereGeometry(0.04, 8, 8);
      const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.2 });
      const leftPupil = new THREE.Mesh(pupilGeom, pupilMat);
      leftPupil.position.set(-0.15, 0.7, 0.48);
      neckSwivelGroup.add(leftPupil);
      
      const rightPupil = new THREE.Mesh(pupilGeom, pupilMat);
      rightPupil.position.set(0.15, 0.7, 0.48);
      neckSwivelGroup.add(rightPupil);
      
      // Nose
      const noseGeom = new THREE.ConeGeometry(0.08, 0.15, 8);
      const noseMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const nose = new THREE.Mesh(noseGeom, noseMat);
      nose.position.set(0, 0.55, 0.45);
      nose.rotation.x = Math.PI / 2;
      neckSwivelGroup.add(nose);
      
      // Mouth
      const mouthGeom = new THREE.BoxGeometry(0.25, 0.05, 0.1);
      const mouthMat = new THREE.MeshStandardMaterial({ color: 0xff6666, roughness: 0.4 });
      const mouth = new THREE.Mesh(mouthGeom, mouthMat);
      mouth.position.set(0, 0.4, 0.42);
      neckSwivelGroup.add(mouth);
      
      // Ears
      const earGeom = new THREE.SphereGeometry(0.1, 8, 8);
      const earMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const leftEar = new THREE.Mesh(earGeom, earMat);
      leftEar.position.set(-0.45, 0.65, 0);
      leftEar.scale.set(0.4, 1, 0.6);
      neckSwivelGroup.add(leftEar);
      
      const rightEar = new THREE.Mesh(earGeom, earMat);
      rightEar.position.set(0.45, 0.65, 0);
      rightEar.scale.set(0.4, 1, 0.6);
      neckSwivelGroup.add(rightEar);
      
      // Tag head group for selection
      neckSwivelGroup.userData.bodyPart = 'head';
      neckSwivelGroup.userData.partName = 'Head';
      neckSwivelGroup.userData.controlGroup = neckSwivelGroup;
      
      headGroup.add(neckSwivelGroup);
      headGroup.position.set(0, 12, 0); // At top of torso (4.5 + 7.5)
      fullBodyGroup.add(headGroup);
      totalVertices += 100;
      
      // ===== ADD TO SCENE =====
      fullBodyGroup.position.set(0, 0, 0); // Standing upright at origin
      
      // Store global reference for body part selection
      window.fullBodyGroup = fullBodyGroup;
      
      scene.add(fullBodyGroup);
      objects.push(fullBodyGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `FULL BODY (${totalVertices}V)`;
      
      // Show articulation controls
      document.getElementById('armArticulationControls').style.display = 'block';
      document.getElementById('neckSwivelControls').style.display = 'block';
      
      console.log(`ğŸ§ âœ… FULL BODY loaded: ${totalVertices} vertices total`);
      console.log(`  â†’ Legs: 172V (86V Ã— 2) at ground level`);
      console.log(`  â†’ Torso: 120V connecting legs to arms`);
      console.log(`  â†’ Arms: 172V (86V Ã— 2) at shoulder height`);
      console.log(`  â†’ Head: 100V at top of torso`);
      console.log(`  â†’ All articulation controls enabled (elbow bend, neck swivel)`);
      console.log(`\nğŸ¦´ ANATOMICAL BONE STRUCTURE:`);
      console.log(`  LEGS (per side):`);
      console.log(`    â€¢ Acetabulum (Hip Socket)`);
      console.log(`    â€¢ Femur (Thigh Bone - longest bone)`);
      console.log(`    â€¢ Patella (Kneecap)`);
      console.log(`    â€¢ Tibia & Fibula (Shin Bones)`);
      console.log(`    â€¢ Talus (Ankle Joint)`);
      console.log(`    â€¢ Malleolus (Ankle Protrusion)`);
      console.log(`    â€¢ Metatarsals & Tarsals (Foot Bones)`);
      console.log(`    â€¢ Hallux (Big Toe - 1st Phalanx)`);
      console.log(`    â€¢ 2nd-5th Phalanges (Toes)`);
      console.log(`  ARMS (per side):`);
      console.log(`    â€¢ Humerus (Upper Arm)`);
      console.log(`    â€¢ Radius & Ulna (Forearm)`);
      console.log(`    â€¢ Carpals (Wrist)`);
      console.log(`    â€¢ Metacarpals & Phalanges (Hand & Fingers)`);
      console.log(`  TORSO:`);
      console.log(`    â€¢ Pelvis (Ilium, Ischium, Pubis)`);
      console.log(`    â€¢ Lumbar Vertebrae (L1-L5)`);
      console.log(`    â€¢ Thoracic Vertebrae (T1-T12)`);
      console.log(`    â€¢ Ribs (1-12 pairs)`);
      console.log(`    â€¢ Sternum (Breastbone)`);
      console.log(`    â€¢ Clavicles (Collarbones)`);
      console.log(`  HEAD:`);
      console.log(`    â€¢ Cervical Vertebrae (C1-C7 - Neck)`);
      console.log(`    â€¢ Cranium (Skull)`);
      console.log(`    â€¢ Mandible (Jawbone)`);
      console.log(`  â†’ ğŸš¶ WALKING ANIMATION: Click body, then scroll mouse wheel!`);
      console.log(`     â€¢ Scroll slowly = walking | Scroll faster = running`);
      console.log(`     â€¢ Stop scrolling to slow down naturally`);
      console.log(`  â†’ ğŸš¶ WALK MODE: Enable 'Walk Mode' button to move through scene!`);
      console.log(`     â€¢ A/D or â†/â†’ = Turn body left/right`);
      console.log(`     â€¢ W/S or â†‘/â†“ = Speed up/slow down`);
      console.log(`     â€¢ Camera follows body automatically`);
      console.log(`\nğŸ”¬ VERTEX ENGINE: Click ğŸ”¬ button, then click any bone to inspect vertices!`);
    }

    // Load skeleton body (bones only - for enemies/friends in Sky Relics)
    function loadSkeletonBody() {
      clearScene();
      
      const skeletonGroup = new THREE.Group();
      let totalVertices = 0;
      
      // === LEGS (172V) - Bone structure only ===
      function createSkeletonLeg(xOffset, isRight) {
        const legGroup = new THREE.Group();
        const sideName = isRight ? 'Right' : 'Left';
        const boneMat = new THREE.MeshStandardMaterial({ 
          color: 0xdddddd, 
          roughness: 0.3,
          metalness: 0.1,
          emissive: 0x222222
        });
        
        // Femur (thigh bone)
        const femurGeom = new THREE.CylinderGeometry(0.08, 0.06, 3.5, 12);
        const femur = new THREE.Mesh(femurGeom, boneMat);
        femur.name = `${sideName} Femur`;
        femur.position.y = -1.75;
        legGroup.add(femur);
        
        // Femur head (ball joint at hip)
        const femurHeadGeom = new THREE.SphereGeometry(0.12, 12, 12);
        const femurHead = new THREE.Mesh(femurHeadGeom, boneMat);
        femurHead.position.y = 0;
        legGroup.add(femurHead);
        
        // Patella (kneecap)
        const patellaGeom = new THREE.SphereGeometry(0.15, 12, 12);
        const patella = new THREE.Mesh(patellaGeom, boneMat);
        patella.name = `${sideName} Patella`;
        patella.position.y = -3.5;
        legGroup.add(patella);
        
        // Knee group for articulation
        const kneeGroup = new THREE.Group();
        kneeGroup.position.y = -3.5;
        
        // Tibia (shin bone - larger)
        const tibiaGeom = new THREE.CylinderGeometry(0.07, 0.055, 3.5, 12);
        const tibia = new THREE.Mesh(tibiaGeom, boneMat);
        tibia.name = `${sideName} Tibia`;
        tibia.position.set(-0.04, -1.75, 0);
        kneeGroup.add(tibia);
        
        // Fibula (smaller lateral bone)
        const fibulaGeom = new THREE.CylinderGeometry(0.035, 0.03, 3.5, 8);
        const fibula = new THREE.Mesh(fibulaGeom, boneMat);
        fibula.name = `${sideName} Fibula`;
        fibula.position.set(0.08, -1.75, 0);
        kneeGroup.add(fibula);
        
        // Malleolus (ankle protrusion)
        const malleolusGeom = new THREE.SphereGeometry(0.06, 8, 8);
        const malleolus = new THREE.Mesh(malleolusGeom, boneMat);
        malleolus.position.set(isRight ? 0.08 : -0.08, -3.5, 0);
        kneeGroup.add(malleolus);
        
        // Foot group for articulation
        const footGroup = new THREE.Group();
        footGroup.position.y = -3.8;
        
        // Tarsals (heel/ankle bones)
        const tarsalsGeom = new THREE.BoxGeometry(0.25, 0.15, 0.4);
        const tarsals = new THREE.Mesh(tarsalsGeom, boneMat);
        tarsals.position.set(0, 0, 0);
        footGroup.add(tarsals);
        
        // Metatarsals (foot bones)
        for (let i = 0; i < 5; i++) {
          const metatarsalGeom = new THREE.CylinderGeometry(0.02, 0.015, 0.5, 8);
          const metatarsal = new THREE.Mesh(metatarsalGeom, boneMat);
          const xPos = isRight ? (-0.1 + i * 0.05) : (0.1 - i * 0.05);
          metatarsal.position.set(xPos, 0, 0.35);
          metatarsal.rotation.x = Math.PI / 2;
          footGroup.add(metatarsal);
          
          // Phalanges (toe bones)
          const phalanxGeom = new THREE.CylinderGeometry(0.015, 0.01, 0.2, 6);
          const phalanx = new THREE.Mesh(phalanxGeom, boneMat);
          phalanx.position.set(xPos, 0, 0.6);
          phalanx.rotation.x = Math.PI / 2;
          footGroup.add(phalanx);
        }
        
        kneeGroup.add(footGroup);
        legGroup.add(kneeGroup);
        
        // Tag groups for animation
        legGroup.userData.bodyPart = isRight ? 'rightLeg' : 'leftLeg';
        legGroup.userData.controlGroup = legGroup;
        
        return { legGroup, kneeGroup, footGroup };
      }
      
      // Create both legs
      const leftLegData = createSkeletonLeg(-0.4, false);
      const rightLegData = createSkeletonLeg(0.4, true);
      skeletonGroup.add(leftLegData.legGroup);
      skeletonGroup.add(rightLegData.legGroup);
      leftLegData.legGroup.position.set(-0.4, 7.5, 0);
      rightLegData.legGroup.position.set(0.4, 7.5, 0);
      totalVertices += 172;
      
      // Store references for animation
      leftLegGroup = leftLegData.legGroup;
      rightLegGroup = rightLegData.legGroup;
      leftKneeGroup = leftLegData.kneeGroup;
      rightKneeGroup = rightLegData.kneeGroup;
      leftFootGroup = leftLegData.footGroup;
      rightFootGroup = rightLegData.footGroup;
      
      // === PELVIS & SPINE (Torso skeleton) ===
      const torsoGroup = new THREE.Group();
      const boneMat = new THREE.MeshStandardMaterial({ 
        color: 0xdddddd, 
        roughness: 0.3,
        metalness: 0.1,
        emissive: 0x222222
      });
      
      // Pelvis (hip bones)
      const pelvisGeom = new THREE.SphereGeometry(0.5, 12, 12);
      const pelvis = new THREE.Mesh(pelvisGeom, boneMat);
      pelvis.position.y = 0.5;
      pelvis.scale.set(1.2, 0.6, 0.8);
      torsoGroup.add(pelvis);
      
      // Lumbar vertebrae (L1-L5)
      for (let i = 0; i < 5; i++) {
        const vertebraGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.2, 8);
        const vertebra = new THREE.Mesh(vertebraGeom, boneMat);
        vertebra.position.y = 1.0 + (i * 0.25);
        torsoGroup.add(vertebra);
      }
      
      // Thoracic vertebrae (T1-T12) + Ribs
      for (let i = 0; i < 12; i++) {
        const vertebraGeom = new THREE.CylinderGeometry(0.07, 0.07, 0.15, 8);
        const vertebra = new THREE.Mesh(vertebraGeom, boneMat);
        vertebra.position.y = 2.25 + (i * 0.18);
        torsoGroup.add(vertebra);
        
        // Ribs (pairs)
        const ribGeom = new THREE.TorusGeometry(0.25 + (i * 0.03), 0.015, 6, 12, Math.PI);
        const leftRib = new THREE.Mesh(ribGeom, boneMat);
        leftRib.position.set(-0.1, 2.25 + (i * 0.18), 0);
        leftRib.rotation.y = Math.PI / 2;
        leftRib.rotation.z = -Math.PI / 12;
        torsoGroup.add(leftRib);
        
        const rightRib = new THREE.Mesh(ribGeom, boneMat);
        rightRib.position.set(0.1, 2.25 + (i * 0.18), 0);
        rightRib.rotation.y = -Math.PI / 2;
        rightRib.rotation.z = Math.PI / 12;
        torsoGroup.add(rightRib);
      }
      
      // Sternum (breastbone)
      const sternumGeom = new THREE.BoxGeometry(0.12, 0.8, 0.08);
      const sternum = new THREE.Mesh(sternumGeom, boneMat);
      sternum.position.set(0, 3.5, 0.3);
      torsoGroup.add(sternum);
      
      // Clavicles (collarbones)
      const clavicleGeom = new THREE.CylinderGeometry(0.025, 0.025, 0.6, 8);
      const leftClavicle = new THREE.Mesh(clavicleGeom, boneMat);
      leftClavicle.position.set(-0.35, 4.5, 0.1);
      leftClavicle.rotation.z = Math.PI / 6;
      torsoGroup.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(clavicleGeom, boneMat);
      rightClavicle.position.set(0.35, 4.5, 0.1);
      rightClavicle.rotation.z = -Math.PI / 6;
      torsoGroup.add(rightClavicle);
      
      // Scapulae (shoulder blades)
      const scapulaGeom = new THREE.BoxGeometry(0.3, 0.4, 0.05);
      const leftScapula = new THREE.Mesh(scapulaGeom, boneMat);
      leftScapula.position.set(-0.5, 4, -0.2);
      torsoGroup.add(leftScapula);
      
      const rightScapula = new THREE.Mesh(scapulaGeom, boneMat);
      rightScapula.position.set(0.5, 4, -0.2);
      torsoGroup.add(rightScapula);
      
      torsoGroup.position.y = 7.5;
      skeletonGroup.add(torsoGroup);
      totalVertices += 120;
      
      // === ARMS (172V) - Bone structure ===
      function createSkeletonArm(xOffset, isRight) {
        const armGroup = new THREE.Group();
        const sideName = isRight ? 'Right' : 'Left';
        
        // Humerus (upper arm bone)
        const humerusGeom = new THREE.CylinderGeometry(0.06, 0.05, 3.5, 12);
        const humerus = new THREE.Mesh(humerusGeom, boneMat);
        humerus.name = `${sideName} Humerus`;
        humerus.position.y = -1.75;
        armGroup.add(humerus);
        
        // Elbow joint
        const elbowGeom = new THREE.SphereGeometry(0.1, 10, 10);
        const elbow = new THREE.Mesh(elbowGeom, boneMat);
        elbow.position.y = -3.5;
        armGroup.add(elbow);
        
        // Forearm group
        const forearmGroup = new THREE.Group();
        forearmGroup.position.y = -3.5;
        
        // Radius (thumb side)
        const radiusGeom = new THREE.CylinderGeometry(0.04, 0.035, 3.5, 10);
        const radius = new THREE.Mesh(radiusGeom, boneMat);
        radius.name = `${sideName} Radius`;
        radius.position.set(isRight ? -0.04 : 0.04, -1.75, 0);
        forearmGroup.add(radius);
        
        // Ulna (pinky side)
        const ulnaGeom = new THREE.CylinderGeometry(0.035, 0.03, 3.5, 10);
        const ulna = new THREE.Mesh(ulnaGeom, boneMat);
        ulna.name = `${sideName} Ulna`;
        ulna.position.set(isRight ? 0.04 : -0.04, -1.75, 0);
        forearmGroup.add(ulna);
        
        // Carpals (wrist bones cluster)
        const carpalsGeom = new THREE.BoxGeometry(0.15, 0.1, 0.12);
        const carpals = new THREE.Mesh(carpalsGeom, boneMat);
        carpals.position.y = -3.5;
        forearmGroup.add(carpals);
        
        // Metacarpals & Phalanges (hand bones)
        for (let i = 0; i < 5; i++) {
          const metacarpalGeom = new THREE.CylinderGeometry(0.015, 0.012, 0.35, 6);
          const metacarpal = new THREE.Mesh(metacarpalGeom, boneMat);
          const xPos = isRight ? (0.06 - i * 0.03) : (-0.06 + i * 0.03);
          metacarpal.position.set(xPos, -4.1, 0);
          forearmGroup.add(metacarpal);
          
          // Finger bones (3 phalanges per finger)
          for (let j = 0; j < 3; j++) {
            const phalanxGeom = new THREE.CylinderGeometry(0.01, 0.008, 0.15, 6);
            const phalanx = new THREE.Mesh(phalanxGeom, boneMat);
            phalanx.position.set(xPos, -4.4 - (j * 0.15), 0);
            forearmGroup.add(phalanx);
          }
        }
        
        armGroup.add(forearmGroup);
        armGroup.position.set(xOffset, 0, 0);
        
        return { armGroup, forearmGroup };
      }
      
      const armsGroup = new THREE.Group();
      const leftArmData = createSkeletonArm(-1.2, false);
      const rightArmData = createSkeletonArm(1.2, true);
      armsGroup.add(leftArmData.armGroup);
      armsGroup.add(rightArmData.armGroup);
      armsGroup.position.set(0, 12.25, 0);
      skeletonGroup.add(armsGroup);
      totalVertices += 172;
      
      // Store arm references for animation
      leftArmGroupRef = leftArmData.armGroup;
      rightArmGroupRef = rightArmData.armGroup;
      leftForearmGroup = leftArmData.forearmGroup;
      rightForearmGroup = rightArmData.forearmGroup;
      
      // === SKULL & SPINE (Head skeleton) ===
      const headGroup = new THREE.Group();
      const neckSwivelGroup = new THREE.Group();
      
      // Cervical vertebrae (C1-C7)
      for (let i = 0; i < 7; i++) {
        const cervicalGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.12, 8);
        const cervical = new THREE.Mesh(cervicalGeom, boneMat);
        cervical.position.y = 0.2 + (i * 0.14);
        headGroup.add(cervical);
      }
      
      // Cranium (skull)
      const craniumGeom = new THREE.SphereGeometry(0.55, 16, 16);
      const cranium = new THREE.Mesh(craniumGeom, boneMat);
      cranium.name = 'Cranium';
      cranium.position.y = 1.8;
      cranium.scale.set(1, 1.1, 1);
      neckSwivelGroup.add(cranium);
      
      // Eye sockets
      const socketGeom = new THREE.SphereGeometry(0.12, 12, 12);
      const socketMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const leftSocket = new THREE.Mesh(socketGeom, socketMat);
      leftSocket.position.set(-0.18, 1.85, 0.45);
      neckSwivelGroup.add(leftSocket);
      
      const rightSocket = new THREE.Mesh(socketGeom, socketMat);
      rightSocket.position.set(0.18, 1.85, 0.45);
      neckSwivelGroup.add(rightSocket);
      
      // Nasal cavity
      const noseGeom = new THREE.BoxGeometry(0.08, 0.15, 0.08);
      const nose = new THREE.Mesh(noseGeom, socketMat);
      nose.position.set(0, 1.7, 0.52);
      neckSwivelGroup.add(nose);
      
      // Mandible (jawbone)
      const mandibleGeom = new THREE.BoxGeometry(0.4, 0.25, 0.3);
      const mandible = new THREE.Mesh(mandibleGeom, boneMat);
      mandible.name = 'Mandible';
      mandible.position.set(0, 1.3, 0.35);
      mandible.scale.set(1, 0.6, 1);
      neckSwivelGroup.add(mandible);
      
      // Teeth (upper)
      for (let i = 0; i < 8; i++) {
        const toothGeom = new THREE.BoxGeometry(0.04, 0.08, 0.04);
        const tooth = new THREE.Mesh(toothGeom, new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
        tooth.position.set(-0.14 + (i * 0.04), 1.5, 0.52);
        neckSwivelGroup.add(tooth);
      }
      
      // Teeth (lower)
      for (let i = 0; i < 8; i++) {
        const toothGeom = new THREE.BoxGeometry(0.04, 0.08, 0.04);
        const tooth = new THREE.Mesh(toothGeom, new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
        tooth.position.set(-0.14 + (i * 0.04), 1.38, 0.52);
        neckSwivelGroup.add(tooth);
      }
      
      headGroup.add(neckSwivelGroup);
      headGroup.position.y = 16.5;
      skeletonGroup.add(headGroup);
      totalVertices += 100;
      
      // Add to scene
      scene.add(skeletonGroup);
      objects.push(skeletonGroup);
      window.fullBodyGroup = skeletonGroup;
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `SKELETON BODY (${totalVertices}V)`;
      
      console.log(`ğŸ’€ âœ… SKELETON BODY loaded: ${totalVertices} vertices total`);
      console.log(`  â†’ Perfect for Sky Relics enemies, frenemies, and skeleton friends!`);
      console.log(`  â†’ All bones anatomically labeled and ready to animate`);
      console.log(`  â†’ Supports full walking/running animation with WASD controls`);
      console.log(`  â†’ Press W to walk, SHIFT to run, SPACE to jump, F to fly!`);
      console.log(`\nğŸ’€ SKELETON ANATOMY:`);
      console.log(`  â†’ Femur, Tibia, Fibula (Leg bones)`);
      console.log(`  â†’ Humerus, Radius, Ulna (Arm bones)`);
      console.log(`  â†’ Pelvis, Vertebrae (L1-L5, T1-T12, C1-C7)`);
      console.log(`  â†’ 24 Ribs (12 pairs)`);
      console.log(`  â†’ Sternum, Clavicles, Scapulae`);
      console.log(`  â†’ Cranium, Mandible with teeth`);
      console.log(`  â†’ Carpals, Metacarpals, Phalanges (Hands)`);
      console.log(`  â†’ Tarsals, Metatarsals, Phalanges (Feet)`);
      console.log(`\nğŸ”¬ VERTEX ENGINE: Click ğŸ”¬ button, then click any bone to inspect vertices!`);
    }

    function updateSize(value) {
      primitiveSize = parseFloat(value);
      document.getElementById('sizeValue').textContent = value;
    }

    function updateAngle(value) {
      rotationAngle = parseFloat(value);
      document.getElementById('angleValue').textContent = value + 'Â°';
    }

    // Open 3D vertex matrix editor in new window
    function openAnatomyEditor() {
      const editorWindow = window.open('3d_vertex_matrix_environment.html', 'VertexMatrixEditor', 'width=1400,height=900');
      if (editorWindow) {
        console.log('âœ… 3D Vertex Matrix Editor opened in new window');
      } else {
        alert('âš ï¸ Please allow pop-ups to open the vertex matrix editor');
      }
    }

    // ========================================
    // ğŸ”¬ VERTEX ENGINE - Microscopic Detail Access
    // ========================================
    let vertexEngineActive = false;
    let selectedVertexIndex = null;
    let vertexHelpers = []; // Visual helpers for vertices
    let sculptMode = 'push'; // push, pull, smooth, inflate
    let brushSize = 1.0;
    let sculptStrength = 0.5;

    function toggleVertexEngine() {
      vertexEngineActive = !vertexEngineActive;
      const panel = document.getElementById('vertexEnginePanel');
      panel.style.display = vertexEngineActive ? 'block' : 'none';
      
      if (vertexEngineActive) {
        console.log('ğŸ”¬ VERTEX ENGINE ACTIVATED');
        console.log('â†’ Click any object to inspect its vertices');
        console.log('â†’ Three.js BufferGeometry vertices are now accessible');
        
        // If an object is selected, analyze it immediately
        if (transformControl.object) {
          analyzeObjectVertices(transformControl.object);
        }
      } else {
        console.log('ğŸ”¬ Vertex Engine deactivated');
        clearVertexHelpers();
      }
    }

    function analyzeObjectVertices(object) {
      if (!object || !object.geometry) {
        // Check if this is a group (like fullBodyGroup)
        if (object && object.children && object.children.length > 0) {
          console.log(`\nğŸ”¬ GROUP ANALYSIS: ${object.name || 'Body Group'}`);
          console.log(`â†’ Contains ${object.children.length} child objects`);
          
          let totalVertices = 0;
          const bodyParts = [];
          
          // Recursively count all vertices in hierarchy
          object.traverse((child) => {
            if (child.geometry) {
              const posAttr = child.geometry.getAttribute('position');
              if (posAttr) {
                const vCount = posAttr.count;
                totalVertices += vCount;
                bodyParts.push({
                  name: child.name || child.type || 'Unnamed',
                  vertices: vCount,
                  object: child
                });
              }
            }
          });
          
          console.log(`â†’ Total Vertices in Body: ${totalVertices}`);
          console.log(`\nğŸ“‹ BODY PARTS (Click individual bones to inspect):`);
          bodyParts.forEach(part => {
            console.log(`  â€¢ ${part.name}: ${part.vertices} vertices`);
          });
          
          // Update UI
          document.getElementById('vertexObjectName').textContent = `${object.name || 'Body'} (${bodyParts.length} parts)`;
          document.getElementById('vertexTotalCount').textContent = `${totalVertices} (across all bones)`;
          
          console.log(`\nğŸ’¡ TIP: Click individual bones (femur, skull, ribs, etc.) to see their vertices!`);
          return;
        }
        
        console.warn('âš ï¸ No geometry found on this object');
        return;
      }

      const geometry = object.geometry;
      const positionAttribute = geometry.getAttribute('position');
      
      if (!positionAttribute) {
        console.warn('âš ï¸ No position attribute found');
        return;
      }

      const vertexCount = positionAttribute.count;
      
      // Update UI
      document.getElementById('vertexObjectName').textContent = object.name || object.type || 'Unnamed';
      document.getElementById('vertexTotalCount').textContent = vertexCount;
      
      console.log(`\nğŸ”¬ VERTEX ANALYSIS:`);
      console.log(`â†’ Object: ${object.name || object.type}`);
      console.log(`â†’ Total Vertices: ${vertexCount}`);
      console.log(`â†’ Position Buffer: Float32Array[${positionAttribute.array.length}]`);
      console.log(`â†’ Format: [x, y, z] for each vertex`);
      
      // Show first 10 vertices as example
      console.log(`\nğŸ“ First 10 Vertices (local coordinates):`);
      for (let i = 0; i < Math.min(10, vertexCount); i++) {
        const x = positionAttribute.getX(i).toFixed(3);
        const y = positionAttribute.getY(i).toFixed(3);
        const z = positionAttribute.getZ(i).toFixed(3);
        console.log(`  Vertex ${i}: (${x}, ${y}, ${z})`);
      }
      
      if (vertexCount > 10) {
        console.log(`  ... ${vertexCount - 10} more vertices`);
      }
      
      // Show vertex density info
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      const bbox = geometry.boundingBox;
      const size = new THREE.Vector3();
      bbox.getSize(size);
      const volume = size.x * size.y * size.z;
      const density = (vertexCount / volume).toFixed(2);
      
      console.log(`\nğŸ“Š MESH STATISTICS:`);
      console.log(`  â€¢ Bounding Box: ${size.x.toFixed(2)} Ã— ${size.y.toFixed(2)} Ã— ${size.z.toFixed(2)}`);
      console.log(`  â€¢ Vertex Density: ${density} vertices/unitÂ³`);
      console.log(`  â€¢ Triangle Count: ${vertexCount / 3} (approx)`);
    }

    function toggleVertexVisualization(show) {
      clearVertexHelpers();
      
      if (show) {
        // Check if we have a selected object with geometry
        if (transformControl.object && transformControl.object.geometry) {
          const object = transformControl.object;
          const geometry = object.geometry;
          const positionAttribute = geometry.getAttribute('position');
          const vertexCount = positionAttribute.count;
          
          console.log(`ğŸ”¬ Rendering ${vertexCount} vertex points for ${object.name || 'selected object'}...`);
          
          // Create a point for each vertex
          const pointsGeometry = new THREE.BufferGeometry();
          pointsGeometry.setAttribute('position', positionAttribute.clone());
          
          const pointsMaterial = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.1,
            sizeAttenuation: true
          });
          
          const points = new THREE.Points(pointsGeometry, pointsMaterial);
          points.name = 'VertexHelper_Points';
          
          // Match the object's transform
          points.position.copy(object.position);
          points.rotation.copy(object.rotation);
          points.scale.copy(object.scale);
          
          scene.add(points);
          vertexHelpers.push(points);
          
          console.log(`âœ… ${vertexCount} vertices visualized as cyan points`);
        }
        // Or visualize entire body if loaded
        else if (window.fullBodyGroup) {
          console.log(`ğŸ”¬ Rendering vertices for entire body...`);
          let totalPoints = 0;
          
          window.fullBodyGroup.traverse((child) => {
            if (child.geometry) {
              const posAttr = child.geometry.getAttribute('position');
              if (posAttr) {
                const pointsGeometry = new THREE.BufferGeometry();
                pointsGeometry.setAttribute('position', posAttr.clone());
                
                const pointsMaterial = new THREE.PointsMaterial({
                  color: 0x00ffff,
                  size: 0.08,
                  sizeAttenuation: true
                });
                
                const points = new THREE.Points(pointsGeometry, pointsMaterial);
                points.name = 'VertexHelper_Points';
                
                // Match the child's world transform
                points.position.copy(child.getWorldPosition(new THREE.Vector3()));
                points.rotation.copy(child.getWorldQuaternion(new THREE.Quaternion()));
                points.scale.copy(child.getWorldScale(new THREE.Vector3()));
                
                scene.add(points);
                vertexHelpers.push(points);
                totalPoints += posAttr.count;
              }
            }
          });
          
          console.log(`âœ… ${totalPoints} vertices visualized across all bones`);
        }
        else {
          alert('âš ï¸ Please load a body (ğŸ§ or ğŸ’€) or select an object first');
          document.getElementById('showVertexPoints').checked = false;
        }
      }
    }

    function toggleVertexNumbers(show) {
      // Clear existing labels
      const existingLabels = scene.children.filter(c => c.name === 'VertexLabel');
      existingLabels.forEach(label => scene.remove(label));
      
      if (show) {
        // Check if we have a selected object with geometry
        if (transformControl.object && transformControl.object.geometry) {
          const object = transformControl.object;
          const geometry = object.geometry;
          const positionAttribute = geometry.getAttribute('position');
          const vertexCount = positionAttribute.count;
          
          console.log(`ğŸ”¢ Adding labels for ${vertexCount} vertices on ${object.name || 'selected object'}...`);
          
          // Only show labels for first 100 vertices (performance)
          const maxLabels = Math.min(100, vertexCount);
          
          for (let i = 0; i < maxLabels; i++) {
            const x = positionAttribute.getX(i);
            const y = positionAttribute.getY(i);
            const z = positionAttribute.getZ(i);
            
            // Create text sprite
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 32;
            context.fillStyle = '#00ffff';
            context.font = 'Bold 20px Arial';
            context.fillText(i.toString(), 10, 24);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(0.2, 0.1, 1);
            sprite.name = 'VertexLabel';
            
            // Transform to world space
            sprite.position.applyMatrix4(object.matrixWorld);
            
            scene.add(sprite);
            vertexHelpers.push(sprite);
          }
          
          if (vertexCount > 100) {
            console.log(`â„¹ï¸ Showing first 100 labels only (${vertexCount} total vertices)`);
          }
        }
        else if (window.fullBodyGroup) {
          console.log(`ğŸ”¢ Adding vertex labels to body (first 10 per bone)...`);
          let totalLabels = 0;
          
          window.fullBodyGroup.traverse((child) => {
            if (child.geometry) {
              const posAttr = child.geometry.getAttribute('position');
              if (posAttr && totalLabels < 100) { // Limit total labels
                const maxPerBone = Math.min(10, posAttr.count, 100 - totalLabels);
                
                for (let i = 0; i < maxPerBone; i++) {
                  const vec = new THREE.Vector3(
                    posAttr.getX(i),
                    posAttr.getY(i),
                    posAttr.getZ(i)
                  );
                  
                  // Transform to world space
                  vec.applyMatrix4(child.matrixWorld);
                  
                  const canvas = document.createElement('canvas');
                  const context = canvas.getContext('2d');
                  canvas.width = 64;
                  canvas.height = 32;
                  context.fillStyle = '#00ffff';
                  context.font = 'Bold 16px Arial';
                  context.fillText(i.toString(), 10, 24);
                  
                  const texture = new THREE.CanvasTexture(canvas);
                  const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                  const sprite = new THREE.Sprite(spriteMaterial);
                  sprite.position.copy(vec);
                  sprite.scale.set(0.15, 0.075, 1);
                  sprite.name = 'VertexLabel';
                  
                  scene.add(sprite);
                  vertexHelpers.push(sprite);
                  totalLabels++;
                }
              }
            }
          });
          
          console.log(`â„¹ï¸ Showing ${totalLabels} vertex labels (limited for performance)`);
        }
        else {
          alert('âš ï¸ Please load a body (ğŸ§ or ğŸ’€) or select an object first');
          document.getElementById('showVertexNumbers').checked = false;
        }
      }
    }

    function toggleWireframe(show) {
      // Check if we have a selected object
      if (transformControl.object && transformControl.object.material) {
        const object = transformControl.object;
        
        if (Array.isArray(object.material)) {
          object.material.forEach(mat => mat.wireframe = show);
        } else {
          object.material.wireframe = show;
        }
        
        console.log(`ğŸ”² Wireframe: ${show ? 'ON' : 'OFF'} for ${object.name || 'selected object'}`);
      }
      // Or apply to entire body
      else if (window.fullBodyGroup) {
        let count = 0;
        window.fullBodyGroup.traverse((child) => {
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.wireframe = show);
            } else {
              child.material.wireframe = show;
            }
            count++;
          }
        });
        console.log(`ğŸ”² Wireframe: ${show ? 'ON' : 'OFF'} for ${count} body parts`);
      }
      else {
        alert('âš ï¸ Please load a body (ğŸ§ or ğŸ’€) or select an object first');
        document.getElementById('showWireframe').checked = false;
      }
    }

    function clearVertexHelpers() {
      vertexHelpers.forEach(helper => scene.remove(helper));
      vertexHelpers = [];
      
      // Clear labels
      const labels = scene.children.filter(c => c.name === 'VertexLabel');
      labels.forEach(label => scene.remove(label));
    }

    function updateVertexPosition() {
      if (!transformControl.object || selectedVertexIndex === null) {
        alert('âš ï¸ No vertex selected');
        return;
      }

      const object = transformControl.object;
      const geometry = object.geometry;
      const positionAttribute = geometry.getAttribute('position');
      
      const x = parseFloat(document.getElementById('vertexPosX').value);
      const y = parseFloat(document.getElementById('vertexPosY').value);
      const z = parseFloat(document.getElementById('vertexPosZ').value);
      
      positionAttribute.setXYZ(selectedVertexIndex, x, y, z);
      positionAttribute.needsUpdate = true;
      
      // Recompute normals for proper lighting
      geometry.computeVertexNormals();
      
      console.log(`âœ… Vertex ${selectedVertexIndex} moved to (${x}, ${y}, ${z})`);
    }

    function setSculptMode(mode) {
      sculptMode = mode;
      console.log(`ğŸ¨ Sculpt mode: ${mode.toUpperCase()}`);
    }

    function updateBrushSize(value) {
      brushSize = parseFloat(value);
    }

    function updateSculptStrength(value) {
      sculptStrength = parseFloat(value);
    }

    function exportVertexData() {
      if (!transformControl.object || !transformControl.object.geometry) {
        alert('âš ï¸ Please select an object first');
        return;
      }

      const object = transformControl.object;
      const geometry = object.geometry;
      const positionAttribute = geometry.getAttribute('position');
      const vertexCount = positionAttribute.count;
      
      const vertices = [];
      for (let i = 0; i < vertexCount; i++) {
        vertices.push({
          index: i,
          x: positionAttribute.getX(i),
          y: positionAttribute.getY(i),
          z: positionAttribute.getZ(i)
        });
      }
      
      const data = {
        objectName: object.name || object.type || 'Unnamed',
        vertexCount: vertexCount,
        vertices: vertices,
        exportDate: new Date().toISOString()
      };
      
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${object.name || 'object'}_vertices.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      console.log(`ğŸ’¾ Exported ${vertexCount} vertices to JSON`);
      
      // Show preview in UI
      const preview = document.getElementById('vertexInfoDisplay');
      preview.style.display = 'block';
      preview.textContent = json.substring(0, 1000) + '\n...\n(Download complete file)';
    }
    
    // Smart export - detects if body is loaded and exports entire hierarchy
    function smartExportVertices() {
      if (window.fullBodyGroup) {
        // Export entire body
        exportBodyVertexData();
      } else if (transformControl.object && transformControl.object.geometry) {
        // Export single object
        exportVertexData();
      } else {
        alert('âš ï¸ Please select an object or load a body first!');
      }
    }
    
    // ========================================
    // BODY-SPECIFIC VERTEX ANALYSIS
    // ========================================
    
    function analyzeFullBody() {
      if (!window.fullBodyGroup) {
        alert('âš ï¸ No full body loaded! Click ğŸ§ FULL BODY button first.');
        return;
      }
      
      console.log('\nğŸ§ ===== FULL BODY VERTEX ANALYSIS =====');
      analyzeObjectVertices(window.fullBodyGroup);
      
      // Auto-enable vertex engine if not active
      if (!vertexEngineActive) {
        toggleVertexEngine();
      }
    }
    
    function analyzeSkeletonBody() {
      if (!window.fullBodyGroup) {
        alert('âš ï¸ No skeleton body loaded! Click ğŸ’€ BONES BODY button first.');
        return;
      }
      
      console.log('\nğŸ’€ ===== SKELETON BODY VERTEX ANALYSIS =====');
      analyzeObjectVertices(window.fullBodyGroup);
      
      // Auto-enable vertex engine if not active
      if (!vertexEngineActive) {
        toggleVertexEngine();
      }
    }
    
    // Export entire body's vertex data (all bones)
    function exportBodyVertexData() {
      if (!window.fullBodyGroup) {
        alert('âš ï¸ No body loaded!');
        return;
      }
      
      const bodyParts = [];
      let totalVertices = 0;
      
      window.fullBodyGroup.traverse((child) => {
        if (child.geometry) {
          const posAttr = child.geometry.getAttribute('position');
          if (posAttr) {
            const vertices = [];
            for (let i = 0; i < posAttr.count; i++) {
              vertices.push({
                index: i,
                x: posAttr.getX(i),
                y: posAttr.getY(i),
                z: posAttr.getZ(i)
              });
            }
            
            bodyParts.push({
              name: child.name || child.type || 'Unnamed',
              vertexCount: posAttr.count,
              vertices: vertices,
              position: {
                x: child.position.x,
                y: child.position.y,
                z: child.position.z
              },
              rotation: {
                x: child.rotation.x,
                y: child.rotation.y,
                z: child.rotation.z
              }
            });
            
            totalVertices += posAttr.count;
          }
        }
      });
      
      const data = {
        bodyName: window.fullBodyGroup.name || 'Full Body',
        totalVertices: totalVertices,
        bodyPartCount: bodyParts.length,
        bodyParts: bodyParts,
        exportDate: new Date().toISOString()
      };
      
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `full_body_vertices_${totalVertices}V.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      console.log(`ğŸ’¾ Exported entire body: ${totalVertices} vertices across ${bodyParts.length} bones`);
    }

    // ========================================
    // END VERTEX ENGINE
    // ========================================

    function clearScene() {
      if (confirm('Clear all objects?')) {
        objects.forEach(obj => scene.remove(obj));
        objects = [];
        updateObjectCount();
      }
    }

    function switchWorkspace(workspace, btn) {
      // Update tab UI
      document.querySelectorAll('.workspace-tab').forEach(tab => tab.classList.remove('active'));
      btn.classList.add('active');

      // Hide all workspace content
      document.querySelectorAll('.workspace-content').forEach(content => {
        content.style.display = 'none';
      });

      // Show selected workspace
      const workspaceElement = document.getElementById(`workspace-${workspace}`);
      if (workspaceElement) {
        workspaceElement.style.display = 'block';
      }

      // Update display
      const workspaceNames = {
        'sculpt': '3D SCULPT',
        'css': 'CSS DESIGNER',
        'word': 'WORDWEAVER',
        'campus': 'CAMPUS',
        'perfect': 'PERFECT'
      };
      document.getElementById('workspaceDisplay').textContent = workspaceNames[workspace] || workspace.toUpperCase();
      
      console.log('Switched to:', workspace);
    }

    function updateObjectCount() {
      document.getElementById('objectCount').textContent = objects.length;
    }

    function updateVertexCount() {
      let totalVertices = 0;
      objects.forEach(obj => {
        obj.traverse((child) => {
          if (child.geometry) {
            const positions = child.geometry.attributes.position;
            if (positions) {
              totalVertices += positions.count;
            }
          }
        });
      });
      document.getElementById('vertexCount').textContent = totalVertices;
      console.log(`ğŸ“Š Total vertices in scene: ${totalVertices}`);
    }

    // =============================================
    // MATHEMATICIAN TRIBUTE SYSTEM
    // =============================================

    let learnModeActive = false;
    let currentMethod = 'fibonacci';

    const MATHEMATICIANS = {
      fibonacci: {
        name: "Leonardo Fibonacci",
        born: 1170,
        died: 1250,
        flag: "ğŸ‡®ğŸ‡¹",
        nationality: "Italian",
        discovery: "Fibonacci Sequence",
        story: "Italian mathematician who discovered the famous sequence (0,1,1,2,3,5,8...) while studying rabbit populations. Each number is the sum of the two before it! This sequence appears everywhere in nature: sunflower spirals, pinecones, nautilus shells.",
        kidFact: "He introduced Arabic numerals (0-9) to Europe! Before him, Europeans used Roman numerals (I, II, III, IV...) which made math really hard."
      },
      catmull: {
        name: "Edwin Catmull",
        born: 1945,
        died: null,
        flag: "ğŸ‡ºğŸ‡¸",
        nationality: "American",
        discovery: "Catmull-Rom Splines & Subdivision",
        story: "Co-founder of Pixar! Created smooth curve algorithms while dreaming of making the first computer-animated movie. His math makes characters move smoothly and naturally.",
        kidFact: "He won an Oscar for his technology! Every Pixar movie (Toy Story, Finding Nemo, The Incredibles) uses his math to make characters move smoothly."
      },
      bezier: {
        name: "Pierre BÃ©zier",
        born: 1910,
        died: 1999,
        flag: "ğŸ‡«ğŸ‡·",
        nationality: "French",
        discovery: "BÃ©zier Curves",
        story: "Renault car designer who invented curves you can control with just a few points. Used in fonts, animations, car design, and every vector graphic you see!",
        kidFact: "Every letter you're reading right now uses BÃ©zier curves! Computer fonts are made entirely of his curves. Even emojis! ğŸ˜Š"
      },
      perlin: {
        name: "Ken Perlin",
        born: 1951,
        died: null,
        flag: "ğŸ®",
        nationality: "American",
        discovery: "Perlin Noise",
        story: "NYU professor who created natural-looking randomness for the movie TRON (1982). Won an Oscar for making computer graphics look organic instead of artificial!",
        kidFact: "Minecraft's entire world generation uses Perlin noise! Every mountain, cave, and biome is created with his algorithm. Without it, Minecraft wouldn't exist!"
      },
      quaternion: {
        name: "William Hamilton",
        born: 1805,
        died: 1865,
        flag: "ğŸ‡®ğŸ‡ª",
        nationality: "Irish",
        discovery: "Quaternions",
        story: "Had a 'eureka moment' while walking across Brougham Bridge in Dublin. He was so excited he carved the formula (iÂ²=jÂ²=kÂ²=ijk=-1) into the bridge stone with his knife!",
        kidFact: "Every 3D video game character rotation uses quaternions! They prevent 'gimbal lock' - a glitch that made old games spin weirdly. Your character wouldn't turn smoothly without them!"
      },
      lsystem: {
        name: "Aristid Lindenmayer",
        born: 1925,
        died: 1989,
        flag: "ğŸ‡­ğŸ‡º",
        nationality: "Hungarian",
        discovery: "L-Systems (Lindenmayer Systems)",
        story: "Biologist and botanist who created a simple alphabet system to model how plants grow. Simple rules like 'A becomes AB, B becomes A' create complex fractal patterns that look like real plants!",
        kidFact: "Video game trees and plants are grown with L-Systems! One simple rule repeated over and over can create an entire realistic forest. It's like growing a digital plant from a seed!"
      },
      voronoi: {
        name: "Georgy Voronoi",
        born: 1868,
        died: 1908,
        flag: "ğŸ‡ºğŸ‡¦",
        nationality: "Ukrainian",
        discovery: "Voronoi Diagrams",
        story: "Mathematician who figured out how to divide space based on nearest neighbors. Imagine drawing territories around each point where everything inside is closer to that point than any other!",
        kidFact: "Giraffe spots follow Voronoi patterns! Nature uses this math for animal patterns, cell structures, and crystal growth. Your body's cells organize using Voronoi math!"
      },
      phong: {
        name: "Bui Tuong Phong",
        born: 1942,
        died: 1975,
        flag: "ğŸ‡»ğŸ‡³",
        nationality: "Vietnamese",
        discovery: "Phong Shading",
        story: "Created the lighting model that made 3D objects look shiny and realistic. His PhD thesis at University of Utah changed computer graphics forever. Tragically died of leukemia at age 32, but his legacy lives in every 3D game.",
        kidFact: "Every shiny surface in 3D games uses Phong shading! He made plastic, metal, and glass look real on computers. When you see light reflecting off a character's armor - that's his math!"
      },
      delaunay: {
        name: "Boris Delaunay",
        born: 1890,
        died: 1980,
        flag: "ğŸ‡·ğŸ‡º",
        nationality: "Russian",
        discovery: "Delaunay Triangulation",
        story: "Russian mathematician who figured out the optimal way to connect dots with triangles. His method creates the 'fattest' triangles possible, avoiding skinny ones that cause problems in 3D graphics.",
        kidFact: "3D game terrain is built with Delaunay triangles! Mountains, valleys, and landscapes are made by connecting height points with his optimal triangles. Every open-world game uses this!"
      },
      subdivision: {
        name: "Jim Clark & Edwin Catmull",
        born: 1944,
        died: null,
        flag: "ğŸ’",
        nationality: "American",
        discovery: "Subdivision Surfaces",
        story: "Jim Clark founded Silicon Graphics (the company that made movie CGI possible) and Netscape (early web browser). With Catmull, they figured out how to make blocky shapes smooth by subdividing faces repeatedly.",
        kidFact: "Every smooth 3D character starts blocky! Artists model a simple cube-like shape, then subdivision turns it into a smooth character. It's like magic - a cube becomes a smooth head!"
      }
    };

    function toggleLearnMode(btn) {
      learnModeActive = !learnModeActive;
      const info = document.getElementById('learnModeInfo');
      
      if (learnModeActive) {
        btn.innerHTML = '<span class="tool-icon">ğŸ“</span><span>Learn Mode ON</span>';
        btn.style.background = 'rgba(0, 255, 136, 0.3)';
        btn.style.borderColor = '#00ff88';
        info.style.display = 'block';
        
        // Show initial method story
        showMathematicianStory(currentMethod);
        
        console.log(`
ğŸ“š ============================================
   LEARN MODE ACTIVATED!
   
   Now when you select Mathematical Methods,
   you'll see the mathematician's story, their
   discovery, and how it powers your creations!
   
   Click any method below to learn! ğŸ†
============================================
        `);
      } else {
        btn.innerHTML = '<span class="tool-icon">ğŸ‘¨â€ğŸ«</span><span>Enable Story Mode</span>';
        btn.style.background = 'rgba(0, 255, 136, 0.1)';
        btn.style.borderColor = 'rgba(0, 255, 136, 0.3)';
        info.style.display = 'none';
        document.getElementById('mathematicianStory').style.display = 'none';
      }
    }

    function selectMethod(method, btn) {
      currentMethod = method;
      
      // Update active button
      btn.parentElement.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Show story if Learn Mode is active
      if (learnModeActive) {
        showMathematicianStory(method);
      }
      
      // Log to console
      const mathematician = MATHEMATICIANS[method];
      console.log(`
ğŸ† ============================================
   METHOD SELECTED: ${mathematician.discovery}
   Mathematician: ${mathematician.name} (${mathematician.born}-${mathematician.died || 'Present'})
   ${mathematician.flag} ${mathematician.nationality}
   
   ğŸ“– Story: ${mathematician.story}
   
   ğŸ’¡ Kid Fact: ${mathematician.kidFact}
============================================
      `);
    }

    function showMathematicianStory(method) {
      const mathematician = MATHEMATICIANS[method];
      const panel = document.getElementById('mathematicianStory');
      
      // Update story content
      document.getElementById('storyTitle').textContent = `ğŸ† ${mathematician.discovery}`;
      document.getElementById('storyFlag').textContent = mathematician.flag;
      document.getElementById('storyName').textContent = mathematician.name;
      document.getElementById('storyDates').textContent = `${mathematician.born}-${mathematician.died || 'Present'} â€¢ ${mathematician.nationality}`;
      document.getElementById('storyDiscovery').textContent = `Discovery: ${mathematician.discovery}`;
      document.getElementById('storyText').textContent = mathematician.story;
      document.getElementById('storyKidFact').textContent = mathematician.kidFact;
      
      // Show panel with smooth animation
      panel.style.display = 'block';
    }

    // Start
    window.addEventListener('load', init);
  </script>
</body>
</html>
