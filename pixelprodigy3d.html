<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PixelProdigy Universe - Multi-Workspace Studio</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      height: 100vh;
    }

    #container {
      display: grid;
      grid-template-columns: 250px 1fr;
      grid-template-rows: 60px 1fr 40px;
      height: 100vh;
    }

    #header {
      grid-column: 1 / -1;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 20px;
    }

    #header h1 {
      font-size: 24px;
      font-weight: 600;
    }

    .workspace-tabs {
      display: flex;
      gap: 4px;
      flex: 1;
    }

    .workspace-tab {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: rgba(255, 255, 255, 0.7);
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 6px 6px 0 0;
      transition: all 0.2s;
      font-size: 13px;
      font-weight: 500;
    }

    .workspace-tab:hover {
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
    }

    .workspace-tab.active {
      background: #1a1a1a;
      color: #fff;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
    }

    #sidebar {
      background: #1a1a1a;
      padding: 20px;
      overflow-y: auto;
      border-right: 2px solid #333;
    }

    #viewport {
      background: #0f0f0f;
      position: relative;
      overflow: hidden;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
    }

    #footer {
      grid-column: 1 / -1;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      border-top: 2px solid #333;
      font-size: 13px;
      color: #888;
    }

    .section {
      margin-bottom: 25px;
    }

    .section-title {
      font-size: 12px;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 12px;
      font-weight: 600;
      letter-spacing: 1px;
    }

    .tool-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .tool-btn {
      background: #2a2a2a;
      border: 2px solid #3a3a3a;
      color: #fff;
      padding: 12px 8px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
      font-size: 13px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .tool-btn:hover {
      background: #3a3a3a;
      border-color: #667eea;
    }

    .tool-btn.active {
      background: #667eea;
      border-color: #764ba2;
      box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
    }

    .tool-icon {
      font-size: 24px;
    }

    .slider-control {
      margin-bottom: 15px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 12px;
      color: #aaa;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      background: #2a2a2a;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #667eea;
      cursor: pointer;
      border-radius: 50%;
      transition: all 0.2s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #764ba2;
      transform: scale(1.2);
    }

    .primitive-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #667eea;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="header">
      <h1>‚ö° PixelProdigy Universe</h1>
      <div class="workspace-tabs">
        <button class="workspace-tab active" onclick="switchWorkspace('sculpt', this)">3D Sculpt</button>
        <button class="workspace-tab" onclick="switchWorkspace('css', this)">CSS Designer</button>
        <button class="workspace-tab" onclick="switchWorkspace('word', this)">WordWeaver</button>
        <button class="workspace-tab" onclick="switchWorkspace('campus', this)">Campus</button>
        <button class="workspace-tab" onclick="switchWorkspace('perfect', this)">Perfect</button>
      </div>
      <div style="color: rgba(255,255,255,0.8); font-size: 14px;">Multi-Workspace Studio</div>
      
      <!-- Camera Controls -->
      <div style="display: flex; gap: 8px; margin-left: auto;">
        <button id="orbitToggle" onclick="toggleOrbitControls()" style="padding: 8px 16px; background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3); color: #fff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
          üé• Orbit: ON
        </button>
      </div>
    </div>

    <div id="sidebar">
      <!-- Sculpt Workspace -->
      <div id="workspace-sculpt" class="workspace-content">
        <div class="section">
          <div class="section-title">üîß Mode</div>
          <div class="tool-grid">
            <button class="tool-btn active" onclick="setMode('add', this)">
              <span class="tool-icon">‚ûï</span>
              <span>Add</span>
            </button>
            <button class="tool-btn" onclick="setMode('subtract', this)">
              <span class="tool-icon">‚ûñ</span>
              <span>Subtract</span>
            </button>
          </div>
        </div>

        <div class="section">
          <div class="section-title">‚úã Manipulate</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="setTransformMode('translate')">
              <span class="tool-icon">‚ÜîÔ∏è</span>
              <span>Move (W)</span>
            </button>
            <button class="tool-btn" onclick="setTransformMode('rotate')">
              <span class="tool-icon">üîÑ</span>
              <span>Rotate (E)</span>
            </button>
            <button class="tool-btn" onclick="setTransformMode('scale')">
              <span class="tool-icon">üìè</span>
              <span>Scale (R)</span>
            </button>
          </div>
        </div>

        <div class="section">
          <div class="section-title">üé® Primitives</div>
          <div class="primitive-grid">
            <button class="tool-btn active" onclick="setPrimitive('sphere', this)">
              <span class="tool-icon">‚ö™</span>
              <span>Sphere</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cube', this)">
              <span class="tool-icon">‚¨õ</span>
              <span>Cube</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cylinder', this)">
              <span class="tool-icon">üîµ</span>
              <span>Cylinder</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('cone', this)">
              <span class="tool-icon">üîª</span>
              <span>Cone</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('torus', this)">
              <span class="tool-icon">üç©</span>
              <span>Torus</span>
            </button>
            <button class="tool-btn" onclick="setPrimitive('pyramid', this)">
              <span class="tool-icon">üî∫</span>
              <span>Pyramid</span>
            </button>
            <button class="tool-btn" onclick="loadHumanAnatomy(this)" style="grid-column: 1 / -1; background: rgba(102, 126, 234, 0.2);">
              <span class="tool-icon">ü¶æ</span>
              <span>Load Arm (86V)</span>
            </button>
            <button class="tool-btn" onclick="loadBothArms(this)" style="grid-column: 1 / -1; background: rgba(63, 81, 181, 0.25); border: 2px solid rgba(63, 81, 181, 0.5);">
              <span class="tool-icon">ü¶æü¶æ</span>
              <span>Both Arms (172V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanLeg(this)" style="grid-column: 1 / -1; background: rgba(76, 175, 80, 0.2); border: 2px solid rgba(76, 175, 80, 0.4);">
              <span class="tool-icon">ü¶µ</span>
              <span>Load Leg (86V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanTorso(this)" style="grid-column: 1 / -1; background: rgba(255, 193, 7, 0.2); border: 2px solid rgba(255, 193, 7, 0.4);">
              <span class="tool-icon">ü¶¥</span>
              <span>Load Torso (120V)</span>
            </button>
            <button class="tool-btn" onclick="loadHumanHead(this)" style="grid-column: 1 / -1; background: rgba(156, 39, 176, 0.2); border: 2px solid rgba(156, 39, 176, 0.4);">
              <span class="tool-icon">üß†</span>
              <span>Load Head (100V)</span>
            </button>
            <button class="tool-btn" onclick="openAnatomyEditor()" style="grid-column: 1 / -1; background: rgba(255, 165, 0, 0.2); border: 2px solid rgba(255, 165, 0, 0.4);">
              <span class="tool-icon">‚úèÔ∏è</span>
              <span>Edit Anatomy (Advanced)</span>
            </button>
          </div>
        </div>

        <!-- ARM ARTICULATION -->
        <div class="section" id="armArticulation" style="display: none;">
          <div class="section-title">üí™ Arm Articulation</div>
          <div style="margin-bottom: 15px;">
            <label style="font-size: 12px; color: #888; display: flex; justify-content: space-between; margin-bottom: 5px;">
              <span>Elbow Angle</span>
              <span id="elbowAngleValue" style="color: #00ff88;">180¬∞</span>
            </label>
            <input type="range" id="elbowAngle" min="180" max="340" value="180" step="1" 
                   oninput="updateElbowAngle(parseInt(this.value))"
                   style="width: 100%; cursor: pointer;">
            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;">
              <span>180¬∞ (straight)</span>
              <span>340¬∞ (bent)</span>
            </div>
          </div>
        </div>

        <!-- NECK SWIVEL -->
        <div class="section" id="neckSwivel" style="display: none;">
          <div class="section-title">üîÑ Neck Swivel</div>
          <div style="margin-bottom: 15px;">
            <label style="font-size: 12px; color: #888; display: flex; justify-content: space-between; margin-bottom: 5px;">
              <span>Head Rotation</span>
              <span id="neckSwivelValue" style="color: #00ff88;">0¬∞</span>
            </label>
            <input type="range" id="neckSwivelAngle" min="-180" max="180" value="0" step="1" 
                   oninput="updateNeckSwivel(parseInt(this.value))"
                   style="width: 100%; cursor: pointer;">
            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;">
              <span>-180¬∞ (left)</span>
              <span>0¬∞ (center)</span>
              <span>180¬∞ (right)</span>
            </div>
          </div>
        </div>

        <!-- LEARN MODE TOGGLE -->
        <div class="section">
          <div class="section-title">üìö Learn Mode</div>
          <button class="tool-btn" id="learnModeToggle" onclick="toggleLearnMode(this)" style="width: 100%; background: rgba(0, 255, 136, 0.1); border: 2px solid rgba(0, 255, 136, 0.3);">
            <span class="tool-icon">üë®‚Äçüè´</span>
            <span>Enable Story Mode</span>
          </button>
          <div id="learnModeInfo" style="display: none; margin-top: 10px; padding: 12px; background: rgba(0, 255, 136, 0.1); border-radius: 8px; font-size: 11px; line-height: 1.5; color: rgba(255, 255, 255, 0.9);">
            <strong>Learn Mode Active!</strong><br>
            Click any Mathematical Method below to see the mathematician's story and how their discovery powers your creations! üèÜ
          </div>
        </div>

        <!-- MATHEMATICAL METHODS -->
        <div class="section">
          <div class="section-title">üèÜ Mathematical Methods</div>
          <div class="tool-grid">
            <button class="tool-btn active" onclick="selectMethod('fibonacci', this)">
              <span class="tool-icon">üáÆüáπ</span>
              <span>Fibonacci</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('catmull', this)">
              <span class="tool-icon">üá∫üá∏</span>
              <span>Catmull-Rom</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('bezier', this)">
              <span class="tool-icon">üá´üá∑</span>
              <span>B√©zier</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('perlin', this)">
              <span class="tool-icon">üéÆ</span>
              <span>Perlin Noise</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('quaternion', this)">
              <span class="tool-icon">üáÆüá™</span>
              <span>Quaternion</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('lsystem', this)">
              <span class="tool-icon">üá≠üá∫</span>
              <span>L-System</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('voronoi', this)">
              <span class="tool-icon">üá∫üá¶</span>
              <span>Voronoi</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('phong', this)">
              <span class="tool-icon">üáªüá≥</span>
              <span>Phong</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('delaunay', this)">
              <span class="tool-icon">üá∑üá∫</span>
              <span>Delaunay</span>
            </button>
            <button class="tool-btn" onclick="selectMethod('subdivision', this)">
              <span class="tool-icon">üíé</span>
              <span>Subdivision</span>
            </button>
          </div>
        </div>

        <!-- MATHEMATICIAN STORY PANEL -->
        <div id="mathematicianStory" class="section" style="display: none;">
          <div class="section-title" id="storyTitle">üèÜ Mathematician Story</div>
          <div style="padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 2px solid rgba(102, 126, 234, 0.3);">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
              <span id="storyFlag" style="font-size: 24px;">üáÆüáπ</span>
              <div>
                <div id="storyName" style="font-weight: 700; font-size: 14px; color: #00ff88;">Leonardo Fibonacci</div>
                <div id="storyDates" style="font-size: 11px; opacity: 0.8;">1170-1250</div>
              </div>
            </div>
            <div id="storyDiscovery" style="font-size: 12px; font-weight: 600; color: #667eea; margin-bottom: 8px;">
              Discovery: Fibonacci Sequence
            </div>
            <div id="storyText" style="font-size: 11px; line-height: 1.6; margin-bottom: 10px; color: rgba(255, 255, 255, 0.9);">
              Italian mathematician who discovered the famous sequence (0,1,1,2,3,5,8...) while studying rabbit populations.
            </div>
            <div style="background: rgba(0, 255, 136, 0.1); padding: 8px; border-radius: 6px; border-left: 3px solid #00ff88;">
              <div style="font-size: 10px; font-weight: 700; color: #00ff88; margin-bottom: 4px;">üí° KID FACT:</div>
              <div id="storyKidFact" style="font-size: 11px; line-height: 1.5;">
                He introduced Arabic numerals (0-9) to Europe! Before him, Europeans used Roman numerals.
              </div>
            </div>
          </div>
        </div>

        <div class="section">
          <div class="section-title">‚öôÔ∏è Settings</div>
          <div class="slider-control">
            <div class="slider-label">
              <span>Size</span>
              <span id="sizeValue">0.5</span>
            </div>
            <input type="range" min="0.1" max="2" step="0.1" value="0.5" oninput="updateSize(this.value)">
          </div>
          <div class="slider-control">
            <div class="slider-label">
              <span>Angle</span>
              <span id="angleValue">0¬∞</span>
            </div>
            <input type="range" min="0" max="360" step="15" value="0" oninput="updateAngle(this.value)">
          </div>
        </div>

        <div class="section">
          <div class="section-title">üéØ Actions</div>
          <button class="tool-btn" onclick="clearScene()" style="width: 100%; grid-column: 1 / -1;">
            <span class="tool-icon">üóëÔ∏è</span>
            <span>Clear All</span>
          </button>
        </div>
      </div>

      <!-- CSS Designer Workspace -->
      <div id="workspace-css" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">üíÖ CSS Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Gradient generator coming soon!')">
              <span class="tool-icon">üåà</span>
              <span>Gradient</span>
            </button>
            <button class="tool-btn" onclick="alert('Shadow generator coming soon!')">
              <span class="tool-icon">üå´Ô∏è</span>
              <span>Shadow</span>
            </button>
            <button class="tool-btn" onclick="alert('Border designer coming soon!')">
              <span class="tool-icon">üî≤</span>
              <span>Border</span>
            </button>
            <button class="tool-btn" onclick="alert('Animation builder coming soon!')">
              <span class="tool-icon">üé¨</span>
              <span>Animate</span>
            </button>
          </div>
        </div>
      </div>

      <!-- WordWeaver Workspace -->
      <div id="workspace-word" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">üìù Writing Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Text editor coming soon!')">
              <span class="tool-icon">‚úçÔ∏è</span>
              <span>Editor</span>
            </button>
            <button class="tool-btn" onclick="alert('Templates coming soon!')">
              <span class="tool-icon">üìÑ</span>
              <span>Templates</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Campus Workspace -->
      <div id="workspace-campus" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">üè´ Campus Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Building designer coming soon!')">
              <span class="tool-icon">üè¢</span>
              <span>Buildings</span>
            </button>
            <button class="tool-btn" onclick="alert('Layout planner coming soon!')">
              <span class="tool-icon">üó∫Ô∏è</span>
              <span>Layout</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Perfect Workspace -->
      <div id="workspace-perfect" class="workspace-content" style="display: none;">
        <div class="section">
          <div class="section-title">‚ú® Perfect Tools</div>
          <div class="tool-grid">
            <button class="tool-btn" onclick="alert('Perfect system coming soon!')">
              <span class="tool-icon">‚≠ê</span>
              <span>Optimize</span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <div id="viewport">
      <canvas id="canvas"></canvas>
      <div class="loading" id="loading">Initializing 3D Engine...</div>
    </div>

    <div id="footer">
      <div>Workspace: <strong id="workspaceDisplay">3D SCULPT</strong> | Mode: <strong id="modeDisplay">ADD</strong> | Primitive: <strong id="primitiveDisplay">SPHERE</strong></div>
      <div>Click viewport to place objects | Drag to rotate view</div>
      <div>Objects: <strong id="objectCount">0</strong> | Vertices: <strong id="vertexCount">0</strong></div>
    </div>
  </div>

  <script src="lib/three.min.js"></script>
  <script src="lib/OrbitControls.js"></script>
  <script src="lib/TransformControls.js"></script>
  <script>
    // State
    let scene, camera, renderer, controls, transformControl;
    let currentMode = 'add';
    let currentPrimitive = 'sphere';
    let primitiveSize = 0.5;
    let rotationAngle = 0;
    let objects = [];
    let selectedObject = null;
    let selectionBox = null; // Visual selection indicator
    let orbitEnabled = true; // Camera orbit control state
    let currentArmGroup = null; // Reference to loaded arm for articulation
    let armForearmPart = null; // Reference to forearm+hand section
    let currentHeadGroup = null; // Reference to loaded head
    let headNeckSwivel = null; // Reference to neck swivel group
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();

    // Initialize
    function init() {
      const canvas = document.getElementById('canvas');
      
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);
      scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);

      // Camera
      camera = new THREE.PerspectiveCamera(
        75,
        canvas.parentElement.offsetWidth / canvas.parentElement.offsetHeight,
        0.1,
        1000
      );
      camera.position.set(5, 5, 5);

      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.parentElement.offsetWidth, canvas.parentElement.offsetHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 2;
      controls.maxDistance = 50;

      // Transform Controls for object manipulation
      transformControl = new THREE.TransformControls(camera, renderer.domElement);
      transformControl.addEventListener('dragging-changed', function(event) {
        controls.enabled = !event.value;
      });
      scene.add(transformControl);
      
      // Keyboard: W=move, E=rotate, R=scale, Delete=remove
      window.addEventListener('keydown', function(event) {
        switch(event.key.toLowerCase()) {
          case 'w': 
            if (selectedObject) setTransformMode('translate');
            break;
          case 'e': 
            if (selectedObject) setTransformMode('rotate');
            break;
          case 'r': 
            if (selectedObject) setTransformMode('scale');
            break;
          case 'delete':
          case 'backspace':
            if (selectedObject) {
              scene.remove(selectedObject);
              objects = objects.filter(obj => obj !== selectedObject);
              transformControl.detach();
              selectedObject = null;
              
              // Remove selection box
              if (selectionBox) {
                scene.remove(selectionBox);
                selectionBox = null;
              }
              
              updateObjectCount();
            }
            break;
        }
      });

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 10, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0x667eea, 1, 100);
      pointLight.position.set(-5, 5, -5);
      scene.add(pointLight);

      // Ground plane
      const groundGeometry = new THREE.PlaneGeometry(50, 50);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a,
        roughness: 0.8,
        metalness: 0.2
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid
      const gridHelper = new THREE.GridHelper(50, 50, 0x667eea, 0x2a2a2a);
      scene.add(gridHelper);

      // Events
      canvas.addEventListener('click', onCanvasClick);
      window.addEventListener('resize', onWindowResize);

      // Hide loading
      document.getElementById('loading').style.display = 'none';

      // Start animation
      animate();
    }

    // Toggle orbit controls on/off
    function toggleOrbitControls() {
      orbitEnabled = !orbitEnabled;
      controls.enabled = orbitEnabled;
      
      const btn = document.getElementById('orbitToggle');
      if (orbitEnabled) {
        btn.textContent = 'üé• Orbit: ON';
        btn.style.background = 'rgba(76, 175, 80, 0.3)';
        btn.style.borderColor = 'rgba(76, 175, 80, 0.6)';
      } else {
        btn.textContent = 'üé• Orbit: OFF';
        btn.style.background = 'rgba(244, 67, 54, 0.3)';
        btn.style.borderColor = 'rgba(244, 67, 54, 0.6)';
      }
      
      console.log(`üé• Orbit controls: ${orbitEnabled ? 'ENABLED' : 'DISABLED'}`);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      
      // Update selection box to follow selected object
      if (selectionBox && selectedObject) {
        selectionBox.update();
      }
      
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const canvas = document.getElementById('canvas');
      camera.aspect = canvas.parentElement.offsetWidth / canvas.parentElement.offsetHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.parentElement.offsetWidth, canvas.parentElement.offsetHeight);
    }

    function onCanvasClick(event) {
      const canvas = document.getElementById('canvas');
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      // Check if clicking existing object to select it
      const intersects = raycaster.intersectObjects(objects, true);
      
      if (intersects.length > 0) {
        // Find the root object (in case of groups like anatomical arm)
        let clickedObject = intersects[0].object;
        while (clickedObject.parent && !objects.includes(clickedObject)) {
          clickedObject = clickedObject.parent;
        }
        
        selectedObject = clickedObject;
        
        // Don't auto-attach transform, just select
        console.log('‚úÖ Object selected - Click Move/Rotate/Scale or press W/E/R');
        return;
      }
      
      // Otherwise place new object on ground
      if (currentMode === 'add') {
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(groundPlane, intersectPoint);

        if (intersectPoint) {
          placePrimitive(intersectPoint);
        }
      }
    }

    function placePrimitive(position) {
      let geometry;
      
      switch(currentPrimitive) {
        case 'sphere':
          geometry = new THREE.SphereGeometry(primitiveSize, 32, 32);
          break;
        case 'cube':
          geometry = new THREE.BoxGeometry(primitiveSize, primitiveSize, primitiveSize);
          break;
        case 'cylinder':
          geometry = new THREE.CylinderGeometry(primitiveSize, primitiveSize, primitiveSize * 2, 32);
          break;
        case 'cone':
          geometry = new THREE.ConeGeometry(primitiveSize, primitiveSize * 2, 32);
          break;
        case 'torus':
          geometry = new THREE.TorusGeometry(primitiveSize, primitiveSize * 0.3, 16, 32);
          break;
        case 'pyramid':
          geometry = new THREE.ConeGeometry(primitiveSize, primitiveSize * 1.5, 4);
          break;
      }

      const material = new THREE.MeshStandardMaterial({
        color: currentMode === 'add' ? 0x00ff88 : 0xff3366,
        roughness: 0.7,
        metalness: 0.3,
        transparent: true,
        opacity: 0.9
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.position.y = primitiveSize / 2;
      mesh.rotation.y = (rotationAngle * Math.PI) / 180;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData.mode = currentMode;

      scene.add(mesh);
      objects.push(mesh);
      
      updateObjectCount();
      console.log(`Placed ${currentPrimitive} at`, position);
    }

    function setMode(mode, btn) {
      currentMode = mode;
      document.querySelectorAll('#sidebar .tool-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('modeDisplay').textContent = mode.toUpperCase();
      
      // Detach transform and remove selection box when switching to add mode
      if (mode === 'add' && selectedObject) {
        transformControl.detach();
        selectedObject = null;
        
        if (selectionBox) {
          scene.remove(selectionBox);
          selectionBox = null;
        }
      }
    }

    function setTransformMode(mode) {
      if (!selectedObject) {
        alert('‚ö†Ô∏è Click an object first to select it!\n\n1. Click any object in the scene\n2. Then use Move/Rotate/Scale buttons\n3. Or press W/E/R keys');
        return;
      }
      
      // Disable orbit controls when using transform
      if (orbitEnabled) {
        orbitEnabled = false;
        controls.enabled = false;
        const btn = document.getElementById('orbitToggle');
        btn.textContent = 'üé• Orbit: OFF';
        btn.style.background = 'rgba(244, 67, 54, 0.3)';
        btn.style.borderColor = 'rgba(244, 67, 54, 0.6)';
      }
      
      transformControl.setMode(mode);
      
      // Show selection box when entering transform mode
      if (!selectionBox && selectedObject) {
        selectionBox = new THREE.BoxHelper(selectedObject, 0x00ff88);
        scene.add(selectionBox);
      }
      console.log(`üé® Transform mode: ${mode.toUpperCase()}`);
    }

    function setPrimitive(primitive, btn) {
      currentPrimitive = primitive;
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('primitiveDisplay').textContent = primitive.toUpperCase();
    }

    // ü¶æ HUMAN ANATOMY LOADER (86-Vertex System)
    function loadHumanAnatomy(btn) {
      console.log('ü¶æ Loading 86-vertex human anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical arm with 86 vertices
      const armGroup = new THREE.Group();
      const vertexCount = 86;
      
      // Shoulder (origin point)
      const shoulderGeom = new THREE.SphereGeometry(0.3, 8, 8);
      const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
      armGroup.add(shoulder);
      
      // Upper arm (14" / 35cm extended cylinder)
      const upperArmGeom = new THREE.CylinderGeometry(0.2, 0.18, 3.5, 16);
      const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
      upperArm.position.y = -1.75;
      armGroup.add(upperArm);
      
      // Elbow joint (180¬∞ pivot capability)
      const elbowGeom = new THREE.SphereGeometry(0.22, 8, 8);
      const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const elbow = new THREE.Mesh(elbowGeom, elbowMat);
      elbow.position.y = -3.5;
      armGroup.add(elbow);
      
      // Create forearm group for articulation (rotates at elbow)
      const forearmGroup = new THREE.Group();
      forearmGroup.position.y = -3.5; // At elbow position
      armGroup.add(forearmGroup);
      
      // Forearm (14" / 35cm) - relative to elbow
      const forearmGeom = new THREE.CylinderGeometry(0.18, 0.15, 3.5, 16);
      const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const forearm = new THREE.Mesh(forearmGeom, forearmMat);
      forearm.position.y = -1.75; // Relative to elbow
      forearmGroup.add(forearm);
      
      // Wrist joint
      const wristGeom = new THREE.SphereGeometry(0.16, 8, 8);
      const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const wrist = new THREE.Mesh(wristGeom, wristMat);
      wrist.position.y = -3.5; // Relative to elbow
      forearmGroup.add(wrist);
      
      // Wrist bone protrusion (270-300¬∞ styloid process)
      const wristBoneGeom = new THREE.SphereGeometry(0.01, 8, 8);
      const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
      wristBone.position.set(0.15, -3.5, 0); // Relative to elbow
      forearmGroup.add(wristBone);
      
      // Hand (oval with 40% growth + curl)
      const handGeom = new THREE.BoxGeometry(0.4, 0.6, 0.15);
      const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const hand = new THREE.Mesh(handGeom, handMat);
      hand.position.y = -4.3; // Relative to elbow
      hand.rotation.x = Math.PI / 8; // 45¬∞ curl
      forearmGroup.add(hand);
      
      // Thumb (190¬∞ hump alignment)
      const thumbGeom = new THREE.CylinderGeometry(0.08, 0.06, 0.5, 8);
      const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const thumb = new THREE.Mesh(thumbGeom, thumbMat);
      thumb.position.set(-0.25, -4.1, 0.1); // Relative to elbow
      thumb.rotation.z = -Math.PI / 3;
      forearmGroup.add(thumb);
      
      // 4 Fingers (progressive sizing: 3.5" base, -10% per finger)
      const fingerLengths = [0.875, 0.7875, 0.7, 0.6125];
      for (let i = 0; i < 4; i++) {
        const fingerGeom = new THREE.CylinderGeometry(0.06 * (1 - i * 0.1), 0.04 * (1 - i * 0.1), fingerLengths[i], 8);
        const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const finger = new THREE.Mesh(fingerGeom, fingerMat);
        finger.position.set(-0.15 + (i * 0.1), -4.8, 0); // Relative to elbow
        finger.rotation.x = Math.PI / 12;
        forearmGroup.add(finger);
        
        // Fingertip (spherical)
        const tipGeom = new THREE.SphereGeometry(0.05 * (1 - i * 0.1), 8, 8);
        const tipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const tip = new THREE.Mesh(tipGeom, tipMat);
        tip.position.set(-0.15 + (i * 0.1), -4.8 - fingerLengths[i] / 2, 0); // Relative to elbow
        forearmGroup.add(tip);
      }
      
      // Store references for articulation
      currentArmGroup = armGroup;
      armForearmPart = forearmGroup;
      
      // Position the arm group so hand rests on ground
      armGroup.position.set(0, 8.75, 0);
      scene.add(armGroup);
      objects.push(armGroup);
      
      // Show articulation controls
      document.getElementById('armArticulation').style.display = 'block';
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HUMAN ARM (${vertexCount}V)`;
      
      console.log(`‚úÖ Anatomical arm loaded: ${vertexCount} vertices - shoulder, upper arm, elbow, forearm, wrist, hand, thumb, 4 fingers - ARTICULATION ENABLED`);
    }
    
    // ü¶æü¶æ DUAL ARMS LOADER (172 Vertices Total)
    function loadBothArms(btn) {
      console.log('ü¶æü¶æ Loading both arms (left + right)...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      const bothArmsGroup = new THREE.Group();
      const totalVertexCount = 172;
      
      // Helper function to create a single arm
      function createArm(xOffset, isRight = false) {
        const armGroup = new THREE.Group();
        
        // Shoulder
        const shoulderGeom = new THREE.SphereGeometry(0.3, 8, 8);
        const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
        armGroup.add(shoulder);
        
        // Upper arm
        const upperArmGeom = new THREE.CylinderGeometry(0.2, 0.18, 3.5, 16);
        const upperArmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const upperArm = new THREE.Mesh(upperArmGeom, upperArmMat);
        upperArm.position.y = -1.75;
        armGroup.add(upperArm);
        
        // Elbow joint
        const elbowGeom = new THREE.SphereGeometry(0.22, 8, 8);
        const elbowMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const elbow = new THREE.Mesh(elbowGeom, elbowMat);
        elbow.position.y = -3.5;
        armGroup.add(elbow);
        
        // Forearm group for articulation
        const forearmGroup = new THREE.Group();
        forearmGroup.position.y = -3.5;
        armGroup.add(forearmGroup);
        
        // Forearm
        const forearmGeom = new THREE.CylinderGeometry(0.18, 0.15, 3.5, 16);
        const forearmMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const forearm = new THREE.Mesh(forearmGeom, forearmMat);
        forearm.position.y = -1.75;
        forearmGroup.add(forearm);
        
        // Wrist
        const wristGeom = new THREE.SphereGeometry(0.16, 8, 8);
        const wristMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const wrist = new THREE.Mesh(wristGeom, wristMat);
        wrist.position.y = -3.5;
        forearmGroup.add(wrist);
        
        // Wrist bone (mirror for right arm)
        const wristBoneGeom = new THREE.SphereGeometry(0.01, 8, 8);
        const wristBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const wristBone = new THREE.Mesh(wristBoneGeom, wristBoneMat);
        wristBone.position.set(isRight ? -0.15 : 0.15, -3.5, 0);
        forearmGroup.add(wristBone);
        
        // Hand
        const handGeom = new THREE.BoxGeometry(0.4, 0.6, 0.15);
        const handMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const hand = new THREE.Mesh(handGeom, handMat);
        hand.position.y = -4.3;
        hand.rotation.x = Math.PI / 8;
        forearmGroup.add(hand);
        
        // Thumb (mirror position for right arm)
        const thumbGeom = new THREE.CylinderGeometry(0.08, 0.06, 0.5, 8);
        const thumbMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const thumb = new THREE.Mesh(thumbGeom, thumbMat);
        thumb.position.set(isRight ? 0.25 : -0.25, -4.1, 0.1);
        thumb.rotation.z = isRight ? Math.PI / 3 : -Math.PI / 3;
        forearmGroup.add(thumb);
        
        // 4 Fingers
        const fingerLengths = [0.875, 0.7875, 0.7, 0.6125];
        for (let i = 0; i < 4; i++) {
          const fingerGeom = new THREE.CylinderGeometry(0.06 * (1 - i * 0.1), 0.04 * (1 - i * 0.1), fingerLengths[i], 8);
          const fingerMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
          const finger = new THREE.Mesh(fingerGeom, fingerMat);
          const xPos = isRight ? 0.15 - (i * 0.1) : -0.15 + (i * 0.1);
          finger.position.set(xPos, -4.8, 0);
          finger.rotation.x = Math.PI / 12;
          forearmGroup.add(finger);
          
          // Fingertip
          const tipGeom = new THREE.SphereGeometry(0.05 * (1 - i * 0.1), 8, 8);
          const tipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
          const tip = new THREE.Mesh(tipGeom, tipMat);
          tip.position.set(xPos, -4.8 - fingerLengths[i] / 2, 0);
          forearmGroup.add(tip);
        }
        
        // Position arm at shoulder offset
        armGroup.position.set(xOffset, 0, 0);
        
        return { armGroup, forearmGroup };
      }
      
      // Create left arm (negative X)
      const leftArm = createArm(-1.2, false);
      bothArmsGroup.add(leftArm.armGroup);
      
      // Create right arm (positive X)
      const rightArm = createArm(1.2, true);
      bothArmsGroup.add(rightArm.armGroup);
      
      // Position both arms at shoulder height
      bothArmsGroup.position.set(0, 8.75, 0);
      scene.add(bothArmsGroup);
      objects.push(bothArmsGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `BOTH ARMS (${totalVertexCount}V)`;
      
      console.log(`‚úÖ Both arms loaded: ${totalVertexCount} vertices (86V √ó 2) - left shoulder at X=-1.2, right shoulder at X=1.2`);
    }
    
    // Update elbow angle (180¬∞ = straight, 340¬∞ = fully bent)
    function updateElbowAngle(angle) {
      if (!armForearmPart) {
        console.warn('‚ö†Ô∏è No arm loaded for articulation');
        return;
      }
      
      // Convert angle to radians (180¬∞ = 0 rad, 340¬∞ = bent forward)
      // Rotate around X axis to bend elbow
      const bendAngle = (angle - 180) * (Math.PI / 180);
      armForearmPart.rotation.x = bendAngle;
      
      // Update display
      document.getElementById('elbowAngleValue').textContent = angle + '¬∞';
      
      console.log(`üí™ Elbow angle: ${angle}¬∞ (${bendAngle.toFixed(2)} rad)`);
    }

    // ü¶µ HUMAN LEG LOADER (86-Vertex System)
    function loadHumanLeg(btn) {
      console.log('ü¶µ Loading 86-vertex leg anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical leg with 86 vertices
      const legGroup = new THREE.Group();
      const vertexCount = 86;
      
      // Hip joint (origin point)
      const hipGeom = new THREE.SphereGeometry(0.35, 8, 8);
      const hipMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const hip = new THREE.Mesh(hipGeom, hipMat);
      legGroup.add(hip);
      
      // Thigh (14" / 35cm extended cylinder)
      const thighGeom = new THREE.CylinderGeometry(0.25, 0.22, 3.5, 16);
      const thighMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const thigh = new THREE.Mesh(thighGeom, thighMat);
      thigh.position.y = -1.75;
      legGroup.add(thigh);
      
      // Knee joint (180¬∞ pivot capability)
      const kneeGeom = new THREE.SphereGeometry(0.24, 8, 8);
      const kneeMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const knee = new THREE.Mesh(kneeGeom, kneeMat);
      knee.position.y = -3.5;
      legGroup.add(knee);
      
      // Calf (14" / 35cm)
      const calfGeom = new THREE.CylinderGeometry(0.22, 0.18, 3.5, 16);
      const calfMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const calf = new THREE.Mesh(calfGeom, calfMat);
      calf.position.y = -5.25;
      legGroup.add(calf);
      
      // Ankle joint
      const ankleGeom = new THREE.SphereGeometry(0.18, 8, 8);
      const ankleMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
      const ankle = new THREE.Mesh(ankleGeom, ankleMat);
      ankle.position.y = -7;
      legGroup.add(ankle);
      
      // Ankle bone protrusion (malleolus)
      const ankleBoneGeom = new THREE.SphereGeometry(0.012, 8, 8);
      const ankleBoneMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const ankleBone = new THREE.Mesh(ankleBoneGeom, ankleBoneMat);
      ankleBone.position.set(0.18, -7, 0);
      legGroup.add(ankleBone);
      
      // Foot (elongated with 40% growth)
      const footGeom = new THREE.BoxGeometry(0.35, 0.25, 0.8);
      const footMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const foot = new THREE.Mesh(footGeom, footMat);
      foot.position.set(0, -7.3, 0.3);
      foot.rotation.x = -Math.PI / 16; // Slight arch
      legGroup.add(foot);
      
      // Big toe (larger and separate)
      const bigToeGeom = new THREE.CylinderGeometry(0.07, 0.05, 0.35, 8);
      const bigToeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const bigToe = new THREE.Mesh(bigToeGeom, bigToeMat);
      bigToe.position.set(-0.12, -7.5, 0.65);
      bigToe.rotation.x = Math.PI / 2;
      legGroup.add(bigToe);
      
      // 4 Toes (progressive sizing: smaller than big toe, decreasing)
      const toeLengths = [0.28, 0.26, 0.24, 0.22]; // Progressive reduction
      for (let i = 0; i < 4; i++) {
        const toeGeom = new THREE.CylinderGeometry(0.045 * (1 - i * 0.08), 0.03 * (1 - i * 0.08), toeLengths[i], 8);
        const toeMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
        const toe = new THREE.Mesh(toeGeom, toeMat);
        toe.position.set(-0.05 + (i * 0.08), -7.5, 0.65);
        toe.rotation.x = Math.PI / 2;
        legGroup.add(toe);
        
        // Toe tip (spherical)
        const toeTipGeom = new THREE.SphereGeometry(0.035 * (1 - i * 0.08), 8, 8);
        const toeTipMat = new THREE.MeshStandardMaterial({ color: 0xffaa88, roughness: 0.6 });
        const toeTip = new THREE.Mesh(toeTipGeom, toeTipMat);
        toeTip.position.set(-0.05 + (i * 0.08), -7.5, 0.65 + toeLengths[i] / 2);
        legGroup.add(toeTip);
      }
      
      // Position the leg group so foot rests on ground (foot bottom is at ~Y=-7.5, so lift by 7.5)
      legGroup.position.set(0, 7.5, 0);
      scene.add(legGroup);
      objects.push(legGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HUMAN LEG (${vertexCount}V)`;
      
      console.log(`‚úÖ Anatomical leg loaded: ${vertexCount} vertices - hip, thigh, knee, calf, ankle, foot, big toe, 4 toes`);
    }

    // ü¶¥ HUMAN TORSO LOADER (120+ Vertices)
    function loadHumanTorso(btn) {
      console.log('ü¶¥ Loading torso anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical torso
      const torsoGroup = new THREE.Group();
      let vertexCount = 120;
      
      // Pelvis base (hip connector)
      const pelvisGeom = new THREE.CylinderGeometry(0.45, 0.5, 0.6, 16);
      const pelvisMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const pelvis = new THREE.Mesh(pelvisGeom, pelvisMat);
      pelvis.position.y = 0;
      torsoGroup.add(pelvis);
      
      // Lower spine (L1-L5 lumbar vertebrae)
      const lowerSpineGeom = new THREE.CylinderGeometry(0.12, 0.12, 1.2, 12);
      const spineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      const lowerSpine = new THREE.Mesh(lowerSpineGeom, spineMat);
      lowerSpine.position.y = 0.9;
      torsoGroup.add(lowerSpine);
      
      // Mid spine (T7-T12 thoracic vertebrae)
      const midSpineGeom = new THREE.CylinderGeometry(0.13, 0.12, 1.5, 12);
      const midSpine = new THREE.Mesh(midSpineGeom, spineMat);
      midSpine.position.y = 2.25;
      torsoGroup.add(midSpine);
      
      // Upper spine (T1-T6 thoracic vertebrae)
      const upperSpineGeom = new THREE.CylinderGeometry(0.14, 0.13, 1.2, 12);
      const upperSpine = new THREE.Mesh(upperSpineGeom, spineMat);
      upperSpine.position.y = 3.6;
      torsoGroup.add(upperSpine);
      
      // Ribcage (12 ribs on each side)
      for (let i = 0; i < 12; i++) {
        const ribHeight = 2.0 + (i * 0.15);
        const ribWidth = 0.35 + (i * 0.04);
        const ribDepth = 0.25 + (i * 0.03);
        
        // Left rib
        const leftRibGeom = new THREE.TorusGeometry(ribWidth, 0.02, 8, 16, Math.PI);
        const ribMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const leftRib = new THREE.Mesh(leftRibGeom, ribMat);
        leftRib.position.set(-0.15, ribHeight, 0);
        leftRib.rotation.y = Math.PI / 2;
        leftRib.rotation.z = -Math.PI / 12;
        torsoGroup.add(leftRib);
        
        // Right rib
        const rightRib = new THREE.Mesh(leftRibGeom.clone(), ribMat);
        rightRib.position.set(0.15, ribHeight, 0);
        rightRib.rotation.y = -Math.PI / 2;
        rightRib.rotation.z = Math.PI / 12;
        torsoGroup.add(rightRib);
      }
      
      // Chest/sternum
      const chestGeom = new THREE.BoxGeometry(0.4, 1.8, 0.2);
      const chestMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.7 });
      const chest = new THREE.Mesh(chestGeom, chestMat);
      chest.position.set(0, 3.0, 0.35);
      torsoGroup.add(chest);
      
      // Left shoulder socket
      const leftShoulderGeom = new THREE.SphereGeometry(0.25, 8, 8);
      const shoulderMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.6 });
      const leftShoulder = new THREE.Mesh(leftShoulderGeom, shoulderMat);
      leftShoulder.position.set(-0.6, 4.0, 0);
      torsoGroup.add(leftShoulder);
      
      // Right shoulder socket
      const rightShoulder = new THREE.Mesh(leftShoulderGeom, shoulderMat);
      rightShoulder.position.set(0.6, 4.0, 0);
      torsoGroup.add(rightShoulder);
      
      // Clavicles (collar bones)
      const clavicleGeom = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8);
      const clavicleMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
      
      const leftClavicle = new THREE.Mesh(clavicleGeom, clavicleMat);
      leftClavicle.position.set(-0.35, 4.0, 0.1);
      leftClavicle.rotation.z = Math.PI / 6;
      torsoGroup.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(clavicleGeom, clavicleMat);
      rightClavicle.position.set(0.35, 4.0, 0.1);
      rightClavicle.rotation.z = -Math.PI / 6;
      torsoGroup.add(rightClavicle);
      
      // Position torso at ground level (pelvis at Y=0, lift to ground)
      torsoGroup.position.set(0, 0.3, 0);
      scene.add(torsoGroup);
      objects.push(torsoGroup);
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `TORSO (${vertexCount}V)`;
      
      console.log(`‚úÖ Anatomical torso loaded: ${vertexCount}+ vertices - pelvis, spine, 24 ribs, chest, shoulders, clavicles`);
    }

    // üß† HUMAN HEAD & NECK LOADER (100+ Vertices)
    function loadHumanHead(btn) {
      console.log('üß† Loading head and neck anatomy...');
      
      // Clear primitive selection
      document.querySelectorAll('.primitive-grid .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Create anatomical head & neck group
      const headGroup = new THREE.Group();
      let vertexCount = 100;
      
      // Neck base (C7 vertebra)
      const neckBaseGeom = new THREE.CylinderGeometry(0.14, 0.12, 0.4, 12);
      const neckMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.6 });
      const neckBase = new THREE.Mesh(neckBaseGeom, neckMat);
      neckBase.position.y = 0.2;
      headGroup.add(neckBase);
      
      // Create neck swivel group (rotates for head turning)
      const neckSwivelGroup = new THREE.Group();
      neckSwivelGroup.position.y = 0.4;
      headGroup.add(neckSwivelGroup);
      
      // Neck cylinder (C1-C6 cervical vertebrae)
      const neckGeom = new THREE.CylinderGeometry(0.12, 0.14, 1.0, 12);
      const neck = new THREE.Mesh(neckGeom, neckMat);
      neck.position.y = 0.5;
      neckSwivelGroup.add(neck);
      
      // Skull base (foramen magnum)
      const skullBaseGeom = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 12);
      const boneMat = new THREE.MeshStandardMaterial({ color: 0xfff8e7, roughness: 0.4 });
      const skullBase = new THREE.Mesh(skullBaseGeom, boneMat);
      skullBase.position.y = 1.1;
      neckSwivelGroup.add(skullBase);
      
      // Cranium (main skull sphere)
      const craniumGeom = new THREE.SphereGeometry(0.65, 16, 16);
      const cranium = new THREE.Mesh(craniumGeom, boneMat);
      cranium.position.y = 1.6;
      cranium.scale.set(1, 1.1, 1); // Slightly taller
      neckSwivelGroup.add(cranium);
      
      // Jaw (mandible)
      const jawGeom = new THREE.BoxGeometry(0.5, 0.3, 0.4);
      const skinMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const jaw = new THREE.Mesh(jawGeom, skinMat);
      jaw.position.set(0, 1.0, 0.25);
      neckSwivelGroup.add(jaw);
      
      // Face plane (for features)
      const faceGeom = new THREE.CircleGeometry(0.55, 16);
      const faceMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.6, side: THREE.DoubleSide });
      const face = new THREE.Mesh(faceGeom, faceMat);
      face.position.set(0, 1.6, 0.6);
      neckSwivelGroup.add(face);
      
      // Left eye
      const eyeGeom = new THREE.SphereGeometry(0.08, 12, 12);
      const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
      const leftEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
      leftEye.position.set(-0.18, 1.7, 0.58);
      neckSwivelGroup.add(leftEye);
      
      // Left pupil
      const pupilGeom = new THREE.SphereGeometry(0.04, 12, 12);
      const pupilMat = new THREE.MeshStandardMaterial({ color: 0x2a4d69, roughness: 0.2 });
      const leftPupil = new THREE.Mesh(pupilGeom, pupilMat);
      leftPupil.position.set(-0.18, 1.7, 0.63);
      neckSwivelGroup.add(leftPupil);
      
      // Right eye
      const rightEye = new THREE.Mesh(eyeGeom, eyeWhiteMat);
      rightEye.position.set(0.18, 1.7, 0.58);
      neckSwivelGroup.add(rightEye);
      
      // Right pupil
      const rightPupil = new THREE.Mesh(pupilGeom, pupilMat);
      rightPupil.position.set(0.18, 1.7, 0.63);
      neckSwivelGroup.add(rightPupil);
      
      // Nose
      const noseGeom = new THREE.ConeGeometry(0.08, 0.2, 8);
      const nose = new THREE.Mesh(noseGeom, skinMat);
      nose.position.set(0, 1.5, 0.62);
      nose.rotation.x = Math.PI / 2;
      neckSwivelGroup.add(nose);
      
      // Mouth
      const mouthGeom = new THREE.BoxGeometry(0.25, 0.05, 0.1);
      const mouthMat = new THREE.MeshStandardMaterial({ color: 0xff6b8a, roughness: 0.5 });
      const mouth = new THREE.Mesh(mouthGeom, mouthMat);
      mouth.position.set(0, 1.25, 0.6);
      neckSwivelGroup.add(mouth);
      
      // Left ear
      const earGeom = new THREE.SphereGeometry(0.12, 12, 12);
      const leftEar = new THREE.Mesh(earGeom, skinMat);
      leftEar.position.set(-0.6, 1.6, 0.1);
      leftEar.scale.set(0.5, 1, 0.8);
      neckSwivelGroup.add(leftEar);
      
      // Right ear
      const rightEar = new THREE.Mesh(earGeom, skinMat);
      rightEar.position.set(0.6, 1.6, 0.1);
      rightEar.scale.set(0.5, 1, 0.8);
      neckSwivelGroup.add(rightEar);
      
      // Store reference for neck swivel
      currentHeadGroup = headGroup;
      headNeckSwivel = neckSwivelGroup;
      
      // Position head at appropriate height
      headGroup.position.set(0, 4.5, 0);
      scene.add(headGroup);
      objects.push(headGroup);
      
      // Show neck swivel controls
      document.getElementById('neckSwivel').style.display = 'block';
      
      // Update UI
      updateObjectCount();
      updateVertexCount();
      document.getElementById('primitiveDisplay').textContent = `HEAD (${vertexCount}V)`;
      
      console.log(`‚úÖ Anatomical head loaded: ${vertexCount}+ vertices - neck, skull, jaw, eyes, nose, mouth, ears - NECK SWIVEL ENABLED`);
    }
    
    // Update neck swivel angle (-180¬∞ to 180¬∞)
    function updateNeckSwivel(angle) {
      if (!headNeckSwivel) {
        console.warn('‚ö†Ô∏è No head loaded for neck swivel');
        return;
      }
      
      // Convert angle to radians and rotate around Y axis
      const swivelAngle = angle * (Math.PI / 180);
      headNeckSwivel.rotation.y = swivelAngle;
      
      // Update display
      document.getElementById('neckSwivelValue').textContent = angle + '¬∞';
      
      console.log(`üîÑ Neck swivel: ${angle}¬∞ (${swivelAngle.toFixed(2)} rad)`);
    }

    function updateSize(value) {
      primitiveSize = parseFloat(value);
      document.getElementById('sizeValue').textContent = value;
    }

    function updateAngle(value) {
      rotationAngle = parseFloat(value);
      document.getElementById('angleValue').textContent = value + '¬∞';
    }

    // Open 3D vertex matrix editor in new window
    function openAnatomyEditor() {
      const editorWindow = window.open('3d_vertex_matrix_environment.html', 'VertexMatrixEditor', 'width=1400,height=900');
      if (editorWindow) {
        console.log('‚úÖ 3D Vertex Matrix Editor opened in new window');
      } else {
        alert('‚ö†Ô∏è Please allow pop-ups to open the vertex matrix editor');
      }
    }

    function clearScene() {
      if (confirm('Clear all objects?')) {
        objects.forEach(obj => scene.remove(obj));
        objects = [];
        updateObjectCount();
      }
    }

    function switchWorkspace(workspace, btn) {
      // Update tab UI
      document.querySelectorAll('.workspace-tab').forEach(tab => tab.classList.remove('active'));
      btn.classList.add('active');

      // Hide all workspace content
      document.querySelectorAll('.workspace-content').forEach(content => {
        content.style.display = 'none';
      });

      // Show selected workspace
      const workspaceElement = document.getElementById(`workspace-${workspace}`);
      if (workspaceElement) {
        workspaceElement.style.display = 'block';
      }

      // Update display
      const workspaceNames = {
        'sculpt': '3D SCULPT',
        'css': 'CSS DESIGNER',
        'word': 'WORDWEAVER',
        'campus': 'CAMPUS',
        'perfect': 'PERFECT'
      };
      document.getElementById('workspaceDisplay').textContent = workspaceNames[workspace] || workspace.toUpperCase();
      
      console.log('Switched to:', workspace);
    }

    function updateObjectCount() {
      document.getElementById('objectCount').textContent = objects.length;
    }

    function updateVertexCount() {
      let totalVertices = 0;
      objects.forEach(obj => {
        obj.traverse((child) => {
          if (child.geometry) {
            const positions = child.geometry.attributes.position;
            if (positions) {
              totalVertices += positions.count;
            }
          }
        });
      });
      document.getElementById('vertexCount').textContent = totalVertices;
      console.log(`üìä Total vertices in scene: ${totalVertices}`);
    }

    // =============================================
    // MATHEMATICIAN TRIBUTE SYSTEM
    // =============================================

    let learnModeActive = false;
    let currentMethod = 'fibonacci';

    const MATHEMATICIANS = {
      fibonacci: {
        name: "Leonardo Fibonacci",
        born: 1170,
        died: 1250,
        flag: "üáÆüáπ",
        nationality: "Italian",
        discovery: "Fibonacci Sequence",
        story: "Italian mathematician who discovered the famous sequence (0,1,1,2,3,5,8...) while studying rabbit populations. Each number is the sum of the two before it! This sequence appears everywhere in nature: sunflower spirals, pinecones, nautilus shells.",
        kidFact: "He introduced Arabic numerals (0-9) to Europe! Before him, Europeans used Roman numerals (I, II, III, IV...) which made math really hard."
      },
      catmull: {
        name: "Edwin Catmull",
        born: 1945,
        died: null,
        flag: "üá∫üá∏",
        nationality: "American",
        discovery: "Catmull-Rom Splines & Subdivision",
        story: "Co-founder of Pixar! Created smooth curve algorithms while dreaming of making the first computer-animated movie. His math makes characters move smoothly and naturally.",
        kidFact: "He won an Oscar for his technology! Every Pixar movie (Toy Story, Finding Nemo, The Incredibles) uses his math to make characters move smoothly."
      },
      bezier: {
        name: "Pierre B√©zier",
        born: 1910,
        died: 1999,
        flag: "üá´üá∑",
        nationality: "French",
        discovery: "B√©zier Curves",
        story: "Renault car designer who invented curves you can control with just a few points. Used in fonts, animations, car design, and every vector graphic you see!",
        kidFact: "Every letter you're reading right now uses B√©zier curves! Computer fonts are made entirely of his curves. Even emojis! üòä"
      },
      perlin: {
        name: "Ken Perlin",
        born: 1951,
        died: null,
        flag: "üéÆ",
        nationality: "American",
        discovery: "Perlin Noise",
        story: "NYU professor who created natural-looking randomness for the movie TRON (1982). Won an Oscar for making computer graphics look organic instead of artificial!",
        kidFact: "Minecraft's entire world generation uses Perlin noise! Every mountain, cave, and biome is created with his algorithm. Without it, Minecraft wouldn't exist!"
      },
      quaternion: {
        name: "William Hamilton",
        born: 1805,
        died: 1865,
        flag: "üáÆüá™",
        nationality: "Irish",
        discovery: "Quaternions",
        story: "Had a 'eureka moment' while walking across Brougham Bridge in Dublin. He was so excited he carved the formula (i¬≤=j¬≤=k¬≤=ijk=-1) into the bridge stone with his knife!",
        kidFact: "Every 3D video game character rotation uses quaternions! They prevent 'gimbal lock' - a glitch that made old games spin weirdly. Your character wouldn't turn smoothly without them!"
      },
      lsystem: {
        name: "Aristid Lindenmayer",
        born: 1925,
        died: 1989,
        flag: "üá≠üá∫",
        nationality: "Hungarian",
        discovery: "L-Systems (Lindenmayer Systems)",
        story: "Biologist and botanist who created a simple alphabet system to model how plants grow. Simple rules like 'A becomes AB, B becomes A' create complex fractal patterns that look like real plants!",
        kidFact: "Video game trees and plants are grown with L-Systems! One simple rule repeated over and over can create an entire realistic forest. It's like growing a digital plant from a seed!"
      },
      voronoi: {
        name: "Georgy Voronoi",
        born: 1868,
        died: 1908,
        flag: "üá∫üá¶",
        nationality: "Ukrainian",
        discovery: "Voronoi Diagrams",
        story: "Mathematician who figured out how to divide space based on nearest neighbors. Imagine drawing territories around each point where everything inside is closer to that point than any other!",
        kidFact: "Giraffe spots follow Voronoi patterns! Nature uses this math for animal patterns, cell structures, and crystal growth. Your body's cells organize using Voronoi math!"
      },
      phong: {
        name: "Bui Tuong Phong",
        born: 1942,
        died: 1975,
        flag: "üáªüá≥",
        nationality: "Vietnamese",
        discovery: "Phong Shading",
        story: "Created the lighting model that made 3D objects look shiny and realistic. His PhD thesis at University of Utah changed computer graphics forever. Tragically died of leukemia at age 32, but his legacy lives in every 3D game.",
        kidFact: "Every shiny surface in 3D games uses Phong shading! He made plastic, metal, and glass look real on computers. When you see light reflecting off a character's armor - that's his math!"
      },
      delaunay: {
        name: "Boris Delaunay",
        born: 1890,
        died: 1980,
        flag: "üá∑üá∫",
        nationality: "Russian",
        discovery: "Delaunay Triangulation",
        story: "Russian mathematician who figured out the optimal way to connect dots with triangles. His method creates the 'fattest' triangles possible, avoiding skinny ones that cause problems in 3D graphics.",
        kidFact: "3D game terrain is built with Delaunay triangles! Mountains, valleys, and landscapes are made by connecting height points with his optimal triangles. Every open-world game uses this!"
      },
      subdivision: {
        name: "Jim Clark & Edwin Catmull",
        born: 1944,
        died: null,
        flag: "üíé",
        nationality: "American",
        discovery: "Subdivision Surfaces",
        story: "Jim Clark founded Silicon Graphics (the company that made movie CGI possible) and Netscape (early web browser). With Catmull, they figured out how to make blocky shapes smooth by subdividing faces repeatedly.",
        kidFact: "Every smooth 3D character starts blocky! Artists model a simple cube-like shape, then subdivision turns it into a smooth character. It's like magic - a cube becomes a smooth head!"
      }
    };

    function toggleLearnMode(btn) {
      learnModeActive = !learnModeActive;
      const info = document.getElementById('learnModeInfo');
      
      if (learnModeActive) {
        btn.innerHTML = '<span class="tool-icon">üéì</span><span>Learn Mode ON</span>';
        btn.style.background = 'rgba(0, 255, 136, 0.3)';
        btn.style.borderColor = '#00ff88';
        info.style.display = 'block';
        
        // Show initial method story
        showMathematicianStory(currentMethod);
        
        console.log(`
üìö ============================================
   LEARN MODE ACTIVATED!
   
   Now when you select Mathematical Methods,
   you'll see the mathematician's story, their
   discovery, and how it powers your creations!
   
   Click any method below to learn! üèÜ
============================================
        `);
      } else {
        btn.innerHTML = '<span class="tool-icon">üë®‚Äçüè´</span><span>Enable Story Mode</span>';
        btn.style.background = 'rgba(0, 255, 136, 0.1)';
        btn.style.borderColor = 'rgba(0, 255, 136, 0.3)';
        info.style.display = 'none';
        document.getElementById('mathematicianStory').style.display = 'none';
      }
    }

    function selectMethod(method, btn) {
      currentMethod = method;
      
      // Update active button
      btn.parentElement.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Show story if Learn Mode is active
      if (learnModeActive) {
        showMathematicianStory(method);
      }
      
      // Log to console
      const mathematician = MATHEMATICIANS[method];
      console.log(`
üèÜ ============================================
   METHOD SELECTED: ${mathematician.discovery}
   Mathematician: ${mathematician.name} (${mathematician.born}-${mathematician.died || 'Present'})
   ${mathematician.flag} ${mathematician.nationality}
   
   üìñ Story: ${mathematician.story}
   
   üí° Kid Fact: ${mathematician.kidFact}
============================================
      `);
    }

    function showMathematicianStory(method) {
      const mathematician = MATHEMATICIANS[method];
      const panel = document.getElementById('mathematicianStory');
      
      // Update story content
      document.getElementById('storyTitle').textContent = `üèÜ ${mathematician.discovery}`;
      document.getElementById('storyFlag').textContent = mathematician.flag;
      document.getElementById('storyName').textContent = mathematician.name;
      document.getElementById('storyDates').textContent = `${mathematician.born}-${mathematician.died || 'Present'} ‚Ä¢ ${mathematician.nationality}`;
      document.getElementById('storyDiscovery').textContent = `Discovery: ${mathematician.discovery}`;
      document.getElementById('storyText').textContent = mathematician.story;
      document.getElementById('storyKidFact').textContent = mathematician.kidFact;
      
      // Show panel with smooth animation
      panel.style.display = 'block';
    }

    // Start
    window.addEventListener('load', init);
  </script>
</body>
</html>
