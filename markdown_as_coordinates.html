<!DOCTYPE html>
<html>
<head>
    <title>Markdown Symbols as Executable Coordinates</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            overflow-x: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 100vh;
        }
        
        .panel {
            background: #111;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
        }
        
        .panel h2 {
            margin: 0 0 15px 0;
            color: #00ffff;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 5px;
        }
        
        #markdown-source {
            white-space: pre-wrap;
            line-height: 1.8;
            position: relative;
        }
        
        /* Highlight different markdown symbols */
        .asterisk {
            background: rgba(255, 100, 0, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .asterisk:hover {
            background: rgba(255, 100, 0, 0.8);
            transform: scale(1.1);
        }
        
        .heading {
            background: rgba(0, 255, 255, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .heading:hover {
            background: rgba(0, 255, 255, 0.8);
        }
        
        .backtick {
            background: rgba(255, 255, 0, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .backtick:hover {
            background: rgba(255, 255, 0, 0.8);
        }
        
        .function-block {
            background: rgba(0, 255, 0, 0.2);
            border-left: 3px solid #00ff00;
            padding: 5px;
            margin: 5px 0;
        }
        
        #canvas-output {
            width: 100%;
            height: 500px;
            background: #000;
            border-radius: 5px;
        }
        
        #coordinate-log {
            background: #000;
            padding: 10px;
            border-radius: 5px;
            height: 300px;
            overflow-y: auto;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .coordinate-marker {
            color: #ff6600;
            margin: 3px 0;
        }
        
        .vertex-count {
            color: #00ffff;
            font-weight: bold;
        }
        
        .controls {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        button:hover {
            background: #00ffff;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        .stat-box {
            display: inline-block;
            background: #1a1a1a;
            padding: 5px 10px;
            margin: 5px;
            border-radius: 5px;
            border: 1px solid #00ff00;
        }
        
        .stat-label {
            color: #888;
            font-size: 11px;
        }
        
        .stat-value {
            color: #00ff00;
            font-size: 16px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel: Markdown with Coordinate Markers -->
        <div class="panel">
            <h2>üìÑ Markdown as Coordinate System</h2>
            <div class="controls">
                <button onclick="parseMarkdown()">üîç Parse Coordinates</button>
                <button onclick="traverseForward()">‚ñ∂Ô∏è Traverse Forward</button>
                <button onclick="traverseBackward()">‚óÄÔ∏è Traverse Backward</button>
                <button onclick="enlargeAll()">üî¨ Enlarge All (*)</button>
            </div>
            
            <div id="stats">
                <div class="stat-box">
                    <div class="stat-label">Asterisks (*)</div>
                    <div class="stat-value" id="asterisk-count">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Headings (#)</div>
                    <div class="stat-value" id="heading-count">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Functions</div>
                    <div class="stat-value" id="function-count">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Total Vertices</div>
                    <div class="stat-value vertex-count" id="vertex-count">0</div>
                </div>
            </div>
            
            <div id="markdown-source"></div>
        </div>
        
        <!-- Right Panel: Visual Execution -->
        <div class="panel">
            <h2>üé® Coordinate Visualization</h2>
            <canvas id="canvas-output"></canvas>
            <div id="coordinate-log"></div>
        </div>
    </div>
    
    <script>
        // Sample markdown with mixed code
        const sampleMarkdown = `# Main Coordinate Anchor

This is text with some **asterisk markers** that could be *vertex points*.

## Sub-Coordinate

More text with \`code boundaries\` that mark regions.

### Function Block (Don't Iterate Inside)

\`\`\`javascript
function stableBlock() {
    // This stays intact
    return "function = stable coordinate";
}
\`\`\`

Another paragraph with *multiple* *asterisk* *markers*.

#### Nested Coordinate

The **breathing** system uses *micro-iterations*.
The **joint** system uses *macro-iterations*.

JavaScript controls *time* and can read *forward* or *backward*.

### Code Block with Iteration

\`\`\`javascript
for (let i = 0; i < n; i++) {
    // Iteration between functions
    vertices[i].position *= scale;
}
\`\`\`

More *coordinate* *markers* that **enlarge** all vertices.

## Multiple Reaches All

When you use *multiple*, it doesn't iterate sequentially.
It reaches **every** *vertex* *point* **simultaneously**.

### Final Coordinates

The end with some *final* *markers*.`;

        // Coordinate tracking
        let coordinates = {
            asterisks: [],
            headings: [],
            backticks: [],
            functions: [],
            vertices: []
        };
        
        let currentIndex = 0;
        let canvas, ctx;
        
        // Initialize
        window.onload = function() {
            canvas = document.getElementById('canvas-output');
            ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            displayMarkdown();
            parseMarkdown();
        };
        
        // Display markdown with syntax highlighting
        function displayMarkdown() {
            const container = document.getElementById('markdown-source');
            let html = sampleMarkdown;
            
            // Highlight headings
            html = html.replace(/^(#{1,6})\s+(.+)$/gm, (match, hashes, text) => {
                return `<span class="heading" data-type="heading">${hashes} ${text}</span>`;
            });
            
            // Highlight backticks
            html = html.replace(/`([^`]+)`/g, (match, code) => {
                return `<span class="backtick" data-type="backtick">\`${code}\`</span>`;
            });
            
            // Highlight asterisks (bold/italic)
            html = html.replace(/\*\*([^*]+)\*\*/g, (match, text) => {
                return `<span class="asterisk" data-type="asterisk-bold">**${text}**</span>`;
            });
            
            html = html.replace(/\*([^*]+)\*/g, (match, text) => {
                return `<span class="asterisk" data-type="asterisk-italic">*${text}*</span>`;
            });
            
            // Highlight function blocks
            html = html.replace(/(function\s+\w+\s*\([^)]*\)\s*{[^}]+})/g, (match) => {
                return `<div class="function-block" data-type="function">${match}</div>`;
            });
            
            container.innerHTML = html;
            
            // Add click handlers
            container.querySelectorAll('[data-type]').forEach(el => {
                el.addEventListener('click', () => {
                    const type = el.getAttribute('data-type');
                    logCoordinate(`Clicked ${type}: "${el.textContent.substring(0, 30)}..."`);
                });
            });
        }
        
        // Parse markdown to extract coordinates
        function parseMarkdown() {
            coordinates = {
                asterisks: [],
                headings: [],
                backticks: [],
                functions: [],
                vertices: []
            };
            
            const lines = sampleMarkdown.split('\n');
            let vertexIndex = 0;
            
            lines.forEach((line, lineNum) => {
                // Find headings
                const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
                if (headingMatch) {
                    coordinates.headings.push({
                        line: lineNum,
                        level: headingMatch[1].length,
                        text: headingMatch[2],
                        vertex: vertexIndex++
                    });
                }
                
                // Find asterisks (vertex markers)
                const asteriskMatches = line.matchAll(/\*([^*]+)\*/g);
                for (const match of asteriskMatches) {
                    coordinates.asterisks.push({
                        line: lineNum,
                        text: match[1],
                        vertex: vertexIndex++
                    });
                }
                
                // Find backticks
                const backtickMatches = line.matchAll(/`([^`]+)`/g);
                for (const match of backtickMatches) {
                    coordinates.backticks.push({
                        line: lineNum,
                        text: match[1],
                        vertex: vertexIndex++
                    });
                }
                
                // Find functions
                const functionMatch = line.match(/function\s+(\w+)/);
                if (functionMatch) {
                    coordinates.functions.push({
                        line: lineNum,
                        name: functionMatch[1],
                        stable: true  // Don't iterate inside
                    });
                }
            });
            
            // Total vertices = all markers
            coordinates.vertices = [
                ...coordinates.asterisks,
                ...coordinates.headings,
                ...coordinates.backticks
            ];
            
            updateStats();
            visualizeCoordinates();
            
            logCoordinate('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            logCoordinate('üìä COORDINATE PARSING COMPLETE');
            logCoordinate('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            logCoordinate(`Asterisks: ${coordinates.asterisks.length} (vertex points)`);
            logCoordinate(`Headings: ${coordinates.headings.length} (major anchors)`);
            logCoordinate(`Backticks: ${coordinates.backticks.length} (boundaries)`);
            logCoordinate(`Functions: ${coordinates.functions.length} (stable blocks)`);
            logCoordinate(`Total Vertices: ${coordinates.vertices.length}`);
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('asterisk-count').textContent = coordinates.asterisks.length;
            document.getElementById('heading-count').textContent = coordinates.headings.length;
            document.getElementById('function-count').textContent = coordinates.functions.length;
            document.getElementById('vertex-count').textContent = coordinates.vertices.length;
        }
        
        // Visualize coordinates on canvas
        function visualizeCoordinates() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw vertices
            coordinates.vertices.forEach((vertex, i) => {
                const x = (i % 10) * (canvas.width / 10) + 30;
                const y = Math.floor(i / 10) * 60 + 30;
                
                // Different colors for different types
                let color = '#ff6600';  // Default (asterisk)
                if (coordinates.headings.includes(vertex)) {
                    color = '#00ffff';  // Heading
                } else if (coordinates.backticks.includes(vertex)) {
                    color = '#ffff00';  // Backtick
                }
                
                // Draw vertex point
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw index
                ctx.fillStyle = '#00ff00';
                ctx.font = '10px Courier New';
                ctx.fillText(i, x + 8, y + 4);
                
                // Draw line to next vertex
                if (i < coordinates.vertices.length - 1) {
                    const nextX = ((i + 1) % 10) * (canvas.width / 10) + 30;
                    const nextY = Math.floor((i + 1) / 10) * 60 + 30;
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(nextX, nextY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            // Draw functions as stable blocks
            coordinates.functions.forEach((func, i) => {
                const x = canvas.width - 150;
                const y = i * 40 + 30;
                
                ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.fillRect(x, y, 130, 30);
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(x, y, 130, 30);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = '12px Courier New';
                ctx.fillText(func.name, x + 5, y + 20);
            });
        }
        
        // Traverse forward through coordinates
        function traverseForward() {
            if (currentIndex >= coordinates.vertices.length - 1) {
                currentIndex = 0;
            }
            
            const vertex = coordinates.vertices[currentIndex];
            logCoordinate(`‚ñ∂Ô∏è Forward to vertex ${currentIndex}: ${vertex.text || 'N/A'} (line ${vertex.line})`);
            
            highlightVertex(currentIndex);
            currentIndex++;
        }
        
        // Traverse backward through coordinates
        function traverseBackward() {
            if (currentIndex <= 0) {
                currentIndex = coordinates.vertices.length - 1;
            }
            
            currentIndex--;
            const vertex = coordinates.vertices[currentIndex];
            logCoordinate(`‚óÄÔ∏è Backward to vertex ${currentIndex}: ${vertex.text || 'N/A'} (line ${vertex.line})`);
            
            highlightVertex(currentIndex);
        }
        
        // Highlight specific vertex
        function highlightVertex(index) {
            visualizeCoordinates();
            
            const x = (index % 10) * (canvas.width / 10) + 30;
            const y = Math.floor(index / 10) * 60 + 30;
            
            // Draw pulse animation
            let radius = 5;
            const pulse = setInterval(() => {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                radius += 2;
                if (radius > 20) {
                    clearInterval(pulse);
                    visualizeCoordinates();
                }
            }, 50);
        }
        
        // Enlarge all asterisk vertices (the "multiple" concept)
        function enlargeAll() {
            logCoordinate('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            logCoordinate('üî¨ MULTIPLE: Enlarging ALL asterisk vertices');
            logCoordinate('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            const asteriskVertices = coordinates.asterisks;
            
            logCoordinate(`Reaching ${asteriskVertices.length} vertices simultaneously...`);
            
            // Simulate parallel operation
            asteriskVertices.forEach((vertex, i) => {
                setTimeout(() => {
                    logCoordinate(`  ‚úì Vertex ${vertex.vertex}: "${vertex.text}" ENLARGED`);
                    
                    // Visual feedback
                    const x = (vertex.vertex % 10) * (canvas.width / 10) + 30;
                    const y = Math.floor(vertex.vertex / 10) * 60 + 30;
                    
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(x, y, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                }, i * 50);  // Stagger for visual effect
            });
            
            setTimeout(() => {
                logCoordinate(`‚úÖ ${asteriskVertices.length} vertices enlarged!`);
                visualizeCoordinates();
            }, asteriskVertices.length * 50 + 500);
        }
        
        // Log coordinate events
        function logCoordinate(message) {
            const log = document.getElementById('coordinate-log');
            const entry = document.createElement('div');
            entry.className = 'coordinate-marker';
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
    </script>
</body>
</html>
