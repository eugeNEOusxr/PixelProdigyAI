<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VLS 3D Triangle Matrix Demo</title>
  <style>
    body { 
      margin: 0; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }
    canvas { display: block; }
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.9);
      color: #0f0;
      padding: 20px;
      border: 3px solid #0f0;
      border-radius: 10px;
      max-width: 400px;
      font-size: 12px;
      line-height: 1.6;
      box-shadow: 0 0 20px rgba(0,255,0,0.5);
    }
    h2 { 
      color: #0ff; 
      margin-top: 0;
      text-shadow: 0 0 10px #0ff;
    }
    .highlight { 
      color: #ff0; 
      font-weight: bold;
    }
    .success { color: #0f0; }
    .section {
      border-top: 1px solid #0f0;
      margin-top: 10px;
      padding-top: 10px;
    }
  </style>
</head>
<body>
  <div id="info">
    <h2>üå≤ VLS 3D Triangle Matrix System</h2>
    <div><span class="highlight">Status:</span> <span id="status">Loading...</span></div>
    <div class="section">
      <strong>Triangle Matrix Geometry:</strong><br>
      Each tree segment is generated using triangle matrices:<br>
      <code>(x1,y1,z1) ‚Üí (x2,y2,z2) ‚Üí (x3,y3,z3)</code>
    </div>
    <div class="section">
      <strong>Trees Generated:</strong><br>
      <span id="treeStats">Waiting...</span>
    </div>
    <div class="section">
      <strong>VLS Operations:</strong><br>
      ‚Ä¢ <code>+E^16</code> = 16-node upward path<br>
      ‚Ä¢ <code>-DA^4</code> = 4 depth rings<br>
      ‚Ä¢ <code>+Q^2</code> = double extrude<br>
      ‚Ä¢ Triangle matrices connect all nodes
    </div>
    <div class="section">
      <strong>Controls:</strong><br>
      üñ±Ô∏è Drag to rotate camera<br>
      Trees auto-rotate for viewing
    </div>
  </div>

  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="object_generator/vls_parser.js"></script>
  <script src="object_generator/vls_triangle_matrix.js"></script>
  <script src="world_generation/vls_tree_generator.js"></script>

  <script>
    console.log('üöÄ VLS 3D Triangle Matrix Demo Starting...');
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 10, 50);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(8, 4, 8);
    camera.lookAt(0, 2, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    // Lights
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(10, 15, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    scene.add(sun);
    
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    
    const hemi = new THREE.HemisphereLight(0x87CEEB, 0x4a7c59, 0.5);
    scene.add(hemi);
    
    // Ground with grid
    const groundGeo = new THREE.PlaneGeometry(40, 40, 20, 20);
    const groundMat = new THREE.MeshStandardMaterial({ 
      color: 0x4a7c59,
      roughness: 0.8
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    
    // Add terrain variation
    const vertices = ground.geometry.attributes.position;
    for (let i = 0; i < vertices.count; i++) {
      const x = vertices.getX(i);
      const y = vertices.getY(i);
      const height = Math.sin(x * 0.3) * Math.cos(y * 0.3) * 0.5;
      vertices.setZ(i, height);
    }
    ground.geometry.attributes.position.needsUpdate = true;
    ground.geometry.computeVertexNormals();
    scene.add(ground);
    
    // Grid helper
    const grid = new THREE.GridHelper(40, 40, 0x00ff00, 0x006600);
    grid.position.y = 0.01;
    scene.add(grid);
    
    // Initialize VLS System
    const statusDiv = document.getElementById('status');
    const statsDiv = document.getElementById('treeStats');
    
    try {
      statusDiv.innerHTML = '<span class="success">‚úì Initializing VLS System...</span>';
      
      const vlsParser = new VLSParser();
      const treeGenerator = new VLSTreeGenerator(vlsParser);
      
      statusDiv.innerHTML = '<span class="success">‚úì VLS System Active</span>';
      
      // Generate trees
      const treeTypes = ['oak', 'pine', 'willow', 'dead'];
      const trees = [];
      const treeData = [];
      
      const positions = [
        { x: -4, z: 0 },
        { x: -1, z: 0 },
        { x: 2, z: 0 },
        { x: 5, z: 0 }
      ];
      
      for (let i = 0; i < treeTypes.length; i++) {
        const type = treeTypes[i];
        const pos = positions[i];
        
        console.log(`üå≥ Generating VLS ${type} tree...`);
        
        const tree = treeGenerator.generateTree(type, {
          position: { x: pos.x, y: 0, z: pos.z },
          scale: 1.0,
          rotation: 0,
          color: 0x8B4513,
          leafColor: type === 'dead' ? 0x666666 :
                     type === 'pine' ? 0x1a5f1a :
                     type === 'willow' ? 0x90ee90 :
                     0x228B22
        });
        
        if (tree) {
          scene.add(tree);
          trees.push(tree);
          
          // Count vertices and triangles
          let totalVerts = 0;
          let totalTris = 0;
          tree.traverse(child => {
            if (child.geometry) {
              totalVerts += child.geometry.attributes.position.count;
              if (child.geometry.index) {
                totalTris += child.geometry.index.count / 3;
              }
            }
          });
          
          treeData.push({
            type,
            vertices: totalVerts,
            triangles: Math.floor(totalTris)
          });
          
          // Add label
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 64;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, 256, 64);
          ctx.fillStyle = '#0f0';
          ctx.font = 'bold 24px Courier';
          ctx.fillText(type.toUpperCase(), 10, 40);
          
          const texture = new THREE.CanvasTexture(canvas);
          const labelMat = new THREE.SpriteMaterial({ map: texture });
          const label = new THREE.Sprite(labelMat);
          label.position.set(pos.x, 5, pos.z);
          label.scale.set(2, 0.5, 1);
          scene.add(label);
        }
      }
      
      // Update stats
      let statsHTML = '';
      treeData.forEach(data => {
        statsHTML += `<strong>${data.type}:</strong> ${data.vertices} verts, ${data.triangles} tris<br>`;
      });
      statsDiv.innerHTML = statsHTML;
      
      console.log('‚úÖ All VLS trees generated!');
      
    } catch (e) {
      statusDiv.innerHTML = `<span style="color:#f00">‚úó Error: ${e.message}</span>`;
      console.error('VLS Error:', e);
    }
    
    // Camera controls
    let isDragging = false;
    let previousMouse = { x: 0, y: 0 };
    let cameraAngle = Math.PI / 4;
    let cameraHeight = 4;
    const cameraDistance = 10;
    
    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMouse = { x: e.clientX, y: e.clientY };
    });
    
    renderer.domElement.addEventListener('mouseup', () => {
      isDragging = false;
    });
    
    renderer.domElement.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMouse.x;
        const deltaY = e.clientY - previousMouse.y;
        
        cameraAngle += deltaX * 0.01;
        cameraHeight = Math.max(1, Math.min(8, cameraHeight - deltaY * 0.02));
        
        previousMouse = { x: e.clientX, y: e.clientY };
      }
    });
    
    // Animation
    function animate() {
      requestAnimationFrame(animate);
      
      // Update camera position
      camera.position.x = Math.cos(cameraAngle) * cameraDistance;
      camera.position.z = Math.sin(cameraAngle) * cameraDistance;
      camera.position.y = cameraHeight;
      camera.lookAt(0, 2, 0);
      
      // Slowly rotate scene
      scene.rotation.y += 0.002;
      
      renderer.render(scene, camera);
    }
    animate();
    
    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
  </script>
</body>
</html>
