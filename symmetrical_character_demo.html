<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symmetrical Character System - Like Solana's Drawings!</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas { display: block; }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.85);
            padding: 25px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 380px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        #info h2 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 22px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .concept {
            background: rgba(102, 126, 234, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }
        
        .concept h3 {
            margin: 0 0 10px 0;
            color: #a0d8ff;
            font-size: 16px;
        }
        
        .feature {
            margin: 10px 0;
            padding-left: 25px;
            position: relative;
            line-height: 1.6;
        }
        
        .feature:before {
            content: "‚ö°";
            position: absolute;
            left: 0;
            color: #ffd700;
            font-size: 16px;
        }
        
        .highlight {
            color: #ffd700;
            font-weight: bold;
        }
        
        .symmetry-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 100%;
            background: rgba(255, 215, 0, 0.3);
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 100;
        }
        
        .symmetry-label {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 101;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="symmetry-indicator"></div>
    <div class="symmetry-label">‚Üê Symmetry Line ‚Üí</div>
    
    <div id="info">
        <h2>‚ú® Symmetrical Character System</h2>
        
        <div class="concept">
            <h3>üé® Solana's Technique:</h3>
            <p>Remember how Solana drew? Define <span class="highlight">ONE SIDE</span>, fold the paper, trace the mirror. Same concept here!</p>
        </div>
        
        <div class="feature">Define <span class="highlight">right half</span> vertices</div>
        <div class="feature">System <span class="highlight">mirrors automatically</span></div>
        <div class="feature">Edit one side = both sides update</div>
        <div class="feature"><span class="highlight">Half the work</span>, perfect symmetry!</div>
        
        <hr style="margin: 15px 0; border-color: rgba(255,255,255,0.2);">
        
        <p style="margin: 10px 0;"><span class="highlight">WASD:</span> Move camera</p>
        <p style="margin: 10px 0;"><span class="highlight">Mouse:</span> Look around</p>
        <p style="margin: 10px 0;"><span class="highlight">Space:</span> Rotate character</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // === SYMMETRICAL CHARACTER SYSTEM ===

        const materials = {
            skin: new THREE.MeshStandardMaterial({
                color: 0xffdbac,
                roughness: 0.6,
                metalness: 0.0
            }),
            hair: new THREE.MeshStandardMaterial({
                color: 0x3a2a1a,
                roughness: 0.8,
                metalness: 0.0
            }),
            eyes: new THREE.MeshStandardMaterial({
                color: 0x4a90e2,
                roughness: 0.2,
                metalness: 0.1
            }),
            clothes: new THREE.MeshStandardMaterial({
                color: 0x2c5aa0,
                roughness: 0.7,
                metalness: 0.0
            }),
            rightSide: new THREE.MeshStandardMaterial({
                color: 0xff6b6b, // Red tint for right side
                roughness: 0.6,
                metalness: 0.0,
                transparent: true,
                opacity: 0.9
            }),
            leftSide: new THREE.MeshStandardMaterial({
                color: 0x6b9bff, // Blue tint for left side (mirrored)
                roughness: 0.6,
                metalness: 0.0,
                transparent: true,
                opacity: 0.9
            })
        };

        // Function to mirror vertices
        function mirrorVertices(vertices, axis = 'x') {
            const mirrored = [];
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                const z = vertices[i + 2];
                mirrored.push(-x, y, z); // Flip X for left-right symmetry
            }
            return mirrored;
        }

        // Create symmetrical character
        const character = new THREE.Group();

        // HEAD
        const headGroup = new THREE.Group();

        // Right half of head (RED tinted)
        const rightHead = new THREE.Mesh(
            new THREE.SphereGeometry(1.2, 16, 16, 0, Math.PI), // Half sphere
            materials.rightSide
        );
        rightHead.castShadow = true;
        headGroup.add(rightHead);

        // Left half of head (BLUE tinted - mirrored)
        const leftHead = new THREE.Mesh(
            new THREE.SphereGeometry(1.2, 16, 16, Math.PI, Math.PI), // Other half sphere
            materials.leftSide
        );
        leftHead.castShadow = true;
        headGroup.add(leftHead);

        // Right eye
        const rightEye = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 16, 16),
            materials.eyes
        );
        rightEye.position.set(0.4, 0.3, 0.9);
        rightEye.castShadow = true;
        headGroup.add(rightEye);

        // Left eye (MIRRORED from right)
        const leftEye = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 16, 16),
            materials.eyes
        );
        leftEye.position.set(-0.4, 0.3, 0.9); // Negative X = mirrored
        leftEye.castShadow = true;
        headGroup.add(leftEye);

        headGroup.position.y = 6;
        character.add(headGroup);

        // TORSO (centered)
        const torso = new THREE.Mesh(
            new THREE.CylinderGeometry(0.8, 0.9, 3, 16),
            materials.clothes
        );
        torso.position.y = 3.5;
        torso.castShadow = true;
        character.add(torso);

        // RIGHT ARM (red tinted)
        const rightArmVertices = [
            1.2, 5, 0,
            1.3, 4.5, 0,
            1.35, 4, 0,
            1.3, 3.5, 0,
            1.25, 3, 0.1,
            1.2, 2.5, 0.2,
            1.15, 2, 0.2,
            1.1, 1.5, 0.15
        ];

        const rightArmGeo = new THREE.BufferGeometry();
        rightArmGeo.setAttribute('position', new THREE.Float32BufferAttribute(rightArmVertices, 3));
        const rightArm = new THREE.Line(
            rightArmGeo,
            new THREE.LineBasicMaterial({ color: 0xff6b6b, linewidth: 8 })
        );
        character.add(rightArm);

        // Add spheres to show vertices on right arm
        for (let i = 0; i < rightArmVertices.length; i += 3) {
            const vertexMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 8, 8),
                materials.rightSide
            );
            vertexMarker.position.set(rightArmVertices[i], rightArmVertices[i+1], rightArmVertices[i+2]);
            vertexMarker.castShadow = true;
            character.add(vertexMarker);
        }

        // LEFT ARM (MIRRORED - blue tinted)
        const leftArmVertices = mirrorVertices(rightArmVertices);
        const leftArmGeo = new THREE.BufferGeometry();
        leftArmGeo.setAttribute('position', new THREE.Float32BufferAttribute(leftArmVertices, 3));
        const leftArm = new THREE.Line(
            leftArmGeo,
            new THREE.LineBasicMaterial({ color: 0x6b9bff, linewidth: 8 })
        );
        character.add(leftArm);

        // Add spheres to show mirrored vertices on left arm
        for (let i = 0; i < leftArmVertices.length; i += 3) {
            const vertexMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 8, 8),
                materials.leftSide
            );
            vertexMarker.position.set(leftArmVertices[i], leftArmVertices[i+1], leftArmVertices[i+2]);
            vertexMarker.castShadow = true;
            character.add(vertexMarker);
        }

        // RIGHT LEG (red tinted)
        const rightLegVertices = [
            0.4, 2, 0,
            0.42, 1, 0,
            0.43, 0, 0,
            0.42, -1, 0.1,
            0.4, -2, 0.15,
            0.38, -2.8, 0.2,
            0.35, -3.2, 0.5
        ];

        const rightLegGeo = new THREE.BufferGeometry();
        rightLegGeo.setAttribute('position', new THREE.Float32BufferAttribute(rightLegVertices, 3));
        const rightLeg = new THREE.Line(
            rightLegGeo,
            new THREE.LineBasicMaterial({ color: 0xff6b6b, linewidth: 8 })
        );
        character.add(rightLeg);

        // Add vertex markers
        for (let i = 0; i < rightLegVertices.length; i += 3) {
            const vertexMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 8, 8),
                materials.rightSide
            );
            vertexMarker.position.set(rightLegVertices[i], rightLegVertices[i+1], rightLegVertices[i+2]);
            vertexMarker.castShadow = true;
            character.add(vertexMarker);
        }

        // LEFT LEG (MIRRORED - blue tinted)
        const leftLegVertices = mirrorVertices(rightLegVertices);
        const leftLegGeo = new THREE.BufferGeometry();
        leftLegGeo.setAttribute('position', new THREE.Float32BufferAttribute(leftLegVertices, 3));
        const leftLeg = new THREE.Line(
            leftLegGeo,
            new THREE.LineBasicMaterial({ color: 0x6b9bff, linewidth: 8 })
        );
        character.add(leftLeg);

        // Add mirrored vertex markers
        for (let i = 0; i < leftLegVertices.length; i += 3) {
            const vertexMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 8, 8),
                materials.leftSide
            );
            vertexMarker.position.set(leftLegVertices[i], leftLegVertices[i+1], leftLegVertices[i+2]);
            vertexMarker.castShadow = true;
            character.add(vertexMarker);
        }

        // SYMMETRY LINE (visual guide)
        const symmetryLine = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -5, 0),
                new THREE.Vector3(0, 10, 0)
            ]),
            new THREE.LineBasicMaterial({ color: 0xffd700, linewidth: 2, transparent: true, opacity: 0.5 })
        );
        scene.add(symmetryLine);

        scene.add(character);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
        keyLight.position.set(5, 10, 7);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 2048;
        keyLight.shadow.mapSize.height = 2048;
        scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0x6b9bff, 0.3);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);

        const rimLight = new THREE.DirectionalLight(0xff6b6b, 0.3);
        rimLight.position.set(0, 5, -10);
        scene.add(rimLight);

        // Ground
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 50),
            new THREE.MeshStandardMaterial({ 
                color: 0x2a2a3e,
                roughness: 0.8,
                metalness: 0.2
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -5;
        ground.receiveShadow = true;
        scene.add(ground);

        // Controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // Animation
        let autoRotate = true;

        function animate() {
            requestAnimationFrame(animate);

            // Camera controls
            const speed = 0.2;
            if (keys['w']) camera.position.z -= speed;
            if (keys['s']) camera.position.z += speed;
            if (keys['a']) camera.position.x -= speed;
            if (keys['d']) camera.position.x += speed;
            if (keys[' ']) autoRotate = !autoRotate;

            // Mouse look
            camera.rotation.y = -mouseX * 0.3;
            camera.rotation.x = mouseY * 0.2;

            // Auto-rotate character to show symmetry
            if (autoRotate) {
                character.rotation.y += 0.005;
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

        console.log("‚ú® Symmetrical Character System");
        console.log("üî¥ Red = Right side (you define these vertices)");
        console.log("üîµ Blue = Left side (system mirrors automatically)");
        console.log("üé® Like Solana's folded paper technique!");
    </script>
</body>
</html>
