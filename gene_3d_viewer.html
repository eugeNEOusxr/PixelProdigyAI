<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GENE Language 3D Viewer | PixelProdigyAI</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      overflow-x: hidden;
    }

    .header {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      text-align: center;
      backdrop-filter: blur(10px);
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    .header p {
      font-size: 1.2em;
      opacity: 0.9;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .viewer-section {
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 20px;
      margin-top: 20px;
    }

    .sidebar {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      height: fit-content;
    }

    .sidebar h2 {
      font-size: 1.5em;
      margin-bottom: 15px;
      color: #ffd700;
    }

    .asset-list {
      max-height: 600px;
      overflow-y: auto;
    }

    .asset-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 12px;
      margin-bottom: 10px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      border-left: 3px solid transparent;
    }

    .asset-item:hover {
      background: rgba(255, 255, 255, 0.2);
      border-left-color: #ffd700;
      transform: translateX(5px);
    }

    .asset-item.active {
      background: rgba(255, 215, 0, 0.2);
      border-left-color: #ffd700;
    }

    .asset-item h3 {
      font-size: 1em;
      margin-bottom: 5px;
    }

    .asset-item p {
      font-size: 0.85em;
      opacity: 0.8;
    }

    .viewer-canvas {
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      min-height: 700px;
      position: relative;
    }

    #canvas3d {
      width: 100%;
      height: 650px;
      border-radius: 10px;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .control-btn {
      background: rgba(255, 215, 0, 0.2);
      border: 2px solid #ffd700;
      color: #ffd700;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1em;
      font-weight: bold;
      transition: all 0.3s;
    }

    .control-btn:hover {
      background: rgba(255, 215, 0, 0.4);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
    }

    .stats-panel {
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      padding: 15px;
      margin-top: 15px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-value {
      font-size: 2em;
      font-weight: bold;
      color: #ffd700;
    }

    .stat-label {
      font-size: 0.9em;
      opacity: 0.8;
      margin-top: 5px;
    }

    .loading {
      text-align: center;
      padding: 50px;
      font-size: 1.5em;
    }

    .category-filter {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }

    .filter-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      padding: 8px 15px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.3s;
    }

    .filter-btn:hover, .filter-btn.active {
      background: rgba(255, 215, 0, 0.3);
      border-color: #ffd700;
      color: #ffd700;
    }

    @media (max-width: 768px) {
      .viewer-section {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üé® GENE Language 3D Viewer</h1>
    <p>Interactive visualization of 11,000+ PixelProdigyAI assets</p>
  </div>

  <div class="container">
    <div class="stats-panel">
      <div class="stat-item">
        <div class="stat-value" id="totalAssets">11,000</div>
        <div class="stat-label">Total Assets</div>
      </div>
      <div class="stat-item">
        <div class="stat-value">144</div>
        <div class="stat-label">AI Personalities</div>
      </div>
      <div class="stat-item">
        <div class="stat-value">11</div>
        <div class="stat-label">Categories</div>
      </div>
      <div class="stat-item">
        <div class="stat-value">2,800√ó</div>
        <div class="stat-label">Compression</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="currentVertices">0</div>
        <div class="stat-label">Vertices</div>
      </div>
    </div>

    <div class="viewer-section">
      <div class="sidebar">
        <h2>üì¶ Asset Library</h2>
        
        <div class="category-filter" id="categoryFilter">
          <button class="filter-btn active" data-category="all">All</button>
          <button class="filter-btn" data-category="furniture">Furniture</button>
          <button class="filter-btn" data-category="vehicles">Vehicles</button>
          <button class="filter-btn" data-category="architecture">Buildings</button>
          <button class="filter-btn" data-category="nature">Nature</button>
          <button class="filter-btn" data-category="characters">Characters</button>
        </div>

        <div class="asset-list" id="assetList">
          <div class="loading">Loading assets...</div>
        </div>
      </div>

      <div class="viewer-canvas">
        <canvas id="canvas3d"></canvas>
        
        <div class="controls">
          <button class="control-btn" onclick="resetCamera()">üîÑ Reset View</button>
          <button class="control-btn" onclick="toggleRotation()">‚èØÔ∏è Auto-Rotate</button>
          <button class="control-btn" onclick="toggleWireframe()">üî≤ Wireframe</button>
          <button class="control-btn" onclick="exportGLB()">üíæ Export GLB</button>
          <button class="control-btn" onclick="randomAsset()">üé≤ Random</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ============================================
    // MATHEMATICAL CONSTANTS
    // ============================================
    const PHI = 1.618033988749895; // Golden Ratio
    const GOLDEN_ANGLE = 137.507764; // Golden Angle in degrees
    const FIBONACCI = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377];

    // ============================================
    // THREE.JS SCENE SETUP
    // ============================================
    let scene, camera, renderer, currentMesh, controls;
    let autoRotate = true;
    let wireframeMode = false;

    function initScene() {
      const canvas = document.getElementById('canvas3d');
      
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);
      
      // Camera
      camera = new THREE.PerspectiveCamera(
        75,
        canvas.clientWidth / canvas.clientHeight,
        0.1,
        1000
      );
      camera.position.set(5, 5, 5);
      camera.lookAt(0, 0, 0);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 10, 10);
      scene.add(directionalLight);
      
      const pointLight = new THREE.PointLight(0xffd700, 1, 100);
      pointLight.position.set(-10, 10, -10);
      scene.add(pointLight);
      
      // Grid
      const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
      scene.add(gridHelper);
      
      // Axes
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);
      
      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      
      if (currentMesh && autoRotate) {
        currentMesh.rotation.y += 0.01;
        currentMesh.rotation.x += 0.005;
      }
      
      renderer.render(scene, camera);
    }

    // ============================================
    // PROCEDURAL 3D GENERATION
    // ============================================
    function generatePlatonicSolid(type = 'icosahedron') {
      let geometry;
      
      switch(type) {
        case 'tetrahedron':
          geometry = new THREE.TetrahedronGeometry(2);
          break;
        case 'cube':
          geometry = new THREE.BoxGeometry(2, 2, 2);
          break;
        case 'octahedron':
          geometry = new THREE.OctahedronGeometry(2);
          break;
        case 'dodecahedron':
          geometry = new THREE.DodecahedronGeometry(2);
          break;
        case 'icosahedron':
        default:
          geometry = new THREE.IcosahedronGeometry(2, 2);
      }
      
      return geometry;
    }

    function generateFibonacciSphere(count = 500) {
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      
      for (let i = 0; i < count; i++) {
        const theta = i * 2 * Math.PI / PHI;
        const phi = i / count;
        
        const x = Math.cos(theta) * Math.sqrt(1 - phi * phi) * 2;
        const y = phi * 4 - 2;
        const z = Math.sin(theta) * Math.sqrt(1 - phi * phi) * 2;
        
        positions.push(x, y, z);
      }
      
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      
      return geometry;
    }

    function generateGoldenSpiralObject() {
      const curve = new THREE.CatmullRomCurve3(
        Array.from({length: 100}, (_, i) => {
          const theta = i * GOLDEN_ANGLE * Math.PI / 180;
          const r = Math.pow(PHI, i / 30);
          return new THREE.Vector3(
            r * Math.cos(theta),
            i * 0.1,
            r * Math.sin(theta)
          );
        })
      );
      
      const geometry = new THREE.TubeGeometry(curve, 100, 0.2, 8, false);
      return geometry;
    }

    function applyPerlinDisplacement(geometry, intensity = 0.3) {
      const positions = geometry.attributes.position;
      
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        
        // Simple noise approximation
        const noise = Math.sin(x * 2) * Math.cos(y * 2) * Math.sin(z * 2);
        const displacement = noise * intensity;
        
        positions.setXYZ(
          i,
          x + displacement,
          y + displacement,
          z + displacement
        );
      }
      
      geometry.attributes.position.needsUpdate = true;
      geometry.computeVertexNormals();
    }

    function createAssetMesh(assetData) {
      let geometry;
      
      // Generate based on category
      switch(assetData.category) {
        case 'furniture':
          geometry = generatePlatonicSolid('cube');
          applyPerlinDisplacement(geometry, 0.2);
          break;
        case 'vehicles':
          geometry = generatePlatonicSolid('dodecahedron');
          break;
        case 'architecture':
          geometry = generatePlatonicSolid('cube');
          break;
        case 'nature':
          geometry = generateFibonacciSphere(800);
          applyPerlinDisplacement(geometry, 0.5);
          break;
        case 'characters':
          geometry = generatePlatonicSolid('icosahedron');
          break;
        default:
          geometry = generateGoldenSpiralObject();
      }
      
      // Material with Golden Ratio colors
      const hue = (assetData.aiPersonality * GOLDEN_ANGLE) % 360;
      const color = new THREE.Color(`hsl(${hue}, 70%, 60%)`);
      
      const material = wireframeMode ? 
        new THREE.MeshBasicMaterial({ color: color, wireframe: true }) :
        new THREE.MeshPhongMaterial({
          color: color,
          specular: 0x555555,
          shininess: 30,
          flatShading: false
        });
      
      const mesh = new THREE.Mesh(geometry, material);
      return mesh;
    }

    // ============================================
    // ASSET LOADING
    // ============================================
    let allAssets = [];
    let filteredAssets = [];
    let currentFilter = 'all';

    async function loadAssets() {
      try {
        // Load 10K catalog
        const response = await fetch('assets/ASSET_CATALOG_10K.json');
        const catalog = await response.json();
        
        // Flatten all categories
        allAssets = [];
        for (const [category, items] of Object.entries(catalog.categories)) {
          allAssets.push(...items.map(item => ({...item, category})));
        }
        
        // Also load 1K catalog
        const response1k = await fetch('assets/ASSET_CATALOG.json');
        const catalog1k = await response1k.json();
        
        for (const [category, items] of Object.entries(catalog1k.categories)) {
          allAssets.push(...items.map(item => ({...item, category})));
        }
        
        document.getElementById('totalAssets').textContent = allAssets.length.toLocaleString();
        filteredAssets = allAssets;
        renderAssetList();
        
        // Load first asset
        if (allAssets.length > 0) {
          loadAsset(allAssets[0]);
        }
      } catch (error) {
        console.error('Error loading assets:', error);
        document.getElementById('assetList').innerHTML = 
          '<div class="loading">Error loading assets. Make sure catalogs exist.</div>';
      }
    }

    function renderAssetList() {
      const container = document.getElementById('assetList');
      container.innerHTML = '';
      
      const assetsToShow = filteredAssets.slice(0, 50); // Limit to 50 for performance
      
      assetsToShow.forEach((asset, index) => {
        const item = document.createElement('div');
        item.className = 'asset-item';
        if (index === 0) item.classList.add('active');
        
        item.innerHTML = `
          <h3>${asset.id}</h3>
          <p>Category: ${asset.category}</p>
          <p>AI: #${asset.aiPersonality} | VLS: ${asset.vlsLevel}</p>
        `;
        
        item.onclick = () => {
          document.querySelectorAll('.asset-item').forEach(el => el.classList.remove('active'));
          item.classList.add('active');
          loadAsset(asset);
        };
        
        container.appendChild(item);
      });
      
      if (filteredAssets.length > 50) {
        const moreInfo = document.createElement('div');
        moreInfo.className = 'loading';
        moreInfo.style.fontSize = '0.9em';
        moreInfo.textContent = `+ ${filteredAssets.length - 50} more assets`;
        container.appendChild(moreInfo);
      }
    }

    function loadAsset(assetData) {
      // Remove current mesh
      if (currentMesh) {
        scene.remove(currentMesh);
        currentMesh.geometry.dispose();
        currentMesh.material.dispose();
      }
      
      // Create new mesh
      currentMesh = createAssetMesh(assetData);
      scene.add(currentMesh);
      
      // Update stats
      const vertexCount = currentMesh.geometry.attributes.position.count;
      document.getElementById('currentVertices').textContent = vertexCount.toLocaleString();
    }

    // ============================================
    // CONTROLS
    // ============================================
    function resetCamera() {
      camera.position.set(5, 5, 5);
      camera.lookAt(0, 0, 0);
    }

    function toggleRotation() {
      autoRotate = !autoRotate;
    }

    function toggleWireframe() {
      wireframeMode = !wireframeMode;
      if (currentMesh) {
        const asset = filteredAssets[0];
        loadAsset(asset);
      }
    }

    function exportGLB() {
      alert('GLB export feature coming soon! Current mesh uses GENE Language format.');
    }

    function randomAsset() {
      const randomIndex = Math.floor(Math.random() * filteredAssets.length);
      loadAsset(filteredAssets[randomIndex]);
      
      // Update active item in list
      const items = document.querySelectorAll('.asset-item');
      items.forEach((item, index) => {
        item.classList.toggle('active', index === randomIndex % 50);
      });
    }

    // Category filter
    document.getElementById('categoryFilter').addEventListener('click', (e) => {
      if (e.target.classList.contains('filter-btn')) {
        document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
        e.target.classList.add('active');
        
        const category = e.target.dataset.category;
        currentFilter = category;
        
        if (category === 'all') {
          filteredAssets = allAssets;
        } else {
          filteredAssets = allAssets.filter(asset => asset.category === category);
        }
        
        renderAssetList();
        if (filteredAssets.length > 0) {
          loadAsset(filteredAssets[0]);
        }
      }
    });

    // Mouse controls
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    document.getElementById('canvas3d').addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging && currentMesh) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;
        
        currentMesh.rotation.y += deltaX * 0.01;
        currentMesh.rotation.x += deltaY * 0.01;
        
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });

    // Zoom
    document.getElementById('canvas3d').addEventListener('wheel', (e) => {
      e.preventDefault();
      camera.position.z += e.deltaY * 0.01;
      camera.position.z = Math.max(2, Math.min(20, camera.position.z));
    });

    // Resize handler
    window.addEventListener('resize', () => {
      const canvas = document.getElementById('canvas3d');
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    });

    // ============================================
    // INITIALIZE
    // ============================================
    window.addEventListener('load', () => {
      initScene();
      loadAssets();
    });
  </script>
</body>
</html>
