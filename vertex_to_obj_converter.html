<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertex Array to OBJ Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
            color: #00ffaa;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #00ffaa;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ffaa;
            border-radius: 10px;
            padding: 20px;
        }

        .panel h2 {
            color: #ffd700;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ffd700;
        }

        textarea {
            width: 100%;
            height: 400px;
            background: #0a0a0f;
            border: 1px solid #00ffaa;
            border-radius: 5px;
            padding: 15px;
            color: #00ffaa;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }

        button {
            background: linear-gradient(135deg, #8b5cf6, #3b82f6);
            border: none;
            color: white;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px 10px 0 0;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(139, 92, 246, 0.5);
        }

        #preview {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            background: radial-gradient(circle, rgba(0, 255, 170, 0.1), transparent);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffaa;
            border-radius: 5px;
            padding: 15px;
            text-align: center;
        }

        .stat-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #ffd700;
            font-size: 1.5em;
            font-weight: bold;
        }

        .instructions {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #ffd700;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            color: #ffd700;
        }

        .instructions h3 {
            margin-bottom: 10px;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .example {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <h1>üî∑ Vertex Array to OBJ Converter</h1>
    
    <div class="container">
        <!-- Left Panel: Input -->
        <div class="panel">
            <h2>üì• Input (Paste Vertex Data)</h2>
            
            <div class="instructions">
                <h3>üìã How to Use:</h3>
                <ul>
                    <li><strong>Paste vertex coordinates</strong> (one per line or comma-separated)</li>
                    <li>Supports: <code>x, y, z</code> or just <code>x y z</code></li>
                    <li>Click "Parse & Preview" to visualize</li>
                    <li>Click "Download OBJ" to save file</li>
                </ul>
                
                <div class="example">
                    <strong>Example:</strong><br>
                    -0.5, 0.0, 0.5<br>
                    0.5, 0.0, 0.5<br>
                    0.0, 1.0, 0.0
                </div>
            </div>
            
            <textarea id="vertexInput" placeholder="Paste vertex data here...
Example:
-0.5, 0.0, 0.5
0.5, 0.0, 0.5
0.0, 1.0, 0.0
...or...
-0.5 0.0 0.5
0.5 0.0 0.5
0.0 1.0 0.0"></textarea>
            
            <div>
                <button onclick="parseAndPreview()">üîç Parse & Preview</button>
                <button onclick="loadExample()">üìù Load Example</button>
                <button onclick="clearInput()">üóëÔ∏è Clear</button>
            </div>
        </div>

        <!-- Right Panel: Output -->
        <div class="panel">
            <h2>üì§ Output (OBJ Format)</h2>
            
            <textarea id="objOutput" readonly placeholder="OBJ file will appear here..."></textarea>
            
            <div>
                <button onclick="downloadOBJ()">üíæ Download OBJ</button>
                <button onclick="copyToClipboard()">üìã Copy to Clipboard</button>
                <button onclick="sendToMarketplace()">üõí Send to Marketplace</button>
            </div>
        </div>
    </div>

    <!-- Stats -->
    <div class="panel" style="max-width: 1400px; margin: 20px auto 0;">
        <h2>üìä Model Statistics</h2>
        <div class="stats">
            <div class="stat">
                <div class="stat-label">Vertices</div>
                <div class="stat-value" id="vertexCount">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Faces (Auto-generated)</div>
                <div class="stat-value" id="faceCount">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">File Size</div>
                <div class="stat-value" id="fileSize">0 KB</div>
            </div>
        </div>
    </div>

    <!-- 3D Preview -->
    <div class="panel" style="max-width: 1400px; margin: 20px auto 0;">
        <h2>üé® 3D Preview</h2>
        <canvas id="preview"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let currentMesh = null;
        let vertexArray = [];
        let objText = '';

        // Initialize 3D preview
        function initPreview() {
            const canvas = document.getElementById('preview');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);
            
            camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(3, 3, 3);
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            controls = new THREE.OrbitControls(camera, canvas);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            const light1 = new THREE.DirectionalLight(0xffffff, 1);
            light1.position.set(5, 5, 5);
            scene.add(light1);
            
            const light2 = new THREE.DirectionalLight(0x00ffaa, 0.5);
            light2.position.set(-5, 3, -5);
            scene.add(light2);
            
            // Grid
            const gridHelper = new THREE.GridHelper(10, 10, 0x00ffaa, 0x003333);
            scene.add(gridHelper);
            
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            if (currentMesh) {
                currentMesh.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }

        // Parse vertex input
        function parseAndPreview() {
            const input = document.getElementById('vertexInput').value.trim();
            if (!input) {
                alert('Please paste vertex data first!');
                return;
            }

            // Parse vertices
            vertexArray = [];
            const lines = input.split('\n');
            
            for (let line of lines) {
                line = line.trim();
                if (!line || line.startsWith('#')) continue;
                
                // Remove common prefixes
                line = line.replace(/^v\s+/, '');
                
                // Split by comma or space
                const coords = line.split(/[,\s]+/).map(c => parseFloat(c.trim()));
                
                if (coords.length >= 3 && !isNaN(coords[0])) {
                    vertexArray.push(coords[0], coords[1], coords[2]);
                }
            }

            if (vertexArray.length < 9) {
                alert('Need at least 3 vertices (9 values) to create a model!');
                return;
            }

            console.log(`‚úÖ Parsed ${vertexArray.length / 3} vertices`);

            // Generate OBJ
            generateOBJ();

            // Update preview
            updatePreview();

            // Update stats
            updateStats();
        }

        // Generate OBJ format
        function generateOBJ() {
            objText = '# Generated by PixelProdigy Vertex Converter\n';
            objText += `# Vertices: ${vertexArray.length / 3}\n`;
            objText += `# Date: ${new Date().toISOString()}\n\n`;

            // Write vertices
            for (let i = 0; i < vertexArray.length; i += 3) {
                objText += `v ${vertexArray[i]} ${vertexArray[i + 1]} ${vertexArray[i + 2]}\n`;
            }

            // Auto-generate faces (triangle fan from first vertex)
            objText += '\n# Faces (auto-generated)\n';
            const vertexCount = vertexArray.length / 3;
            
            for (let i = 1; i < vertexCount - 1; i++) {
                objText += `f 1 ${i + 1} ${i + 2}\n`;
            }

            document.getElementById('objOutput').value = objText;
        }

        // Update 3D preview
        function updatePreview() {
            // Remove existing mesh
            if (currentMesh) {
                scene.remove(currentMesh);
            }

            // Create geometry from vertices
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertexArray, 3));
            
            // Auto-generate indices
            const indices = [];
            const vertexCount = vertexArray.length / 3;
            for (let i = 1; i < vertexCount - 1; i++) {
                indices.push(0, i, i + 1);
            }
            geometry.setIndex(indices);
            
            geometry.computeVertexNormals();

            // Create mesh
            const material = new THREE.MeshStandardMaterial({
                color: 0x00ffaa,
                roughness: 0.5,
                metalness: 0.3,
                side: THREE.DoubleSide
            });

            currentMesh = new THREE.Mesh(geometry, material);
            scene.add(currentMesh);

            // Center camera on model
            const box = new THREE.Box3().setFromObject(currentMesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 2; // Add some padding
            
            camera.position.set(center.x + cameraZ, center.y + cameraZ, center.z + cameraZ);
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();

            console.log('‚úÖ Preview updated');
        }

        // Update statistics
        function updateStats() {
            const vertexCount = vertexArray.length / 3;
            const faceCount = Math.max(0, vertexCount - 2);
            const fileSize = (new Blob([objText]).size / 1024).toFixed(2);

            document.getElementById('vertexCount').textContent = vertexCount;
            document.getElementById('faceCount').textContent = faceCount;
            document.getElementById('fileSize').textContent = `${fileSize} KB`;
        }

        // Download OBJ file
        function downloadOBJ() {
            if (!objText) {
                alert('Parse vertex data first!');
                return;
            }

            const blob = new Blob([objText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pixelprodigy_model_${Date.now()}.obj`;
            a.click();
            URL.revokeObjectURL(url);

            console.log('üíæ OBJ file downloaded');
        }

        // Copy to clipboard
        function copyToClipboard() {
            if (!objText) {
                alert('Parse vertex data first!');
                return;
            }

            navigator.clipboard.writeText(objText).then(() => {
                alert('‚úÖ OBJ data copied to clipboard!');
            });
        }

        // Send to marketplace
        function sendToMarketplace() {
            if (!objText) {
                alert('Parse vertex data first!');
                return;
            }

            // Save to localStorage for marketplace to access
            localStorage.setItem('pixelprodigy_custom_model', objText);
            localStorage.setItem('pixelprodigy_custom_model_vertices', vertexArray.length / 3);
            
            alert('‚úÖ Model saved! Open marketplace_icon_system.html to view it.');
            console.log('Model saved to localStorage');
        }

        // Load example data
        function loadExample() {
            const example = `# Simple Pyramid
-0.5, 0.0, 0.5
0.5, 0.0, 0.5
0.5, 0.0, -0.5
-0.5, 0.0, -0.5
0.0, 1.0, 0.0`;

            document.getElementById('vertexInput').value = example;
            parseAndPreview();
        }

        // Clear input
        function clearInput() {
            document.getElementById('vertexInput').value = '';
            document.getElementById('objOutput').value = '';
            vertexArray = [];
            objText = '';
            
            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh = null;
            }
            
            updateStats();
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initPreview();
            console.log('‚úÖ Vertex to OBJ Converter ready');
            console.log('üìã Paste your vertex data and click "Parse & Preview"');
        });

        window.addEventListener('resize', () => {
            const canvas = document.getElementById('preview');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        });
    </script>
</body>
</html>
