/**
 * OBJ LOADER UTILITY
 * Loads OBJ vertex files for human anatomy and other models
 * Integrates with marketplace icon system
 */

class PixelProdigyOBJLoader {
    constructor() {
        this.objCache = new Map();
        this.loader = new THREE.OBJLoader();
    }

    /**
     * Load OBJ from file path
     */
    async loadFromFile(filePath) {
        if (this.objCache.has(filePath)) {
            console.log(`‚úÖ Loaded from cache: ${filePath}`);
            return this.objCache.get(filePath).clone();
        }

        return new Promise((resolve, reject) => {
            this.loader.load(
                filePath,
                (object) => {
                    this.objCache.set(filePath, object);
                    console.log(`‚úÖ Loaded OBJ: ${filePath}`);
                    resolve(object.clone());
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                    console.log(`Loading: ${percent}%`);
                },
                (error) => {
                    console.error(`‚ùå Error loading OBJ: ${filePath}`, error);
                    reject(error);
                }
            );
        });
    }

    /**
     * Load OBJ from inline text data
     */
    loadFromText(objText, name = 'inline') {
        const object = this.loader.parse(objText);
        this.objCache.set(name, object);
        console.log(`‚úÖ Parsed inline OBJ: ${name}`);
        return object;
    }

    /**
     * Create OBJ text from vertex array
     * Format: v x y z (vertices), f v1 v2 v3 (faces)
     */
    createOBJFromVertices(vertices, faces = null) {
        let objText = '# Generated by PixelProdigy\n';
        objText += `# Vertices: ${vertices.length / 3}\n\n`;

        // Write vertices
        for (let i = 0; i < vertices.length; i += 3) {
            objText += `v ${vertices[i]} ${vertices[i + 1]} ${vertices[i + 2]}\n`;
        }

        // Write faces if provided
        if (faces && faces.length > 0) {
            objText += '\n';
            for (let i = 0; i < faces.length; i += 3) {
                // OBJ indices are 1-based
                objText += `f ${faces[i] + 1} ${faces[i + 1] + 1} ${faces[i + 2] + 1}\n`;
            }
        } else {
            // Auto-generate faces from vertices (triangle soup)
            objText += '\n';
            for (let i = 0; i < vertices.length / 3 - 2; i += 3) {
                objText += `f ${i + 1} ${i + 2} ${i + 3}\n`;
            }
        }

        return objText;
    }

    /**
     * Export Three.js geometry to OBJ format
     */
    exportGeometryToOBJ(geometry, name = 'model') {
        const vertices = geometry.attributes.position.array;
        const indices = geometry.index ? geometry.index.array : null;
        
        const objText = this.createOBJFromVertices(vertices, indices);
        
        // Download as file
        const blob = new Blob([objText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${name}.obj`;
        a.click();
        URL.revokeObjectURL(url);
        
        console.log(`üíæ Exported: ${name}.obj`);
    }

    /**
     * Clear cache
     */
    clearCache() {
        this.objCache.clear();
        console.log('üóëÔ∏è OBJ cache cleared');
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// EMBEDDED ANATOMY OBJ DATA
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const ANATOMY_OBJ_DATA = {
    // Human Male Skeleton (simplified)
    human_skeleton: `# Human Skeleton
# Generated for PixelProdigy Marketplace

# Head (Skull)
v 0.0 1.7 0.0
v 0.15 1.65 0.1
v -0.15 1.65 0.1
v 0.15 1.65 -0.1
v -0.15 1.65 -0.1
v 0.1 1.55 0.15
v -0.1 1.55 0.15
v 0.1 1.55 -0.15
v -0.1 1.55 -0.15

# Spine vertebrae
v 0.0 1.5 0.0
v 0.0 1.4 0.0
v 0.0 1.3 0.0
v 0.0 1.2 0.0
v 0.0 1.1 0.0
v 0.0 1.0 0.0
v 0.0 0.9 0.0

# Ribcage
v 0.2 1.3 0.0
v -0.2 1.3 0.0
v 0.25 1.2 0.1
v -0.25 1.2 0.1
v 0.25 1.1 0.15
v -0.25 1.1 0.15

# Pelvis
v 0.15 0.9 0.0
v -0.15 0.9 0.0
v 0.2 0.85 0.05
v -0.2 0.85 0.05

# Faces (simplified)
f 1 2 3
f 1 3 4
f 1 4 5
f 2 6 7
f 10 11 12
f 17 18 19
`,

    // Human Male Body (low poly)
    human_male: `# Human Male Body
# Commercial Use License

# Torso
v 0.0 1.5 0.0
v 0.3 1.4 0.15
v -0.3 1.4 0.15
v 0.3 1.4 -0.15
v -0.3 1.4 -0.15
v 0.35 1.0 0.2
v -0.35 1.0 0.2
v 0.35 1.0 -0.2
v -0.35 1.0 -0.2

# Legs
v 0.15 0.9 0.0
v -0.15 0.9 0.0
v 0.15 0.5 0.0
v -0.15 0.5 0.0
v 0.15 0.0 0.0
v -0.15 0.0 0.0

# Arms
v 0.5 1.3 0.0
v -0.5 1.3 0.0
v 0.6 0.8 0.0
v -0.6 0.8 0.0

# Faces
f 1 2 3
f 2 6 7
f 10 11 12
f 16 17 18
`,

    // Add more anatomy models here
    human_female: null, // TODO: Add female model
    organs: null,       // TODO: Add organs
    muscles: null       // TODO: Add muscle system
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INTEGRATION WITH MARKETPLACE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Load anatomy model by ID
 */
async function loadAnatomyModel(modelId, scene) {
    const objLoader = new PixelProdigyOBJLoader();
    
    // Check if we have embedded OBJ data
    if (ANATOMY_OBJ_DATA[modelId]) {
        const objText = ANATOMY_OBJ_DATA[modelId];
        const model = objLoader.loadFromText(objText, modelId);
        
        // Apply material
        model.traverse((child) => {
            if (child.isMesh) {
                child.material = new THREE.MeshStandardMaterial({
                    color: 0xffeedd,
                    roughness: 0.6,
                    metalness: 0.1
                });
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });
        
        scene.add(model);
        return model;
    }
    
    // Try loading from external file
    const filePath = `/models/${modelId}.obj`;
    try {
        const model = await objLoader.loadFromFile(filePath);
        scene.add(model);
        return model;
    } catch (error) {
        console.error(`Failed to load ${modelId}:`, error);
        return null;
    }
}

/**
 * Batch convert vertex arrays to OBJ files
 */
function convertVertexArraysToOBJ(vertexData, name) {
    const objLoader = new PixelProdigyOBJLoader();
    const objText = objLoader.createOBJFromVertices(vertexData);
    
    // Save to file
    const blob = new Blob([objText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${name}.obj`;
    a.click();
    URL.revokeObjectURL(url);
    
    console.log(`‚úÖ Converted vertex array to OBJ: ${name}.obj`);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// USAGE EXAMPLES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/*
// Example 1: Load embedded skeleton
const model = await loadAnatomyModel('human_skeleton', scene);

// Example 2: Export current geometry
const objLoader = new PixelProdigyOBJLoader();
objLoader.exportGeometryToOBJ(mesh.geometry, 'my_model');

// Example 3: Convert vertex array from paste
const vertices = [
    -0.5, 0.0, 0.5,
    0.5, 0.0, 0.5,
    0.0, 1.0, 0.0
];
convertVertexArraysToOBJ(vertices, 'custom_model');

// Example 4: Load external OBJ
const objLoader = new PixelProdigyOBJLoader();
const model = await objLoader.loadFromFile('/models/human_male.obj');
scene.add(model);
*/

console.log('‚úÖ PixelProdigy OBJ Loader initialized');
console.log('üì¶ Embedded models:', Object.keys(ANATOMY_OBJ_DATA).filter(k => ANATOMY_OBJ_DATA[k]));
