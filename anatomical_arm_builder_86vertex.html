<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü¶æ Advanced Anatomical Arm Builder - 86 Vertex System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff88;
            overflow: hidden;
            height: 100vh;
        }

        #container {
            display: grid;
            grid-template-columns: 300px 1fr 250px;
            height: 100vh;
        }

        .panel {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff88;
            padding: 15px;
            overflow-y: auto;
        }

        .panel h2 {
            color: #00ffaa;
            margin-bottom: 15px;
            font-size: 14px;
            border-bottom: 1px solid #00ff88;
            padding-bottom: 5px;
        }

        #canvas-container {
            position: relative;
            background: #000;
            border: 2px solid #00ff88;
        }

        .control-group {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 5px;
        }

        .control-group h3 {
            color: #00ccff;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .slider-container {
            margin: 8px 0;
        }

        .slider-container label {
            font-size: 10px;
            color: #ccc;
            display: block;
            margin-bottom: 3px;
        }

        .slider {
            width: 100%;
            height: 20px;
            background: #333;
            border: 1px solid #00ff88;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 18px;
            background: #00ff88;
            cursor: pointer;
            border-radius: 2px;
        }

        .value-display {
            font-size: 10px;
            color: #00ff88;
            text-align: right;
        }

        .vertex-info {
            font-size: 10px;
            line-height: 1.4;
            margin: 5px 0;
            padding: 5px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 3px;
        }

        .build-button {
            background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%);
            color: #000;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 11px;
            width: 100%;
            margin: 5px 0;
            transition: all 0.3s ease;
        }

        .build-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0, 255, 136, 0.3);
        }

        .anatomy-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border: 1px solid #00ff88;
            border-radius: 5px;
            font-size: 10px;
            z-index: 100;
        }

        .rotation-controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border: 1px solid #00ff88;
            border-radius: 5px;
            z-index: 100;
        }

        .angle-indicator {
            color: #ffaa00;
            font-weight: bold;
        }

        .vertex-count {
            color: #ff6600;
            font-weight: bold;
        }

        #stats {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 20px;
            border: 1px solid #00ff88;
            border-radius: 20px;
            font-size: 12px;
            z-index: 200;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="stats">
        ü¶æ Anatomical Arm Builder | Vertices: <span id="vertexCount">0</span> | Segments: <span id="segmentCount">0</span>
    </div>

    <div id="container">
        <!-- Left Panel: Anatomical Controls -->
        <div class="panel">
            <h2>ü¶æ ANATOMICAL ARM SYSTEM</h2>
            
            <div class="control-group">
                <h3>ü§ö WRIST (Origin Point)</h3>
                <div class="slider-container">
                    <label>Wrist Width (Oblong)</label>
                    <input type="range" class="slider" id="wristWidth" min="0.5" max="2.0" step="0.1" value="1.2">
                    <div class="value-display" id="wristWidthVal">1.2</div>
                </div>
                <div class="slider-container">
                    <label>Wrist Height</label>
                    <input type="range" class="slider" id="wristHeight" min="0.3" max="1.0" step="0.05" value="0.8">
                    <div class="value-display" id="wristHeightVal">0.8</div>
                </div>
                <div class="vertex-info">
                    Base: <span class="vertex-count">86 vertices</span> in oblong pattern
                </div>
            </div>

            <div class="control-group">
                <h3>ü¶¥ WRIST BONE (270-300¬∞ Protrusion)</h3>
                <div class="slider-container">
                    <label>Wrist Bone Angle (270-300¬∞)</label>
                    <input type="range" class="slider" id="wristBoneAngle" min="270" max="300" step="5" value="285">
                    <div class="value-display" id="wristBoneAngleVal">285¬∞</div>
                </div>
                <div class="slider-container">
                    <label>Bone Protrusion (1/16 wrist size)</label>
                    <input type="range" class="slider" id="wristBoneSize" min="0.05" max="0.15" step="0.01" value="0.0625">
                    <div class="value-display" id="wristBoneSizeVal">1/16</div>
                </div>
                <div class="vertex-info">
                    Styloid Process: <span class="vertex-count">86 vertices</span> micro-sphere<br>
                    Angle: <span class="angle-indicator">270-300¬∞</span> anatomical position<br>
                    Size: <span class="vertex-count">1/16th</span> of wrist diameter
                </div>
            </div>

            <div class="control-group">
                <h3>üëã HAND (Complex Anatomical Structure)</h3>
                <div class="slider-container">
                    <label>Hand X-Axis Extension</label>
                    <input type="range" class="slider" id="handXExtension" min="4" max="8" step="0.2" value="6">
                    <div class="value-display" id="handXExtensionVal">6"</div>
                </div>
                <div class="slider-container">
                    <label>Growth Factor (40% wider/taller)</label>
                    <input type="range" class="slider" id="handGrowth" min="1.2" max="1.6" step="0.05" value="1.4">
                    <div class="value-display" id="handGrowthVal">140%</div>
                </div>
                <div class="slider-container">
                    <label>Curl Slope (45¬∞ curve)</label>
                    <input type="range" class="slider" id="handCurlSlope" min="35" max="55" step="2" value="45">
                    <div class="value-display" id="handCurlSlopeVal">45¬∞</div>
                </div>
                <div class="slider-container">
                    <label>Thumb Hump (190¬∞ alignment)</label>
                    <input type="range" class="slider" id="thumbHumpAngle" min="180" max="200" step="2" value="190">
                    <div class="value-display" id="thumbHumpAngleVal">190¬∞</div>
                </div>
                <div class="vertex-info">
                    Structure: <span class="vertex-count">86 vertices</span> oval ‚Üí curl ‚Üí hump ‚Üí palm<br>
                    Growth: <span class="angle-indicator">40% expansion</span> along curve<br>
                    Thumb: <span class="angle-indicator">190¬∞ hump</span> anatomical position
                </div>
            </div>

            <div class="control-group">
                <h3>üñêÔ∏è FINGERS (Progressive Sizing)</h3>
                <div class="slider-container">
                    <label>Finger Base Length (0.5" increments)</label>
                    <input type="range" class="slider" id="fingerBaseLength" min="2.5" max="4.0" step="0.5" value="3.5">
                    <div class="value-display" id="fingerBaseLengthVal">3.5"</div>
                </div>
                <div class="slider-container">
                    <label>Size Reduction Per Finger (%)</label>
                    <input type="range" class="slider" id="fingerSizeReduction" min="5" max="15" step="1" value="10">
                    <div class="value-display" id="fingerSizeReductionVal">10%</div>
                </div>
                <div class="slider-container">
                    <label>Vertex Circle Scaling</label>
                    <input type="range" class="slider" id="fingerVertexScaling" min="0.3" max="0.8" step="0.05" value="0.6">
                    <div class="value-display" id="fingerVertexScalingVal">0.6</div>
                </div>
                <div class="slider-container">
                    <label>Spherical Tip Size</label>
                    <input type="range" class="slider" id="fingertipSize" min="0.1" max="0.4" step="0.02" value="0.25">
                    <div class="value-display" id="fingertipSizeVal">0.25</div>
                </div>
                <div class="vertex-info">
                    Structure: <span class="vertex-count">4 fingers</span> √ó 3 segments each<br>
                    Sizing: <span class="angle-indicator">0.5" decrements</span> per finger<br>
                    Tips: <span class="vertex-count">Spherical vertices</span> anatomical<br>
                    Circles: <span class="angle-indicator">Progressive scaling</span> smaller
                </div>
            </div>

            <div class="control-group">
                <h3>üí™ FOREARM (14" Extension)</h3>
                <div class="slider-container">
                    <label>Forearm Length (inches)</label>
                    <input type="range" class="slider" id="forearmLength" min="10" max="18" step="0.5" value="14">
                    <div class="value-display" id="forearmLengthVal">14"</div>
                </div>
                <div class="slider-container">
                    <label>Expansion Factor</label>
                    <input type="range" class="slider" id="forearmExpansion" min="1.0" max="1.5" step="0.05" value="1.15">
                    <div class="value-display" id="forearmExpansionVal">1.15</div>
                </div>
                <div class="vertex-info">
                    Cylinder: <span class="vertex-count">86 vertices</span> extended<br>
                    Gap separation with vertex lengthening
                </div>
            </div>

            <div class="control-group">
                <h3>üîó ELBOW (180¬∞ Pivot)</h3>
                <div class="slider-container">
                    <label>Elbow Bend (160-170¬∞)</label>
                    <input type="range" class="slider" id="elbowBend" min="160" max="170" step="2" value="165">
                    <div class="value-display" id="elbowBendVal">165¬∞</div>
                </div>
                <div class="slider-container">
                    <label>Joint Flexibility</label>
                    <input type="range" class="slider" id="elbowFlex" min="0.8" max="1.2" step="0.05" value="1.0">
                    <div class="value-display" id="elbowFlexVal">1.0</div>
                </div>
                <div class="vertex-info">
                    Pivot: <span class="angle-indicator">180¬∞ base</span><br>
                    Connection: <span class="vertex-count">86 ‚Üí 86</span> via 90¬∞ match<br>
                    Range: <span class="angle-indicator">90¬∞ quadrant</span>
                </div>
            </div>
        </div>

        <!-- Center: 3D Viewport -->
        <div id="canvas-container">
            <div class="anatomy-display">
                <strong>ü¶æ ANATOMICAL DATA</strong><br>
                Total Vertices: <span id="totalVertices">0</span><br>
                Wrist Vertices: <span id="wristVertices">86</span><br>
                Wrist Bone: <span id="wristBoneVertices">86</span><br>
                Hand Structure: <span id="handVertices">0</span><br>
                Finger Segments: <span id="fingerVertices">0</span><br>
                Fingertips: <span id="fingertipVertices">0</span><br>
                Thumb: <span id="thumbVertices">0</span><br>
                Forearm Vertices: <span id="forearmVertices">0</span><br>
                Elbow Vertices: <span id="elbowVertices">86</span><br>
                Bicep Vertices: <span id="bicepVertices">0</span>
            </div>

            <div class="rotation-controls">
                <strong>üéÆ ROTATION</strong><br>
                X: <span id="rotX">0¬∞</span><br>
                Y: <span id="rotY">0¬∞</span><br>
                Z: <span id="rotZ">0¬∞</span><br>
                <small>Drag to rotate</small>
            </div>
        </div>

        <!-- Right Panel: Advanced Controls -->
        <div class="panel">
            <h2>üí™ UPPER ARM SYSTEM</h2>
            
            <div class="control-group">
                <h3>üí™ BICEP/TRICEP</h3>
                <div class="slider-container">
                    <label>Muscle Height</label>
                    <input type="range" class="slider" id="bicepHeight" min="8" max="16" step="0.5" value="12">
                    <div class="value-display" id="bicepHeightVal">12"</div>
                </div>
                <div class="slider-container">
                    <label>Muscle Width</label>
                    <input type="range" class="slider" id="bicepWidth" min="3" max="8" step="0.2" value="5">
                    <div class="value-display" id="bicepWidthVal">5"</div>
                </div>
                <div class="slider-container">
                    <label>Peak Squeeze (35-45¬∞)</label>
                    <input type="range" class="slider" id="peakSqueeze" min="35" max="45" step="2" value="40">
                    <div class="value-display" id="peakSqueezeVal">40¬∞</div>
                </div>
                <div class="vertex-info">
                    Squeeze: <span class="vertex-count">86 vertices</span> closer at peak<br>
                    Angles: <span class="angle-indicator">35-45¬∞</span> bottom curves<br>
                    Pattern: <span class="angle-indicator">360¬∞ muscular</span>
                </div>
            </div>

            <div class="control-group">
                <h3>üéØ VERTEX MATHEMATICS</h3>
                <div class="vertex-info">
                    <strong>86-Point System:</strong><br>
                    ‚Ä¢ Wrist: Oblong distribution<br>
                    ‚Ä¢ Hand: Spherical scaling<br>
                    ‚Ä¢ Forearm: Cylindrical extension<br>
                    ‚Ä¢ Elbow: 90¬∞ connection matrix<br>
                    ‚Ä¢ Bicep: Muscular compression<br><br>
                    <strong>Angles:</strong><br>
                    ‚Ä¢ Hand: 270-300¬∞ extrusion<br>
                    ‚Ä¢ Elbow: 160-170¬∞ bend (90¬∞ quad)<br>
                    ‚Ä¢ Bicep: 35-45¬∞ curves<br>
                </div>
            </div>

            <div class="control-group">
                <h3>‚ö° BUILD ACTIONS</h3>
                <button class="build-button" onclick="generateArm()">
                    ü¶æ GENERATE ARM
                </button>
                <button class="build-button" onclick="animateMovement()">
                    üé¨ ANIMATE MOVEMENT
                </button>
                <button class="build-button" onclick="exportVertices()">
                    üíæ EXPORT VERTICES
                </button>
                <button class="build-button" onclick="resetArm()">
                    üîÑ RESET ARM
                </button>
            </div>

            <div class="control-group">
                <h3>üìä REAL-TIME DATA</h3>
                <div class="vertex-info" id="realtimeData">
                    Calculating vertex positions...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Three.js Setup
        let scene, camera, renderer, arm = {};
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 20);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x00ff88, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // Mouse controls
            setupMouseControls();
            
            // Initialize arm generation
            generateArm();
            
            animate();
        }

        function setupMouseControls() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };
                
                // Rotate camera around the arm
                const rotationSpeed = 0.005;
                camera.position.x = camera.position.x * Math.cos(deltaMove.x * rotationSpeed) - camera.position.z * Math.sin(deltaMove.x * rotationSpeed);
                camera.position.z = camera.position.x * Math.sin(deltaMove.x * rotationSpeed) + camera.position.z * Math.cos(deltaMove.x * rotationSpeed);
                
                camera.position.y += deltaMove.y * rotationSpeed * 5;
                
                camera.lookAt(0, 0, 0);
                
                // Update rotation display
                updateRotationDisplay();
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('wheel', (event) => {
                const zoomSpeed = 0.1;
                const distance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
                
                if (event.deltaY > 0 && distance < 50) {
                    camera.position.multiplyScalar(1 + zoomSpeed);
                } else if (event.deltaY < 0 && distance > 5) {
                    camera.position.multiplyScalar(1 - zoomSpeed);
                }
            });
        }

        function generate86VertexRing(radius, height, oblongFactor = 1.0) {
            const vertices = [];
            const vertexCount = 86;
            
            for (let i = 0; i < vertexCount; i++) {
                const angle = (i / vertexCount) * Math.PI * 2;
                const x = Math.cos(angle) * radius * oblongFactor;
                const z = Math.sin(angle) * radius;
                vertices.push(new THREE.Vector3(x, height, z));
            }
            
            return vertices;
        }

        function generateArm() {
            // Clear existing arm
            Object.values(arm).forEach(part => {
                if (part && scene.children.includes(part)) {
                    scene.remove(part);
                }
            });
            arm = {};
            
            // Get control values
            const wristWidth = parseFloat(document.getElementById('wristWidth').value);
            const wristHeight = parseFloat(document.getElementById('wristHeight').value);
            const handAngle = parseFloat(document.getElementById('handAngle').value);
            const handHeight = parseFloat(document.getElementById('handHeight').value);
            const forearmLength = parseFloat(document.getElementById('forearmLength').value);
            const forearmExpansion = parseFloat(document.getElementById('forearmExpansion').value);
            const elbowBend = parseFloat(document.getElementById('elbowBend').value);
            const bicepHeight = parseFloat(document.getElementById('bicepHeight').value);
            const bicepWidth = parseFloat(document.getElementById('bicepWidth').value);
            const peakSqueeze = parseFloat(document.getElementById('peakSqueeze').value);
            
            // 1. WRIST (Origin - 86 vertices in oblong pattern)
            const wristVertices = generate86VertexRing(1.0, 0, wristWidth / wristHeight);
            arm.wrist = createVertexMesh(wristVertices, 0x00ff88);
            scene.add(arm.wrist);
            
            // 2. WRIST BONE (270-300¬∞ tiny spherical protrusion - styloid process)
            const wristBoneAngle = parseFloat(document.getElementById('wristBoneAngle').value);
            const wristBoneSize = parseFloat(document.getElementById('wristBoneSize').value);
            const wristBoneAngleRad = (wristBoneAngle * Math.PI) / 180;
            
            // Calculate wrist bone position (1/16th size protrusion)
            const wristBoneDirection = new THREE.Vector3(Math.cos(wristBoneAngleRad), 0, Math.sin(wristBoneAngleRad));
            const wristBoneVertices = [];
            
            // Create tiny spherical bone protrusion
            const boneCenter = wristBoneDirection.clone().multiplyScalar(wristBoneSize * 2);
            for (let i = 0; i < 86; i++) {
                const angle1 = (i / 86) * Math.PI * 2;
                const angle2 = (i / 86) * Math.PI;
                const x = Math.cos(angle1) * Math.sin(angle2) * wristBoneSize + boneCenter.x;
                const y = Math.cos(angle2) * wristBoneSize + boneCenter.y;
                const z = Math.sin(angle1) * Math.sin(angle2) * wristBoneSize + boneCenter.z;
                wristBoneVertices.push(new THREE.Vector3(x, y, z));
            }
            
            arm.wristBone = createVertexMesh(wristBoneVertices, 0xffeeaa);
            scene.add(arm.wristBone);
            
            // 3. HAND (Complex anatomical structure with curves and thumb hump)
            const handXExtension = parseFloat(document.getElementById('handXExtension').value);
            const handGrowth = parseFloat(document.getElementById('handGrowth').value);
            const handCurlSlope = parseFloat(document.getElementById('handCurlSlope').value);
            const thumbHumpAngle = parseFloat(document.getElementById('thumbHumpAngle').value);
            const palmFlatten = parseFloat(document.getElementById('palmFlatten').value);
            const fingerBaseLength = parseFloat(document.getElementById('fingerBaseLength').value);
            const fingerSizeReduction = parseFloat(document.getElementById('fingerSizeReduction').value);
            const fingerVertexScaling = parseFloat(document.getElementById('fingerVertexScaling').value);
            const fingertipSize = parseFloat(document.getElementById('fingertipSize').value);
            const thumbLength = parseFloat(document.getElementById('thumbLength').value);
            
            const handVertices = [];
            const handSegments = 20; // Segments for smooth curve progression
            
            // Convert angles to radians
            const curlSlopeRad = (handCurlSlope * Math.PI) / 180;
            const thumbHumpRad = (thumbHumpAngle * Math.PI) / 180;
            
            for (let segment = 0; segment <= handSegments; segment++) {
                const t = segment / handSegments; // Progress along hand (0 to 1)
                
                // Calculate X-axis progression
                const xProgress = (handXExtension / 12) * t; // Convert inches to units
                
                // Calculate growth factor (40% wider/taller as it progresses)
                const currentGrowth = 1.0 + ((handGrowth - 1.0) * t);
                
                // Calculate curl slope (45-degree curve)
                const curlHeight = Math.sin(t * Math.PI * 0.5) * Math.sin(curlSlopeRad) * 2;
                
                // Thumb hump calculation (190-degree alignment)
                let thumbHumpEffect = 0;
                if (t > 0.3 && t < 0.7) { // Thumb hump in middle section
                    const humpProgress = (t - 0.3) / 0.4; // Normalize to 0-1 for hump section
                    thumbHumpEffect = Math.sin(humpProgress * Math.PI) * 0.8; // Hump height
                }
                
                // Palm flattening effect (more pronounced toward end)
                const flattenEffect = palmFlatten * t;
                
                // Generate 86 vertices for this segment
                for (let i = 0; i < 86; i++) {
                    const baseVertex = wristVertices[i].clone();
                    const angle = (i / 86) * Math.PI * 2;
                    
                    // Apply growth factor to radius
                    const currentRadius = Math.sqrt(baseVertex.x * baseVertex.x + baseVertex.z * baseVertex.z) * currentGrowth;
                    
                    // Calculate new position with all transformations
                    let x = Math.cos(angle) * currentRadius;
                    let y = curlHeight; // Curl slope effect
                    let z = Math.sin(angle) * currentRadius;
                    
                    // Apply thumb hump (190-degree side)
                    if (angle >= thumbHumpRad - 0.5 && angle <= thumbHumpRad + 0.5) {
                        y += thumbHumpEffect;
                        x += thumbHumpEffect * 0.3; // Slight outward push for thumb area
                    }
                    
                    // Apply palm flattening
                    y *= (1.0 - flattenEffect);
                    
                    // Add X-axis progression
                    x += xProgress;
                    
                    // Add to base wrist position
                    const finalVertex = new THREE.Vector3(
                        baseVertex.x + x,
                        baseVertex.y + y,
                        baseVertex.z + z
                    );
                    
                    handVertices.push(finalVertex);
                }
            }
            
            // Add detailed finger structure with progressive sizing
            const fingerVertices = [];
            const fingerCount = 4; // Index, Middle, Ring, Pinky
            const fingerNames = ['Index', 'Middle', 'Ring', 'Pinky'];
            
            // Define finger lengths (each 0.5" smaller than previous)
            const fingerLengths = [
                fingerBaseLength,                                    // Index finger (longest)
                fingerBaseLength - 0.5,                             // Middle finger
                fingerBaseLength - 1.0,                             // Ring finger  
                fingerBaseLength - 1.5                              // Pinky (shortest)
            ];
            
            for (let finger = 0; finger < fingerCount; finger++) {
                const fingerAngle = (finger / (fingerCount - 1)) * Math.PI * 0.6 + Math.PI * 0.7; // Spread across front
                const currentFingerLength = fingerLengths[finger];
                const sizeReductionFactor = 1.0 - (finger * (fingerSizeReduction / 100)); // Progressive size reduction
                
                // Create 3 segments per finger (proximal, middle, distal phalanges)
                for (let segment = 0; segment < 3; segment++) {
                    const segmentLength = (currentFingerLength / 12) / 3; // Divide finger into 3 equal segments
                    const segmentRadius = fingerVertexScaling * sizeReductionFactor * (1.0 - segment * 0.2); // Taper toward tip
                    
                    // Calculate finger position from palm
                    const baseX = Math.cos(fingerAngle) * handGrowth + (handXExtension / 12);
                    const baseY = palmFlatten * 0.5;
                    const baseZ = Math.sin(fingerAngle) * handGrowth;
                    
                    const segmentX = baseX + (segment + 1) * segmentLength;
                    
                    // Create vertex circle for this finger segment (smaller circles as we go)
                    const segmentVertexCount = Math.max(8, Math.floor(20 * segmentRadius)); // Fewer vertices for smaller segments
                    
                    for (let v = 0; v < segmentVertexCount; v++) {
                        const vertexAngle = (v / segmentVertexCount) * Math.PI * 2;
                        const x = segmentX + Math.cos(vertexAngle) * segmentRadius;
                        const y = baseY + Math.sin(vertexAngle) * segmentRadius * 0.5; // Flatter in Y
                        const z = baseZ + Math.sin(vertexAngle) * segmentRadius;
                        
                        fingerVertices.push(new THREE.Vector3(x, y, z));
                    }
                    
                    // Add spherical fingertip for the last segment
                    if (segment === 2) {
                        const tipCenter = new THREE.Vector3(
                            segmentX + segmentLength * 0.5,
                            baseY,
                            baseZ
                        );
                        
                        // Create spherical tip with fewer vertices
                        const tipVertexCount = 12;
                        for (let t = 0; t < tipVertexCount; t++) {
                            const phi = (t / tipVertexCount) * Math.PI * 2;
                            const theta = Math.PI * 0.5; // Half sphere for fingertip
                            
                            const tipX = tipCenter.x + Math.cos(phi) * Math.sin(theta) * fingertipSize;
                            const tipY = tipCenter.y + Math.cos(theta) * fingertipSize;
                            const tipZ = tipCenter.z + Math.sin(phi) * Math.sin(theta) * fingertipSize;
                            
                            fingerVertices.push(new THREE.Vector3(tipX, tipY, tipZ));
                        }
                    }
                }
            }
            
            // Create thumb (separate from fingers, positioned at 190¬∞)
            const thumbVertices = [];
            const thumbAngleRad = (thumbHumpAngle * Math.PI) / 180;
            const thumbSegments = 2; // Thumbs have 2 segments (no middle phalanx)
            
            for (let segment = 0; segment < thumbSegments; segment++) {
                const segmentLength = (thumbLength / 12) / thumbSegments;
                const segmentRadius = fingerVertexScaling * 0.8 * (1.0 - segment * 0.3); // Thumb slightly thicker
                
                const baseX = Math.cos(thumbAngleRad) * handGrowth * 0.8 + (handXExtension / 12) * 0.6;
                const baseY = palmFlatten + segment * 0.2;
                const baseZ = Math.sin(thumbAngleRad) * handGrowth * 0.8;
                
                const segmentX = baseX + (segment + 1) * segmentLength;
                
                // Create vertex circle for thumb segment
                const thumbVertexCount = 16; // Thumb gets more vertices (thicker)
                
                for (let v = 0; v < thumbVertexCount; v++) {
                    const vertexAngle = (v / thumbVertexCount) * Math.PI * 2;
                    const x = segmentX + Math.cos(vertexAngle) * segmentRadius;
                    const y = baseY + Math.sin(vertexAngle) * segmentRadius * 0.6;
                    const z = baseZ + Math.sin(vertexAngle) * segmentRadius;
                    
                    thumbVertices.push(new THREE.Vector3(x, y, z));
                }
                
                // Add spherical thumb tip
                if (segment === thumbSegments - 1) {
                    const thumbTipCenter = new THREE.Vector3(
                        segmentX + segmentLength * 0.5,
                        baseY,
                        baseZ
                    );
                    
                    const thumbTipVertexCount = 12;
                    for (let t = 0; t < thumbTipVertexCount; t++) {
                        const phi = (t / thumbTipVertexCount) * Math.PI * 2;
                        const theta = Math.PI * 0.5;
                        
                        const tipX = thumbTipCenter.x + Math.cos(phi) * Math.sin(theta) * fingertipSize * 1.2; // Thumb tip slightly larger
                        const tipY = thumbTipCenter.y + Math.cos(theta) * fingertipSize * 1.2;
                        const tipZ = thumbTipCenter.z + Math.sin(phi) * Math.sin(theta) * fingertipSize * 1.2;
                        
                        thumbVertices.push(new THREE.Vector3(tipX, tipY, tipZ));
                    }
                }
            }
            
            // Combine all hand components
            const allHandVertices = [...handVertices, ...fingerVertices, ...thumbVertices];
            
            arm.hand = createVertexMesh(allHandVertices, 0xffaa00);
            scene.add(arm.hand);
            
            // 3. FOREARM (14" extension with expansion)
            const forearmVertices = [];
            const segments = 20;
            
            for (let s = 0; s <= segments; s++) {
                const t = s / segments;
                const currentRadius = 1.0 + (forearmExpansion - 1.0) * t;
                const currentHeight = (forearmLength / 12) * t; // Convert inches to units
                const ringVertices = generate86VertexRing(currentRadius, currentHeight);
                forearmVertices.push(...ringVertices);
            }
            
            arm.forearm = createVertexMesh(forearmVertices, 0x00ccff);
            scene.add(arm.forearm);
            
            // 4. ELBOW (180¬∞ pivot connection)
            const elbowBendRad = (elbowBend * Math.PI) / 180;
            const elbowVertices = generate86VertexRing(forearmExpansion * 1.1, forearmLength / 12);
            
            // Transform elbow vertices for bend
            elbowVertices.forEach(vertex => {
                const newY = vertex.y * Math.cos(elbowBendRad);
                const newZ = vertex.z + vertex.y * Math.sin(elbowBendRad);
                vertex.y = newY;
                vertex.z = newZ;
            });
            
            arm.elbow = createVertexMesh(elbowVertices, 0xff6600);
            scene.add(arm.elbow);
            
            // 5. BICEP/TRICEP (Muscular shape with peak squeeze)
            const bicepVertices = [];
            const bicepSegments = 25;
            const peakSqueezeRad = (peakSqueeze * Math.PI) / 180;
            
            for (let s = 0; s <= bicepSegments; s++) {
                const t = s / bicepSegments;
                // Create muscular bulge using sine wave
                const muscleBulge = Math.sin(t * Math.PI) * 0.5;
                const currentRadius = (forearmExpansion * 1.1) + muscleBulge * (bicepWidth / 5);
                
                // Apply peak squeeze - vertices closer at peak
                const squeeze = 1.0 - (Math.sin(t * Math.PI) * (Math.sin(peakSqueezeRad) * 0.3));
                const squeezedRadius = currentRadius * squeeze;
                
                const currentHeight = (forearmLength / 12) + (bicepHeight / 12) * t;
                const ringVertices = generate86VertexRing(squeezedRadius, currentHeight);
                
                // Apply 35-45¬∞ curves at bottom left and right
                ringVertices.forEach((vertex, i) => {
                    if (i >= 20 && i <= 30) { // Bottom left curve
                        vertex.x *= Math.cos(peakSqueezeRad * 0.8);
                    }
                    if (i >= 55 && i <= 65) { // Bottom right curve
                        vertex.x *= Math.cos(peakSqueezeRad * 0.8);
                    }
                });
                
                bicepVertices.push(...ringVertices);
            }
            
            arm.bicep = createVertexMesh(bicepVertices, 0xff0088);
            scene.add(arm.bicep);
            
            updateVertexCounts();
            updateRealtimeData();
        }

        function createVertexMesh(vertices, color) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            
            vertices.forEach(vertex => {
                positions.push(vertex.x, vertex.y, vertex.z);
            });
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            return new THREE.Points(geometry, material);
        }

        function updateVertexCounts() {
            const wristCount = 86;
            const wristBoneCount = 86;
            
            // Hand structure calculation
            const handSegments = 21;
            const handStructureCount = 86 * handSegments;
            
            // Finger calculation (4 fingers √ó 3 segments each)
            const fingerSegmentVertices = 4 * 3 * 16; // Average 16 vertices per segment
            const fingertipVertices = 4 * 12; // 4 fingertips √ó 12 vertices each
            
            // Thumb calculation (2 segments + tip)
            const thumbVertices = 2 * 16 + 12; // 2 segments √ó 16 vertices + 12 tip vertices
            
            const totalHandCount = handStructureCount + fingerSegmentVertices + fingertipVertices + thumbVertices;
            
            const forearmCount = 86 * 21;
            const elbowCount = 86;
            const bicepCount = 86 * 26;
            
            const total = wristCount + wristBoneCount + totalHandCount + forearmCount + elbowCount + bicepCount;
            
            document.getElementById('vertexCount').textContent = total;
            document.getElementById('totalVertices').textContent = total;
            document.getElementById('wristVertices').textContent = wristCount;
            document.getElementById('wristBoneVertices').textContent = wristBoneCount;
            document.getElementById('handVertices').textContent = handStructureCount;
            document.getElementById('fingerVertices').textContent = fingerSegmentVertices;
            document.getElementById('fingertipVertices').textContent = fingertipVertices;
            document.getElementById('thumbVertices').textContent = thumbVertices;
            document.getElementById('forearmVertices').textContent = forearmCount;
            document.getElementById('elbowVertices').textContent = elbowCount;
            document.getElementById('bicepVertices').textContent = bicepCount;
            document.getElementById('segmentCount').textContent = 12; // Updated segment count
        }

        function updateRealtimeData() {
            const data = document.getElementById('realtimeData');
            const wristW = document.getElementById('wristWidth').value;
            const wristBoneA = document.getElementById('wristBoneAngle').value;
            const handGrowth = document.getElementById('handGrowth').value;
            const curlSlope = document.getElementById('handCurlSlope').value;
            const thumbAngle = document.getElementById('thumbHumpAngle').value;
            const forearmL = document.getElementById('forearmLength').value;
            const elbowB = document.getElementById('elbowBend').value;
            
            data.innerHTML = `
                <strong>Current Config:</strong><br>
                Wrist: ${wristW}" oblong<br>
                Wrist Bone: ${wristBoneA}¬∞ protrusion<br>
                Hand Growth: ${Math.round(handGrowth * 100)}%<br>
                Curl Slope: ${curlSlope}¬∞<br>
                Thumb Hump: ${thumbAngle}¬∞<br>
                Forearm: ${forearmL}" length<br>
                Elbow: ${elbowB}¬∞ bend<br><br>
                <strong>Hand Architecture:</strong><br>
                ‚Ä¢ 86-vertex oval progression<br>
                ‚Ä¢ 40% growth along X-axis<br>
                ‚Ä¢ 45¬∞ curl slope transition<br>
                ‚Ä¢ 190¬∞ thumb hump alignment<br>
                ‚Ä¢ Palm flattening + knuckles<br>
                ‚Ä¢ Separated finger joints
            `;
        }

        function updateRotationDisplay() {
            // Calculate rotation angles from camera position
            const rotX = Math.atan2(camera.position.y, camera.position.z) * (180 / Math.PI);
            const rotY = Math.atan2(camera.position.x, camera.position.z) * (180 / Math.PI);
            
            document.getElementById('rotX').textContent = Math.round(rotX) + '¬∞';
            document.getElementById('rotY').textContent = Math.round(rotY) + '¬∞';
            document.getElementById('rotZ').textContent = '0¬∞';
        }

        function animateMovement() {
            // Animate elbow bending
            let startBend = 165;
            let targetBend = 90;
            let currentBend = startBend;
            
            const animationStep = () => {
                currentBend += (targetBend - currentBend) * 0.05;
                document.getElementById('elbowBend').value = currentBend;
                document.getElementById('elbowBendVal').textContent = Math.round(currentBend) + '¬∞';
                
                generateArm();
                
                if (Math.abs(currentBend - targetBend) > 1) {
                    requestAnimationFrame(animationStep);
                } else {
                    // Reverse animation
                    targetBend = startBend;
                    if (currentBend < startBend - 1) {
                        requestAnimationFrame(animationStep);
                    }
                }
            };
            
            animationStep();
        }

        function exportVertices() {
            const vertices = [];
            
            Object.entries(arm).forEach(([partName, mesh]) => {
                if (mesh && mesh.geometry) {
                    const positions = mesh.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        vertices.push({
                            part: partName,
                            x: positions[i],
                            y: positions[i + 1],
                            z: positions[i + 2]
                        });
                    }
                }
            });
            
            const exportData = {
                timestamp: new Date().toISOString(),
                totalVertices: vertices.length,
                anatomicalSystem: '86-vertex arm model',
                configuration: {
                    wristWidth: document.getElementById('wristWidth').value,
                    handAngle: document.getElementById('handAngle').value,
                    forearmLength: document.getElementById('forearmLength').value,
                    elbowBend: document.getElementById('elbowBend').value,
                    bicepHeight: document.getElementById('bicepHeight').value,
                    peakSqueeze: document.getElementById('peakSqueeze').value
                },
                vertices: vertices
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `anatomical_arm_86vertex_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function resetArm() {
            // Reset all sliders to default values
            document.getElementById('wristWidth').value = 1.2;
            document.getElementById('wristHeight').value = 0.8;
            document.getElementById('wristBoneAngle').value = 285;
            document.getElementById('wristBoneSize').value = 0.0625;
            document.getElementById('handXExtension').value = 6;
            document.getElementById('handGrowth').value = 1.4;
            document.getElementById('handCurlSlope').value = 45;
            document.getElementById('thumbHumpAngle').value = 190;
            document.getElementById('palmFlatten').value = 0.5;
            document.getElementById('fingerBaseLength').value = 3.5;
            document.getElementById('fingerSizeReduction').value = 10;
            document.getElementById('fingerVertexScaling').value = 0.6;
            document.getElementById('fingertipSize').value = 0.25;
            document.getElementById('thumbLength').value = 2.5;
            document.getElementById('forearmLength').value = 14;
            document.getElementById('forearmExpansion').value = 1.15;
            document.getElementById('elbowBend').value = 165;
            document.getElementById('elbowFlex').value = 1.0;
            document.getElementById('bicepHeight').value = 12;
            document.getElementById('bicepWidth').value = 5;
            document.getElementById('peakSqueeze').value = 40;
            
            // Update displays
            updateValueDisplays();
            generateArm();
        }

        function updateValueDisplays() {
            const sliders = document.querySelectorAll('.slider');
            sliders.forEach(slider => {
                const valueDisplay = document.getElementById(slider.id + 'Val');
                if (valueDisplay) {
                    let value = slider.value;
                    if (slider.id.includes('Angle') || slider.id.includes('Bend') || slider.id.includes('Squeeze')) {
                        value += '¬∞';
                    } else if (slider.id.includes('Length') || slider.id.includes('Height') || slider.id.includes('Width')) {
                        value += '"';
                    }
                    valueDisplay.textContent = value;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            initThreeJS();
            
            // Add slider event listeners
            const sliders = document.querySelectorAll('.slider');
            sliders.forEach(slider => {
                slider.addEventListener('input', () => {
                    updateValueDisplays();
                    updateRealtimeData();
                    generateArm();
                });
            });
            
            updateValueDisplays();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>