<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelVerse Connection Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #0f0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 36px;
            text-shadow: 0 0 10px #0f0;
            margin-bottom: 10px;
        }

        .status {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }

        .status-box {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            text-align: center;
        }

        .status-box.connected {
            border-color: #0f0;
            background: rgba(0, 255, 0, 0.1);
        }

        .status-box.disconnected {
            border-color: #f00;
            background: rgba(255, 0, 0, 0.1);
            color: #f00;
        }

        .controls {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            background: #0f0;
            color: #000;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #0ff;
            transform: scale(1.05);
        }

        .btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .log {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 20px;
            height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            padding: 5px;
            margin: 2px 0;
            border-left: 3px solid #0f0;
            padding-left: 10px;
        }

        .log-entry.success {
            border-color: #0f0;
            color: #0f0;
        }

        .log-entry.error {
            border-color: #f00;
            color: #f00;
        }

        .log-entry.info {
            border-color: #0ff;
            color: #0ff;
        }

        .log-entry.warning {
            border-color: #ff0;
            color: #ff0;
        }

        input {
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0f0;
            color: #0f0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            width: 200px;
            margin: 5px;
        }

        label {
            display: inline-block;
            width: 120px;
            color: #0f0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ PixelVerse Connection Test</h1>
            <p>WebSocket & Renderer Sync Diagnostic</p>
        </div>

        <div class="status">
            <div class="status-box" id="serverStatus">
                <h3>Server</h3>
                <div id="serverState">Checking...</div>
            </div>
            <div class="status-box" id="wsStatus">
                <h3>WebSocket</h3>
                <div id="wsState">Not Connected</div>
            </div>
            <div class="status-box" id="rendererStatus">
                <h3>Renderer</h3>
                <div id="rendererState">Not Initialized</div>
            </div>
        </div>

        <div class="controls">
            <h3>Connection Controls</h3>
            <div style="margin: 15px 0;">
                <label>Server URL:</label>
                <input type="text" id="serverUrl" value="ws://localhost:8080">
            </div>
            <button class="btn" id="connectBtn" onclick="connect()">Connect</button>
            <button class="btn" id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
            <button class="btn" onclick="testPing()">Test Ping</button>
            <button class="btn" onclick="clearLog()">Clear Log</button>
        </div>

        <div class="log" id="log"></div>
    </div>

    <script>
        let ws = null;
        let connected = false;
        let renderer = null;

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            log('Page loaded', 'info');
            checkServerHealth();
            initRenderer();
        });

        // Check server health
        async function checkServerHealth() {
            try {
                const response = await fetch('http://localhost:8080/health');
                const data = await response.json();
                
                if (data.status === 'ok') {
                    updateStatus('serverStatus', 'connected', 'Online');
                    log('‚úÖ Server health check passed', 'success');
                    log(`Players: ${data.players}, Uptime: ${Math.round(data.uptime)}s`, 'info');
                } else {
                    updateStatus('serverStatus', 'disconnected', 'Error');
                    log('‚ùå Server health check failed', 'error');
                }
            } catch (error) {
                updateStatus('serverStatus', 'disconnected', 'Offline');
                log('‚ùå Cannot reach server: ' + error.message, 'error');
            }
        }

        // Initialize renderer
        function initRenderer() {
            try {
                renderer = {
                    initialized: true,
                    characters: new Map(),
                    lastUpdate: Date.now()
                };
                updateStatus('rendererStatus', 'connected', 'Ready');
                log('‚úÖ Renderer initialized', 'success');
            } catch (error) {
                updateStatus('rendererStatus', 'disconnected', 'Error');
                log('‚ùå Renderer initialization failed: ' + error.message, 'error');
            }
        }

        // Connect to WebSocket
        function connect() {
            const url = document.getElementById('serverUrl').value;
            
            try {
                log(`Connecting to ${url}...`, 'info');
                ws = new WebSocket(url);

                ws.onopen = () => {
                    connected = true;
                    updateStatus('wsStatus', 'connected', 'Connected');
                    log('‚úÖ WebSocket connected!', 'success');
                    
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = false;
                    
                    // Send handshake
                    sendMessage({
                        type: 'handshake',
                        data: {
                            version: '1.0.0',
                            clientType: 'test_client'
                        }
                    });
                };

                ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        log(`üì® Received: ${message.type}`, 'info');
                        handleMessage(message);
                    } catch (error) {
                        log('‚ùå Error parsing message: ' + error.message, 'error');
                    }
                };

                ws.onerror = (error) => {
                    log('‚ùå WebSocket error', 'error');
                    updateStatus('wsStatus', 'disconnected', 'Error');
                };

                ws.onclose = () => {
                    connected = false;
                    updateStatus('wsStatus', 'disconnected', 'Disconnected');
                    log('üîå WebSocket disconnected', 'warning');
                    
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = true;
                };

            } catch (error) {
                log('‚ùå Connection failed: ' + error.message, 'error');
            }
        }

        // Disconnect
        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        // Handle messages
        function handleMessage(message) {
            switch (message.type) {
                case 'welcome':
                    log(`üëã Welcome! Player ID: ${message.data.playerId}`, 'success');
                    syncRenderer(message.data);
                    break;
                    
                case 'player_joined':
                    log(`‚ûï Player joined: ${message.data.playerId}`, 'info');
                    if (renderer) {
                        renderer.characters.set(message.data.playerId, message.data);
                        log(`üéÆ Character added to renderer`, 'success');
                    }
                    break;
                    
                case 'player_left':
                    log(`‚ûñ Player left: ${message.data.playerId}`, 'info');
                    if (renderer) {
                        renderer.characters.delete(message.data.playerId);
                    }
                    break;
                    
                case 'state_update':
                    log(`üîÑ State update from ${message.data.playerId}`, 'info');
                    updateCharacterState(message.data);
                    break;
                    
                case 'pong':
                    const latency = Date.now() - pingTime;
                    log(`üèì Pong received! Latency: ${latency}ms`, 'success');
                    break;
                    
                default:
                    log(`üì® Received: ${message.type}`, 'info');
            }
        }

        // Sync renderer
        function syncRenderer(data) {
            if (!renderer) {
                log('‚ö†Ô∏è Renderer not initialized', 'warning');
                return;
            }
            
            log('üîÑ Syncing renderer with server...', 'info');
            
            if (data.players) {
                data.players.forEach(player => {
                    renderer.characters.set(player.id, player);
                });
                log(`‚úÖ Synced ${data.players.length} characters to renderer`, 'success');
            }
            
            renderer.lastUpdate = Date.now();
            log('‚úÖ Renderer sync complete!', 'success');
        }

        // Update character state
        function updateCharacterState(data) {
            if (!renderer) return;
            
            const character = renderer.characters.get(data.playerId);
            if (character) {
                character.position = data.position;
                character.rotation = data.rotation;
                character.state = data.state;
                log(`üéÆ Updated character ${data.playerId} in renderer`, 'success');
            }
        }

        // Send message
        function sendMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
                log(`üì§ Sent: ${message.type}`, 'info');
            } else {
                log('‚ùå Cannot send: not connected', 'error');
            }
        }

        // Test ping
        let pingTime;
        function testPing() {
            if (!connected) {
                log('‚ùå Not connected to server', 'error');
                return;
            }
            
            pingTime = Date.now();
            sendMessage({
                type: 'ping',
                data: { pingId: Math.random().toString(36).substr(2, 9) }
            });
        }

        // Update status
        function updateStatus(elementId, status, text) {
            const element = document.getElementById(elementId);
            element.className = 'status-box ' + status;
            document.getElementById(elementId.replace('Status', 'State')).textContent = text;
        }

        // Log message
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Clear log
        function clearLog() {
            document.getElementById('log').innerHTML = '';
            log('Log cleared', 'info');
        }

        // Auto-reconnect check
        setInterval(checkServerHealth, 10000);
    </script>
</body>
</html>
