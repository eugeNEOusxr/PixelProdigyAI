<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architectural Detail Demo - Marble, Black Trim, Lightning Bolt Roof</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas { display: block; }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 350px;
        }
        
        #info h2 {
            margin: 0 0 15px 0;
            color: #4af;
            font-size: 20px;
        }
        
        .feature {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        
        .feature:before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #4af;
            font-weight: bold;
        }
        
        .highlight {
            color: #4af;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>üèõÔ∏è Architectural Details</h2>
        <div class="feature">Marble walls with light reflectivity</div>
        <div class="feature">Black trim on all edges</div>
        <div class="feature">Doorway with black edging</div>
        <div class="feature">Window seals (black trim)</div>
        <div class="feature">Gutter rails with underskirts</div>
        <div class="feature">Hard cuts with rounded corners</div>
        <div class="feature">Lightning bolt roof pattern</div>
        <div class="feature">Three angled roof dynamics</div>
        <hr style="margin: 15px 0; border-color: #333;">
        <p><span class="highlight">WASD:</span> Move</p>
        <p><span class="highlight">Mouse:</span> Look around</p>
        <p><span class="highlight">Space/Shift:</span> Up/Down</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 50, 300);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // === ARCHITECTURAL DETAIL SYSTEM ===

        // Materials
        function createMarbleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#f8f8f8';
            ctx.fillRect(0, 0, 1024, 1024);

            // Black veins
            ctx.strokeStyle = 'rgba(10, 10, 10, 0.4)';
            ctx.lineWidth = 2;

            for (let i = 0; i < 40; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * 1024, Math.random() * 1024);
                
                for (let j = 0; j < 4; j++) {
                    ctx.bezierCurveTo(
                        Math.random() * 1024, Math.random() * 1024,
                        Math.random() * 1024, Math.random() * 1024,
                        Math.random() * 1024, Math.random() * 1024
                    );
                }
                ctx.stroke();
            }

            // Grey veins
            ctx.strokeStyle = 'rgba(120, 120, 120, 0.2)';
            ctx.lineWidth = 1;

            for (let i = 0; i < 60; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * 1024, Math.random() * 1024);
                ctx.lineTo(Math.random() * 1024, Math.random() * 1024);
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(3, 3);
            return texture;
        }

        const materials = {
            marble: new THREE.MeshStandardMaterial({
                color: 0xf5f5f5,
                roughness: 0.15,
                metalness: 0.2,
                map: createMarbleTexture(),
                clearcoat: 0.8,
                clearcoatRoughness: 0.1
            }),

            blackTrim: new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.2,
                metalness: 0.3,
                clearcoat: 1.0,
                clearcoatRoughness: 0.05
            }),

            reflectiveGlass: new THREE.MeshStandardMaterial({
                color: 0xaaddff,
                roughness: 0.05,
                metalness: 0.1,
                transparent: true,
                opacity: 0.35
            })
        };

        // === BUILD THE DETAILED BUILDING ===

        const buildingGroup = new THREE.Group();
        const width = 40;
        const depth = 30;
        const height = 25;
        const floors = 3;
        const floorHeight = height / floors;

        // 1. MARBLE WALLS
        const frontWall = new THREE.Mesh(
            new THREE.BoxGeometry(width, height, 0.3),
            materials.marble
        );
        frontWall.position.set(0, height / 2, depth / 2);
        frontWall.castShadow = true;
        frontWall.receiveShadow = true;
        buildingGroup.add(frontWall);

        const leftWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, height, depth),
            materials.marble
        );
        leftWall.position.set(-width / 2, height / 2, 0);
        leftWall.castShadow = true;
        leftWall.receiveShadow = true;
        buildingGroup.add(leftWall);

        const rightWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, height, depth),
            materials.marble
        );
        rightWall.position.set(width / 2, height / 2, 0);
        rightWall.castShadow = true;
        rightWall.receiveShadow = true;
        buildingGroup.add(rightWall);

        const backWall = new THREE.Mesh(
            new THREE.BoxGeometry(width, height, 0.3),
            materials.marble
        );
        backWall.position.set(0, height / 2, -depth / 2);
        backWall.castShadow = true;
        backWall.receiveShadow = true;
        buildingGroup.add(backWall);

        // 2. DOORWAY WITH BLACK TRIM EDGING
        const doorWidth = 4;
        const doorHeight = 8;
        const trimWidth = 0.12;

        // Door opening (marble frame)
        const doorFrame = new THREE.Mesh(
            new THREE.BoxGeometry(doorWidth + 0.3, doorHeight + 0.3, 0.35),
            materials.marble
        );
        doorFrame.position.set(0, doorHeight / 2, depth / 2);
        buildingGroup.add(doorFrame);

        // Black trim around door
        const doorTopTrim = new THREE.Mesh(
            new THREE.BoxGeometry(doorWidth + trimWidth * 2, trimWidth, 0.4),
            materials.blackTrim
        );
        doorTopTrim.position.set(0, doorHeight + trimWidth / 2, depth / 2 + 0.05);
        doorTopTrim.castShadow = true;
        buildingGroup.add(doorTopTrim);

        const doorLeftTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, doorHeight, 0.4),
            materials.blackTrim
        );
        doorLeftTrim.position.set(-doorWidth / 2 - trimWidth / 2, doorHeight / 2, depth / 2 + 0.05);
        doorLeftTrim.castShadow = true;
        buildingGroup.add(doorLeftTrim);

        const doorRightTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, doorHeight, 0.4),
            materials.blackTrim
        );
        doorRightTrim.position.set(doorWidth / 2 + trimWidth / 2, doorHeight / 2, depth / 2 + 0.05);
        doorRightTrim.castShadow = true;
        buildingGroup.add(doorRightTrim);

        const doorBottomTrim = new THREE.Mesh(
            new THREE.BoxGeometry(doorWidth + trimWidth * 2, trimWidth, 0.4),
            materials.blackTrim
        );
        doorBottomTrim.position.set(0, -trimWidth / 2, depth / 2 + 0.05);
        doorBottomTrim.castShadow = true;
        buildingGroup.add(doorBottomTrim);

        // 3. WINDOWS WITH BLACK SEALS
        const windowsPerFloor = 5;
        const windowWidth = 2.5;
        const windowHeight = 3;
        const windowSpacing = (width - 8) / windowsPerFloor;
        const sealThickness = 0.08;

        for (let floor = 0; floor < floors; floor++) {
            for (let i = 0; i < windowsPerFloor; i++) {
                const windowX = -width / 2 + 4 + i * windowSpacing + windowSpacing / 2;
                const windowY = floorHeight / 2 + floor * floorHeight + 2;
                const windowZ = depth / 2;

                // Glass
                const glass = new THREE.Mesh(
                    new THREE.BoxGeometry(windowWidth, windowHeight, 0.05),
                    materials.reflectiveGlass
                );
                glass.position.set(windowX, windowY, windowZ + 0.2);
                glass.receiveShadow = true;
                buildingGroup.add(glass);

                // Black window seal (top, bottom, left, right)
                const topSeal = new THREE.Mesh(
                    new THREE.BoxGeometry(windowWidth + sealThickness * 2, sealThickness, 0.25),
                    materials.blackTrim
                );
                topSeal.position.set(windowX, windowY + windowHeight / 2 + sealThickness / 2, windowZ + 0.2);
                topSeal.castShadow = true;
                buildingGroup.add(topSeal);

                const bottomSeal = new THREE.Mesh(
                    new THREE.BoxGeometry(windowWidth + sealThickness * 2, sealThickness, 0.25),
                    materials.blackTrim
                );
                bottomSeal.position.set(windowX, windowY - windowHeight / 2 - sealThickness / 2, windowZ + 0.2);
                bottomSeal.castShadow = true;
                buildingGroup.add(bottomSeal);

                const leftSeal = new THREE.Mesh(
                    new THREE.BoxGeometry(sealThickness, windowHeight, 0.25),
                    materials.blackTrim
                );
                leftSeal.position.set(windowX - windowWidth / 2 - sealThickness / 2, windowY, windowZ + 0.2);
                leftSeal.castShadow = true;
                buildingGroup.add(leftSeal);

                const rightSeal = new THREE.Mesh(
                    new THREE.BoxGeometry(sealThickness, windowHeight, 0.25),
                    materials.blackTrim
                );
                rightSeal.position.set(windowX + windowWidth / 2 + sealThickness / 2, windowY, windowZ + 0.2);
                rightSeal.castShadow = true;
                buildingGroup.add(rightSeal);
            }
        }

        // 4. GUTTER RAILS WITH BLACK UNDERSKIRTS
        const gutterDepth = 0.3;
        const gutterHeight = 0.15;
        const underskirtHeight = 0.08;

        const frontGutter = new THREE.Mesh(
            new THREE.BoxGeometry(width, gutterHeight, gutterDepth),
            materials.marble
        );
        frontGutter.position.set(0, height - 0.2, depth / 2 + 0.2);
        frontGutter.castShadow = true;
        buildingGroup.add(frontGutter);

        // Black underskirt (hangs below gutter)
        const frontUnderskirt = new THREE.Mesh(
            new THREE.BoxGeometry(width, underskirtHeight, gutterDepth + 0.05),
            materials.blackTrim
        );
        frontUnderskirt.position.set(0, height - 0.2 - (gutterHeight / 2 + underskirtHeight / 2), depth / 2 + 0.2);
        frontUnderskirt.castShadow = true;
        buildingGroup.add(frontUnderskirt);

        // 5. LIGHTNING BOLT ROOF (three angled dynamics)
        const roofOverhang = 3.0;
        const roofThickness = 0.4;
        const baseRoofWidth = width + roofOverhang * 2;
        const baseRoofDepth = depth + roofOverhang * 2;

        // Three roof sections at different angles
        const section1Angle = Math.PI / 8;   // 22.5 degrees
        const section2Angle = -Math.PI / 6;  // -30 degrees
        const section3Angle = Math.PI / 10;  // 18 degrees

        function createAngledRoofSection(sectionWidth, sectionDepth, angle, offsetX, offsetZ) {
            const geo = new THREE.BoxGeometry(sectionWidth, roofThickness, sectionDepth);
            const vertices = geo.attributes.position.array;
            
            // Rotate vertices to create angled section
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                
                vertices[i] = x * Math.cos(angle) - z * Math.sin(angle);
                vertices[i + 2] = x * Math.sin(angle) + z * Math.cos(angle);
            }
            
            geo.attributes.position.needsUpdate = true;
            geo.computeVertexNormals();
            
            const mesh = new THREE.Mesh(geo, materials.marble);
            mesh.position.set(offsetX, height + roofThickness / 2, offsetZ);
            mesh.castShadow = true;
            
            // Add black trim to roof edges
            const trimHeight = 0.12;
            const frontTrim = new THREE.Mesh(
                new THREE.BoxGeometry(sectionWidth, trimHeight, 0.08),
                materials.blackTrim
            );
            frontTrim.position.set(0, -roofThickness / 2 - trimHeight / 2, sectionDepth / 2);
            frontTrim.castShadow = true;
            mesh.add(frontTrim);

            const backTrim = new THREE.Mesh(
                new THREE.BoxGeometry(sectionWidth, trimHeight, 0.08),
                materials.blackTrim
            );
            backTrim.position.set(0, -roofThickness / 2 - trimHeight / 2, -sectionDepth / 2);
            backTrim.castShadow = true;
            mesh.add(backTrim);
            
            return mesh;
        }

        // Section 1 (left third, angled right)
        const roofSection1 = createAngledRoofSection(
            baseRoofWidth / 3,
            baseRoofDepth,
            section1Angle,
            -baseRoofWidth / 3,
            0
        );
        buildingGroup.add(roofSection1);

        // Section 2 (middle, angled left - creates lightning bolt zig)
        const roofSection2 = createAngledRoofSection(
            baseRoofWidth / 3,
            baseRoofDepth * 0.8,
            section2Angle,
            0,
            baseRoofDepth * 0.1
        );
        buildingGroup.add(roofSection2);

        // Section 3 (right third, angled right again - completes pattern)
        const roofSection3 = createAngledRoofSection(
            baseRoofWidth / 3,
            baseRoofDepth,
            section3Angle,
            baseRoofWidth / 3,
            0
        );
        buildingGroup.add(roofSection3);

        scene.add(buildingGroup);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffee, 1.2);
        sunLight.position.set(50, 80, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.left = -60;
        sunLight.shadow.camera.right = 60;
        sunLight.shadow.camera.top = 60;
        sunLight.shadow.camera.bottom = -60;
        scene.add(sunLight);

        // Ground
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x4a7c59, roughness: 0.9 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1;
        ground.receiveShadow = true;
        scene.add(ground);

        // Controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            const speed = 0.3;
            if (keys['w']) camera.position.z -= speed;
            if (keys['s']) camera.position.z += speed;
            if (keys['a']) camera.position.x -= speed;
            if (keys['d']) camera.position.x += speed;
            if (keys[' ']) camera.position.y += speed;
            if (keys['shift']) camera.position.y -= speed;

            camera.rotation.y = -mouseX * 0.5;
            camera.rotation.x = mouseY * 0.3;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
