<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SkyRelics - 144 AI Legends | PixelProdigy</title>
    
    <!-- 🔍 Bing Webmaster Verification -->
    <meta name="msvalidate.01" content="2624BBC0969B7788D5C73FAA22ACD0EE" />
    
    <!-- 🔍 CREATOR ATTRIBUTION & SEO -->
    <meta name="description" content="Explore SkyRelics - A mystical 3D world where 144 AI personalities teach mathematics through gameplay. Built with Delaunay triangulation, Fibonacci spirals, and Perlin noise.">
    <meta name="keywords" content="SkyRelics, educational gaming, AI characters, mathematics game, procedural generation, Delaunay mountains, 144 AI legends">
    <meta name="author" content="Eugene Ousos, PixelProdigy AI">
    
    <!-- Open Graph for Social Sharing -->
    <meta property="og:title" content="SkyRelics - Where 144 AI Legends Live">
    <meta property="og:description" content="Learn mathematics through gaming. Meet Aurora the Artist, LLAMA the Meta-Shepherd, and 142 other AI characters in a world built on algorithms.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pixel-prodigy.com/skyrelics_world.html">
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "SkyRelics",
      "description": "Educational 3D game featuring 144 AI characters teaching mathematics",
      "author": {
        "@type": "Person",
        "name": "Eugene Ousos",
        "email": "eugeneousxr2025@outlook.com",
        "url": "https://pixel-prodigy.com",
        "sameAs": [
          "https://github.com/eugeNEOusxr"
        ]
      },
      "genre": ["Educational", "Adventure", "Exploration"],
      "gamePlatform": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
    </script>
    
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #000;
            overflow: hidden;
            color: #fff;
        }
        
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: relative;
        }
        
        /* Loading Screen */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        
        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-logo {
            font-size: 72px;
            font-weight: bold;
            background: linear-gradient(135deg, #00ffff, #0088ff);
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }
        
        .loading-bar {
            width: 400px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .loading-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0088ff);
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }
        
        .loading-text {
            color: #00ffff;
            font-size: 16px;
            margin-top: 10px;
        }
        
        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Title */
        .title-card {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 20px 30px;
            backdrop-filter: blur(10px);
        }
        
        .title-card h1 {
            font-size: 32px;
            background: linear-gradient(135deg, #00ffff, #0088ff);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }
        
        .title-card p {
            color: #888;
            font-size: 14px;
        }
        
        /* Stats Panel */
        .stats-panel {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px 20px;
            backdrop-filter: blur(10px);
            min-width: 250px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 13px;
        }
        
        .stat-label {
            color: #888;
        }
        
        .stat-value {
            color: #00ffff;
            font-weight: bold;
        }
        
        /* Controls Info */
        .controls-panel {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px 20px;
            backdrop-filter: blur(10px);
            max-width: 350px;
        }
        
        .controls-panel h3 {
            color: #00ffff;
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 12px;
            color: #ccc;
        }
        
        .control-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            color: #00ffff;
        }
        
        /* Location Indicator */
        .location-indicator {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px 25px;
            backdrop-filter: blur(10px);
            text-align: center;
            transition: all 0.5s ease;
        }
        
        .location-name {
            font-size: 24px;
            color: #00ffff;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .location-description {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        /* Cinematic Message */
        .cinematic-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 30px 50px;
            font-size: 32px;
            color: #00ffff;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 200;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }
        
        .cinematic-message.visible {
            opacity: 1;
        }
        
        /* Minimap */
        #minimap {
            position: absolute;
            top: 150px;
            right: 30px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #minimap canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Volume/Mute Button */
        #volume-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 28px;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            z-index: 200;
        }
        
        #volume-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        #volume-btn.muted {
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff4444;
        }
        
        /* Combat UI - Health/Stamina/Mana Bars */
        #combat-ui {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(255, 100, 100, 0.6);
            border-radius: 10px;
            padding: 15px 20px;
            min-width: 280px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        
        .resource-bar-container {
            margin: 8px 0;
        }
        
        .resource-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 4px;
            font-weight: bold;
        }
        
        .resource-bar-bg {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }
        
        .resource-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
            position: relative;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        .health-bar {
            background: linear-gradient(90deg, #ff0000, #ff4444);
        }
        
        .stamina-bar {
            background: linear-gradient(90deg, #00ff00, #44ff44);
        }
        
        .mana-bar {
            background: linear-gradient(90deg, #0088ff, #44aaff);
        }
        
        .resource-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            z-index: 1;
        }
        
        /* Damage Indicators */
        .damage-indicator {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1.5s ease-out forwards;
            text-shadow: 2px 2px 4px black;
            z-index: 1000;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1.5);
            }
        }
        
        .damage-physical { color: #ff4444; }
        .damage-critical { color: #ffaa00; font-size: 32px; }
        .heal-indicator { color: #44ff44; }
        .xp-indicator { color: #ffdd00; font-size: 20px; }
        
        /* Inventory UI */
        #inventory-ui {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ffaa00;
            border-radius: 15px;
            padding: 30px;
            min-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 600;
            pointer-events: auto;
        }
        
        #inventory-ui h2 {
            color: #ffaa00;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(10, 50px);
            gap: 5px;
            margin-bottom: 20px;
        }
        
        .inventory-slot {
            width: 50px;
            height: 50px;
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .inventory-slot:hover {
            border-color: #ffaa00;
            transform: scale(1.1);
        }
        
        .inventory-slot.filled {
            background: rgba(100, 100, 100, 0.9);
            border-color: #ffaa00;
        }
        
        .close-inventory {
            width: 100%;
            padding: 10px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }
        
        /* Quest UI */
        #quest-ui {
            display: none;
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffdd00;
            border-radius: 10px;
            padding: 20px;
            min-width: 300px;
            max-width: 400px;
            z-index: 500;
        }
        
        #quest-ui h3 {
            color: #ffdd00;
            margin-bottom: 15px;
        }
        
        .quest-item {
            background: rgba(50, 50, 50, 0.6);
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            border-left: 4px solid #ffdd00;
        }
        
        .quest-objective {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
        
        /* Crafting UI */
        #crafting-ui {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff8800;
            border-radius: 15px;
            padding: 30px;
            min-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 650;
        }
        
        #crafting-ui h2 {
            color: #ff8800;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .recipe-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .recipe-card {
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid #666;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .recipe-card:hover {
            border-color: #ff8800;
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(255, 136, 0, 0.3);
        }
        
        .recipe-card.craftable {
            border-color: #44ff44;
        }
        
        .recipe-card h4 {
            color: #ff8800;
            margin-bottom: 10px;
        }
        
        .materials-list {
            font-size: 12px;
            color: #aaa;
        }
        
        .craft-btn {
            width: 100%;
            padding: 10px;
            background: #44ff44;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
        }
        
        .craft-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        /* Level Progression UI */
        #level-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffdd00;
            border-radius: 10px;
            padding: 15px;
            min-width: 250px;
            z-index: 500;
        }
        
        .level-display {
            color: #ffdd00;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .xp-bar-container {
            background: rgba(50, 50, 50, 0.8);
            border-radius: 10px;
            height: 25px;
            position: relative;
            overflow: hidden;
            border: 2px solid #666;
        }
        
        .xp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffdd00, #ffaa00);
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(255, 221, 0, 0.5);
        }
        
        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        
        .level-up-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ffdd00, #ff8800);
            border: 4px solid #ffff00;
            border-radius: 20px;
            padding: 40px 60px;
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px black;
            z-index: 1000;
            display: none;
            animation: levelUpPulse 0.5s ease-in-out;
            box-shadow: 0 0 50px rgba(255, 221, 0, 0.8);
        }
        
        @keyframes levelUpPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
        
        .stats-display {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-logo">SKYRELICS</div>
        <div class="loading-bar">
            <div class="loading-bar-fill" id="loading-bar-fill"></div>
        </div>
        <div class="loading-text" id="loading-text">Initializing world...</div>
    </div>
    
    <!-- Canvas Container -->
    <div id="canvas-container"></div>
    
    <!-- HUD -->
    <div id="hud">
        <!-- Volume/Mute Button -->
        <div id="volume-btn" onclick="toggleSound()" title="Toggle Sound (M key)">
            <span id="volume-icon">🔊</span>
        </div>
        
        <!-- Title Card -->
        <div class="title-card">
            <h1>SKYRELICS</h1>
            <p>Complete World Demo</p>
        </div>
        
        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stat-row">
                <span class="stat-label">Objects:</span>
                <span class="stat-value" id="stat-objects">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Triangles:</span>
                <span class="stat-value" id="stat-triangles">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Draw Calls:</span>
                <span class="stat-value" id="stat-drawcalls">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">FPS:</span>
                <span class="stat-value" id="stat-fps">60</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Position:</span>
                <span class="stat-value" id="stat-position">0, 0, 0</span>
            </div>
        </div>
        
        <!-- Controls -->
        <div class="controls-panel">
            <h3>🎮 CONTROLS</h3>
            <div class="control-item">
                <span>Move Camera</span>
                <span class="control-key">WASD</span>
            </div>
            <div class="control-item">
                <span>Look Around</span>
                <span class="control-key">MOUSE</span>
            </div>
            <div class="control-item">
                <span>Ascend</span>
                <span class="control-key">SPACE / CTRL+E</span>
            </div>
            <div class="control-item">
                <span>Descend</span>
                <span class="control-key">F</span>
            </div>
            <div class="control-item">
                <span>Sprint</span>
                <span class="control-key">HOLD SHIFT</span>
            </div>
            <div class="control-item">
                <span>Cinematic Tour</span>
                <span class="control-key">C</span>
            </div>
            <div class="control-item">
                <span>Toggle Stats</span>
                <span class="control-key">T</span>
            </div>
            <div class="control-item">
                <span>Toggle Sound</span>
                <span class="control-key">M</span>
            </div>
            <div class="control-item">
                <span>3rd Person View</span>
                <span class="control-key">V</span>
            </div>
            <div class="control-item" style="margin-top: 10px; border-top: 1px solid rgba(0,255,255,0.3); padding-top: 10px;">
                <span>🔥 Fireball</span>
                <span class="control-key">1</span>
            </div>
            <div class="control-item">
                <span>💨 Dash</span>
                <span class="control-key">2</span>
            </div>
            <div class="control-item">
                <span>💚 Heal</span>
                <span class="control-key">3</span>
            </div>
        </div>
        
        <!-- Location Indicator -->
        <div class="location-indicator">
            <div class="location-name" id="location-name">Residential District</div>
            <div class="location-description" id="location-description">Suburban neighborhood</div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimap-canvas" width="200" height="200"></canvas>
        </div>
        
        <!-- Portal Fast Travel Menu -->
        <div id="portalMenu" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); border: 3px solid #4488ff; border-radius: 15px; padding: 30px; min-width: 400px; z-index: 500; pointer-events: auto;">
            <div id="portalList"></div>
            <button onclick="hidePortalMenu()" style="margin-top: 20px; width: 100%; padding: 10px; background: rgba(255, 50, 50, 0.8); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">Close (ESC)</button>
        </div>
        
        <!-- Combat UI - Health/Stamina/Mana -->
        <div id="combat-ui">
            <div class="resource-bar-container">
                <div class="resource-label">
                    <span style="color: #ff4444;">❤️ HEALTH</span>
                    <span id="health-value" style="color: #ff4444;">100/100</span>
                </div>
                <div class="resource-bar-bg">
                    <div class="resource-bar-fill health-bar" id="health-bar" style="width: 100%;"></div>
                </div>
            </div>
            
            <div class="resource-bar-container">
                <div class="resource-label">
                    <span style="color: #44ff44;">⚡ STAMINA</span>
                    <span id="stamina-value" style="color: #44ff44;">100/100</span>
                </div>
                <div class="resource-bar-bg">
                    <div class="resource-bar-fill stamina-bar" id="stamina-bar" style="width: 100%;"></div>
                </div>
            </div>
            
            <div class="resource-bar-container">
                <div class="resource-label">
                    <span style="color: #44aaff;">✨ MANA</span>
                    <span id="mana-value" style="color: #44aaff;">100/100</span>
                </div>
                <div class="resource-bar-bg">
                    <div class="resource-bar-fill mana-bar" id="mana-bar" style="width: 100%;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Inventory UI -->
    <div id="inventory-ui">
        <h2>🎒 Inventory</h2>
        <div class="inventory-grid" id="inventory-grid"></div>
        <button class="open onclick="toggleInventory()">Close (Press I)</button>
    </div>
    
    <!-- Quest UI -->
    <div id="quest-ui">
        <h3>📜 Active Quests</h3>
        <div id="quest-list"></div>
    </div>
    
    <!-- Crafting UI -->
    <div id="crafting-ui">
        <h2>🔨 Crafting Station</h2>
        <div class="recipe-grid" id="recipe-grid"></div>
        <button class="close-inventory" onclick="toggleCrafting()">Close (Press C)</button>
    </div>
    
    <!-- Level Progression UI -->
    <div id="level-ui">
        <div class="level-display">Level <span id="player-level">1</span></div>
        <div class="xp-bar-container">
            <div class="xp-bar-fill" id="xp-bar" style="width: 0%;"></div>
            <div class="xp-text" id="xp-text">0 / 100 XP</div>
        </div>
        <div class="stats-display" id="stats-display">
            ⚔️ Attack: <span id="stat-attack">10</span> | 🛡️ Defense: <span id="stat-defense">5</span>
        </div>
    </div>
    
    <!-- Level Up Notification -->
    <div id="level-up-notification" class="level-up-notification">
        🎉 LEVEL UP! 🎉
    </div>
    
    <style>
        .portal-btn {
            width: 100%;
            padding: 15px;
            margin: 8px 0;
            background: linear-gradient(135deg, rgba(68, 136, 255, 0.3), rgba(136, 68, 255, 0.3));
            border: 2px solid #4488ff;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }
        
        .portal-btn:hover {
            background: linear-gradient(135deg, rgba(68, 136, 255, 0.6), rgba(136, 68, 255, 0.6));
            transform: translateX(5px);
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.5);
        }
    </style>
    
    <!-- Game Systems (loaded before Three.js module) -->
    <script src="./world_generation/combat_system.js"></script>
    <script src="./world_system/inventory_manager.js"></script>
    <script src="./world_generation/dialogue_quest_system.js"></script>
    <script src="./world_generation/skills_abilities_system.js"></script>
    <script src="./world_generation/minimap_system.js"></script>
    <script src="./world_generation/save_system.js"></script>
    <script src="./world_generation/crafting_system.js"></script>
    <script src="./world_generation/level_progression_system.js"></script>
    <script src="./vsl_character_generator.js"></script>
    <script src="./enhanced_building_system.js"></script>
    
    <!-- Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
    import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { ColorCorrectionShader } from 'three/addons/shaders/ColorCorrectionShader.js';
    import { Sky } from 'three/addons/objects/Sky.js';
    import { Water } from 'three/addons/objects/Water.js';
    
    // Make THREE globally available for vsl_character_generator.js
    window.THREE = THREE;
    
        // ═══════════════════════════════════════════════════════════════════════
        // GLOBAL ERROR HANDLER (for debugging black screens)
        // ═══════════════════════════════════════════════════════════════════════
        
        window.addEventListener('error', (e) => {
            console.error('❌ GLOBAL ERROR:', e.error);
            // Display error on screen if console not accessible
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:10px;left:10px;background:rgba(255,0,0,0.9);color:white;padding:20px;z-index:999999;font-family:monospace;max-width:80%;border:3px solid white;';
            errorDiv.innerHTML = `<h2>⚠️ JAVASCRIPT ERROR</h2><pre>${e.message}\n${e.filename}:${e.lineno}:${e.colno}\n\n${e.error ? e.error.stack : ''}</pre>`;
            document.body.appendChild(errorDiv);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('❌ UNHANDLED PROMISE REJECTION:', e.reason);
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:10px;left:10px;background:rgba(255,0,0,0.9);color:white;padding:20px;z-index:999999;font-family:monospace;max-width:80%;border:3px solid white;';
            errorDiv.innerHTML = `<h2>⚠️ PROMISE ERROR</h2><pre>${e.reason}</pre>`;
            document.body.appendChild(errorDiv);
        });
        
        // ═══════════════════════════════════════════════════════════════════════
        // GLOBAL STATE
        // ═══════════════════════════════════════════════════════════════════════
        
    let scene, camera, renderer, controls;
    let canvas;
    let clock = new THREE.Clock();
    let composer; // Post-processing composer
    let ssaoPass; // Ambient occlusion pass
    let colorGradePass; // Color grading pass
    let pmremGenerator; // Environment map generator
    
    // VSL Character System
    let vslCharacterGenerator = null;
    
    // Ability Manager (needs to be global for animate function)
    let playerAbilityManager = null;
    
    // Minimap System
    let minimap = null;
    
    // Save System
    let saveManager = null;
    
    // Cinematic Dialogue System (must be global for animate() function)
    let dialogueCinematicActive = false;
    let dialogueCameraSequence = [];
    let dialogueSequenceIndex = 0;
    let dialogueTimer = 0;
    let dialogueNPC = null;
    let originalCameraPos = new THREE.Vector3();
    let originalCameraRot = new THREE.Euler();
        
        // Movement
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let sprint = false;
        let lastFootstep = 0; // Track footstep timing
        
    // Performance monitoring
    let performanceMode = 'auto'; // 'auto', 'high', 'medium', 'low'
    let avgFrameTime = 16.67; // Target 60fps
    let frameTimeSamples = [];
    let performanceWarningShown = false;
    
    // World objects
    const worldObjects = new THREE.Group();
    worldObjects.name = 'WorldObjects';
    const waterMeshes = []; // Track water surfaces for animation
        
        // Cinematic mode
        let cinematicMode = false;
        let cinematicPath = null;
        let cinematicProgress = 0;
        
        // Stats
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
    // Lighting helpers
    let sky;
    const sunPosition = new THREE.Vector3();

    // Keep spawn area clear of NPCs/critters
    const START_SAFE_CENTER = new THREE.Vector3(0, 0, 10); // initial camera (x,z=10)
    const START_SAFE_RADIUS = 80; // units to keep clear around start

    function enforceStartSafeZone(center = START_SAFE_CENTER, radius = START_SAFE_RADIUS) {
        if (!worldObjects) return;
        worldObjects.traverse((obj) => {
            if (!obj || !obj.position) return;
            if (obj === playerCharacter) return;

            // Heuristic: treat as NPC/creature if it has movement/behavior tags or NPC-like name
            const isActor = !!(
                obj.userData?.walkPath ||
                obj.userData?.sitting ||
                obj.userData?.talking ||
                (typeof obj.name === 'string' && obj.name.startsWith('NPC_'))
            );
            if (!isActor) return;

            const dx = obj.position.x - center.x;
            const dz = obj.position.z - center.z;
            const dist = Math.hypot(dx, dz);

            if (dist < radius) {
                // Push actor to just outside the safe radius with a small random buffer
                const dirX = dist === 0 ? 1 : dx / dist;
                const dirZ = dist === 0 ? 0 : dz / dist;
                const target = radius + 5 + Math.random() * 15;
                obj.position.x = center.x + dirX * target;
                obj.position.z = center.z + dirZ * target;
            }
        });
        console.log(`🧹 Start area cleared (radius ${radius})`);
    }
    let sunlight;

    // ═══════════════════════════════════════════════════════════════════════
    // AUDIO SYSTEM
    // ═══════════════════════════════════════════════════════════════════════
    const audioListener = new THREE.AudioListener();
    const sounds = {
        ambient: null,
        footsteps: null,
        water: null,
        wind: null,
        birds: null,
        conversations: []
    };
    let audioContext = null;
    let soundEnabled = true;

    function initAudioSystem() {
        // Add listener to camera
        if (camera) {
            camera.add(audioListener);
        }

        // Create AudioContext for procedural sounds
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Create ambient sounds
        sounds.wind = createWindSound();
        sounds.birds = createBirdSound();
        sounds.water = createWaterSound();
        
        console.log('🔊 Audio system initialized');
    }

    // Procedural wind sound
    function createWindSound() {
        const sound = new THREE.Audio(audioListener);
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(300, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.start();
        
        // Gentle wind variation
        setInterval(() => {
            const freq = 70 + Math.random() * 30;
            oscillator.frequency.linearRampToValueAtTime(freq, audioContext.currentTime + 2);
        }, 3000);
        
        return sound;
    }

    // Procedural bird chirps
    function createBirdSound() {
        setInterval(() => {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(2000 + Math.random() * 1000, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.02, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }, 4000 + Math.random() * 6000); // Random bird chirps
        
        return true;
    }

    // Procedural water sound
    function createWaterSound() {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        oscillator.type = 'brown';
        oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(400, audioContext.currentTime);
        filter.Q.setValueAtTime(1, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.03, audioContext.currentTime);
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.start();
        
        return true;
    }

    // Footstep sound (plays when moving)
    function playFootstep() {
        if (!soundEnabled || !audioContext) return;
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(50 + Math.random() * 30, audioContext.currentTime);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
    }

    // NPC conversation sound (robot-like placeholder using Web Speech API)
    function playNPCVoice(npc, text = null) {
        if (!soundEnabled || !('speechSynthesis' in window)) return;
        
        const phrases = [
            "Hello there",
            "Nice weather today",
            "How are you",
            "See you later",
            "Have a good day",
            "Surprise MOTHA FUCKA",
            "Take care"
        ];
        
        const utterance = new SpeechSynthesisUtterance(
            text || phrases[Math.floor(Math.random() * phrases.length)]
        );
        
        utterance.rate = 0.9;
        utterance.pitch = 0.8 + Math.random() * 0.4;
        utterance.volume = 0.3;
        
        // Use robotic voice if available
        const voices = window.speechSynthesis.getVoices();
        const robotVoice = voices.find(v => v.name.includes('Google') || v.name.includes('Microsoft'));
        if (robotVoice) utterance.voice = robotVoice;
        
        // DISABLED - NPCs only talk to each other, not player
        // window.speechSynthesis.speak(utterance);
    }

    // Toggle sound on/off
    function toggleSound() {
        soundEnabled = !soundEnabled;
        
        // Update button appearance
        const volumeBtn = document.getElementById('volume-btn');
        const volumeIcon = document.getElementById('volume-icon');
        
        if (soundEnabled) {
            volumeBtn.classList.remove('muted');
            volumeIcon.textContent = '🔊';
            console.log('🔊 Sound ON');
        } else {
            volumeBtn.classList.add('muted');
            volumeIcon.textContent = '🔇';
            console.log('🔇 Sound OFF');
            
            // Stop any ongoing speech
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
            }
        }
    }

    // Global metadata registry for descriptive object breakdowns
    const worldObjectCatalog = [];

    function annotateObject(object, metadata = {}) {
        const info = {
            id: metadata.id || object.name || `object_${worldObjectCatalog.length + 1}`,
            name: metadata.name || object.name || 'Unnamed Object',
            type: metadata.type || 'general',
            category: metadata.category || 'uncategorized',
            description: metadata.description || '',
            dimensions: metadata.dimensions || null,
            materials: metadata.materials || [],
            animations: metadata.animations || [],
            rendering: metadata.rendering || {},
            tags: metadata.tags || [],
            uuid: object.uuid
        };

        object.userData.metadata = info;
        object.userData.renderingProfile = info.rendering;
        object.name = info.name;
        worldObjectCatalog.push(info);
    }

    function applyHighDetail(object, options = {}) {
        const multiplier = options.multiplier ?? 2;
        const targetTypes = options.targetTypes || new Set([
            'BoxGeometry',
            'PlaneGeometry',
            'CylinderGeometry',
            'ConeGeometry',
            'SphereGeometry',
            'CircleGeometry',
            'TorusGeometry'
        ]);

        object.traverse(child => {
            if (!child.isMesh) return;
            if (child.userData.detailUpgraded) return;

            const geometry = child.geometry;
            if (!geometry || !geometry.parameters || !targetTypes.has(geometry.type)) return;

            const params = geometry.parameters;
            let upgraded = null;

            switch (geometry.type) {
                case 'BoxGeometry':
                    upgraded = new THREE.BoxGeometry(
                        params.width,
                        params.height,
                        params.depth,
                        Math.max(4, (params.widthSegments || 1) * multiplier),
                        Math.max(4, (params.heightSegments || 1) * multiplier),
                        Math.max(4, (params.depthSegments || 1) * multiplier)
                    );
                    break;
                case 'PlaneGeometry':
                    upgraded = new THREE.PlaneGeometry(
                        params.width,
                        params.height,
                        Math.max(4, (params.widthSegments || 1) * multiplier),
                        Math.max(4, (params.heightSegments || 1) * multiplier)
                    );
                    break;
                case 'CylinderGeometry':
                    upgraded = new THREE.CylinderGeometry(
                        params.radiusTop,
                        params.radiusBottom,
                        params.height,
                        Math.max(16, (params.radialSegments || 8) * multiplier),
                        Math.max(4, (params.heightSegments || 1) * multiplier),
                        params.openEnded ?? false,
                        params.thetaStart ?? 0,
                        params.thetaLength ?? Math.PI * 2
                    );
                    break;
                        upgraded = new THREE.CylinderGeometry(
                            params.radiusTop,
                            params.radiusBottom,
                            params.height,
                            Math.max(18, (params.radialSegments || 8) * multiplier),
                            Math.max(4, (params.heightSegments || 1) * multiplier),
                            params.openEnded ?? false,
                            params.thetaStart ?? 0,
                            params.thetaLength ?? Math.PI * 2
                        );
                    break;
                case 'SphereGeometry':
                    upgraded = new THREE.SphereGeometry(
                        params.radius,
                        Math.max(32, (params.widthSegments || 16) * multiplier),
                        Math.max(24, (params.heightSegments || 12) * multiplier),
                        params.phiStart ?? 0,
                        params.phiLength ?? Math.PI * 2,
                        params.thetaStart ?? 0,
                        params.thetaLength ?? Math.PI
                    );
                    break;
                        upgraded = new THREE.SphereGeometry(
                            params.radius,
                            Math.max(18, (params.widthSegments || 16) * multiplier),
                            Math.max(14, (params.heightSegments || 12) * multiplier),
                            params.phiStart ?? 0,
                            params.phiLength ?? Math.PI * 2,
                            params.thetaStart ?? 0,
                            params.thetaLength ?? Math.PI
                        );
                    upgraded = new THREE.TorusGeometry(
                        params.radius,
                        params.tube,
                        Math.max(24, (params.radialSegments || 12) * multiplier),
                        Math.max(48, (params.tubularSegments || 24) * multiplier),
                        params.arc ?? Math.PI * 2
                    );
                    break;
                default:
                    break;
            }

            if (upgraded) {
                upgraded.computeVertexNormals();
                child.geometry.dispose();
                child.geometry = upgraded;
                child.userData.detailUpgraded = true;
            }
        });
    }

    // Assets
    let waterNormalTexture;

    // Loading
    let loadingProgress = 0;
    const loadingSteps = [
            'Initializing renderer...',
            'Creating terrain...',
            'Building neighborhood...',
            'Constructing college...',
            'Planting forest...',
            'Filling lake...',
            'Raising mountains...',
            'Generating ocean...',
            'Adding wildlife & NPCs...',
            'Finalizing world...'
        ];

    // ═══════════════════════════════════════════════════════════════════════
    // SKY AND ENVIRONMENT SETUP
    // ═══════════════════════════════════════════════════════════════════════
    
    function setupSkyAndEnvironment() {
        // Create Sky
        sky = new Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);

        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 10;
        skyUniforms['rayleigh'].value = 2;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.8;

        // Sun position
        const phi = THREE.MathUtils.degToRad(88);
        const theta = THREE.MathUtils.degToRad(180);
        sunPosition.setFromSphericalCoords(1, phi, theta);
        skyUniforms['sunPosition'].value.copy(sunPosition);

        // Generate environment map from sky
        const renderTarget = pmremGenerator.fromScene(sky);
        scene.environment = renderTarget.texture;
        scene.background = renderTarget.texture;

        console.log('✅ Sky and environment setup complete');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TEXTURE PRELOADING
    // ═══════════════════════════════════════════════════════════════════════
    
    async function preloadTextures() {
        return new Promise((resolve) => {
            // For now, we're using procedural textures (canvas-based)
            // If we add external texture files, load them here with TextureLoader
            
            // Example placeholder for future water normal texture:
            // const loader = new THREE.TextureLoader();
            // waterNormalTexture = await loader.loadAsync('path/to/waternormals.jpg');
            
            console.log('✅ Textures preloaded (procedural textures in use)');
            resolve();
        });
    }
        
        // ═══════════════════════════════════════════════════════════════════════
        // PLAYER CHARACTER (3rd Person Body)
        // ═══════════════════════════════════════════════════════════════════════
        
        let playerCharacter = null;
        let thirdPersonMode = false;
        
        // NOTE: createPlayerCharacter() moved to line ~6935 (right before initVSLCharacters)
        // to fix scoping issues. This ensures the function is defined before being called.
        
        // Toggle between 1st and 3rd person
        function togglePersonMode() {
            thirdPersonMode = !thirdPersonMode;
            playerCharacter.visible = thirdPersonMode;
            
            if (thirdPersonMode) {
                // 3rd person camera offset
                console.log('📷 Third Person Mode');
            } else {
                console.log('📷 First Person Mode');
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════════
        
        async function init() {
            console.log('🌍 SkyRelics World Loading...');
            console.time('init');
            
            // Setup renderer
            updateLoading(10, loadingSteps[0]);
            canvas = document.createElement('canvas');
            document.getElementById('canvas-container').appendChild(canvas);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                powerPreference: 'high-performance',
                alpha: false,
                stencil: false,
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Better quality on high-DPI displays
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // UPGRADED: Softer, more realistic shadows
            renderer.shadowMap.autoUpdate = true; // Enable for better scene quality
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5; // BRIGHTER: Enhanced exposure for vibrant colors
            renderer.outputEncoding = THREE.sRGBEncoding;
            if (renderer.outputColorSpace !== undefined) {
                renderer.outputColorSpace = THREE.SRGBColorSpace;
            }
            console.timeLog('init', 'Renderer configured');
            
            // Enable physically correct lighting
            renderer.physicallyCorrectLights = true;
            
            // Scene
            scene = new THREE.Scene();
            console.timeLog('init', 'Scene created');

            // Environment and sky
            pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            setupSkyAndEnvironment();
            console.timeLog('init', 'Sky/environment ready');
            
            // Preload shared textures
            updateLoading(15, 'Loading high fidelity textures...');
            await preloadTextures();
            console.timeLog('init', 'Textures preloaded');
            
            // Camera (initialize BEFORE setting up resize listener)
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                2000
            );
            camera.position.set(0, 5, 10);
            console.timeLog('init', 'Camera ready');

            // Setup window resize handler (now that camera exists)
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            console.timeLog('init', 'Resize handler attached');
            
            // Setup Post-Processing
            composer = new EffectComposer(renderer);
            
            // Render pass (base scene)
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Screen-space ambient occlusion for contact shading
            ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
            ssaoPass.kernelRadius = 18;
            ssaoPass.minDistance = 0.002;
            ssaoPass.maxDistance = 0.12;
            composer.addPass(ssaoPass);
            
            // Bloom pass (glow on lights)
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.55,   // strength
                0.45,   // radius
                0.82    // threshold
            );
            composer.addPass(bloomPass);

            // Color grading / tone balancing
            colorGradePass = new ShaderPass(ColorCorrectionShader);
            colorGradePass.uniforms['powRGB'].value.set(1.15, 1.08, 1.05);
            colorGradePass.uniforms['mulRGB'].value.set(1.08, 1.05, 1.12);
            colorGradePass.uniforms['addRGB'].value.set(0.015, 0.01, 0.0);
            composer.addPass(colorGradePass);
            
            // Anti-aliasing pass
            const smaaPass = new SMAAPass(
                window.innerWidth * renderer.getPixelRatio(),
                window.innerHeight * renderer.getPixelRatio()
            );
            composer.addPass(smaaPass);
            console.timeLog('init', 'Post-processing pipeline ready');
            
            // Controls (First Person)
            controls = new PointerLockControls(camera, canvas);
            
            canvas.addEventListener('click', () => {
                if (!cinematicMode) {
                    controls.lock();
                }
            });
            
            controls.addEventListener('lock', () => {
                console.log('🎮 Controls locked');
            });
            
            controls.addEventListener('unlock', () => {
                console.log('🎮 Controls unlocked');
            });
            
            scene.add(controls.getObject());
            console.timeLog('init', 'PointerLock controls ready');
            
            // ═══════════════════════════════════════════════════════════════════════
            // SKILLS & ABILITIES SYSTEM
            // ═══════════════════════════════════════════════════════════════════════
            
            // playerAbilityManager already declared globally
            let playerSkills = null;
            let playerCombatStats = null;
            let playerInventory = null;
            let playerQuestManager = null;
            let inventoryOpen = false;
            let questUIOpen = false;
            let playerCraftingManager = null;
            let craftingOpen = false;
            let playerXPManager = null;
            let playerLevel = 1;
            
            // NOTE: Cinematic Dialogue System variables moved to global scope (line ~906)
            
            // Initialize Combat Stats
            function initializeCombatStats() {
                if (typeof CombatStats !== 'undefined') {
                    playerCombatStats = new CombatStats({
                        maxHealth: 100,
                        health: 100,
                        maxStamina: 100,
                        stamina: 100,
                        maxMana: 100,
                        mana: 100,
                        healthRegen: 2,
                        staminaRegen: 15,
                        manaRegen: 8
                    });
                    
                    console.log('💪 Combat Stats System Initialized!');
                    
                    // Start regeneration
                    setInterval(() => {
                        if (playerCombatStats && !playerCombatStats.isDead) {
                            playerCombatStats.regenerate(0.1); // 100ms intervals
                            updateCombatUI();
                        }
                    }, 100);
                } else {
                    console.warn('⚠️ CombatStats not loaded');
                }
            }
            
            // Update Combat UI bars
            function updateCombatUI() {
                if (!playerCombatStats) return;
                
                const healthPercent = (playerCombatStats.health / playerCombatStats.maxHealth) * 100;
                const staminaPercent = (playerCombatStats.stamina / playerCombatStats.maxStamina) * 100;
                const manaPercent = (playerCombatStats.mana / playerCombatStats.maxMana) * 100;
                
                document.getElementById('health-bar').style.width = healthPercent + '%';
                document.getElementById('stamina-bar').style.width = staminaPercent + '%';
                document.getElementById('mana-bar').style.width = manaPercent + '%';
                
                document.getElementById('health-value').textContent = 
                    Math.ceil(playerCombatStats.health) + '/' + playerCombatStats.maxHealth;
                document.getElementById('stamina-value').textContent = 
                    Math.ceil(playerCombatStats.stamina) + '/' + playerCombatStats.maxStamina;
                document.getElementById('mana-value').textContent = 
                    Math.ceil(playerCombatStats.mana) + '/' + playerCombatStats.maxMana;
            }
            
            // Spawn damage indicator
            function showDamageIndicator(amount, type = 'physical', position = null) {
                const indicator = document.createElement('div');
                indicator.className = 'damage-indicator';
                
                if (type === 'critical') {
                    indicator.classList.add('damage-critical');
                    indicator.textContent = '⚡ ' + Math.ceil(amount) + ' ⚡';
                } else if (type === 'heal') {
                    indicator.classList.add('heal-indicator');
                    indicator.textContent = '+' + Math.ceil(amount);
                } else if (type === 'xp') {
                    indicator.classList.add('xp-indicator');
                    indicator.textContent = '+' + Math.ceil(amount) + ' XP ⭐';
                } else {
                    indicator.classList.add('damage-physical');
                    indicator.textContent = '-' + Math.ceil(amount);
                }
                
                // Position at center of screen or specific position
                if (position) {
                    indicator.style.left = position.x + 'px';
                    indicator.style.top = position.y + 'px';
                } else {
                    indicator.style.left = '50%';
                    indicator.style.top = '50%';
                    indicator.style.transform = 'translate(-50%, -50%)';
                }
                
                document.body.appendChild(indicator);
                
                // Remove after animation
                setTimeout(() => {
                    indicator.remove();
                }, 1500);
            }
            
            function initializeSkillsSystem() {
                // Create ability manager (from imported system)
                if (typeof AbilityManager !== 'undefined') {
                    // Create a player data object for AbilityManager
                    const playerData = {
                        get mana() { return playerCombatStats ? playerCombatStats.mana : 100; },
                        set mana(val) { if (playerCombatStats) playerCombatStats.mana = val; },
                        get health() { return playerCombatStats ? playerCombatStats.health : 100; },
                        set health(val) { if (playerCombatStats) playerCombatStats.health = val; },
                        level: playerLevel || 1
                    };
                    
                    playerAbilityManager = new AbilityManager(playerData);
                    
                    // The AbilityManager already has abilities from SkillTree
                    // We need to unlock some default abilities and add them to hotbar
                    
                    // Unlock and setup basic magic abilities that exist in SkillTree
                    if (playerAbilityManager.skillTree.getAbility('fireball')) {
                        // Give skill points to unlock abilities
                        playerAbilityManager.awardSkillPoints(10);
                        
                        // Unlock fireball (from magic branch)
                        const fireballAbility = playerAbilityManager.skillTree.getAbility('fireball');
                        if (fireballAbility) {
                            fireballAbility.unlocked = true;
                            // Override the onActivate to use our visual effects
                            fireballAbility.onActivate = (player, target, ability) => {
                                console.log('🔥 FIREBALL!');
                                createFireballEffect();
                                showDamageIndicator(ability.damage || 50, 'physical');
                                updateCombatUI();
                            };
                            // Only assign to hotbar if the method exists
                            if (playerAbilityManager.hotbar && typeof playerAbilityManager.hotbar.assignSlot === 'function') {
                                playerAbilityManager.hotbar.assignSlot(0, 'fireball');
                            }
                            console.log('🔥 Fireball unlocked (Press 1)');
                        }
                    }
                    
                    // Unlock dash (from utility branch)
                    const dashAbility = playerAbilityManager.skillTree.getAbility('dash');
                    if (dashAbility) {
                        dashAbility.unlocked = true;
                        // Override the onActivate to apply speed boost
                        dashAbility.onActivate = (player, target, ability) => {
                            console.log('💨 DASH!');
                            // Apply speed boost
                            velocity.x *= 3;
                            velocity.z *= 3;
                            updateCombatUI();
                        };
                        // Only assign to hotbar if the method exists
                        if (playerAbilityManager.hotbar && typeof playerAbilityManager.hotbar.assignSlot === 'function') {
                            playerAbilityManager.hotbar.assignSlot(1, 'dash');
                        }
                        console.log('💨 Dash unlocked (Press 2)');
                    }
                    
                    // Unlock heal (from utility branch) 
                    const healAbility = playerAbilityManager.skillTree.getAbility('heal');
                    if (healAbility) {
                        healAbility.unlocked = true;
                        // Override the onActivate to use our heal effect
                        healAbility.onActivate = (player, target, ability) => {
                            if (playerCombatStats) {
                                const healAmount = ability.healing || 30;
                                playerCombatStats.heal(healAmount);
                                console.log('💚 HEAL!');
                                createHealEffect();
                                showDamageIndicator(healAmount, 'heal');
                                updateCombatUI();
                            }
                        };
                        // Only assign to hotbar if the method exists
                        if (playerAbilityManager.hotbar && typeof playerAbilityManager.hotbar.assignSlot === 'function') {
                            playerAbilityManager.hotbar.assignSlot(2, 'heal');
                        }
                        console.log('💚 Heal unlocked (Press 3)');
                    }
                    
                    console.log('⚡ Skills & Abilities System Loaded!');
                    console.log('   Press 1: Fireball 🔥');
                    console.log('   Press 2: Dash 💨');
                    console.log('   Press 3: Heal 💚');
                }
            }
            
            function createFireballEffect() {
                // Sword swing animation
                if (playerCharacter && playerCharacter.userData.bodyParts.sword) {
                    const sword = playerCharacter.userData.bodyParts.sword;
                    const originalRotation = { x: sword.rotation.x, z: sword.rotation.z };
                    
                    // Quick slash animation
                    let slashTime = 0;
                    const slashDuration = 0.3;
                    const animateSlash = () => {
                        slashTime += 0.016;
                        if (slashTime < slashDuration) {
                            const progress = slashTime / slashDuration;
                            sword.rotation.x = originalRotation.x - Math.sin(progress * Math.PI) * 1.5;
                            sword.rotation.z = originalRotation.z - Math.sin(progress * Math.PI) * 0.5;
                            requestAnimationFrame(animateSlash);
                        } else {
                            sword.rotation.x = originalRotation.x;
                            sword.rotation.z = originalRotation.z;
                        }
                    };
                    animateSlash();
                }
                
                const fireballGeo = new THREE.SphereGeometry(0.3, 16, 16);
                const fireballMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff4400,
                    emissive: 0xff4400,
                    transparent: true,
                    opacity: 0.8
                });
                const fireball = new THREE.Mesh(fireballGeo, fireballMat);
                
                // Position in front of player
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                fireball.position.copy(camera.position);
                fireball.position.add(direction.multiplyScalar(2));
                
                scene.add(fireball);
                
                // Animate fireball
                const fireballSpeed = 20;
                let fireballLife = 0;
                const maxLife = 3; // 3 seconds
                
                const animateFireball = () => {
                    fireballLife += clock.getDelta();
                    
                    if (fireballLife > maxLife) {
                        scene.remove(fireball);
                        return;
                    }
                    
                    // Move forward
                    fireball.position.add(direction.clone().multiplyScalar(fireballSpeed * 0.016));
                    
                    // Pulse effect
                    fireball.scale.setScalar(1 + Math.sin(fireballLife * 10) * 0.2);
                    
                    requestAnimationFrame(animateFireball);
                };
                
                animateFireball();
            }
            
            function createHealEffect() {
                // Green healing particles around player
                const particleCount = 20;
                const particles = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const particleGeo = new THREE.SphereGeometry(0.1, 8, 8);
                    const particleMat = new THREE.MeshBasicMaterial({ 
                        color: 0x00ff88,
                        transparent: true,
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(particleGeo, particleMat);
                    
                    particle.position.copy(camera.position);
                    particle.position.x += (Math.random() - 0.5) * 2;
                    particle.position.y += Math.random() * 2;
                    particle.position.z += (Math.random() - 0.5) * 2;
                    
                    scene.add(particle);
                    particles.push({ mesh: particle, velocity: Math.random() * 2 + 1 });
                }
                
                // Animate particles rising
                let particleLife = 0;
                const animateHeal = () => {
                    particleLife += 0.016;
                    
                    if (particleLife > 1.5) {
                        particles.forEach(p => scene.remove(p.mesh));
                        return;
                    }
                    
                    particles.forEach(p => {
                        p.mesh.position.y += p.velocity * 0.016;
                        p.mesh.material.opacity = 1 - (particleLife / 1.5);
                    });
                    
                    requestAnimationFrame(animateHeal);
                };
                
                animateHeal();
            }
            
            // Initialize Inventory System
            function initializeInventory() {
                if (typeof InventoryManager !== 'undefined') {
                    playerInventory = new InventoryManager(100); // 100 slots
                    console.log('🎒 Inventory System Initialized!');
                    
                    // Add starting items
                    playerInventory.addItem({ id: 'iron_sword', name: 'Iron Sword', type: 'weapon', damage: 15, icon: '⚔️' });
                    playerInventory.addItem({ id: 'leather_armor', name: 'Leather Armor', type: 'armor', defense: 10, icon: '🛡️' });
                    playerInventory.addItem({ id: 'health_potion', name: 'Health Potion', type: 'consumable', healing: 30, icon: '🧪', stackable: true, quantity: 5 });
                    playerInventory.addItem({ id: 'bread', name: 'Bread', type: 'food', healing: 10, icon: '🍞', stackable: true, quantity: 10 });
                    
                    updateInventoryUI();
                }
            }
            
            // Toggle Inventory UI
            function toggleInventory() {
                inventoryOpen = !inventoryOpen;
                const ui = document.getElementById('inventory-ui');
                ui.style.display = inventoryOpen ? 'block' : 'none';
                if (inventoryOpen) updateInventoryUI();
            }
            window.toggleInventory = toggleInventory;
            
            // Update Inventory UI
            function updateInventoryUI() {
                if (!playerInventory) return;
                const grid = document.getElementById('inventory-grid');
                grid.innerHTML = '';
                
                // Safety check: ensure inventory array exists
                if (!playerInventory.inventory || !Array.isArray(playerInventory.inventory)) {
                    console.warn('⚠️ Inventory not initialized properly');
                    return;
                }
                
                for (let i = 0; i < 100; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot';
                    const item = playerInventory.inventory[i];
                    
                    if (item && item.id) {
                        slot.classList.add('filled');
                        slot.innerHTML = `${item.icon || '📦'}<br><small>${item.quantity > 1 ? item.quantity : ''}</small>`;
                        slot.title = `${item.name}\n${item.type}`;
                    }
                    
                    grid.appendChild(slot);
                }
            }
            
            // Initialize Quest System
            function initializeQuestSystem() {
                if (typeof QuestManager !== 'undefined') {
                    playerQuestManager = new QuestManager();
                    console.log('📜 Quest System Initialized!');
                    
                    // Add starter quest
                    const quest = new Quest(
                        'welcome_quest',
                        'Welcome to SkyRelics',
                        'Explore the world and discover its secrets',
                        {
                            explore_neighborhood: { description: 'Visit the neighborhood', completed: false },
                            visit_college: { description: 'Find Bakersfield College', completed: false },
                            discover_portal: { description: 'Use a fast travel portal', completed: false }
                        },
                        { xp: 100, gold: 50 }
                    );
                    playerQuestManager.addQuest(quest);
                    updateQuestUI();
                }
            }
            
            // Toggle Quest UI
            function toggleQuestUI() {
                questUIOpen = !questUIOpen;
                const ui = document.getElementById('quest-ui');
                ui.style.display = questUIOpen ? 'block' : 'none';
            }
            window.toggleQuestUI = toggleQuestUI;
            
            // Update Quest UI
            function updateQuestUI() {
                if (!playerQuestManager) return;
                const list = document.getElementById('quest-list');
                list.innerHTML = '';
                
                const activeQuests = playerQuestManager.getActiveQuests();
                activeQuests.forEach(quest => {
                    const div = document.createElement('div');
                    div.className = 'quest-item';
                    let objectives = '';
                    Object.entries(quest.objectives).forEach(([key, obj]) => {
                        objectives += `<div class="quest-objective">${obj.completed ? '✅' : '⬜'} ${obj.description}</div>`;
                    });
                    div.innerHTML = `<strong>${quest.title}</strong><br>${quest.description}${objectives}`;
                    list.appendChild(div);
                });
                
                if (activeQuests.length === 0) {
                    list.innerHTML = '<p style="color: #888;">No active quests</p>';
                }
            }
            
            // Initialize Crafting System
            function initializeCraftingSystem() {
                if (typeof CraftingManager !== 'undefined') {
                    playerCraftingManager = new CraftingManager();
                    console.log('🔨 Crafting System Initialized!');
                    
                    // Add basic recipes
                    playerCraftingManager.addRecipe(new CraftingRecipe({
                        id: 'wooden_sword',
                        name: 'Wooden Sword',
                        icon: '🗡️',
                        category: 'weapon',
                        materials: [{ id: 'wood', amount: 3 }],
                        requiredLevel: 1,
                        craftTime: 2,
                        experience: 15
                    }));
                    
                    playerCraftingManager.addRecipe(new CraftingRecipe({
                        id: 'health_potion',
                        name: 'Health Potion',
                        icon: '🧪',
                        category: 'potion',
                        materials: [{ id: 'herbs', amount: 2 }, { id: 'water', amount: 1 }],
                        requiredLevel: 1,
                        craftTime: 1.5,
                        experience: 10
                    }));
                    
                    playerCraftingManager.addRecipe(new CraftingRecipe({
                        id: 'iron_sword',
                        name: 'Iron Sword',
                        icon: '⚔️',
                        category: 'weapon',
                        materials: [{ id: 'iron', amount: 5 }, { id: 'wood', amount: 2 }],
                        requiredLevel: 3,
                        craftTime: 3,
                        experience: 25
                    }));
                    
                    // Add crafting materials to inventory
                    if (playerInventory) {
                        playerInventory.addItem({ id: 'wood', name: 'Wood', type: 'material', icon: '🪵', stackable: true, quantity: 20 });
                        playerInventory.addItem({ id: 'iron', name: 'Iron Ore', type: 'material', icon: '⛏️', stackable: true, quantity: 10 });
                        playerInventory.addItem({ id: 'herbs', name: 'Herbs', type: 'material', icon: '🌿', stackable: true, quantity: 15 });
                        playerInventory.addItem({ id: 'water', name: 'Water', type: 'material', icon: '💧', stackable: true, quantity: 10 });
                    }
                }
            }
            
            // Toggle Crafting UI
            function toggleCrafting() {
                craftingOpen = !craftingOpen;
                const ui = document.getElementById('crafting-ui');
                ui.style.display = craftingOpen ? 'block' : 'none';
                if (craftingOpen) updateCraftingUI();
            }
            window.toggleCrafting = toggleCrafting;
            
            // Update Crafting UI
            function updateCraftingUI() {
                if (!playerCraftingManager || !playerInventory) return;
                const grid = document.getElementById('recipe-grid');
                grid.innerHTML = '';
                
                playerCraftingManager.recipes.forEach(recipe => {
                    const card = document.createElement('div');
                    card.className = 'recipe-card';
                    
                    // Check if craftable
                    const canCraft = recipe.canCraft(playerInventory.inventory, 1, 'none');
                    if (canCraft) card.classList.add('craftable');
                    
                    let materialsHTML = '<div class="materials-list">Requires:<br>';
                    recipe.materials.forEach(mat => {
                        const hasAmount = playerInventory.getItemCount(mat.id);
                        const color = hasAmount >= mat.amount ? '#44ff44' : '#ff4444';
                        materialsHTML += `<span style="color: ${color};">${mat.id}: ${hasAmount}/${mat.amount}</span><br>`;
                    });
                    materialsHTML += '</div>';
                    
                    card.innerHTML = `
                        <h4>${recipe.icon} ${recipe.name}</h4>
                        ${materialsHTML}
                        <button class="craft-btn" ${!canCraft ? 'disabled' : ''} onclick="craftItem('${recipe.id}')">
                            ${canCraft ? 'Craft' : 'Cannot Craft'}
                        </button>
                    `;
                    
                    grid.appendChild(card);
                });
            }
            
            // Craft Item
            function craftItem(recipeId) {
                if (!playerCraftingManager || !playerInventory) return;
                
                const recipe = playerCraftingManager.recipes.find(r => r.id === recipeId);
                if (!recipe) return;
                
                // Remove materials
                recipe.materials.forEach(mat => {
                    for (let i = 0; i < mat.amount; i++) {
                        playerInventory.removeItem(mat.id);
                    }
                });
                
                // Add crafted item
                playerInventory.addItem({
                    id: recipe.output.id || recipe.id,
                    name: recipe.name,
                    type: recipe.category,
                    icon: recipe.icon
                });
                
                // Award XP for crafting
                if (playerXPManager && recipe.experience) {
                    addXP(recipe.experience, 'crafting');
                }
                
                console.log(`✅ Crafted ${recipe.name}!`);
                updateCraftingUI();
                updateInventoryUI();
            }
            window.craftItem = craftItem;
            
            // Initialize Level Progression System
            function initializeLevelProgression() {
                if (typeof XPManager !== 'undefined') {
                    playerXPManager = new XPManager(1); // Start at level 1
                    console.log('📊 Level Progression System Initialized!');
                    
                    // Listen for level up events
                    playerXPManager.onLevelUp = (newLevel) => {
                        playerLevel = newLevel;
                        showLevelUpNotification(newLevel);
                        
                        // Increase stats on level up
                        if (playerCombatStats) {
                            playerCombatStats.maxHealth += 10;
                            playerCombatStats.health = playerCombatStats.maxHealth;
                            playerCombatStats.maxMana += 5;
                            playerCombatStats.mana = playerCombatStats.maxMana;
                            playerCombatStats.maxStamina += 5;
                            playerCombatStats.stamina = playerCombatStats.maxStamina;
                            updateCombatUI();
                        }
                        
                        updateLevelUI();
                        console.log(`🎉 LEVEL UP! Now level ${newLevel}!`);
                    };
                    
                    updateLevelUI();
                }
            }
            
            // Update Level UI
            function updateLevelUI() {
                if (!playerXPManager) return;
                
                const currentXP = playerXPManager.currentXP;
                const xpNeeded = playerXPManager.xpNeededForNextLevel;
                const xpPercent = (currentXP / xpNeeded) * 100;
                
                document.getElementById('player-level').textContent = playerXPManager.level;
                document.getElementById('xp-bar').style.width = xpPercent + '%';
                document.getElementById('xp-text').textContent = `${currentXP} / ${xpNeeded} XP`;
                
                // Update stats display
                const attack = 10 + (playerXPManager.level * 2);
                const defense = 5 + playerXPManager.level;
                document.getElementById('stat-attack').textContent = attack;
                document.getElementById('stat-defense').textContent = defense;
            }
            
            // Show Level Up Notification
            function showLevelUpNotification(newLevel) {
                const notification = document.getElementById('level-up-notification');
                notification.textContent = `🎉 LEVEL ${newLevel}! 🎉`;
                notification.style.display = 'block';
                
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }
            
            // Add XP (can be called from various sources)
            function addXP(amount, source = 'unknown') {
                if (!playerXPManager) return;
                
                playerXPManager.addXP(amount);
                updateLevelUI();
                
                // Show floating XP indicator
                showDamageIndicator(amount, 'xp');
                console.log(`+${amount} XP from ${source}`);
            }
            window.addXP = addXP;
            
            // ═══════════════════════════════════════════════════════════════════════
            // PHYSICS-BASED CHARACTER ANIMATION SYSTEM
            // ═══════════════════════════════════════════════════════════════════════
            
            /**
             * Character Physics Controller with Joint Constraints
             * Each joint has mass, damping, and gravity influence
             */
            class CharacterPhysicsController {
                constructor(character) {
                    this.character = character;
                    this.centerOfGravity = new THREE.Vector3(0, 0.9, 0); // Hip height
                    this.mass = 70; // kg
                    this.balance = 1.0; // 0-1, affects stability
                    this.velocity = new THREE.Vector3();
                    this.acceleration = new THREE.Vector3();
                    
                    // BREATHING SYSTEM - Micro-iteration layer (60 Hz)
                    this.breathing = {
                        cycle: 0,                    // Current phase
                        frequency: 0.25,             // Breaths per second (15 BPM)
                        inhale: 0,                   // 0 to 1
                        affectedJoints: new Set(['neck', 'leftShoulder', 'rightShoulder']),
                        amplitude: 0.05              // How much breathing affects joints
                    };
                    
                    // Joint system with pivot points
                    this.joints = {
                        // Upper body
                        neck: { 
                            angle: { x: 0, y: 0, z: 0 },
                            velocity: { x: 0, y: 0, z: 0 },
                            acceleration: { x: 0, y: 0, z: 0 },
                            targetAngle: { x: 0, y: 0, z: 0 },
                            springForce: { x: 0, y: 0, z: 0 },
                            dampingForce: { x: 0, y: 0, z: 0 },
                            limits: { x: [-0.5, 0.5], y: [-0.8, 0.8], z: [-0.3, 0.3] },
                            stiffness: 0.15,
                            damping: 0.85,
                            mass: 5,
                            name: 'neck'
                        },
                        leftShoulder: {
                            angle: { x: 0, y: 0, z: 0 },
                            velocity: { x: 0, y: 0, z: 0 },
                            acceleration: { x: 0, y: 0, z: 0 },
                            targetAngle: { x: 0, y: 0, z: 0 },
                            springForce: { x: 0, y: 0, z: 0 },
                            dampingForce: { x: 0, y: 0, z: 0 },
                            limits: { x: [-2.0, 2.0], y: [-1.5, 1.5], z: [-0.5, 2.0] },
                            stiffness: 0.12,
                            damping: 0.88,
                            mass: 4,
                            name: 'leftShoulder'
                        },
                        rightShoulder: {
                            angle: { x: 0, y: 0, z: 0 },
                            velocity: { x: 0, y: 0, z: 0 },
                            limits: { x: [-2.0, 2.0], y: [-1.5, 1.5], z: [-2.0, 0.5] },
                            stiffness: 0.12,
                            damping: 0.88,
                            mass: 4
                        },
                        leftElbow: {
                            angle: { x: 0, y: 0, z: 0 },
                            velocity: { x: 0, y: 0, z: 0 },
                            limits: { x: [-2.4, 0], y: [-0.3, 0.3], z: [-0.2, 0.2] },
                            stiffness: 0.18,
                            damping: 0.82,
                            mass: 2
                        },
                        rightElbow: {
                            angle: { x: 0, y: 0, z: 0 },
                            velocity: { x: 0, y: 0, z: 0 },
                            limits: { x: [-2.4, 0], y: [-0.3, 0.3], z: [-0.2, 0.2] },
                            stiffness: 0.18,
                            damping: 0.82,
                            mass: 2
                        },
                        // Lower body
                        leftHip: {
                            angle: { x: 0, y: 0, z: 0 },
                            velocity: { x: 0, y: 0, z: 0 },
                            limits: { x: [-1.8, 1.2], y: [-0.5, 0.5], z: [-0.3, 0.8] },
                            stiffness: 0.2,
                            damping: 0.8,
                            mass: 8
                        },
                        rightHip: {
                            angle: { x: 0, y: 0, z: 0 },
                            velocity: { x: 0, y: 0, z: 0 },
                            limits: { x: [-1.8, 1.2], y: [-0.5, 0.5], z: [-0.8, 0.3] },
                            stiffness: 0.2,
                            damping: 0.8,
                            mass: 8
                        },
                        leftKnee: {
                            angle: { x: 0, y: 0, z: 0 },
                            velocity: { x: 0, y: 0, z: 0 },
                            limits: { x: [0, 2.4], y: [-0.1, 0.1], z: [-0.1, 0.1] },
                            stiffness: 0.22,
                            damping: 0.78,
                            mass: 5
                        },
                        rightKnee: {
                            angle: { x: 0, y: 0, z: 0 },
                            velocity: { x: 0, y: 0, z: 0 },
                            limits: { x: [0, 2.4], y: [-0.1, 0.1], z: [-0.1, 0.1] },
                            stiffness: 0.22,
                            damping: 0.78,
                            mass: 5
                        },
                        spine: {
                            angle: { x: 0, y: 0, z: 0 },
                            velocity: { x: 0, y: 0, z: 0 },
                            limits: { x: [-0.3, 0.3], y: [-0.4, 0.4], z: [-0.2, 0.2] },
                            stiffness: 0.25,
                            damping: 0.9,
                            mass: 15
                        }
                    };
                    
                    // Behavior state machine
                    this.behaviorState = 'idle';
                    this.stateTimer = 0;
                    this.stateData = {};
                }
                
                /**
                 * Apply physics forces to joints
                 * F = ma (Newton's second law)
                 */
                applyPhysics(delta, gravity = -9.81) {
                    const gravityForce = new THREE.Vector3(0, gravity * this.mass * delta, 0);
                    
                    // Update center of gravity based on joint positions
                    this.updateCenterOfGravity();
                    
                    // Apply spring-damper physics to each joint
                    for (const [jointName, joint] of Object.entries(this.joints)) {
                        ['x', 'y', 'z'].forEach(axis => {
                            // Spring force: F = -k * displacement
                            const springForce = -joint.stiffness * (joint.angle[axis] - (joint.targetAngle[axis] || 0));
                            joint.springForce[axis] = springForce; // Track for telemetry
                            
                            // Damping force: F = -c * velocity
                            const dampingForce = -joint.damping * joint.velocity[axis];
                            joint.dampingForce[axis] = dampingForce; // Track for telemetry
                            
                            // Gravity influence (varies by joint)
                            const gravityInfluence = jointName.includes('shoulder') || jointName.includes('hip') 
                                ? gravity * joint.mass * 0.001 * delta
                                : 0;
                            
                            // Total force
                            const totalForce = springForce + dampingForce + gravityInfluence;
                            
                            // F = ma, so a = F/m
                            const acceleration = totalForce / joint.mass;
                            joint.acceleration[axis] = acceleration; // Track for telemetry
                            
                            // Update velocity: v = v₀ + at
                            joint.velocity[axis] += acceleration * delta;
                            
                            // Update angle: θ = θ₀ + vt
                            joint.angle[axis] += joint.velocity[axis] * delta;
                            
                            // Clamp to joint limits
                            if (joint.limits[axis]) {
                                joint.angle[axis] = Math.max(
                                    joint.limits[axis][0],
                                    Math.min(joint.limits[axis][1], joint.angle[axis])
                                );
                                
                                // Bounce back if hit limit
                                if (joint.angle[axis] === joint.limits[axis][0] || 
                                    joint.angle[axis] === joint.limits[axis][1]) {
                                    joint.velocity[axis] *= -0.3;
                                }
                            }
                        });
                    }
                }
                
                /**
                 * Calculate center of gravity from joint masses
                 */
                updateCenterOfGravity() {
                    let totalMass = 0;
                    let weightedSum = new THREE.Vector3();
                    
                    for (const [name, joint] of Object.entries(this.joints)) {
                        totalMass += joint.mass;
                        // Simplified: assume joint positions based on angles
                        weightedSum.y += joint.angle.x * joint.mass * 0.1;
                    }
                    
                    this.centerOfGravity.y = 0.9 + (weightedSum.y / totalMass);
                    this.balance = Math.max(0, Math.min(1, 1 - Math.abs(weightedSum.y / totalMass)));
                }
                
                /**
                 * Set target pose for joints (IK target)
                 * Breathing layer can modulate these targets
                 */
                setJointTargets(targets) {
                    for (const [jointName, target] of Object.entries(targets)) {
                        if (this.joints[jointName]) {
                            ['x', 'y', 'z'].forEach(axis => {
                                if (target[axis] !== undefined) {
                                    // Set target angle
                                    this.joints[jointName].targetAngle[axis] = target[axis];
                                    
                                    // Apply breathing modulation to affected joints (micro-iteration)
                                    let finalTarget = target[axis];
                                    if (this.breathing.affectedJoints.has(jointName)) {
                                        // Breathing adds small oscillation on top of macro movement
                                        finalTarget += this.breathing.inhale * this.breathing.amplitude;
                                    }
                                    
                                    // Add velocity towards target (spring behavior)
                                    const diff = finalTarget - this.joints[jointName].angle[axis];
                                    this.joints[jointName].velocity[axis] += diff * 0.5;
                                }
                            });
                        }
                    }
                }
                
                /**
                 * Update breathing - micro-iteration layer (60 Hz)
                 * Runs INSIDE the joint update - same system controls both!
                 */
                updateBreathing(delta) {
                    // Increment breathing phase (the i++ of breathing)
                    this.breathing.cycle += delta * this.breathing.frequency * Math.PI * 2;
                    
                    // Calculate inhale value (0 to 1)
                    this.breathing.inhale = (Math.sin(this.breathing.cycle) + 1) / 2;
                    
                    // Breathing affects joint targets - micro modulation of macro movement
                    // This happens EVERY frame, while joint behaviors change every ~2 seconds
                    return this.breathing.inhale;
                }
                
                /**
                 * Behavior state: Walking
                 */
                updateWalkingBehavior(delta, speed = 1.0) {
                    const walkCycle = Math.sin(this.stateTimer * 8 * speed);
                    const walkCycle2 = Math.sin(this.stateTimer * 8 * speed + Math.PI);
                    
                    this.setJointTargets({
                        leftHip: { x: walkCycle * 0.6 },
                        rightHip: { x: walkCycle2 * 0.6 },
                        leftKnee: { x: Math.max(0, walkCycle * 0.8) },
                        rightKnee: { x: Math.max(0, walkCycle2 * 0.8) },
                        leftShoulder: { x: -walkCycle * 0.4 },
                        rightShoulder: { x: -walkCycle2 * 0.4 },
                        spine: { x: Math.sin(this.stateTimer * 4) * 0.05 }
                    });
                }
                
                /**
                 * Behavior state: Running
                 */
                updateRunningBehavior(delta, speed = 2.0) {
                    const runCycle = Math.sin(this.stateTimer * 12 * speed);
                    const runCycle2 = Math.sin(this.stateTimer * 12 * speed + Math.PI);
                    
                    this.setJointTargets({
                        leftHip: { x: runCycle * 1.2 },
                        rightHip: { x: runCycle2 * 1.2 },
                        leftKnee: { x: Math.max(0, runCycle * 1.5) },
                        rightKnee: { x: Math.max(0, runCycle2 * 1.5) },
                        leftShoulder: { x: -runCycle * 0.8, z: runCycle * 0.3 },
                        rightShoulder: { x: -runCycle2 * 0.8, z: -runCycle2 * 0.3 },
                        spine: { x: Math.sin(this.stateTimer * 6) * 0.15, z: Math.sin(this.stateTimer * 12) * 0.08 }
                    });
                }
                
                /**
                 * Behavior state: Sitting (drinking coffee/vaping)
                 */
                updateSittingBehavior(delta) {
                    const breathe = Math.sin(this.stateTimer * 1.5) * 0.05;
                    const sway = Math.sin(this.stateTimer * 0.8) * 0.03;
                    
                    // Drinking coffee animation
                    if (this.stateData.drinkingCoffee) {
                        const drinkCycle = (Math.sin(this.stateTimer * 0.5) + 1) * 0.5; // 0 to 1
                        this.setJointTargets({
                            rightShoulder: { x: -1.2 + drinkCycle * 0.4, z: -0.3 },
                            rightElbow: { x: -1.4 + drinkCycle * 0.6 },
                            leftShoulder: { x: -0.3, z: 0.2 },
                            leftElbow: { x: -0.5 }
                        });
                    }
                    // Vaping animation
                    else if (this.stateData.vaping) {
                        const vapeCycle = (Math.sin(this.stateTimer * 0.7) + 1) * 0.5;
                        this.setJointTargets({
                            rightShoulder: { x: -1.0 + vapeCycle * 0.3, z: -0.4 },
                            rightElbow: { x: -1.6 + vapeCycle * 0.8 },
                            leftShoulder: { x: -0.2, z: 0.3 },
                            leftElbow: { x: -0.4 }
                        });
                    }
                    // Just sitting
                    else {
                        this.setJointTargets({
                            rightShoulder: { x: -0.4, z: -0.2 },
                            rightElbow: { x: -0.8 },
                            leftShoulder: { x: -0.4, z: 0.2 },
                            leftElbow: { x: -0.8 }
                        });
                    }
                    
                    // Sitting pose (legs bent)
                    this.setJointTargets({
                        leftHip: { x: -1.5, z: 0.3 },
                        rightHip: { x: -1.5, z: -0.3 },
                        leftKnee: { x: 1.8 },
                        rightKnee: { x: 1.8 },
                        spine: { x: 0.2 + breathe, z: sway },
                        neck: { x: 0.1, y: sway * 0.5 }
                    });
                }
                
                /**
                 * Behavior state: Idle (standing, slight movements)
                 */
                updateIdleBehavior(delta) {
                    const breathe = Math.sin(this.stateTimer * 2) * 0.03;
                    const shift = Math.sin(this.stateTimer * 0.5) * 0.05;
                    
                    this.setJointTargets({
                        leftShoulder: { x: shift * 0.5 },
                        rightShoulder: { x: -shift * 0.5 },
                        spine: { x: breathe, z: shift * 0.3 },
                        neck: { y: Math.sin(this.stateTimer * 0.3) * 0.1 }, // Looking around
                        leftHip: { z: shift * 0.2 },
                        rightHip: { z: -shift * 0.2 }
                    });
                }
                
                /**
                 * Main update loop
                 * Two iteration layers: Breathing (micro) + Joints (macro)
                 */
                update(delta) {
                    this.stateTimer += delta;
                    
                    // MICRO-ITERATION: Update breathing layer (60 Hz)
                    // This runs EVERY frame regardless of behavior state
                    this.updateBreathing(delta);
                    
                    // MACRO-ITERATION: Update behavior based on state
                    // This runs at the same frequency but changes every ~2 seconds
                    switch(this.behaviorState) {
                        case 'walking':
                            this.updateWalkingBehavior(delta, this.stateData.speed || 1.0);
                            break;
                        case 'running':
                            this.updateRunningBehavior(delta, this.stateData.speed || 2.0);
                            break;
                        case 'sitting':
                            this.updateSittingBehavior(delta);
                            break;
                        case 'idle':
                        default:
                            this.updateIdleBehavior(delta);
                            break;
                    }
                    
                    // Apply physics to all joints (receives both breathing + behavior modulation)
                    this.applyPhysics(delta);
                    
                    // Apply joint rotations to character mesh
                    this.applyJointsToMesh();
                }
                
                /**
                 * Apply calculated joint angles to actual 3D mesh
                 */
                applyJointsToMesh() {
                    if (!this.character.userData.bodyParts) return;
                    
                    const parts = this.character.userData.bodyParts;
                    
                    // Apply rotations
                    if (parts.head) {
                        parts.head.rotation.x = this.joints.neck.angle.x;
                        parts.head.rotation.y = this.joints.neck.angle.y;
                        parts.head.rotation.z = this.joints.neck.angle.z;
                    }
                    
                    if (parts.leftArm) {
                        parts.leftArm.rotation.x = this.joints.leftShoulder.angle.x;
                        parts.leftArm.rotation.z = this.joints.leftShoulder.angle.z;
                    }
                    if (parts.rightArm) {
                        parts.rightArm.rotation.x = this.joints.rightShoulder.angle.x;
                        parts.rightArm.rotation.z = this.joints.rightShoulder.angle.z;
                    }
                    
                    if (parts.leftLeg) {
                        parts.leftLeg.rotation.x = this.joints.leftHip.angle.x;
                        parts.leftLeg.rotation.z = this.joints.leftHip.angle.z;
                    }
                    if (parts.rightLeg) {
                        parts.rightLeg.rotation.x = this.joints.rightHip.angle.x;
                        parts.rightLeg.rotation.z = this.joints.rightHip.angle.z;
                    }
                    
                    if (parts.body) {
                        parts.body.rotation.x = this.joints.spine.angle.x;
                        parts.body.rotation.z = this.joints.spine.angle.z;
                    }
                }
                
                /**
                 * Transition to new behavior state
                 */
                setBehavior(state, data = {}) {
                    this.behaviorState = state;
                    this.stateData = data;
                    this.stateTimer = 0;
                    console.log(`🎭 Character behavior: ${state}`, data);
                }
            }
            
            // ═══════════════════════════════════════════════════════════
            // 📐 INVERSE KINEMATICS (IK) SYSTEM
            // ═══════════════════════════════════════════════════════════
            
            /**
             * 2-Joint IK Solver (Analytical Solution)
             * Uses law of cosines for arm/leg chains
             */
            function solveIK2Joint(target, length1, length2, origin) {
                const dx = target.x - origin.x;
                const dy = target.y - origin.y;
                const dz = target.z - origin.z;
                let distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                // Check reachability
                const maxReach = length1 + length2;
                const minReach = Math.abs(length1 - length2);
                
                if (distance > maxReach) {
                    distance = maxReach - 0.001;
                } else if (distance < minReach) {
                    distance = minReach + 0.001;
                }
                
                // Law of cosines for elbow angle
                const cosElbow = (length1*length1 + length2*length2 - distance*distance) 
                               / (2 * length1 * length2);
                const elbowAngle = Math.acos(Math.max(-1, Math.min(1, cosElbow)));
                
                // Law of cosines for shoulder angle component
                const cosShoulder = (length1*length1 + distance*distance - length2*length2)
                                  / (2 * length1 * distance);
                const shoulderAngleToTarget = Math.acos(Math.max(-1, Math.min(1, cosShoulder)));
                
                // Direction to target
                const horizontalDist = Math.sqrt(dx*dx + dz*dz);
                const angleToTarget = Math.atan2(dy, horizontalDist);
                const yawToTarget = Math.atan2(dx, dz);
                
                // Final angles
                const shoulderPitch = angleToTarget + shoulderAngleToTarget;
                
                return {
                    shoulderPitch: shoulderPitch,
                    shoulderYaw: yawToTarget,
                    elbow: Math.PI - elbowAngle // Interior angle
                };
            }
            
            /**
             * ARM IK Controller
             * Makes hand reach for target positions
             */
            class ArmIKController {
                constructor(character, side = 'left') {
                    this.character = character;
                    this.side = side;
                    this.upperArmLength = 0.3;
                    this.forearmLength = 0.25;
                    this.isActive = false;
                    this.target = new THREE.Vector3();
                    this.smoothness = 0.15; // Interpolation speed
                }
                
                getShoulderPosition() {
                    const offset = this.side === 'left' ? -0.2 : 0.2;
                    return new THREE.Vector3(
                        this.character.position.x + offset,
                        this.character.position.y + 1.4,
                        this.character.position.z
                    );
                }
                
                setTarget(position) {
                    this.target.copy(position);
                    this.isActive = true;
                }
                
                release() {
                    this.isActive = false;
                }
                
                update() {
                    if (!this.isActive) return;
                    
                    const bodyParts = this.character.userData.bodyParts;
                    if (!bodyParts) return;
                    
                    const shoulderPos = this.getShoulderPosition();
                    const solution = solveIK2Joint(
                        this.target,
                        this.upperArmLength,
                        this.forearmLength,
                        shoulderPos
                    );
                    
                    // Get appropriate body parts
                    const shoulder = this.side === 'left' ? bodyParts.leftArm : bodyParts.rightArm;
                    
                    if (shoulder) {
                        // Smooth interpolation
                        shoulder.rotation.x += (solution.shoulderPitch - shoulder.rotation.x) * this.smoothness;
                        shoulder.rotation.y += (solution.shoulderYaw - shoulder.rotation.y) * this.smoothness;
                    }
                }
            }
            
            /**
             * FABRIK IK Solver (Multi-joint chain)
             * Forward And Backward Reaching IK
             */
            class FABRIKSolver {
                constructor(boneLengths) {
                    this.boneLengths = boneLengths;
                    this.joints = boneLengths.map(() => new THREE.Vector3());
                    this.tolerance = 0.01;
                    this.maxIterations = 10;
                }
                
                solve(target, base) {
                    const n = this.joints.length;
                    const originalBase = base.clone();
                    
                    // Check reachability
                    const totalLength = this.boneLengths.reduce((sum, len) => sum + len, 0);
                    const distToTarget = base.distanceTo(target);
                    
                    if (distToTarget > totalLength) {
                        // Unreachable - stretch towards target
                        const direction = new THREE.Vector3().subVectors(target, base).normalize();
                        this.joints[0] = base.clone();
                        for (let i = 1; i < n; i++) {
                            this.joints[i] = this.joints[i-1].clone()
                                .add(direction.clone().multiplyScalar(this.boneLengths[i-1]));
                        }
                        return this.joints;
                    }
                    
                    // Initialize joints in straight line
                    if (this.joints[0].length() === 0) {
                        const direction = new THREE.Vector3().subVectors(target, base).normalize();
                        this.joints[0] = base.clone();
                        for (let i = 1; i < n; i++) {
                            this.joints[i] = this.joints[i-1].clone()
                                .add(direction.clone().multiplyScalar(this.boneLengths[i-1]));
                        }
                    }
                    
                    // Iterative solving
                    for (let iter = 0; iter < this.maxIterations; iter++) {
                        if (this.joints[n-1].distanceTo(target) < this.tolerance) break;
                        
                        // BACKWARD PASS
                        this.joints[n-1].copy(target);
                        for (let i = n - 2; i >= 0; i--) {
                            const direction = new THREE.Vector3()
                                .subVectors(this.joints[i], this.joints[i+1])
                                .normalize();
                            this.joints[i].copy(this.joints[i+1])
                                .add(direction.multiplyScalar(this.boneLengths[i]));
                        }
                        
                        // FORWARD PASS
                        this.joints[0].copy(originalBase);
                        for (let i = 0; i < n - 1; i++) {
                            const direction = new THREE.Vector3()
                                .subVectors(this.joints[i+1], this.joints[i])
                                .normalize();
                            this.joints[i+1].copy(this.joints[i])
                                .add(direction.multiplyScalar(this.boneLengths[i]));
                        }
                    }
                    
                    return this.joints;
                }
                
                getJointAngles() {
                    const angles = [];
                    for (let i = 0; i < this.joints.length - 1; i++) {
                        const direction = new THREE.Vector3()
                            .subVectors(this.joints[i+1], this.joints[i])
                            .normalize();
                        
                        const angleX = Math.atan2(direction.y, 
                            Math.sqrt(direction.x * direction.x + direction.z * direction.z));
                        const angleY = Math.atan2(direction.x, direction.z);
                        
                        angles.push({ x: angleX, y: angleY, z: 0 });
                    }
                    return angles;
                }
            }
            
            // ═══════════════════════════════════════════════════════════
            // 🎯 IK VISUALIZATION & TESTING
            // ═══════════════════════════════════════════════════════════
            
            let ikTarget = null;
            let ikLine = null;
            let activeIKController = null;
            
            function createIKTarget() {
                const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.8
                });
                ikTarget = new THREE.Mesh(geometry, material);
                ikTarget.position.set(camera.position.x + 1, camera.position.y, camera.position.z - 2);
                scene.add(ikTarget);
                
                // Add glow
                const glowGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                ikTarget.add(glow);
                
                // Add line from shoulder to target
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.5
                });
                const lineGeometry = new THREE.BufferGeometry();
                ikLine = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(ikLine);
                
                console.log('🎯 IK TARGET CREATED! Press T to toggle IK mode, arrow keys to move target');
            }
            
            function updateIKTarget() {
                if (!ikTarget || !activeIKController) return;
                
                // Update line
                const shoulderPos = activeIKController.getShoulderPosition();
                const positions = new Float32Array([
                    shoulderPos.x, shoulderPos.y, shoulderPos.z,
                    ikTarget.position.x, ikTarget.position.y, ikTarget.position.z
                ]);
                ikLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                // Pulse glow
                const time = Date.now() * 0.003;
                ikTarget.children[0].scale.setScalar(1 + Math.sin(time) * 0.2);
            }
            
            // ═══════════════════════════════════════════════════════════
            // 🔢 ITERATION TELEMETRY - Live Values Display
            // ═══════════════════════════════════════════════════════════
            
            let telemetryDisplay = null;
            let showTelemetry = false;
            
            function createTelemetryDisplay() {
                telemetryDisplay = document.createElement('div');
                telemetryDisplay.style.position = 'absolute';
                telemetryDisplay.style.top = '50%';
                telemetryDisplay.style.right = '10px';
                telemetryDisplay.style.transform = 'translateY(-50%)';
                telemetryDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
                telemetryDisplay.style.color = '#00ff00';
                telemetryDisplay.style.fontFamily = 'Courier New, monospace';
                telemetryDisplay.style.fontSize = '12px';
                telemetryDisplay.style.padding = '15px';
                telemetryDisplay.style.borderRadius = '8px';
                telemetryDisplay.style.border = '2px solid #00ff00';
                telemetryDisplay.style.minWidth = '400px';
                telemetryDisplay.style.maxWidth = '500px';
                telemetryDisplay.style.zIndex = '1000';
                telemetryDisplay.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.5)';
                document.body.appendChild(telemetryDisplay);
            }
            
            function updateTelemetryDisplay(delta) {
                if (!showTelemetry || !telemetryDisplay) return;
                
                const npc = findNearestNPC();
                if (!npc || !npc.userData.physicsController) {
                    telemetryDisplay.innerHTML = '<div style="color: #ff6600;">⚠️ No NPC nearby with physics</div>';
                    return;
                }
                
                const physics = npc.userData.physicsController;
                const joints = physics.joints;
                
                // Get shoulder joint as example
                const shoulderJoint = joints.leftShoulder;
                if (!shoulderJoint) return;
                
                // Record to iteration recorder if active
                if (window.iterationRecorder && window.iterationRecorder.isRecording) {
                    window.iterationRecorder.recordFrame({
                        time: physics.stateTimer,
                        delta: delta,
                        joint: {
                            name: 'leftShoulder',
                            angle: shoulderJoint.angle.x,
                            velocity: shoulderJoint.velocity.x,
                            acceleration: shoulderJoint.acceleration?.x || 0,
                            springForce: shoulderJoint.springForce?.x || 0,
                            dampingForce: shoulderJoint.dampingForce?.x || 0
                        }
                    });
                }
                
                // Build telemetry output
                let html = `
<div style="color: #00ffff; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #00ff00; padding-bottom: 5px;">
⚙️ ITERATION TELEMETRY - LEFT SHOULDER ${window.iterationRecorder?.isRecording ? '🔴 REC' : ''}
</div>

<div style="margin-bottom: 8px;">
<span style="color: #ffff00;">ITERATION VALUES:</span>
  i = ${physics.stateTimer.toFixed(3)}s    <span style="color: #666;">// loop counter (time)</span>
  n = ${Object.keys(joints).length}              <span style="color: #666;">// total joints</span>
  Δt = ${delta.toFixed(6)}s  <span style="color: #666;">// delta time (frame)</span>
</div>

<div style="margin-bottom: 8px;">
<span style="color: #ffff00;">STATE REGISTERS:</span>
  θ = ${shoulderJoint.angle.x.toFixed(4)} rad   <span style="color: #666;">// current angle</span>
  θ₀ = ${shoulderJoint.targetAngle.toFixed(4)} rad  <span style="color: #666;">// target angle</span>
  ω = ${shoulderJoint.velocity.toFixed(4)} rad/s <span style="color: #666;">// angular velocity</span>
  α = ${shoulderJoint.acceleration.toFixed(4)} rad/s² <span style="color: #666;">// acceleration</span>
</div>

<div style="margin-bottom: 8px;">
<span style="color: #ffff00;">FORCE CALCULATIONS:</span>
  F_spring = ${shoulderJoint.springForce.toFixed(3)} N    <span style="color: #666;">// F = -kx</span>
  F_damping = ${shoulderJoint.dampingForce.toFixed(3)} N  <span style="color: #666;">// F = -cv</span>
  F_total = ${(shoulderJoint.springForce + shoulderJoint.dampingForce).toFixed(3)} N
</div>

<div style="margin-bottom: 8px;">
<span style="color: #ffff00;">PHYSICS CONSTANTS:</span>
  m = ${shoulderJoint.mass} kg          <span style="color: #666;">// mass</span>
  k = ${shoulderJoint.stiffness.toFixed(2)}             <span style="color: #666;">// spring constant</span>
  c = ${shoulderJoint.damping.toFixed(2)}              <span style="color: #666;">// damping coefficient</span>
</div>

<div style="margin-bottom: 8px;">
<span style="color: #ffff00;">BEHAVIOR STATE:</span>
  state = "${physics.behaviorState}"
  frame = ${physics.stateTimer.toFixed(1)}s in state
</div>

<div style="margin-bottom: 8px; color: #00ff00;">
<span style="color: #ffff00;">INTEGRATION (60Hz):</span>
  ω = ω + α×Δt    <span style="color: #666;">// velocity update</span>
  θ = θ + ω×Δt    <span style="color: #666;">// position update</span>
</div>

<div style="color: #666; font-size: 10px; margin-top: 10px; border-top: 1px solid #333; padding-top: 5px;">
M=toggle | R=record | S=stop | P=playback | E=export
The elbows, bearings & transmissions of the code 🔧
</div>
`;
                
                telemetryDisplay.innerHTML = html;
            }
            
            // ═══════════════════════════════════════════════════════════
            // 🎥 ITERATION RECORDER - Capture & Export Values
            // ═══════════════════════════════════════════════════════════
            
            window.iterationRecorder = {
                isRecording: false,
                frames: [],
                startTime: 0,
                
                start() {
                    this.isRecording = true;
                    this.frames = [];
                    this.startTime = Date.now();
                    console.log('🔴 RECORDING STARTED - Capturing iteration values...');
                },
                
                stop() {
                    this.isRecording = false;
                    console.log(`⏹️ RECORDING STOPPED - Captured ${this.frames.length} frames`);
                    return this.frames;
                },
                
                recordFrame(data) {
                    if (!this.isRecording) return;
                    this.frames.push({
                        frameIndex: this.frames.length,
                        timestamp: Date.now() - this.startTime,
                        ...data
                    });
                },
                
                exportToJSON() {
                    const data = {
                        metadata: {
                            totalFrames: this.frames.length,
                            duration: this.frames.length > 0 
                                ? this.frames[this.frames.length - 1].timestamp / 1000 
                                : 0,
                            recordedAt: new Date().toISOString()
                        },
                        frames: this.frames
                    };
                    
                    const json = JSON.stringify(data, null, 2);
                    this.downloadFile(json, `iteration_recording_${Date.now()}.json`, 'application/json');
                    console.log('💾 Exported', this.frames.length, 'frames to JSON');
                },
                
                exportToCSV() {
                    let csv = 'frameIndex,timestamp,time,delta,angle,velocity,acceleration,springForce,dampingForce\n';
                    
                    this.frames.forEach(frame => {
                        csv += `${frame.frameIndex},`;
                        csv += `${frame.timestamp},`;
                        csv += `${frame.time.toFixed(6)},`;
                        csv += `${frame.delta.toFixed(6)},`;
                        csv += `${frame.joint.angle.toFixed(6)},`;
                        csv += `${frame.joint.velocity.toFixed(6)},`;
                        csv += `${frame.joint.acceleration.toFixed(6)},`;
                        csv += `${frame.joint.springForce.toFixed(6)},`;
                        csv += `${frame.joint.dampingForce.toFixed(6)}\n`;
                    });
                    
                    this.downloadFile(csv, `iteration_data_${Date.now()}.csv`, 'text/csv');
                    console.log('💾 Exported', this.frames.length, 'frames to CSV');
                },
                
                downloadFile(content, filename, mimeType) {
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                }
        };
        
        // Store physics controllers globally
        const characterPhysicsControllers = [];
        
        /**
         * Attach physics controller to character
         */
        window.enableCharacterPhysics = function(character) {
            const controller = new CharacterPhysicsController(character);
            character.userData.physicsController = controller;
            characterPhysicsControllers.push(controller);
            return controller;
        };            /**
             * Update all character physics
             */
            function updateCharacterPhysics(delta) {
                characterPhysicsControllers.forEach(controller => {
                    controller.update(delta);
                });
            }
            
            // ═══════════════════════════════════════════════════════════════════════
            // CINEMATIC DIALOGUE CAMERA SYSTEM
            // ═══════════════════════════════════════════════════════════════════════
            
            /**
             * Vertex-based camera interpolation using cubic Bezier curves
             * Creates smooth, studio-quality camera movements between characters
             */
            function calculateBezierPoint(t, p0, p1, p2, p3) {
                // Cubic Bezier formula: B(t) = (1-t)³P₀ + 3(1-t)²tP₁ + 3(1-t)t²P₂ + t³P₃
                const u = 1 - t;
                const tt = t * t;
                const uu = u * u;
                const uuu = uu * u;
                const ttt = tt * t;
                
                // Calculate vertex position using mathematical interpolation
                const x = uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x;
                const y = uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y;
                const z = uuu * p0.z + 3 * uu * t * p1.z + 3 * u * tt * p2.z + ttt * p3.z;
                
                return new THREE.Vector3(x, y, z);
            }
            
            /**
             * Easing function for cinematic timing - creates acceleration/deceleration
             * Uses sine wave mathematics for smooth motion
             */
            function easeInOutSine(t) {
                return -(Math.cos(Math.PI * t) - 1) / 2;
            }
            
            /**
             * Generate camera path vertices between two points
             * Creates arc motion for dramatic effect
             */
            function generateCameraPath(start, end, height = 2) {
                const mid = new THREE.Vector3().lerpVectors(start, end, 0.5);
                
                // Create arc control points using vector mathematics
                const direction = new THREE.Vector3().subVectors(end, start).normalize();
                const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                
                // Control point 1: offset from start with height
                const cp1 = start.clone().add(perpendicular.multiplyScalar(1.5));
                cp1.y += height * 0.5;
                
                // Control point 2: offset from end with height
                const cp2 = end.clone().add(perpendicular.multiplyScalar(-1.5));
                cp2.y += height * 0.7;
                
                return { p0: start, p1: cp1, p2: cp2, p3: end };
            }
            
            /**
             * Start cinematic dialogue sequence with NPC
             * DISABLED - Cinematics removed to prevent UI hijacking
             */
            function startDialogueCinematic(npc) {
                return; // DISABLED - Cinematic system off
                
                /* CINEMATIC CODE DISABLED
                if (!npc) return;
                
                dialogueNPC = npc;
                dialogueCinematicActive = true;
                dialogueSequenceIndex = 0;
                dialogueTimer = 0;
                
                // Save original camera state
                originalCameraPos.copy(camera.position);
                originalCameraRot.copy(camera.rotation);
                
                // Unlock controls for cinematic
                if (controls.isLocked) {
                    controls.unlock();
                }
                
                const playerPos = controls.getObject().position;
                const npcPos = npc.position;
                
                // Calculate midpoint between player and NPC
                const midpoint = new THREE.Vector3().lerpVectors(playerPos, npcPos, 0.5);
                
                // ═══ SHOT 1: Establishing Wide Shot (shows both characters) ═══
                const widePos = midpoint.clone();
                widePos.y += 3; // Elevated view
                widePos.z += 8; // Pull back
                
                // ═══ SHOT 2: Over-shoulder on NPC (player POV) ═══
                const overShoulderNPC = new THREE.Vector3().lerpVectors(playerPos, npcPos, 0.3);
                overShoulderNPC.y = npcPos.y + 1.6; // Eye level
                overShoulderNPC.z += 0.5;
                
                // ═══ SHOT 3: Close-up on NPC face ═══
                const npcCloseup = npcPos.clone();
                npcCloseup.y = npcPos.y + 1.7; // Face height
                npcCloseup.z += 2.5; // Close but not too close
                npcCloseup.x += 0.5; // Slight angle
                
                // ═══ SHOT 4: Over-shoulder on Player (NPC POV) ═══
                const overShoulderPlayer = new THREE.Vector3().lerpVectors(npcPos, playerPos, 0.3);
                overShoulderPlayer.y = playerPos.y + 1.6;
                overShoulderPlayer.z += 0.5;
                
                // ═══ SHOT 5: Two-shot (side angle) ═══
                const twoShot = midpoint.clone();
                twoShot.y += 2;
                twoShot.x += 6; // Side angle
                
                // Build sequence with timing (vertex count increases with complexity)
                dialogueCameraSequence = [
                    {
                        position: widePos,
                        lookAt: midpoint,
                        duration: 3.0, // 3 seconds establishing shot
                        name: 'Wide Establishing',
                        vertexCount: 128 // Complexity metric
                    },
                    {
                        position: overShoulderNPC,
                        lookAt: npcPos,
                        duration: 2.5,
                        name: 'Over-Shoulder NPC',
                        vertexCount: 256
                    },
                    {
                        position: npcCloseup,
                        lookAt: npcPos,
                        duration: 2.0,
                        name: 'NPC Close-up',
                        vertexCount: 512 // Higher detail for close-up
                    },
                    {
                        position: overShoulderPlayer,
                        lookAt: playerPos,
                        duration: 2.5,
                        name: 'Over-Shoulder Player',
                        vertexCount: 256
                    },
                    {
                        position: twoShot,
                        lookAt: midpoint,
                        duration: 2.0,
                        name: 'Two-Shot',
                        vertexCount: 384
                    }
                ];
                
                console.log('🎬 Cinematic Dialogue Started - ' + dialogueCameraSequence.length + ' shots');
                console.log('📊 Total Vertex Count: ' + dialogueCameraSequence.reduce((sum, shot) => sum + shot.vertexCount, 0));
                */ // END DISABLED CINEMATIC CODE
            }
            
            /**
             * Update cinematic dialogue camera each frame
             * DISABLED - Cinematic system removed
             */
            function updateDialogueCinematic(delta) {
                return; // DISABLED
                
                /* DISABLED CINEMATIC CODE
                if (!dialogueCinematicActive || dialogueCameraSequence.length === 0) return;
                
                const currentShot = dialogueCameraSequence[dialogueSequenceIndex];
                if (!currentShot) {
                    endDialogueCinematic();
                    return;
                }
                
                dialogueTimer += delta;
                
                // Calculate progress through current shot (0 to 1)
                const progress = Math.min(dialogueTimer / currentShot.duration, 1);
                const easedProgress = easeInOutSine(progress);
                
                // If first frame of shot, generate camera path
                if (!currentShot.path) {
                    const startPos = camera.position.clone();
                    currentShot.path = generateCameraPath(
                        startPos,
                        currentShot.position,
                        1.5 // Arc height
                    );
                }
                
                // Interpolate camera position using Bezier curve (vertex mathematics)
                const newPos = calculateBezierPoint(
                    easedProgress,
                    currentShot.path.p0,
                    currentShot.path.p1,
                    currentShot.path.p2,
                    currentShot.path.p3
                );
                
                camera.position.copy(newPos);
                
                // Smooth look-at with slight lag for natural feel
                const lookTarget = currentShot.lookAt.clone();
                lookTarget.y += Math.sin(clock.getElapsedTime() * 0.5) * 0.1; // Subtle breathing motion
                camera.lookAt(lookTarget);
                
                // Move to next shot when duration complete
                if (progress >= 1.0) {
                    dialogueSequenceIndex++;
                    dialogueTimer = 0;
                    
                    if (dialogueSequenceIndex >= dialogueCameraSequence.length) {
                        endDialogueCinematic();
                    } else {
                        console.log(`🎬 Shot ${dialogueSequenceIndex + 1}: ${dialogueCameraSequence[dialogueSequenceIndex].name}`);
                    }
                }
                */ // END DISABLED
            }
            
            /**
             * End cinematic and return camera control
             * DISABLED - Cinematic system removed
             */
            function endDialogueCinematic() {
                return; // DISABLED
                
                /* DISABLED
                dialogueCinematicActive = false;
                dialogueCameraSequence = [];
                dialogueSequenceIndex = 0;
                dialogueTimer = 0;
                */
                // Smooth transition back to player control
                const returnDuration = 1.0;
                let returnTimer = 0;
                const startPos = camera.position.clone();
                
                const returnAnimation = () => {
                    returnTimer += 0.016;
                    const progress = Math.min(returnTimer / returnDuration, 1);
                    const eased = easeInOutSine(progress);
                    
                    camera.position.lerpVectors(startPos, originalCameraPos, eased);
                    
                    if (progress < 1) {
                        requestAnimationFrame(returnAnimation);
                    } else {
                        console.log('🎬 Cinematic Dialogue Ended');
                    }
                };
                
                returnAnimation();
            }
            
            /**
             * Detect nearby important NPCs for cinematic triggers
             * DISABLED - Cinematics removed to prevent UI hijacking
             */
            function checkForCinematicNPCs() {
                return; // DISABLED - Auto cinematics off
                
                /* CINEMATIC CODE DISABLED
                if (dialogueCinematicActive) return;
                
                const playerPos = controls.getObject().position;
                const detectionRadius = 5;
                
                // Check all NPCs in scene
                scene.traverse((obj) => {
                    if (obj.userData.isImportantNPC && !obj.userData.cinematicPlayed) {
                        const distance = playerPos.distanceTo(obj.position);
                        
                        if (distance < detectionRadius) {
                            // Trigger cinematic on first encounter
                            obj.userData.cinematicPlayed = true;
                            startDialogueCinematic(obj);
                        }
                    }
                });
                */
            }
            
            /**
             * Find nearest NPC to player
             */
            function findNearestNPC() {
                const playerPos = controls.getObject().position;
                let nearestNPC = null;
                let nearestDist = Infinity;
                
                scene.traverse((obj) => {
                    if (obj.userData.physicsController || obj.name?.includes('NPC')) {
                        const dist = playerPos.distanceTo(obj.position);
                        if (dist < nearestDist && dist < 20) {
                            nearestDist = dist;
                            nearestNPC = obj;
                        }
                    }
                });
                
                return nearestNPC;
            }
            
            // Initialize skills system
            // MOVED: Initialize immediately so animate() doesn't error
            console.log('⚡ Initializing game systems...');
            initializeCombatStats();
            initializeSkillsSystem();
            initializeInventory();
            initializeQuestSystem();
            initializeCraftingSystem();
            initializeLevelProgression();
            console.log('✅ Game systems initialized');
            
            // Keyboard input
            setupKeyboardControls();
            
            // Build the world (async)
            buildWorld();
            
            // Setup minimap
            setupMinimap();
            
            // Initialize save system
            initSaveSystem();
            
            // Initialize audio system
            initAudioSystem();
            
            // Hide loading screen
            updateLoading(100, 'Complete!');
            setTimeout(() => {
                document.getElementById('loading-screen').classList.add('hidden');
            }, 100);
            
            // Start render loop
            console.log('🎬 Starting animation loop...');
            animate();
            
            console.log('✅ SkyRelics World Ready!');
            console.log(`📊 Total Objects: ${worldObjects.children.length}`);
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // WORLD BUILDING (Optimized for slower machines)
        // ═══════════════════════════════════════════════════════════════════════
        
        async function buildWorld() {
            console.log('🌍 Building world in optimized chunks...');
            const startTime = performance.now();
            
            // Chunk 1: Essential terrain (lightweight)
            updateLoading(20, loadingSteps[1]);
            await yieldToMain(); // Let browser breathe
            createTerrain();
            console.log(`⏱️ Terrain: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 2: Neighborhood (medium load)
            updateLoading(30, loadingSteps[2]);
            await yieldToMain();
            createNeighborhood();
            console.log(`⏱️ Neighborhood: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 3: College campus (HEAVY - 8 detailed buildings)
            updateLoading(40, loadingSteps[3]);
            await yieldToMain();
            createCollege();
            console.log(`⏱️ College: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 4: Log cabins (lightweight)
            await yieldToMain();
            createWildernessLodges();
            console.log(`⏱️ Cabins: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 5: Park (medium)
            updateLoading(50, loadingSteps[4]);
            await yieldToMain();
            createPark();
            console.log(`⏱️ Park: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 6: Forest (medium)
            updateLoading(60, loadingSteps[5]);
            await yieldToMain();
            createForest();
            console.log(`⏱️ Forest: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 7: Lake (lightweight)
            updateLoading(70, loadingSteps[6]);
            await yieldToMain();
            createLake();
            console.log(`⏱️ Lake: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 8: Mountains (medium)
            updateLoading(80, loadingSteps[7]);
            await yieldToMain();
            createMountains();
            console.log(`⏱️ Mountains: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 9: Ocean (lightweight)
            updateLoading(90, loadingSteps[8]);
            await yieldToMain();
            createOcean();
            console.log(`⏱️ Ocean: ${Math.round(performance.now() - startTime)}ms`);
            console.log(`⏱️ Ocean: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 10: Wildlife & NPCs (medium load)
            updateLoading(95, loadingSteps[9]);
            await yieldToMain();
            createWildlifeAndNPCs();
            console.log(`⏱️ Wildlife/NPCs: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 11: VSL Character System (async)
            updateLoading(96, 'Creating VSL characters...');
            await yieldToMain();
            await initVSLCharacters();
            console.log(`⏱️ VSL Characters: ${Math.round(performance.now() - startTime)}ms`);
            
            // Chunk 12: Fast Travel Portals
            updateLoading(97, 'Creating fast travel portals...');
            await yieldToMain();
            await createFastTravelPortals();
            console.log(`⏱️ Portals: ${Math.round(performance.now() - startTime)}ms`);

            // Ensure no NPCs/creatures spawn near the player start
            enforceStartSafeZone();
            
            // Lighting
            setupLighting();
            
            // Add world to scene
            scene.add(worldObjects);
            
            const totalTime = Math.round(performance.now() - startTime);
            console.log(`✅ World built in ${totalTime}ms (${(totalTime/1000).toFixed(2)}s)`);
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // PERFORMANCE UTILITY - Yield to main thread
        // ═══════════════════════════════════════════════════════════════════════
        
        function yieldToMain() {
            return new Promise(resolve => {
                setTimeout(resolve, 0); // Let browser process events
            });
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // TERRAIN
        // ═══════════════════════════════════════════════════════════════════════
        
        async function createTerrain() {
            const terrainSize = 2000;
            const segments = 200;
            
            const geometry = new THREE.PlaneGeometry(terrainSize, terrainSize, segments, segments);
            
            // Add height variation
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 1];
                
                // Gentle rolling hills
                let height = 0;
                height += Math.sin(x * 0.01) * 2;
                height += Math.cos(z * 0.01) * 2;
                height += Math.sin(x * 0.05) * 0.5;
                height += Math.cos(z * 0.05) * 0.5;
                
                positions[i + 2] = height;
            }
            
            geometry.computeVertexNormals();
            
            // ═══ ENHANCED TERRAIN MATERIAL with variation ═══
            const grassTexture = createGrassTexture();
            const grassNormal = createGrassNormalMap();
            const grassRoughness = createGrassRoughnessMap();
            
            const material = new THREE.MeshStandardMaterial({
                map: grassTexture,
                normalMap: grassNormal,
                roughnessMap: grassRoughness,
                color: 0x3a7d44,
                roughness: 0.95,
                metalness: 0.0,
                envMapIntensity: 0.3
            });
            
            const terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            terrain.name = 'Terrain';
            terrain.userData.isTerrain = true; // Tag for LOD system
            
            worldObjects.add(terrain);

            annotateObject(terrain, {
                id: 'terrain_primary_plateau',
                name: 'Terrain_PrimaryPlateau',
                type: 'environment',
                category: 'landscape',
                description: 'Expansive 2km procedurally sculpted terrain plate with 40k vertex grid. Blended sinusoidal heightfield produces rolling foothills that transition into player districts.',
                dimensions: {
                    widthMeters: terrainSize,
                    lengthMeters: terrainSize,
                    vertexGrid: `${segments}×${segments}`
                },
                materials: [
                    {
                        id: 'grassComposite',
                        description: 'Custom canvas-based PBR set combining albedo, normal, and roughness layers for damp tundra grass. UV scaled 50× for close-up fidelity.'
                    }
                ],
                rendering: {
                    detail: 'High-density plane geometry with per-vertex normal recompute',
                    receivesShadows: true,
                    lightingModel: 'MeshStandardMaterial (PBR)'
                },
                tags: ['terrain', 'procedural', 'landscape']
            });
            
            // ═══ ADD DIRT PATHS ═══
            createDirtPaths();
            
            console.log('✅ Terrain created with grass/dirt variation');
        }
        
        // Create realistic grass texture
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base grass colors with variation
            const grassColors = ['#2d5a2d', '#3a7d44', '#4a8f54', '#356b38'];
            
            // Fill with base
            ctx.fillStyle = grassColors[1];
            ctx.fillRect(0, 0, 512, 512);
            
            // Add grass blade clumps
            for (let i = 0; i < 8000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const color = grassColors[Math.floor(Math.random() * grassColors.length)];
                ctx.fillStyle = color;
                ctx.fillRect(x, y, 2, 4 + Math.random() * 4);
            }
            
            // Add dirt patches (sparse)
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(${101 + Math.random() * 30}, ${67 + Math.random() * 20}, ${33 + Math.random() * 15}, ${0.3 + Math.random() * 0.3})`;
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                ctx.beginPath();
                ctx.arc(x, y, 10 + Math.random() * 20, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(50, 50);
            
            return texture;
        }
        
        // Create grass normal map
        function createGrassNormalMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#8080ff';
            ctx.fillRect(0, 0, 512, 512);
            
            // Grass blade bumps
            for (let i = 0; i < 5000; i++) {
                ctx.fillStyle = `rgba(${128 + Math.random() * 40}, ${128 + Math.random() * 40}, ${200 + Math.random() * 55}, 0.3)`;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, 1, 3);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(50, 50);
            
            return texture;
        }
        
        // Create grass roughness map
        function createGrassRoughnessMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#f0f0f0'; // High roughness
            ctx.fillRect(0, 0, 512, 512);
            
            // Slightly smoother patches
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(${200 + Math.random() * 55}, ${200 + Math.random() * 55}, ${200 + Math.random() * 55}, 0.3)`;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, Math.random() * 30, Math.random() * 30);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(50, 50);
            
            return texture;
        }
        
        // Create dirt paths connecting areas
        function createDirtPaths() {
            const dirtMat = new THREE.MeshStandardMaterial({
                color: 0x654321,
                roughness: 0.9,
                metalness: 0.0,
                map: createDirtTexture()
            });
            
            // Path from neighborhood to college
            const path1 = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 100),
                dirtMat
            );
            path1.rotation.x = -Math.PI / 2;
            path1.position.set(-10, 0.02, -25);
            path1.receiveShadow = true;
            worldObjects.add(path1);
            
            // Path from college to park
            const path2 = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 60),
                dirtMat
            );
            path2.rotation.x = -Math.PI / 2;
            path2.position.set(45, 0.02, -15);
            path2.receiveShadow = true;
            worldObjects.add(path2);
            
            // Path to forest
            const path3 = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 40),
                dirtMat
            );
            path3.rotation.x = -Math.PI / 2;
            path3.rotation.z = Math.PI / 4;
            path3.position.set(100, 0.02, -20);
            path3.receiveShadow = true;
            worldObjects.add(path3);
            
            console.log('✅ Dirt paths added');
        }
        
        // Create dirt texture
        function createDirtTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Base dirt color
            ctx.fillStyle = '#654321';
            ctx.fillRect(0, 0, 256, 256);
            
            // Add pebbles and texture
            for (let i = 0; i < 500; i++) {
                const variation = Math.random() * 0.3;
                ctx.fillStyle = `rgba(${101 + variation * 60}, ${67 + variation * 40}, ${33 + variation * 20}, ${0.3 + variation})`;
                ctx.beginPath();
                ctx.arc(Math.random() * 256, Math.random() * 256, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Tire tracks
            for (let i = 0; i < 10; i++) {
                ctx.strokeStyle = `rgba(50, 35, 20, 0.4)`;
                ctx.lineWidth = 2 + Math.random() * 2;
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * 256);
                ctx.lineTo(256, Math.random() * 256);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 10);
            
            return texture;
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // LIGHTING
        // ═══════════════════════════════════════════════════════════════════════
        
        function setupLighting() {
            // ═══ SUN (Main directional light) ═══
            const sun = new THREE.DirectionalLight(0xFFFAF0, 2.5);
            sun.position.set(100, 200, 100);
            sun.castShadow = true;
            
            // Optimized shadows (reduced resolution for performance)
            sun.shadow.mapSize.width = 1024; // Reduced from 4096
            sun.shadow.mapSize.height = 1024;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 500; // Reduced range
            sun.shadow.camera.left = -300;
            sun.shadow.camera.right = 300;
            sun.shadow.camera.top = 300;
            sun.shadow.camera.bottom = -300;
            sun.shadow.bias = -0.0001;
            sun.shadow.normalBias = 0.02;
            scene.add(sun);
            
            // ═══ AMBIENT (Base illumination) ═══
            const ambient = new THREE.AmbientLight(0xB0C4DE, 0.6);
            scene.add(ambient);
            
            // ═══ HEMISPHERE (Sky + Ground) ═══
            const hemi = new THREE.HemisphereLight(
                0x87CEEB,  // Sky color
                0x6B4423,  // Ground color
                0.8
            );
            hemi.position.set(0, 50, 0);
            scene.add(hemi);
            
            // ═══ FILL LIGHT (Soften shadows) ═══
            const fillLight = new THREE.DirectionalLight(0xE6F3FF, 0.4);
            fillLight.position.set(-50, 30, -50);
            scene.add(fillLight);
            
            // ═══ RIM LIGHT (Edge highlights) ═══
            const rimLight = new THREE.DirectionalLight(0xFFE4B5, 0.5);
            rimLight.position.set(-100, 100, -100);
            scene.add(rimLight);
            
            // ═══ FOG (Atmospheric depth) ═══
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);
            
            console.log('✅ Enhanced lighting setup');
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // KEYBOARD CONTROLS
        // ═══════════════════════════════════════════════════════════════════════
        
        function setupKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'KeyF': moveDown = true; break;
                    case 'Space':
                        moveUp = true;
                        break;
                    case 'KeyE':
                        // Ctrl+E to elevate
                        if (e.ctrlKey) {
                            moveUp = true;
                        }
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        sprint = true;
                        break;
                    case 'KeyC':
                        toggleCinematicMode();
                        break;
                    case 'KeyT':
                        document.querySelector('.stats-panel').style.display = 
                            document.querySelector('.stats-panel').style.display === 'none' ? 'block' : 'none';
                        break;
                    case 'KeyM':
                        toggleSound();
                        break;
                    case 'KeyI':
                        toggleInventory();
                        break;
                    case 'KeyJ':
                        toggleQuestUI();
                        break;
                    case 'KeyC':
                        toggleCrafting();
                        break;
                    case 'KeyV':
                        togglePersonMode();
                        break;
                    case 'Digit1':
                        if (playerAbilityManager) {
                            playerAbilityManager.useHotbarSlot(0);
                        }
                        break;
                    case 'Digit2':
                        if (playerAbilityManager) {
                            playerAbilityManager.useHotbarSlot(1);
                        }
                        break;
                    case 'Digit3':
                        if (playerAbilityManager) {
                            playerAbilityManager.useHotbarSlot(2);
                        }
                        break;
                    case 'KeyR':
                        // Test damage (for testing combat UI)
                        if (playerCombatStats) {
                            const damage = 10 + Math.random() * 15;
                            const isCrit = Math.random() > 0.8;
                            playerCombatStats.takeDamage(damage);
                            showDamageIndicator(damage, isCrit ? 'critical' : 'physical');
                            updateCombatUI();
                            console.log('💥 Test damage: -' + Math.ceil(damage));
                        }
                        break;
                    case 'KeyX':
                        // Test XP gain (for testing level progression)
                        addXP(50, 'test');
                        break;
                    case 'KeyN':
                        // Test Cinematic Dialogue (find nearest NPC)
                        const playerPos = controls.getObject().position;
                        let nearestNPC = null;
                        let nearestDist = Infinity;
                        
                        scene.traverse((obj) => {
                            if (obj.userData.isImportantNPC || obj.parent?.userData?.walkPath) {
                                const dist = playerPos.distanceTo(obj.position);
                                if (dist < nearestDist && dist < 20) {
                                    nearestDist = dist;
                                    nearestNPC = obj;
                                }
                            }
                        });
                        
                        if (nearestNPC) {
                            // DISABLED - Cinematic system removed
                            // nearestNPC.userData.isImportantNPC = true; // Temporarily mark as important
                            // startDialogueCinematic(nearestNPC);
                            console.log('Cinematic system disabled - KeyN trigger blocked');
                        } else {
                            console.log('⚠️ No NPCs nearby for cinematic');
                        }
                        break;
                    case 'KeyB':
                        // Cycle NPC behaviors (for testing physics)
                        const nearbyNPC = findNearestNPC();
                        if (nearbyNPC && nearbyNPC.userData.physicsController) {
                            const behaviors = ['idle', 'walking', 'running', 'sitting'];
                            const current = nearbyNPC.userData.physicsController.behaviorState;
                            const currentIndex = behaviors.indexOf(current);
                            const nextIndex = (currentIndex + 1) % behaviors.length;
                            const nextBehavior = behaviors[nextIndex];
                            
                            if (nextBehavior === 'sitting') {
                                nearbyNPC.userData.physicsController.setBehavior('sitting', {
                                    drinkingCoffee: Math.random() > 0.66,
                                    vaping: Math.random() > 0.5 && !nearbyNPC.userData.physicsController.stateData.drinkingCoffee
                                });
                            } else if (nextBehavior === 'running') {
                                nearbyNPC.userData.physicsController.setBehavior('running', { speed: 1.5 + Math.random() });
                            } else if (nextBehavior === 'walking') {
                                nearbyNPC.userData.physicsController.setBehavior('walking', { speed: 0.8 + Math.random() * 0.6 });
                            } else {
                                nearbyNPC.userData.physicsController.setBehavior('idle');
                            }
                            
                            console.log(`🎭 NPC behavior changed to: ${nextBehavior}`);
                        } else {
                            console.log('⚠️ No NPCs nearby');
                        }
                        break;
                    case 'KeyT':
                        // Toggle IK mode
                        if (!ikTarget) {
                            createIKTarget();
                            if (playerCharacter) {
                                activeIKController = new ArmIKController(playerCharacter, 'right');
                                activeIKController.setTarget(ikTarget.position);
                            }
                        } else {
                            // Remove IK target
                            scene.remove(ikTarget);
                            scene.remove(ikLine);
                            ikTarget = null;
                            ikLine = null;
                            if (activeIKController) {
                                activeIKController.release();
                                activeIKController = null;
                            }
                            console.log('🎯 IK mode disabled');
                        }
                        break;
                    case 'ArrowUp':
                        if (ikTarget) {
                            ikTarget.position.z -= 0.1;
                            if (activeIKController) activeIKController.setTarget(ikTarget.position);
                        }
                        break;
                    case 'ArrowDown':
                        if (ikTarget) {
                            ikTarget.position.z += 0.1;
                            if (activeIKController) activeIKController.setTarget(ikTarget.position);
                        }
                        break;
                    case 'ArrowLeft':
                        if (ikTarget) {
                            ikTarget.position.x -= 0.1;
                            if (activeIKController) activeIKController.setTarget(ikTarget.position);
                        }
                        break;
                    case 'ArrowRight':
                        if (ikTarget) {
                            ikTarget.position.x += 0.1;
                            if (activeIKController) activeIKController.setTarget(ikTarget.position);
                        }
                        break;
                    case 'PageUp':
                        if (ikTarget) {
                            ikTarget.position.y += 0.1;
                            if (activeIKController) activeIKController.setTarget(ikTarget.position);
                        }
                        break;
                    case 'PageDown':
                        if (ikTarget) {
                            ikTarget.position.y -= 0.1;
                            if (activeIKController) activeIKController.setTarget(ikTarget.position);
                        }
                        break;
                    case 'KeyM':
                        // Toggle telemetry display
                        showTelemetry = !showTelemetry;
                        if (showTelemetry && !telemetryDisplay) {
                            createTelemetryDisplay();
                        } else if (!showTelemetry && telemetryDisplay) {
                            telemetryDisplay.style.display = 'none';
                        } else if (showTelemetry && telemetryDisplay) {
                            telemetryDisplay.style.display = 'block';
                        }
                        console.log(showTelemetry ? '📊 Telemetry ON - Iteration values visible!' : '📊 Telemetry OFF');
                        break;
                    case 'KeyR':
                        // Start/stop recording
                        if (e.shiftKey) {
                            // Shift+R = stop recording
                            const frames = window.iterationRecorder.stop();
                            console.log(`⏹️ Stopped recording: ${frames.length} frames captured`);
                        } else {
                            // R = start recording
                            window.iterationRecorder.start();
                            if (!showTelemetry) {
                                showTelemetry = true;
                                if (!telemetryDisplay) createTelemetryDisplay();
                                telemetryDisplay.style.display = 'block';
                            }
                        }
                        break;
                    case 'KeyP':
                        // Playback recorded data
                        window.iterationRecorder.playback(e.shiftKey ? 0.5 : 1.0);
                        break;
                    case 'KeyE':
                        if (e.shiftKey) {
                            // Shift+E = Export CSV
                            window.iterationRecorder.exportToCSV();
                        } else if (e.ctrlKey) {
                            // Ctrl+E = Export Vertex Data
                            const recorder = window.iterationRecorder;
                            const vertices = recorder.frames.map((frame, i) => {
                                return {
                                    index: i,
                                    position: [
                                        frame.time,
                                        frame.joint.angle * 10,
                                        frame.joint.velocity
                                    ],
                                    normal: [0, 1, 0],
                                    uv: [i / recorder.frames.length, 0]
                                };
                            });
                            
                            const data = {
                                metadata: {
                                    vertexCount: vertices.length,
                                    format: 'position, normal, uv'
                                },
                                vertices: vertices
                            };
                            
                            const json = JSON.stringify(data, null, 2);
                            recorder.downloadFile(json, `vertex_data_${Date.now()}.json`, 'application/json');
                            console.log('💾 Exported', vertices.length, 'vertices');
                        } else {
                            // E = Export JSON
                            window.iterationRecorder.exportToJSON();
                        }
                        break;
                    case 'Equal':
                    case 'NumpadAdd':
                        // Zoom in minimap (+)
                        if (minimap && e.shiftKey) {
                            minimap.zoomIn();
                            console.log('🗺️ Minimap zoom: ' + minimap.zoom.toFixed(1) + 'x');
                        }
                        break;
                    case 'Minus':
                    case 'NumpadSubtract':
                        // Zoom out minimap (-)
                        if (minimap && e.shiftKey) {
                            minimap.zoomOut();
                            console.log('🗺️ Minimap zoom: ' + minimap.zoom.toFixed(1) + 'x');
                        }
                        break;
                    case 'KeyG':
                        // Toggle minimap grid
                        if (minimap) {
                            minimap.toggleGrid();
                            console.log('🗺️ Minimap grid: ' + (minimap.showGrid ? 'ON' : 'OFF'));
                        }
                        break;
                    case 'KeyH':
                        // Toggle fog of war
                        if (minimap) {
                            minimap.toggleFogOfWar();
                            console.log('🗺️ Fog of War: ' + (minimap.showFogOfWar ? 'ON' : 'OFF'));
                        }
                        break;
                    case 'KeyT':
                        // Open teleport menu
                        openTeleportMenu();
                        break;
                    case 'KeyK':
                        // Clear waypoint
                        if (minimap) {
                            minimap.clearWaypoint();
                            console.log('🗺️ Waypoint cleared');
                        }
                        break;
                    case 'F5':
                        // Quick save (slot 0)
                        e.preventDefault();
                        saveGame(0);
                        break;
                    case 'F9':
                        // Quick load (slot 0)
                        e.preventDefault();
                        loadGame(0);
                        break;
                    case 'KeyS':
                        // Manual save menu (Ctrl+S)
                        if (e.ctrlKey) {
                            e.preventDefault();
                            console.log('💾 Opening save menu...');
                            showSaveLoadMenu('save');
                        }
                        break;
                    case 'KeyL':
                        // Manual load menu (Ctrl+L)
                        if (e.ctrlKey) {
                            e.preventDefault();
                            console.log('📂 Opening load menu...');
                            showSaveLoadMenu('load');
                        }
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'KeyF': moveDown = false; break;
                    case 'Space':
                    case 'KeyE':
                        moveUp = false;
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        sprint = false;
                        break;
                }
            });
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // MOVEMENT
        // ═══════════════════════════════════════════════════════════════════════
        
        function updateMovement(delta) {
            if (!controls.isLocked && !cinematicMode) return;
            
            // Increased sprint speed: 50 → 100 (2x faster)
            const speed = sprint ? 100.0 : 20.0;
            
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= velocity.y * 10.0 * delta;
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.y = Number(moveUp) - Number(moveDown);
            direction.normalize();
            
            const isMoving = moveForward || moveBackward || moveLeft || moveRight;
            
            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
            if (moveUp || moveDown) velocity.y += direction.y * speed * delta;
            
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            controls.getObject().position.y += velocity.y * delta;
            
            // Footstep sounds
            if (isMoving && controls.getObject().position.y <= 2.1) {
                const footstepInterval = sprint ? 0.3 : 0.5;
                if (clock.getElapsedTime() - lastFootstep > footstepInterval) {
                    playFootstep();
                    lastFootstep = clock.getElapsedTime();
                }
            }
            
            // Keep above ground
            if (controls.getObject().position.y < 2) {
                controls.getObject().position.y = 2;
                velocity.y = 0;
            }
            
            // Update player character position and rotation
            if (playerCharacter) {
                playerCharacter.position.copy(controls.getObject().position);
                playerCharacter.position.y -= 1; // Character feet at ground level
                
                // Rotate character to face movement direction
                if (isMoving) {
                    const angle = Math.atan2(-velocity.x, -velocity.z);
                    playerCharacter.rotation.y = angle;
                    
                    // VSL CHARACTER ANIMATION
                    if (playerCharacter.userData.isVSL && playerCharacter.userData.vslCharacter) {
                        const vslChar = playerCharacter.userData.vslCharacter;
                        
                        // Apply walking motion via VSL
                        const walkIntensity = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
                        if (walkIntensity > 0.1) {
                            // Animate VSL skeleton for walking
                            const walkCycle = Math.sin(clock.getElapsedTime() * 10) * 0.5 * walkIntensity;
                            if (vslChar.skeleton.left_knee) vslChar.skeleton.left_knee.rotation.x = walkCycle;
                            if (vslChar.skeleton.right_knee) vslChar.skeleton.right_knee.rotation.x = -walkCycle;
                            if (vslChar.skeleton.left_elbow) vslChar.skeleton.left_elbow.rotation.x = -walkCycle * 0.5;
                            if (vslChar.skeleton.right_elbow) vslChar.skeleton.right_elbow.rotation.x = walkCycle * 0.5;
                        }
                    } else {
                        // LEGACY ANIMATION (if not VSL)
                        const parts = playerCharacter.userData.bodyParts;
                        const walkCycle = Math.sin(clock.getElapsedTime() * 10) * 0.5;
                        parts.leftLeg.rotation.x = walkCycle;
                        parts.rightLeg.rotation.x = -walkCycle;
                        parts.leftArm.rotation.x = -walkCycle * 0.5;
                        parts.rightArm.rotation.x = walkCycle * 0.5;
                    }
                }
                
                // Third person camera adjustment
                if (thirdPersonMode) {
                    // For VSL characters, follow the head position
                    let cameraFollowTarget = playerCharacter.position.clone();
                    if (playerCharacter.userData.isVSL && playerCharacter.userData.vslCharacter) {
                        // Get world position of head
                        const headJoint = playerCharacter.userData.vslCharacter.skeleton.head;
                        if (headJoint) {
                            const headWorldPos = new THREE.Vector3();
                            headJoint.getWorldPosition(headWorldPos);
                            cameraFollowTarget = headWorldPos;
                        }
                    }
                    
                    const offset = new THREE.Vector3(0, 2, -5);
                    offset.applyQuaternion(camera.quaternion);
                    camera.position.copy(cameraFollowTarget);
                    camera.position.add(offset);
                }
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // CINEMATIC MODE
        // ═══════════════════════════════════════════════════════════════════════
        
        function toggleCinematicMode() {
            cinematicMode = !cinematicMode;
            
            if (cinematicMode) {
                controls.unlock();
                cinematicProgress = 0;
                console.log('🎬 Cinematic mode ON');
            } else {
                console.log('🎬 Cinematic mode OFF');
            }
        }
        
        function updateCinematic(delta) {
            if (!cinematicMode) return;
            
            cinematicProgress += delta * 0.08; // Speed of tour
            
            // Define waypoints for cinematic path
            const waypoints = [
                // 1. Start above neighborhood (0-10s)
                { pos: [-100, 25, -20], lookAt: [-120, 5, 0], duration: 0.1 },
                { pos: [-120, 15, 0], lookAt: [-140, 5, 20], duration: 0.15 },
                
                // 2. Fly over houses (10-20s)
                { pos: [-140, 20, 30], lookAt: [-100, 0, 50], duration: 0.2 },
                { pos: [-80, 18, 40], lookAt: [-30, 8, 20], duration: 0.25 },
                
                // 3. Approach college (20-30s)
                { pos: [-50, 22, 10], lookAt: [-20, 10, 0], duration: 0.3 },
                { pos: [-10, 20, 20], lookAt: [10, 12, 0], duration: 0.35 },
                
                // 4. Circle around main college building (30-40s)
                { pos: [15, 25, -15], lookAt: [-10, 10, 0], duration: 0.4 },
                { pos: [0, 18, -30], lookAt: [-20, 8, 10], duration: 0.45 },
                
                // 5. Fly to park (40-50s)
                { pos: [30, 20, -10], lookAt: [60, 5, -20], duration: 0.5 },
                { pos: [60, 15, -30], lookAt: [70, 3, 0], duration: 0.55 },
                
                // 6. Through forest (50-60s)
                { pos: [90, 18, -10], lookAt: [120, 8, 0], duration: 0.6 },
                { pos: [130, 22, 20], lookAt: [160, 10, -20], duration: 0.65 },
                
                // 7. Approach lake (60-70s)
                { pos: [170, 25, -10], lookAt: [200, 5, 0], duration: 0.7 },
                { pos: [200, 15, -25], lookAt: [200, 3, 15], duration: 0.75 },
                
                // 8. Over mountains (70-80s)
                { pos: [240, 35, -20], lookAt: [280, 25, 0], duration: 0.8 },
                { pos: [300, 45, 10], lookAt: [350, 20, -30], duration: 0.85 },
                
                // 9. Descend to ocean (80-90s)
                { pos: [400, 40, 0], lookAt: [550, 10, 0], duration: 0.9 },
                { pos: [550, 25, -40], lookAt: [650, 5, 0], duration: 0.95 },
                
                // 10. Final ocean view (90-100s)
                { pos: [700, 30, 20], lookAt: [750, 8, -20], duration: 1.0 }
            ];
            
            // Find current segment
            let currentWaypoint = null;
            let nextWaypoint = null;
            let segmentProgress = 0;
            
            for (let i = 0; i < waypoints.length - 1; i++) {
                if (cinematicProgress >= waypoints[i].duration && 
                    cinematicProgress < waypoints[i + 1].duration) {
                    currentWaypoint = waypoints[i];
                    nextWaypoint = waypoints[i + 1];
                    const segmentDuration = nextWaypoint.duration - currentWaypoint.duration;
                    segmentProgress = (cinematicProgress - currentWaypoint.duration) / segmentDuration;
                    break;
                }
            }
            
            if (currentWaypoint && nextWaypoint) {
                // Smooth interpolation (ease in/out)
                const t = segmentProgress;
                const smoothT = t * t * (3 - 2 * t); // Smoothstep
                
                // Interpolate position
                camera.position.lerpVectors(
                    new THREE.Vector3(...currentWaypoint.pos),
                    new THREE.Vector3(...nextWaypoint.pos),
                    smoothT
                );
                
                // Interpolate look-at target
                const currentLookAt = new THREE.Vector3(...currentWaypoint.lookAt);
                const nextLookAt = new THREE.Vector3(...nextWaypoint.lookAt);
                const lookAtTarget = new THREE.Vector3().lerpVectors(currentLookAt, nextLookAt, smoothT);
                
                camera.lookAt(lookAtTarget);
            }
            
            // End after full tour (100 seconds)
            if (cinematicProgress > 1.0) {
                toggleCinematicMode();
                // Reset to starting position
                camera.position.set(0, 5, 10);
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // STATS UPDATE
        // ═══════════════════════════════════════════════════════════════════════
        
        function updateStats() {
            // Count objects and triangles
            let objectCount = 0;
            let triangleCount = 0;
            
            worldObjects.traverse((child) => {
                if (child.isMesh) {
                    objectCount++;
                    if (child.geometry) {
                        if (child.geometry.index) {
                            triangleCount += child.geometry.index.count / 3;
                        } else {
                            triangleCount += child.geometry.attributes.position.count / 3;
                        }
                    }
                }
            });
            
            document.getElementById('stat-objects').textContent = objectCount.toLocaleString();
            document.getElementById('stat-triangles').textContent = Math.floor(triangleCount).toLocaleString();
            document.getElementById('stat-drawcalls').textContent = renderer.info.render.calls;
            
            // Position
            const pos = camera.position;
            document.getElementById('stat-position').textContent = 
                `${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}`;
            
            // FPS
            frameCount++;
            const now = performance.now();
            if (now - lastFpsUpdate > 1000) {
                document.getElementById('stat-fps').textContent = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
            }
            
            // Update location
            updateLocation();
        }
        
        function updateLocation() {
            const pos = camera.position;
            let location = 'Unknown';
            let description = '';
            
            if (pos.x < -50) {
                location = 'Residential District';
                description = 'Suburban neighborhood';
            } else if (pos.x < 0) {
                location = 'College Campus';
                description = 'Academic buildings';
            } else if (pos.x < 50 && pos.z < 0) {
                location = 'City Park';
                description = 'Green space';
            } else if (pos.x < 100) {
                location = 'Forest';
                description = 'Dense woodland';
            } else if (pos.x < 150) {
                location = 'Lake';
                description = 'Freshwater body';
            } else if (pos.x < 200) {
                location = 'Mountain Range';
                description = 'Rocky peaks';
            } else {
                location = 'Ocean';
                description = 'Deep waters';
            }
            
            document.getElementById('location-name').textContent = location;
            document.getElementById('location-description').textContent = description;
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // MINIMAP
        // ═══════════════════════════════════════════════════════════════════════
        
        function setupMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            
            // Initialize MiniMap system with fog of war, markers, etc.
            minimap = new MiniMap(canvas, scene, camera, {
                worldSize: 500,
                zoom: 2.0,
                size: 200,
                position: { x: 10, y: 10 },
                rotateWithPlayer: false, // Keep north at top
                showGrid: true,
                showFogOfWar: true
            });
            
            // Add portal markers as POIs
            const portalLocations = [
                { pos: { x: -100, z: 0 }, label: '🏠 Neighborhood' },
                { pos: { x: 0, z: 0 }, label: '🎓 College' },
                { pos: { x: 100, z: 0 }, label: '🌳 Park' },
                { pos: { x: 150, z: 150 }, label: '🌲 Forest' },
                { pos: { x: 200, z: 200 }, label: '⛰️ Mountains' }
            ];
            
            portalLocations.forEach(portal => {
                minimap.addPOIMarker(portal.pos, portal.label, portal.label.charAt(0), '#4080ff');
            });
            
            console.log('✅ Enhanced Minimap initialized with fog of war, markers, and POIs');
        }
        
        function updateMinimap() {
            if (!minimap) return;
            
            // Update player position on minimap
            minimap.player = camera; // The minimap tracks the camera position
            
            // Update fog of war based on player position
            minimap.update(camera.position.x, camera.position.z, 0); // rotation = 0 for now
            
            // Update NPC markers if VSL characters exist
            if (vslCharacterGenerator && vslCharacterGenerator.characters) {
                const npcData = vslCharacterGenerator.characters.map(char => ({
                    character: char.root,
                    name: char.name || 'NPC',
                    isHostile: false
                }));
                minimap.updateNPCMarkers(npcData);
            }
            
            // Render the minimap
            minimap.render();
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // SAVE/LOAD SYSTEM
        // ═══════════════════════════════════════════════════════════════════════
        
        function initSaveSystem() {
            saveManager = new SaveManager(5); // 5 save slots
            saveManager.loadFromStorage(); // Load existing saves from localStorage
            saveManager.startAutoSave(); // Start auto-save timer
            console.log('✅ Save System initialized with auto-save enabled');
        }
        
        function createSaveData() {
            const saveData = new SaveData();
            
            // Save player position
            saveData.player.position = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            };
            saveData.player.rotation = controls.getObject().rotation.y;
            
            // Save combat stats
            if (playerCombatStats) {
                saveData.player.health = playerCombatStats.health;
                saveData.player.maxHealth = playerCombatStats.maxHealth;
                saveData.player.stamina = playerCombatStats.stamina;
                saveData.player.maxStamina = playerCombatStats.maxStamina;
                saveData.player.mana = playerCombatStats.mana;
                saveData.player.maxMana = playerCombatStats.maxMana;
                saveData.player.attack = playerCombatStats.attack;
                saveData.player.defense = playerCombatStats.defense;
            }
            
            // Save inventory
            if (inventoryManager) {
                saveData.inventory.slots = inventoryManager.inventory.map(item => ({
                    id: item.id,
                    name: item.name,
                    quantity: item.quantity,
                    type: item.type
                }));
            }
            
            // Save quests
            if (questManager) {
                saveData.quests.active = questManager.activeQuests.map(q => ({
                    id: q.id,
                    title: q.title,
                    description: q.description,
                    objectives: q.objectives
                }));
                saveData.quests.completed = questManager.completedQuests;
            }
            
            // Save world state (fog of war)
            if (minimap && minimap.fogOfWar) {
                saveData.world.exploredAreas = Array.from(minimap.fogOfWar.fogData);
            }
            
            // Save level progression
            if (typeof currentLevel !== 'undefined') {
                saveData.player.level = currentLevel;
                saveData.player.xp = currentXP;
            }
            
            return saveData;
        }
        
        function saveGame(slotId = 0) {
            if (!saveManager) {
                console.error('❌ Save system not initialized!');
                return false;
            }
            
            const saveData = createSaveData();
            const success = saveManager.saveToSlot(slotId, saveData);
            
            if (success) {
                console.log(`💾 Game saved to slot ${slotId}`);
                showNotification(`Game Saved to Slot ${slotId + 1}`, 'success');
                return true;
            } else {
                console.error(`❌ Failed to save to slot ${slotId}`);
                showNotification('Save Failed!', 'error');
                return false;
            }
        }
        
        function loadGame(slotId = 0) {
            if (!saveManager) {
                console.error('❌ Save system not initialized!');
                return false;
            }
            
            const saveData = saveManager.loadFromSlot(slotId);
            
            if (!saveData) {
                console.error(`❌ No save data in slot ${slotId}`);
                showNotification('No Save Data Found!', 'error');
                return false;
            }
            
            // Restore player position
            camera.position.set(
                saveData.player.position.x,
                saveData.player.position.y,
                saveData.player.position.z
            );
            controls.getObject().rotation.y = saveData.player.rotation;
            
            // Restore combat stats
            if (playerCombatStats) {
                playerCombatStats.health = saveData.player.health;
                playerCombatStats.maxHealth = saveData.player.maxHealth;
                playerCombatStats.stamina = saveData.player.stamina;
                playerCombatStats.maxStamina = saveData.player.maxStamina;
                playerCombatStats.mana = saveData.player.mana;
                playerCombatStats.maxMana = saveData.player.maxMana;
                playerCombatStats.attack = saveData.player.attack;
                playerCombatStats.defense = saveData.player.defense;
                updateCombatUI();
            }
            
            // Restore inventory
            if (inventoryManager && saveData.inventory.slots) {
                inventoryManager.inventory = [];
                saveData.inventory.slots.forEach(itemData => {
                    inventoryManager.addItem(itemData);
                });
                updateInventoryUI();
            }
            
            // Restore quests
            if (questManager && saveData.quests) {
                questManager.activeQuests = saveData.quests.active.map(q => ({
                    id: q.id,
                    title: q.title,
                    description: q.description,
                    objectives: q.objectives.map(obj => ({ ...obj }))
                }));
                questManager.completedQuests = saveData.quests.completed || [];
                updateQuestUI();
            }
            
            // Restore fog of war
            if (minimap && minimap.fogOfWar && saveData.world.exploredAreas) {
                minimap.fogOfWar.fogData = new Uint8Array(saveData.world.exploredAreas);
                minimap.fogOfWar.needsUpdate = true;
            }
            
            // Restore level
            if (saveData.player.level) {
                currentLevel = saveData.player.level;
                currentXP = saveData.player.xp;
                updateLevelUI();
            }
            
            console.log(`📂 Game loaded from slot ${slotId}`);
            showNotification(`Game Loaded from Slot ${slotId + 1}`, 'success');
            return true;
        }
        
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : '#17a2b8'};
                color: white;
                padding: 15px 30px;
                border-radius: 5px;
                font-size: 16px;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                animation: slideDown 0.3s ease-out;
            `;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideUp 0.3s ease-in';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }
        
        function showSaveLoadMenu(mode = 'save') {
            // Check if menu already exists
            let menu = document.getElementById('save-load-menu');
            if (menu) {
                menu.remove(); // Close if already open
                return;
            }
            
            // Create menu
            menu = document.createElement('div');
            menu.id = 'save-load-menu';
            menu.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.95);
                border: 2px solid #00ffff;
                border-radius: 10px;
                padding: 30px;
                z-index: 10000;
                min-width: 500px;
                max-width: 600px;
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            `;
            
            // Title
            const title = document.createElement('h2');
            title.textContent = mode === 'save' ? '💾 Save Game' : '📂 Load Game';
            title.style.cssText = `
                color: #00ffff;
                margin: 0 0 20px 0;
                text-align: center;
                font-size: 24px;
            `;
            menu.appendChild(title);
            
            // Save slots
            for (let i = 0; i < saveManager.maxSlots; i++) {
                const slot = saveManager.slots[i];
                const summary = slot.getSummary();
                
                const slotDiv = document.createElement('div');
                slotDiv.style.cssText = `
                    background: ${summary.empty ? 'rgba(50, 50, 50, 0.5)' : 'rgba(0, 100, 100, 0.3)'};
                    border: 1px solid ${summary.empty ? '#555' : '#00ffff'};
                    border-radius: 5px;
                    padding: 15px;
                    margin: 10px 0;
                    cursor: pointer;
                    transition: all 0.2s;
                `;
                
                slotDiv.onmouseenter = () => {
                    slotDiv.style.background = summary.empty ? 'rgba(70, 70, 70, 0.7)' : 'rgba(0, 150, 150, 0.5)';
                    slotDiv.style.borderColor = '#00ffff';
                };
                
                slotDiv.onmouseleave = () => {
                    slotDiv.style.background = summary.empty ? 'rgba(50, 50, 50, 0.5)' : 'rgba(0, 100, 100, 0.3)';
                    slotDiv.style.borderColor = summary.empty ? '#555' : '#00ffff';
                };
                
                slotDiv.onclick = () => {
                    if (mode === 'save') {
                        saveGame(i);
                    } else {
                        if (!summary.empty) {
                            loadGame(i);
                        } else {
                            showNotification('Empty Save Slot!', 'error');
                        }
                    }
                    menu.remove();
                };
                
                if (summary.empty) {
                    slotDiv.innerHTML = `
                        <div style="color: #888; font-size: 18px; font-weight: bold;">Slot ${i + 1}: Empty</div>
                        <div style="color: #666; font-size: 14px; margin-top: 5px;">${mode === 'save' ? 'Click to save' : 'No data'}</div>
                    `;
                } else {
                    const date = new Date(summary.timestamp);
                    const dateStr = date.toLocaleString();
                    
                    slotDiv.innerHTML = `
                        <div style="color: #00ffff; font-size: 18px; font-weight: bold;">Slot ${i + 1}</div>
                        <div style="color: #fff; font-size: 14px; margin-top: 5px;">
                            📍 Position: (${Math.floor(summary.location.x)}, ${Math.floor(summary.location.z)})
                        </div>
                        <div style="color: #aaa; font-size: 12px; margin-top: 5px;">
                            🕒 ${dateStr}
                        </div>
                        <div style="color: #4f4; font-size: 12px;">
                            ❤️ Health: ${summary.health} | ⭐ Level: ${summary.level || 1}
                        </div>
                    `;
                }
                
                menu.appendChild(slotDiv);
            }
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close (ESC)';
            closeBtn.style.cssText = `
                width: 100%;
                padding: 10px;
                margin-top: 20px;
                background: #dc3545;
                color: white;
                border: none;
                border-radius: 5px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
            `;
            closeBtn.onclick = () => menu.remove();
            menu.appendChild(closeBtn);
            
            // ESC to close
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    menu.remove();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
            
            document.body.appendChild(menu);
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // FAST TRAVEL PORTAL SYSTEM
        // ═══════════════════════════════════════════════════════════════════════
        
        const portals = [];
        let portalParticles = [];
        let portalMenuVisible = false;
        let currentPortal = null;
        
        const portalLocations = [
            { name: '🏘️ Neighborhood', position: { x: -120, y: 2, z: 0 }, color: 0x4488ff },
            { name: '🏛️ College Campus', position: { x: -20, y: 2, z: 20 }, color: 0xff8844 },
            { name: '🌳 City Park', position: { x: 60, y: 2, z: -20 }, color: 0x44ff88 },
            { name: '🌊 Ocean Beach', position: { x: 700, y: 2, z: 0 }, color: 0x88ddff },
            { name: '⛰️ Mountain Forest', position: { x: -200, y: 2, z: 200 }, color: 0xaa44ff }
        ];
        
        async function createFastTravelPortals() {
            console.log('🌀 Creating fast travel portals...');
            
            portalLocations.forEach((loc, index) => {
                // Create portal ring
                const ringGeo = new THREE.TorusGeometry(2, 0.3, 16, 50);
                const ringMat = new THREE.MeshStandardMaterial({
                    color: loc.color,
                    emissive: loc.color,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.set(loc.position.x, loc.position.y, loc.position.z);
                ring.rotation.x = Math.PI / 2;
                
                // Create inner glowing disc
                const discGeo = new THREE.CircleGeometry(1.8, 32);
                const discMat = new THREE.MeshBasicMaterial({
                    color: loc.color,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const disc = new THREE.Mesh(discGeo, discMat);
                disc.position.copy(ring.position);
                disc.rotation.x = Math.PI / 2;
                
                // Create particle system for portal
                const particleCount = 100;
                const particleGeo = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 2;
                    positions[i] = Math.cos(angle) * radius;
                    positions[i + 1] = (Math.random() - 0.5) * 0.5;
                    positions[i + 2] = Math.sin(angle) * radius;
                }
                
                particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const particleMat = new THREE.PointsMaterial({
                    color: loc.color,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                const particles = new THREE.Points(particleGeo, particleMat);
                particles.position.copy(ring.position);
                
                // Create portal group
                const portalGroup = new THREE.Group();
                portalGroup.add(ring);
                portalGroup.add(disc);
                portalGroup.add(particles);
                portalGroup.userData.portalData = loc;
                portalGroup.userData.particleSystem = particles;
                portalGroup.userData.ring = ring;
                portalGroup.userData.disc = disc;
                
                worldObjects.add(portalGroup);
                portals.push(portalGroup);
                
                // Create floating label
                createPortalLabel(loc);
            });
            
            console.log(`✅ Created ${portals.length} fast travel portals`);
        }
        
        function createPortalLabel(loc) {
            // Create canvas for text
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Draw background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 512, 128);
            
            // Draw text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(loc.name, 256, 64);
            
            // Create sprite
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.set(loc.position.x, loc.position.y + 4, loc.position.z);
            sprite.scale.set(8, 2, 1);
            
            worldObjects.add(sprite);
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // NPC AI SYSTEM WITH PROXIMITY REACTIONS
        // ═══════════════════════════════════════════════════════════════════════
        
        const NPC_REACTIONS = {
            NOTICE_DISTANCE: 15,      // NPCs notice player at this distance
            GREET_DISTANCE: 8,        // NPCs greet/wave at this distance
            PERSONAL_SPACE: 3,        // NPCs back away if player gets this close
            RUN_DISTANCE: 1.5,        // NPCs run if player is THIS close
            INTERACTION_COOLDOWN: 5000 // 5 seconds between reactions
        };
        
        function updateNPCAI(delta) {
            if (!camera || cinematicMode) return;
            
            const playerPos = camera.position;
            
            // Update all NPCs in worldObjects
            worldObjects.children.forEach(obj => {
                // Check if this is an NPC
                if (obj.userData.walkPath || obj.userData.talking) {
                    updateNPCBehavior(obj, playerPos, delta);
                }
            });
            
            // Update VSL characters with proximity AI
            if (vslCharacterGenerator && vslCharacterGenerator.characters) {
                vslCharacterGenerator.characters.forEach(char => {
                    if (char.root && char.name !== 'Player_VSL') {
                        updateVSLCharacterAI(char, playerPos, delta);
                    }
                });
            }
        }
        
        function updateNPCBehavior(npc, playerPos, delta) {
            if (!npc.position) return;
            
            const distanceToPlayer = npc.position.distanceTo(playerPos);
            
            // Initialize NPC state if needed
            if (!npc.userData.aiState) {
                npc.userData.aiState = {
                    state: 'idle',
                    lastReaction: 0,
                    originalPosition: npc.position.clone(),
                    lookAtPlayer: false,
                    emotion: 'neutral'
                };
            }
            
            const aiState = npc.userData.aiState;
            const now = Date.now();
            
            // PROXIMITY REACTIONS
            if (distanceToPlayer < NPC_REACTIONS.RUN_DISTANCE) {
                // TOO CLOSE! Run away!
                if (aiState.state !== 'running') {
                    aiState.state = 'running';
                    aiState.emotion = 'scared';
                    console.log('😱 NPC running away - too close!');
                }
                
                // Run away from player
                const awayDir = new THREE.Vector3()
                    .subVectors(npc.position, playerPos)
                    .normalize();
                npc.position.add(awayDir.multiplyScalar(delta * 5)); // Fast run
                npc.lookAt(playerPos); // Look at threat while running
                
            } else if (distanceToPlayer < NPC_REACTIONS.PERSONAL_SPACE) {
                // Personal space violated - back away slowly
                if (aiState.state !== 'backing_away' && now - aiState.lastReaction > NPC_REACTIONS.INTERACTION_COOLDOWN) {
                    aiState.state = 'backing_away';
                    aiState.emotion = 'uncomfortable';
                    aiState.lastReaction = now;
                    console.log('😬 NPC backing away - personal space');
                }
                
                const awayDir = new THREE.Vector3()
                    .subVectors(npc.position, playerPos)
                    .normalize();
                npc.position.add(awayDir.multiplyScalar(delta * 1.5)); // Slow back away
                npc.lookAt(playerPos);
                
            } else if (distanceToPlayer < NPC_REACTIONS.GREET_DISTANCE) {
                // Greeting distance - wave and look at player
                if (aiState.state !== 'greeting' && now - aiState.lastReaction > NPC_REACTIONS.INTERACTION_COOLDOWN) {
                    aiState.state = 'greeting';
                    aiState.emotion = 'friendly';
                    aiState.lastReaction = now;
                    playNPCGreeting(npc, distanceToPlayer);
                }
                
                // Look at player
                npc.lookAt(new THREE.Vector3(playerPos.x, npc.position.y, playerPos.z));
                aiState.lookAtPlayer = true;
                
            } else if (distanceToPlayer < NPC_REACTIONS.NOTICE_DISTANCE) {
                // Awareness distance - glance at player occasionally
                if (aiState.state === 'idle' && Math.random() < 0.01) { // 1% chance per frame
                    aiState.state = 'noticed';
                    aiState.emotion = 'curious';
                    aiState.lookAtPlayer = true;
                }
                
                if (aiState.lookAtPlayer) {
                    npc.lookAt(new THREE.Vector3(playerPos.x, npc.position.y, playerPos.z));
                }
                
            } else {
                // Far away - normal behavior
                if (aiState.state !== 'idle' && aiState.state !== 'walking') {
                    aiState.state = 'idle';
                    aiState.emotion = 'neutral';
                    aiState.lookAtPlayer = false;
                }
                
                // Normal walking behavior
                if (npc.userData.walkPath && aiState.state === 'idle') {
                    updateNPCWalking(npc, delta);
                }
            }
            
            // Color-code NPCs by emotion (for visibility)
            if (npc.userData.bodyParts && npc.userData.bodyParts.body) {
                const body = npc.userData.bodyParts.body;
                if (body.material) {
                    switch (aiState.emotion) {
                        case 'scared':
                            body.material.color.setHex(0xff4444); // Red
                            break;
                        case 'uncomfortable':
                            body.material.color.setHex(0xffaa44); // Orange
                            break;
                        case 'friendly':
                            body.material.color.setHex(0x44ff44); // Green
                            break;
                        case 'curious':
                            body.material.color.setHex(0x44aaff); // Blue
                            break;
                        default:
                            body.material.color.setHex(0xffc0c0); // Default skin tone
                    }
                }
            }
        }
        
        function updateNPCWalking(npc, delta) {
            const walkData = npc.userData.walkPath;
            
            // Random turning
            if (Math.random() < walkData.turnChance) {
                npc.rotation.y += (Math.random() - 0.5) * 0.5;
            }
            
            // Move forward
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(npc.quaternion);
            npc.position.add(forward.multiplyScalar(walkData.speed));
            
            // Random pausing
            if (Math.random() < walkData.pauseChance) {
                walkData.speed = 0;
                setTimeout(() => {
                    walkData.speed = 0.05 + Math.random() * 0.03;
                }, walkData.pauseDuration * 1000);
            }
        }
        
        function updateVSLCharacterAI(char, playerPos, delta) {
            if (!char.root) return;
            
            const distanceToPlayer = char.root.position.distanceTo(playerPos);
            
            // Initialize AI state
            if (!char.aiState) {
                char.aiState = {
                    state: 'idle',
                    lastReaction: 0,
                    patrolPoints: [
                        char.root.position.clone(),
                        char.root.position.clone().add(new THREE.Vector3(10, 0, 0)),
                        char.root.position.clone().add(new THREE.Vector3(10, 0, 10)),
                        char.root.position.clone().add(new THREE.Vector3(0, 0, 10))
                    ],
                    currentPatrolIndex: 0,
                    moveSpeed: 0.5
                };
            }
            
            const aiState = char.aiState;
            const now = Date.now();
            
            // PROXIMITY REACTIONS
            if (distanceToPlayer < NPC_REACTIONS.RUN_DISTANCE) {
                // Run away!
                const awayDir = new THREE.Vector3()
                    .subVectors(char.root.position, playerPos)
                    .normalize();
                char.root.position.add(awayDir.multiplyScalar(delta * 3));
                
                // Apply running animation
                if (vslCharacterGenerator) {
                    vslCharacterGenerator.executeVSL(char.name, 'left_leg.kick.fast');
                    vslCharacterGenerator.executeVSL(char.name, 'right_leg.kick.fast');
                }
                
            } else if (distanceToPlayer < NPC_REACTIONS.GREET_DISTANCE) {
                // Wave at player
                if (now - aiState.lastReaction > NPC_REACTIONS.INTERACTION_COOLDOWN) {
                    aiState.lastReaction = now;
                    
                    if (vslCharacterGenerator) {
                        vslCharacterGenerator.executeVSL(char.name, 'right_arm.wave');
                        vslCharacterGenerator.executeVSL(char.name, 'head.nod');
                    }
                    
                    console.log(`👋 ${char.name} waves at player!`);
                }
                
                // Look at player
                char.root.lookAt(new THREE.Vector3(playerPos.x, char.root.position.y, playerPos.z));
                
            } else if (distanceToPlayer > 30) {
                // Far away - patrol behavior
                const targetPoint = aiState.patrolPoints[aiState.currentPatrolIndex];
                const distToTarget = char.root.position.distanceTo(targetPoint);
                
                if (distToTarget < 2) {
                    // Reached patrol point, move to next
                    aiState.currentPatrolIndex = (aiState.currentPatrolIndex + 1) % aiState.patrolPoints.length;
                } else {
                    // Move toward patrol point
                    const dir = new THREE.Vector3()
                        .subVectors(targetPoint, char.root.position)
                        .normalize();
                    char.root.position.add(dir.multiplyScalar(delta * aiState.moveSpeed));
                    char.root.lookAt(targetPoint);
                    
                    // Apply walking animation
                    if (vslCharacterGenerator && Math.random() < 0.1) {
                        vslCharacterGenerator.executeVSL(char.name, 'left_leg.step');
                        vslCharacterGenerator.executeVSL(char.name, 'right_arm.swing.gentle');
                    }
                }
            }
        }
        
        function playNPCGreeting(npc, distance) {
            const greetings = [
                `👋 Hey there!`,
                `😊 Hello!`,
                `🙂 Hi neighbor!`,
                `👍 What's up?`,
                `😄 Nice day!`
            ];
            
            const greeting = greetings[Math.floor(Math.random() * greetings.length)];
            console.log(`${greeting} (${distance.toFixed(1)}m away)`);
            
            // Create floating text (optional - can be visible in-world)
            createFloatingText(npc.position, greeting);
        }
        
        function createFloatingText(position, text) {
            // Create canvas for text
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = '24px Arial';
            ctx.fillStyle = '#00FFFF';
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 8);
            
            // Create sprite
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            sprite.position.set(position.x, position.y + 3, position.z);
            sprite.scale.set(4, 1, 1);
            
            scene.add(sprite);
            
            // Fade out and remove
            let opacity = 1;
            const fadeInterval = setInterval(() => {
                opacity -= 0.05;
                sprite.material.opacity = opacity;
                sprite.position.y += 0.02;
                
                if (opacity <= 0) {
                    scene.remove(sprite);
                    clearInterval(fadeInterval);
                }
            }, 50);
        }
        
        function checkPortalProximity() {
            if (!camera) return;
            
            const playerPos = camera.position;
            let nearestPortal = null;
            let nearestDist = Infinity;
            
            portals.forEach(portal => {
                const portalPos = portal.position;
                const dist = playerPos.distanceTo(portalPos);
                
                if (dist < 5 && dist < nearestDist) {
                    nearestPortal = portal;
                    nearestDist = dist;
                }
            });
            
            if (nearestPortal && !portalMenuVisible) {
                currentPortal = nearestPortal;
                showPortalMenu();
            } else if (!nearestPortal && portalMenuVisible) {
                hidePortalMenu();
            }
        }
        
        function showPortalMenu() {
            portalMenuVisible = true;
            const menu = document.getElementById('portalMenu');
            if (menu) {
                menu.style.display = 'block';
                populatePortalMenu();
            }
        }
        
        function hidePortalMenu() {
            portalMenuVisible = false;
            const menu = document.getElementById('portalMenu');
            if (menu) menu.style.display = 'none';
        }
        
        function populatePortalMenu() {
            const list = document.getElementById('portalList');
            if (!list) return;
            
            list.innerHTML = '<h3 style="margin: 0 0 15px 0; color: #4488ff;">🌀 Fast Travel</h3>';
            
            portalLocations.forEach((loc, index) => {
                const btn = document.createElement('button');
                btn.className = 'portal-btn';
                btn.textContent = loc.name;
                btn.onclick = () => teleportTo(index);
                list.appendChild(btn);
            });
        }
        
        function teleportTo(index) {
            const destination = portalLocations[index];
            
            // Smooth camera transition
            const startPos = camera.position.clone();
            const endPos = new THREE.Vector3(
                destination.position.x,
                destination.position.y + 3,
                destination.position.z + 5
            );
            
            let progress = 0;
            const duration = 1.5; // seconds
            
            function animateTeleport() {
                progress += clock.getDelta() / duration;
                
                if (progress < 1) {
                    camera.position.lerpVectors(startPos, endPos, easeInOutCubic(progress));
                    requestAnimationFrame(animateTeleport);
                } else {
                    camera.position.copy(endPos);
                    hidePortalMenu();
                    
                    // Play teleport sound
                    if (audioSystem && audioSystem.enabled) {
                        playTeleportSound();
                    }
                    
                    console.log(`✨ Teleported to ${destination.name}`);
                }
            }
            
            animateTeleport();
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function playTeleportSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.5);
        }
        
        function animatePortals(time) {
            portals.forEach((portal, index) => {
                // Rotate rings
                const ring = portal.userData.ring;
                if (ring) {
                    ring.rotation.z += 0.01;
                }
                
                // Pulse disc opacity
                const disc = portal.userData.disc;
                if (disc && disc.material) {
                    disc.material.opacity = 0.2 + Math.sin(time * 2 + index) * 0.15;
                }
                
                // Animate particles in spiral
                const particles = portal.userData.particleSystem;
                if (particles) {
                    particles.rotation.z -= 0.02;
                    
                    const positions = particles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        const angle = (time + i / 3) * 0.5;
                        const radius = 1.5 + Math.sin(time + i / 10) * 0.3;
                        positions[i] = Math.cos(angle) * radius;
                        positions[i + 2] = Math.sin(angle) * radius;
                        positions[i + 1] = Math.sin(time * 2 + i / 5) * 0.3;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }
            });
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // ANIMATION LOOP
        // ═══════════════════════════════════════════════════════════════════════
        
        function animate() {
            try {
                requestAnimationFrame(animate);
                
                const frameStart = performance.now();
                const delta = clock.getDelta();
                const time = clock.getElapsedTime();
                
                // Performance monitoring (auto-adjust quality)
                if (frameTimeSamples.length < 120) { // First 2 seconds
                    frameTimeSamples.push(delta * 1000);
                    if (frameTimeSamples.length === 120) {
                        avgFrameTime = frameTimeSamples.reduce((a, b) => a + b) / 120;
                        const fps = 1000 / avgFrameTime;
                        console.log(`📊 Average FPS: ${Math.round(fps)} (${avgFrameTime.toFixed(2)}ms per frame)`);
                        
                        // Auto-adjust quality for slower machines
                        if (fps < 30 && !performanceWarningShown) {
                            console.warn('⚠️ Low FPS detected. Consider reducing quality settings.');
                            performanceWarningShown = true;
                            // Reduce shadow quality
                            renderer.shadowMap.enabled = false;
                            console.log('🔧 Disabled shadows for performance');
                        }
                    }
                }
            
            if (cinematicMode) {
                updateCinematic(delta);
            } else if (false) { // DISABLED - dialogueCinematicActive check removed
                // updateDialogueCinematic(delta); // DISABLED
            } else {
                updateMovement(delta);
            }
            // Update VSL characters
            if (vslCharacterGenerator) {
                vslCharacterGenerator.update(time, delta);
            }
            
            // Update ability cooldowns
            if (playerAbilityManager) {
                playerAbilityManager.update(delta);
            }
            
            // Update telemetry display (COMMENTED OUT - may not be in scope)
            // updateTelemetryDisplay(delta);
            
            //
            
            
            // Animate portals
            animatePortals(time);
            
            // Check portal proximity
            checkPortalProximity();
            
            // Update NPC AI and proximity reactions
            updateNPCAI(delta);
            
            // Create frustum for culling
            const frustum = new THREE.Frustum();
            const cameraMatrix = new THREE.Matrix4().multiplyMatrices(
                camera.projectionMatrix,
                camera.matrixWorldInverse
            );
            frustum.setFromProjectionMatrix(cameraMatrix);
            
            // Distance-based activation ranges
            const npcActivationDistance = 150; // NPCs
            const environmentActivationDistance = 200; // Fish, birds, water animations
            const buildingLOD0Distance = 100; // High detail buildings
            const buildingLOD1Distance = 300; // Medium detail buildings  
            const buildingLOD2Distance = 500; // Low detail buildings (simplified)
            const buildingCullDistance = 800; // Beyond this, hide completely
            const playerPosition = camera.position;
            
            // Animate water surfaces (only if nearby)
            worldObjects.traverse((child) => {
                if (child.userData.animate) {
                    // Check distance to water surface
                    const distanceToWater = child.position.distanceTo(playerPosition);
                    if (distanceToWater < environmentActivationDistance) {
                        child.userData.animate(time);
                    }
                }
            });
            
            // Animate fish swimming (with culling)
            worldObjects.traverse((child) => {
                if (child.userData.swimPath) {
                    // CULLING: Only animate fish within range and in view
                    const distanceToPlayer = child.position.distanceTo(playerPosition);
                    const isInRange = distanceToPlayer < environmentActivationDistance;
                    const isInFrustum = frustum.containsPoint(child.position);
                    
                    if (!isInRange && !isInFrustum) {
                        return; // Skip fish animation if too far or not visible
                    }
                    
                    const path = child.userData.swimPath;
                    if (path.center) {
                        // Lake fish - circular swimming
                        const angle = time * path.speed + path.offset;
                        child.position.x = path.center.x + Math.cos(angle) * path.radius;
                        child.position.z = path.center.z + Math.sin(angle) * path.radius;
                        child.rotation.y = angle + Math.PI / 2;
                        
                        // Bob up and down
                        child.position.y = -0.5 + Math.sin(time * 2 + path.offset) * 0.2;
                    } else {
                        // Ocean creatures - forward swimming
                        child.position.x += Math.cos(child.rotation.y) * path.speed * delta * 10;
                        child.position.z += Math.sin(child.rotation.y) * path.speed * delta * 10;
                        
                        // Gentle turning
                        child.rotation.y += Math.sin(time * 0.5 + path.offset) * 0.01;
                        
                        // Wrap around if too far
                        if (child.position.x > 1000) child.position.x = 500;
                        if (child.position.x < 500) child.position.x = 1000;
                    }
                }
                
                // Animate birds flying (with culling)
                if (child.userData.flightPath) {
                    // CULLING: Only animate birds within range
                    const distanceToPlayer = child.position.distanceTo(playerPosition);
                    const isInRange = distanceToPlayer < environmentActivationDistance;
                    
                    if (!isInRange) {
                        return; // Skip bird animation if too far
                    }
                    
                    const path = child.userData.flightPath;
                    const angle = time * path.speed + path.offset;
                    child.position.x += Math.cos(angle) * 0.5;
                    child.position.z += Math.sin(angle) * 0.5;
                    child.position.y = 8 + Math.sin(time * 2 + path.offset) * 3;
                    child.rotation.y = angle;
                    
                    // Flap wings
                    if (child.children.length > 2) {
                        child.children[2].rotation.y = Math.sin(time * 10) * 0.3;
                        child.children[3].rotation.y = -Math.sin(time * 10) * 0.3;
                    }
                }
                
                // Animate walking creatures (humans, deer, rabbits, birds)
                if (child.userData.walkPath) {
                    const path = child.userData.walkPath;
                    
                    // CULLING: Check if NPC is in view and within range
                    const distanceToPlayer = child.position.distanceTo(playerPosition);
                    const isInRange = distanceToPlayer < npcActivationDistance;
                    const isInFrustum = frustum.containsPoint(child.position);
                    
                    // Only process if visible or nearby
                    if (!isInRange && !isInFrustum) {
                        // NPC is far away and not visible - skip animation but track state
                        if (!child.userData.backgroundState) {
                            child.userData.backgroundState = {
                                mood: Math.random(), // 0-1 mood state
                                energy: 0.8 + Math.random() * 0.2, // Energy level
                                lastThought: Date.now()
                            };
                        }
                        // Update background personality slowly (every ~5 seconds)
                        if (Date.now() - child.userData.backgroundState.lastThought > 5000) {
                            child.userData.backgroundState.mood = Math.max(0, Math.min(1, 
                                child.userData.backgroundState.mood + (Math.random() - 0.5) * 0.1
                            ));
                            child.userData.backgroundState.lastThought = Date.now();
                        }
                        return; // Skip animation processing
                    }
                    
                    // Check if paused
                    if (!child.userData.pauseTimer || child.userData.pauseTimer <= 0) {
                        // Occasionally pause if pauseChance is set
                        if (path.pauseChance && Math.random() < path.pauseChance) {
                            child.userData.pauseTimer = path.pauseDuration || 3;
                            child.userData.isPaused = true;
                        } else {
                            // Move forward
                            const moveSpeed = path.speed * delta * 10;
                            child.position.x += Math.cos(child.rotation.y) * moveSpeed;
                            child.position.z += Math.sin(child.rotation.y) * moveSpeed;
                            child.userData.isPaused = false;
                        }
                    } else {
                        // Count down pause timer
                        child.userData.pauseTimer -= delta;
                        child.userData.isPaused = true;
                        
                        // Look around while paused
                        if (child.children.length > 0) {
                            const head = child.children[0];
                            if (head) {
                                head.rotation.y = Math.sin(time * 0.5) * 0.3;
                            }
                        }
                    }
                    
                    // Random turning (only when not paused)
                    if (!child.userData.isPaused && Math.random() < path.turnChance) {
                        child.rotation.y += (Math.random() - 0.5) * Math.PI / 4;
                    }
                    
                    // Boundary checking
                    if (path.bounds) {
                        if (child.position.x < path.bounds.minX || child.position.x > path.bounds.maxX ||
                            child.position.z < path.bounds.minZ || child.position.z > path.bounds.maxZ) {
                            // Turn around
                            child.rotation.y += Math.PI;
                        }
                    }
                    
                    // Walking animation for humans (only when moving)
                    if (!child.userData.isPaused && child.userData.legL && child.userData.legR) {
                        child.userData.walkCycle = (child.userData.walkCycle || 0) + delta * 3; // Slower walk cycle
                        const legSwing = Math.sin(child.userData.walkCycle) * 0.25; // Reduced swing
                        child.userData.legL.rotation.x = legSwing;
                        child.userData.legR.rotation.x = -legSwing;
                        child.userData.armL.rotation.x = -legSwing * 0.4;
                        child.userData.armR.rotation.x = legSwing * 0.4;
                    }
                    
                    // Pecking animation for ground birds
                    if (path.pecking && Math.random() < 0.01) {
                        // Stop and peck
                        child.rotation.x = -Math.PI / 4;
                        setTimeout(() => {
                            child.rotation.x = 0;
                        }, 500);
                    }
                }
                
                // Animate sitting NPCs
                if (child.userData.sitting) {
                    const sitting = child.userData.sitting;
                    
                    // CULLING: Check if NPC is in view and within range
                    const distanceToPlayer = child.position.distanceTo(playerPosition);
                    const isInRange = distanceToPlayer < npcActivationDistance;
                    const isInFrustum = frustum.containsPoint(child.position);
                    
                    // Only process if visible or nearby
                    if (!isInRange && !isInFrustum) {
                        // Background processing for sitting NPCs
                        if (!child.userData.backgroundState) {
                            child.userData.backgroundState = {
                                contemplation: Math.random(),
                                focus: 0.7 + Math.random() * 0.3,
                                lastUpdate: Date.now()
                            };
                        }
                        return; // Skip animation
                    }
                    
                    // Lower body position (sitting pose)
                    if (!child.userData.sittingInitialized) {
                        child.position.y = -0.3; // Lower to simulate sitting
                        if (child.userData.legL && child.userData.legR) {
                            child.userData.legL.rotation.x = Math.PI / 3; // Bend legs
                            child.userData.legR.rotation.x = Math.PI / 3;
                        }
                        child.userData.sittingInitialized = true;
                    }
                    
                    // Look around animation
                    if (sitting.lookAround && child.children.length > 0) {
                        const head = child.children[0];
                        if (head) {
                            head.rotation.y = Math.sin(time * sitting.lookSpeed) * 0.5;
                            head.rotation.x = Math.sin(time * sitting.lookSpeed * 0.7) * 0.1;
                        }
                    }
                    
                    // Reading book animation (subtle head tilt)
                    if (sitting.readingBook && child.children.length > 0) {
                        const head = child.children[0];
                        if (head) {
                            head.rotation.x = -0.3 + Math.sin(time * 0.3) * 0.05;
                        }
                    }
                }
                
                // Animate talking NPCs
                if (child.userData.talking) {
                    const talking = child.userData.talking;
                    
                    // CULLING: Check if NPC is in view and within range
                    const distanceToPlayer = child.position.distanceTo(playerPosition);
                    const isInRange = distanceToPlayer < npcActivationDistance;
                    const isInFrustum = frustum.containsPoint(child.position);
                    
                    // Only process if visible or nearby
                    if (!isInRange && !isInFrustum) {
                        // Background social interaction state
                        if (!child.userData.backgroundState) {
                            child.userData.backgroundState = {
                                conversationDepth: Math.random(),
                                relationship: 0.5 + Math.random() * 0.5, // Relationship quality
                                lastInteraction: Date.now()
                            };
                        }
                        // Relationships slowly improve over time in background
                        if (Date.now() - child.userData.backgroundState.lastInteraction > 8000) {
                            child.userData.backgroundState.relationship = Math.min(1,
                                child.userData.backgroundState.relationship + 0.05
                            );
                            child.userData.backgroundState.lastInteraction = Date.now();
                        }
                        return; // Skip animation and speech
                    }
                    
                    // Sitting position if talking while sitting
                    if (talking.sitting && !child.userData.talkingSittingInit) {
                        child.position.y = -0.3;
                        if (child.userData.legL && child.userData.legR) {
                            child.userData.legL.rotation.x = Math.PI / 3;
                            child.userData.legR.rotation.x = Math.PI / 3;
                        }
                        child.userData.talkingSittingInit = true;
                    }
                    
                    // Occasional conversation audio (robot voice placeholder)
                    if (!child.userData.lastSpeech) child.userData.lastSpeech = 0;
                    if (time - child.userData.lastSpeech > 10 + Math.random() * 15) {
                        if (Math.random() < 0.3) { // 30% chance every 10-25 seconds
                            playNPCVoice(child);
                            child.userData.lastSpeech = time;
                        }
                    }
                    
                    // Head turning to face conversation partner
                    if (child.children.length > 0) {
                        const head = child.children[0];
                        if (head) {
                            // Smooth head turn
                            const targetAngle = Math.sin(time * talking.headTurnSpeed) * 0.6;
                            head.rotation.y += (targetAngle - head.rotation.y) * 0.1;
                            
                            // Occasional head nod
                            if (Math.random() < 0.005) {
                                head.rotation.x = -0.2;
                                setTimeout(() => {
                                    if (head) head.rotation.x = 0;
                                }, 300);
                            }
                        }
                    }
                    
                    // Hand gestures while talking
                    if (talking.gestureChance && Math.random() < talking.gestureChance) {
                        if (child.userData.armL && child.userData.armR) {
                            const armToGesture = Math.random() > 0.5 ? child.userData.armL : child.userData.armR;
                            const gestureType = Math.random();
                            
                            if (gestureType < 0.3) {
                                // Point gesture
                                armToGesture.rotation.x = -Math.PI / 3;
                                armToGesture.rotation.y = Math.PI / 6;
                            } else if (gestureType < 0.6) {
                                // Wave gesture
                                armToGesture.rotation.x = -Math.PI / 4;
                                armToGesture.rotation.z = Math.PI / 4;
                            } else {
                                // Shrug gesture
                                armToGesture.rotation.x = -Math.PI / 6;
                            }
                            
                            // Reset after gesture
                            setTimeout(() => {
                                if (armToGesture) {
                                    armToGesture.rotation.x = 0;
                                    armToGesture.rotation.y = 0;
                                    armToGesture.rotation.z = 0;
                                }
                            }, 800 + Math.random() * 400);
                        }
                    }
                }
            });
            
            // ═══════════════════════════════════════════════════════════════════════
            // BUILDING & TERRAIN LOD SYSTEM
            // ═══════════════════════════════════════════════════════════════════════
            
            // Apply LOD to buildings and large structures
            worldObjects.traverse((child) => {
                // Only process buildings and terrain chunks (skip small objects)
                if (child.isMesh && (child.userData.isBuilding || child.userData.isTerrain || 
                    child.userData.isStructure || child.geometry?.parameters?.width > 10)) {
                    
                    const distanceToPlayer = child.position.distanceTo(playerPosition);
                    const isInFrustum = frustum.containsPoint(child.position);
                    
                    // LOD Level 0: High detail (< 100 units)
                    if (distanceToPlayer < buildingLOD0Distance) {
                        child.visible = true;
                        if (child.material) {
                            child.material.wireframe = false;
                            // Enable shadows for nearby buildings
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    }
                    // LOD Level 1: Medium detail (100-300 units)
                    else if (distanceToPlayer < buildingLOD1Distance) {
                        child.visible = isInFrustum; // Only show if in view
                        if (child.material) {
                            child.material.wireframe = false;
                            // Disable shadows for medium distance
                            child.castShadow = false;
                            child.receiveShadow = false;
                        }
                    }
                    // LOD Level 2: Low detail (300-500 units)
                    else if (distanceToPlayer < buildingLOD2Distance) {
                        child.visible = isInFrustum; // Only show if in view
                        if (child.material) {
                            // Could use simplified material or wireframe
                            child.castShadow = false;
                            child.receiveShadow = false;
                        }
                    }
                    // Beyond cull distance: Hidden
                    else if (distanceToPlayer > buildingCullDistance) {
                        child.visible = false;
                    }
                    // Medium-far range (500-800): Show only if in frustum
                    else {
                        child.visible = isInFrustum;
                        if (child.material) {
                            child.castShadow = false;
                            child.receiveShadow = false;
                        }
                    }
                }
            });
            
            updateStats();
            updateMinimap();
            
            // Render with post-processing
            composer.render();
            
            } catch (error) {
                console.error('❌ ANIMATE ERROR:', error);
                // Display error on screen if console not accessible
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = 'position:fixed;top:10px;left:10px;background:rgba(255,0,0,0.9);color:white;padding:20px;z-index:999999;font-family:monospace;max-width:80%;';
                errorDiv.innerHTML = `<h2>RENDER ERROR</h2><pre>${error.message}\n${error.stack}</pre>`;
                document.body.appendChild(errorDiv);
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // UTILITIES
        // ═══════════════════════════════════════════════════════════════════════
        
        function updateLoading(percent, text) {
            document.getElementById('loading-bar-fill').style.width = percent + '%';
            document.getElementById('loading-text').textContent = text;
            loadingProgress = percent;
        }
        
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // START
        // ═══════════════════════════════════════════════════════════════════════
        
        // ═══════════════════════════════════════════════════════════════════════
        // BUILDING GENERATION - Production Quality
        // ═══════════════════════════════════════════════════════════════════════
        
        async function createNeighborhood() {
            console.log('🏘️ Building neighborhood...');
            
            // Residential houses in grid
            const houseSpacing = 25;
            const housesPerRow = 5;
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < housesPerRow; col++) {
                    const x = -150 + (col * houseSpacing);
                    const z = -50 + (row * houseSpacing);
                    
                    const houseType = Math.floor(Math.random() * 3);
                    const house = createResidentialHouse(houseType);
                    house.position.set(x, 0, z);
                    house.rotation.y = Math.random() * Math.PI * 2;
                    worldObjects.add(house);
                }
            }
            
            console.log('✅ Neighborhood complete');
        }
        
        async function createCollege() {
            console.log('🏛️ Building Bakersfield College campus...');
            
            // === BAKERSFIELD COLLEGE CAMPUS ===
            // Using enhanced vertex rendering with AI personalities
            
            // 1. Main Campus Building (Admin) - Iconic central building
            const mainCampus = createEnhancedBuilding({
                width: 40,
                height: 20,
                depth: 30,
                precision: 85,
                aiPersonality: 'residential_architect',
                detailLevel: 1.5,
                color: 0xD4AF37, // Gold/tan
                name: 'Main Campus Building'
            });
            mainCampus.position.set(-30, 0, 0);
            worldObjects.add(mainCampus);
            
            // 2. Levan Center (Student Center)
            const levanCenter = createEnhancedBuilding({
                width: 35,
                height: 18,
                depth: 25,
                precision: 80,
                aiPersonality: 'interior_designer',
                detailLevel: 1.3,
                color: 0xC19A6B, // Camel
                name: 'Levan Center'
            });
            levanCenter.position.set(0, 0, 0);
            worldObjects.add(levanCenter);
            
            // 3. Science & Engineering Building
            const scienceBuilding = createEnhancedBuilding({
                width: 45,
                height: 25,
                depth: 35,
                precision: 90,
                aiPersonality: 'industrial_designer',
                detailLevel: 1.2,
                color: 0x708090, // Slate gray
                name: 'Science & Engineering'
            });
            scienceBuilding.position.set(10, 0, 0);
            worldObjects.add(scienceBuilding);
            
            // 4. Grace Van Dyke Bird Library
            const library = createEnhancedBuilding({
                width: 38,
                height: 22,
                depth: 32,
                precision: 85,
                aiPersonality: 'residential_architect',
                detailLevel: 1.4,
                color: 0xB87333, // Copper
                name: 'Library'
            });
            library.position.set(-30, 0, 40);
            worldObjects.add(library);
            
            // 5. Humanities Building
            const humanities = createEnhancedBuilding({
                width: 30,
                height: 15,
                depth: 28,
                precision: 75,
                aiPersonality: 'visionary_artist',
                detailLevel: 1.0,
                color: 0xCD853F, // Peru
                name: 'Humanities Building'
            });
            humanities.position.set(15, 0, 35);
            worldObjects.add(humanities);
            
            // 6. Performing Arts Center
            const artsCenter = createEnhancedBuilding({
                width: 32,
                height: 20,
                depth: 30,
                precision: 80,
                aiPersonality: 'visionary_artist',
                detailLevel: 1.5,
                color: 0x8B008B, // Dark magenta
                name: 'Performing Arts Center'
            });
            artsCenter.position.set(30, 0, 20);
            worldObjects.add(artsCenter);
            
            // 7. Athletic Complex & Gymnasium
            const athleticComplex = createEnhancedBuilding({
                width: 50,
                height: 18,
                depth: 40,
                precision: 75,
                aiPersonality: 'industrial_designer',
                detailLevel: 0.8,
                color: 0x4682B4, // Steel blue
                name: 'Athletic Complex'
            });
            athleticComplex.position.set(40, 0, 50);
            worldObjects.add(athleticComplex);
            
            // 8. Campus Center (Bookstore)
            const campusCenter = createEnhancedBuilding({
                width: 25,
                height: 12,
                depth: 20,
                precision: 70,
                aiPersonality: 'interior_designer',
                detailLevel: 1.0,
                color: 0xDAA520, // Goldenrod
                name: 'Campus Center'
            });
            campusCenter.position.set(-10, 0, 25);
            worldObjects.add(campusCenter);
            
            console.log('✅ Bakersfield College campus complete (8 buildings)');
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // LOG CABINS IN WILDERNESS
        // ═══════════════════════════════════════════════════════════════════════
        
        function createLogCabin(type) {
            const cabin = new THREE.Group();
            cabin.name = `LogCabin_${type}`;
            cabin.userData.isBuilding = true;
            cabin.userData.hasInterior = true;
            
            const width = type === 'family' ? 14 : 10;
            const depth = type === 'family' ? 12 : 8;
            const wallHeight = 5;
            
            // ═══ LOG WALLS ═══ (BROWN, not purple!)
            const logMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513, // Saddle brown - realistic wood color
                roughness: 0.9,
                metalness: 0.1
            });
            
            // Stacked log wall appearance
            for (let i = 0; i < wallHeight; i += 0.5) {
                const logGeom = new THREE.BoxGeometry(width, 0.4, 0.3);
                
                // Front and back walls
                const frontLog = new THREE.Mesh(logGeom, logMaterial);
                frontLog.position.set(0, i, depth/2);
                frontLog.castShadow = true;
                cabin.add(frontLog);
                
                const backLog = new THREE.Mesh(logGeom, logMaterial);
                backLog.position.set(0, i, -depth/2);
                backLog.castShadow = true;
                cabin.add(backLog);
                
                // Side walls
                const sideGeom = new THREE.BoxGeometry(0.3, 0.4, depth);
                const leftLog = new THREE.Mesh(sideGeom, logMaterial);
                leftLog.position.set(-width/2, i, 0);
                leftLog.castShadow = true;
                cabin.add(leftLog);
                
                const rightLog = new THREE.Mesh(sideGeom, logMaterial);
                rightLog.position.set(width/2, i, 0);
                rightLog.castShadow = true;
                cabin.add(rightLog);
            }
            
            // ═══ ROOF ═══
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: 0x654321, // Dark brown roof
                roughness: 0.8
            });
            
            const roofGeom = new THREE.ConeGeometry(width * 0.8, 2.5, 4);
            const roof = new THREE.Mesh(roofGeom, roofMaterial);
            roof.position.y = wallHeight + 1.25;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            cabin.add(roof);
            
            // ═══ DOOR ═══
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x654321,
                roughness: 0.7
            });
            
            const doorGeom = new THREE.BoxGeometry(1.5, 2.5, 0.1);
            const door = new THREE.Mesh(doorGeom, doorMaterial);
            door.position.set(0, 1.25, depth/2 + 0.15);
            cabin.add(door);
            
            // ═══ WINDOWS ═══
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFE4B5,
                emissive: 0xFFAA44,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.7
            });
            
            const windowGeom = new THREE.PlaneGeometry(1, 1);
            const window1 = new THREE.Mesh(windowGeom, windowMaterial);
            window1.position.set(-2, 2.5, depth/2 + 0.2);
            cabin.add(window1);
            
            const window2 = new THREE.Mesh(windowGeom, windowMaterial);
            window2.position.set(2, 2.5, depth/2 + 0.2);
            cabin.add(window2);
            
            // ═══ LOG PILE OUTSIDE ═══
            const logPile = new THREE.Group();
            for (let i = 0; i < 6; i++) {
                const log = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8),
                    logMaterial // BROWN wood material, same as walls
                );
                log.rotation.z = Math.PI / 2;
                log.position.set(
                    -width/2 - 1,
                    0.2 + (i * 0.3),
                    depth/2 - 1 + (Math.random() * 0.3)
                );
                logPile.add(log);
            }
            cabin.add(logPile);
            
            // ═══ INTERIOR FURNITURE ═══
            const interior = createCabinInterior(type, width, depth);
            cabin.add(interior);
            
            // Warm interior lighting
            const interiorLight = new THREE.PointLight(0xFFAA44, 3, 15);
            interiorLight.position.set(0, wallHeight * 0.6, 0);
            cabin.add(interiorLight);
            
            return cabin;
        }
        
        function createCabinInterior(type, width, depth) {
            const interior = new THREE.Group();
            interior.name = 'CabinInterior';
            
            // ═══ FLOOR ═══
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B7355,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(width - 1, depth - 1),
                floorMaterial
            );
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0.05;
            floor.receiveShadow = true;
            interior.add(floor);
            
            // ═══ SOFA ═══
            const sofaMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4726, // Leather brown
                roughness: 0.6
            });
            
            const sofaBase = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.8, 1.2),
                sofaMaterial
            );
            sofaBase.position.set(-width/2 + 2, 0.4, -depth/2 + 2);
            sofaBase.castShadow = true;
            interior.add(sofaBase);
            
            const sofaBack = new THREE.Mesh(
                new THREE.BoxGeometry(3, 1.5, 0.3),
                sofaMaterial
            );
            sofaBack.position.set(-width/2 + 2, 1.15, -depth/2 + 1.45);
            sofaBack.castShadow = true;
            interior.add(sofaBack);
            
            // ═══ TV with IFRAME (SkyRelics News) ═══
            const tvStand = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.6, 0.8),
                new THREE.MeshStandardMaterial({ color: 0x2F2F2F })
            );
            tvStand.position.set(-width/2 + 2, 0.3, depth/2 - 2);
            tvStand.castShadow = true;
            interior.add(tvStand);
            
            // TV Screen (will use CSS3DRenderer in future for real iframe)
            const tvScreen = new THREE.Mesh(
                new THREE.PlaneGeometry(1.8, 1),
                new THREE.MeshBasicMaterial({
                    color: 0x001133,
                    emissive: 0x0088FF,
                    emissiveIntensity: 0.5
                })
            );
            tvScreen.position.set(-width/2 + 2, 1.2, depth/2 - 1.6);
            interior.add(tvScreen);
            
            // TV glow effect
            const tvLight = new THREE.PointLight(0x0088FF, 1, 5);
            tvLight.position.copy(tvScreen.position);
            interior.add(tvLight);
            
            // ═══ WOODEN TABLE ═══
            const tableMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.7
            });
            
            const tableTop = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.1, 1.5),
                tableMaterial
            );
            tableTop.position.set(width/2 - 3, 1.5, 0);
            tableTop.castShadow = true;
            interior.add(tableTop);
            
            // Table legs
            for (let x of [-0.8, 0.8]) {
                for (let z of [-0.6, 0.6]) {
                    const leg = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8),
                        tableMaterial
                    );
                    leg.position.set(width/2 - 3 + x, 0.75, z);
                    leg.castShadow = true;
                    interior.add(leg);
                }
            }
            
            // ═══ CHAIRS ═══
            const chairMaterial = new THREE.MeshStandardMaterial({
                color: 0x654321,
                roughness: 0.8
            });
            
            for (let i = 0; i < 2; i++) {
                const chair = new THREE.Group();
                
                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.1, 0.6),
                    chairMaterial
                );
                seat.position.y = 0.8;
                seat.castShadow = true;
                chair.add(seat);
                
                const back = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.8, 0.1),
                    chairMaterial
                );
                back.position.set(0, 1.2, -0.25);
                back.castShadow = true;
                chair.add(back);
                
                chair.position.set(
                    width/2 - 3 + (i === 0 ? -1.2 : 1.2),
                    0,
                    i === 0 ? 1 : -1
                );
                interior.add(chair);
            }
            
            // ═══ RUG ═══
            const rugMaterial = new THREE.MeshStandardMaterial({
                color: 0xA0522D,
                roughness: 0.95
            });
            const rug = new THREE.Mesh(
                new THREE.CircleGeometry(2, 32),
                rugMaterial
            );
            rug.rotation.x = -Math.PI / 2;
            rug.position.set(0, 0.06, 0);
            interior.add(rug);
            
            return interior;
        }
        
        function createWildernessLodges() {
            console.log('🪵 Building wilderness log cabins...');
            
            // Hunter's cabin in deep forest
            const hunterCabin = createLogCabin('hunter');
            hunterCabin.position.set(-150, 0, -100);
            hunterCabin.rotation.y = Math.PI / 6;
            worldObjects.add(hunterCabin);
            
            // Family log home near forest edge
            const familyHome = createLogCabin('family');
            familyHome.position.set(-120, 0, -80);
            familyHome.rotation.y = -Math.PI / 4;
            worldObjects.add(familyHome);
            
            // Ranger station with lookout
            const rangerStation = createLogCabin('ranger');
            rangerStation.position.set(100, 0, -120);
            rangerStation.rotation.y = Math.PI / 3;
            worldObjects.add(rangerStation);
            
            // Abandoned cabin (overgrown)
            const abandonedCabin = createLogCabin('abandoned');
            abandonedCabin.position.set(-200, 0, 50);
            abandonedCabin.rotation.y = Math.PI;
            worldObjects.add(abandonedCabin);
            
            // Cozy cabin near lake
            const lakeCabin = createLogCabin('hunter');
            lakeCabin.position.set(80, 0, 100);
            lakeCabin.rotation.y = -Math.PI / 2;
            worldObjects.add(lakeCabin);
            
            console.log('✅ 5 wilderness log cabins placed');
        }
        
        function createResidentialHouse(type) {
            const house = new THREE.Group();
            house.name = `House_Type${type}`;
            house.userData.isBuilding = true; // Tag for LOD system
            
            const width = 12 + Math.random() * 4;
            const depth = 10 + Math.random() * 3;
            const wallHeight = 6 + Math.random() * 2;
            
            // ═══ WALLS ═══
            const brickTexture = createBrickTexture();
            const wallMaterial = new THREE.MeshStandardMaterial({
                map: brickTexture,
                roughness: 0.9,
                metalness: 0.0
            });
            
            // Main structure
            const wallsGeom = new THREE.BoxGeometry(width, wallHeight, depth, 8, 8, 8);
            const walls = new THREE.Mesh(wallsGeom, wallMaterial);
            walls.position.y = wallHeight / 2;
            walls.castShadow = true;
            walls.receiveShadow = true;
            house.add(walls);
            
            // ═══ ROOF ═══
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: type === 0 ? 0x8B4513 : type === 1 ? 0x2F4F4F : 0x696969,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Pitched roof
            const roofGeom = new THREE.ConeGeometry(width * 0.8, 3, 24, 2);
            const roof = new THREE.Mesh(roofGeom, roofMaterial);
            roof.position.y = wallHeight + 1.5;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            house.add(roof);
            
            // ═══ WINDOWS ═══
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x87CEEB,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.6
            });
            
            // Front windows
            for (let i = 0; i < 3; i++) {
                const windowGeom = new THREE.PlaneGeometry(1.5, 2, 4, 4);
                const window = new THREE.Mesh(windowGeom, windowMaterial);
                window.position.set((i - 1) * 3, wallHeight * 0.5, depth / 2 + 0.05);
                house.add(window);
            }
            
            // ═══ DOOR ═══
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.6,
                metalness: 0.2
            });
            
            const doorGeom = new THREE.PlaneGeometry(1.5, 3, 4, 6);
            const door = new THREE.Mesh(doorGeom, doorMaterial);
            door.position.set(0, 1.5, depth / 2 + 0.06);
            house.add(door);
            
            // ═══ CHIMNEY ═══
            if (Math.random() > 0.5) {
                const chimneyGeom = new THREE.BoxGeometry(1, 4, 1, 6, 6, 6);
                const chimney = new THREE.Mesh(chimneyGeom, wallMaterial);
                chimney.position.set(width * 0.3, wallHeight + 2, 0);
                chimney.castShadow = true;
                house.add(chimney);
            }
            
            // ═══ INTERIOR LIGHTS ═══
            const interiorLight = new THREE.PointLight(0xffeecc, 2, 20);
            interiorLight.position.set(0, wallHeight * 0.5, 0);
            house.add(interiorLight);
            
            applyHighDetail(house, { multiplier: 2 });

            const styleProfiles = [
                'Aurora Ridge Chalet',
                'Coastal Horizon Villa',
                'Midnight Slate Loft'
            ];

            const roofPalette = [
                'Redwood composite shingles with matte sealant',
                'Deep sea architectural steel panels',
                'Charcoal basalt ceramic tiles'
            ];

            const style = styleProfiles[type] || 'Custom SkyRelics Residence';

            annotateObject(house, {
                id: `residence_${type}_${house.uuid.slice(0, 6)}`,
                name: `${style.replace(/\s+/g, '')}_${house.uuid.slice(0, 4)}`,
                type: 'architecture-residential',
                category: 'architecture',
                description: `${style} single-family dwelling with a ${width.toFixed(1)}m × ${depth.toFixed(1)}m footprint, ${wallHeight.toFixed(1)}m load-bearing masonry walls, and a ${roofPalette[type] || 'composite roof system'}. Triple-pane fenestration uses high-index glass to capture the neighborhood glow.`,
                dimensions: {
                    widthMeters: Number(width.toFixed(2)),
                    depthMeters: Number(depth.toFixed(2)),
                    wallHeightMeters: Number(wallHeight.toFixed(2)),
                    ridgeHeightMeters: Number((wallHeight + 3).toFixed(2))
                },
                materials: [
                    {
                        id: 'facade_brickwork',
                        description: 'Procedural brick blend with high roughness and ambient occlusion for mortar relief.'
                    },
                    {
                        id: 'roof_system',
                        description: roofPalette[type] || 'Composite roofing assembly tuned for PBR specular response.'
                    },
                    {
                        id: 'fenestration_glass',
                        description: 'Blue-tinted low-E glazing with reflective metalness for evening highlights.'
                    }
                ],
                animations: [
                    {
                        id: 'interior_illumination_static',
                        description: 'Static 2000 lumen interior emission to imply occupancy; participates in GI bounce.'
                    }
                ],
                rendering: {
                    detail: 'All architectural primitives retopologized to 8+ segment grids for smooth silhouettes.',
                    castsShadow: true,
                    receivesShadow: true
                },
                tags: ['residential', 'neighborhood', 'procedural', 'high-detail']
            });

            return house;
        }
        
        function createPhotoRealisticBuilding(buildingType) {
            const building = new THREE.Group();
            building.name = `Building_${buildingType}`;
            building.userData.isBuilding = true; // Tag for LOD system
            
            // Building dimensions based on type
            let width, depth, height, floors;
            
            switch(buildingType) {
                case 'academic':
                    width = 50; depth = 30; height = 20; floors = 3;
                    break;
                case 'science':
                    width = 40; depth = 25; height = 15; floors = 2;
                    break;
                case 'library':
                    width = 45; depth = 35; height = 18; floors = 3;
                    break;
                default:
                    width = 40; depth = 25; height = 15; floors = 2;
            }
            
            // ═══ PROCEDURAL TEXTURES ═══
            const brickTexture = createBrickTexture();
            const brickNormal = createBrickNormalMap();
            
            // ═══ WALLS ═══
            const wallMaterial = new THREE.MeshStandardMaterial({
                map: brickTexture,
                normalMap: brickNormal,
                roughness: 0.9,
                metalness: 0.0,
                normalScale: new THREE.Vector2(0.5, 0.5)
            });
            
            const buildingGeom = new THREE.BoxGeometry(width, height, depth, 16, 16, 16);
            const buildingMesh = new THREE.Mesh(buildingGeom, wallMaterial);
            buildingMesh.position.y = height / 2;
            buildingMesh.castShadow = true;
            buildingMesh.receiveShadow = true;
            building.add(buildingMesh);
            
            // ═══ GLASS CURTAIN WALLS ═══
            const glassMaterial = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                metalness: 1.0,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7,
                envMapIntensity: 1.0
            });
            
            const windowsPerFloor = Math.floor(width / 4);
            const windowWidth = 2.5;
            const windowHeight = 3;
            
            // Front facade windows
            for (let floor = 0; floor < floors; floor++) {
                for (let i = 0; i < windowsPerFloor; i++) {
                    const windowGeom = new THREE.BoxGeometry(windowWidth, windowHeight, 0.1, 6, 6, 2);
                    const window = new THREE.Mesh(windowGeom, glassMaterial);
                    
                    const spacing = width / (windowsPerFloor + 1);
                    window.position.x = -width/2 + spacing * (i + 1);
                    window.position.y = 3 + floor * (height / floors);
                    window.position.z = depth/2 + 0.05;
                    
                    building.add(window);
                    
                    // Interior light behind window
                    const interiorLight = new THREE.PointLight(0xffeecc, 1, 15);
                    interiorLight.position.copy(window.position);
                    interiorLight.position.z -= 2;
                    building.add(interiorLight);
                }
            }
            
            // Side windows
            const sideWindows = Math.floor(depth / 5);
            for (let floor = 0; floor < floors; floor++) {
                for (let i = 0; i < sideWindows; i++) {
                    const windowGeom = new THREE.BoxGeometry(0.1, windowHeight, windowWidth, 2, 6, 6);
                    const window = new THREE.Mesh(windowGeom, glassMaterial);
                    
                    const spacing = depth / (sideWindows + 1);
                    window.position.x = width/2 + 0.05;
                    window.position.y = 3 + floor * (height / floors);
                    window.position.z = -depth/2 + spacing * (i + 1);
                    
                    building.add(window);
                }
            }
            
            // ═══ ENTRANCE ═══
            const entranceMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.3,
                metalness: 0.8
            });
            
            const entranceGeom = new THREE.BoxGeometry(8, 5, 0.3, 8, 6, 2);
            const entrance = new THREE.Mesh(entranceGeom, entranceMaterial);
            entrance.position.set(0, 2.5, depth/2 + 0.2);
            entrance.castShadow = true;
            building.add(entrance);
            
            // Glass doors
            const doorGeom = new THREE.BoxGeometry(4, 4.5, 0.1, 6, 8, 2);
            const doors = new THREE.Mesh(doorGeom, glassMaterial);
            doors.position.set(0, 2.25, depth/2 + 0.3);
            building.add(doors);
            
            // ═══ ROOF ═══
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a3a3a,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const roofGeom = new THREE.BoxGeometry(width + 2, 0.8, depth + 2, 16, 2, 16);
            const roof = new THREE.Mesh(roofGeom, roofMaterial);
            roof.position.y = height;
            roof.castShadow = true;
            roof.receiveShadow = true;
            building.add(roof);
            
            // ═══ STRUCTURAL PILLARS ═══
            const pillarMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.4,
                metalness: 0.7
            });
            
            const pillarGeom = new THREE.BoxGeometry(1.5, height, 1.5, 6, 16, 6);
            
            // Four corner pillars
            const pillarPositions = [
                [-width/2 + 2, height/2, depth/2 - 2],
                [width/2 - 2, height/2, depth/2 - 2],
                [-width/2 + 2, height/2, -depth/2 + 2],
                [width/2 - 2, height/2, -depth/2 + 2]
            ];
            
            pillarPositions.forEach(pos => {
                const pillar = new THREE.Mesh(pillarGeom, pillarMaterial);
                pillar.position.set(...pos);
                pillar.castShadow = true;
                building.add(pillar);
            });
            
            // ═══ BUILDING SIGNAGE ═══
            if (buildingType === 'library') {
                const signGeom = new THREE.BoxGeometry(10, 2, 0.2, 8, 4, 2);
                const signMat = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.6
                });
                const sign = new THREE.Mesh(signGeom, signMat);
                sign.position.set(0, height - 2, depth/2 + 0.4);
                building.add(sign);
            }
            
            applyHighDetail(building, { multiplier: 2 });

            const typeDescriptions = {
                academic: 'Flagship academic complex with stepped lecture halls, mezzanine study decks, and curtain-wall glazing that tracks circadian lighting.',
                science: 'STEM research hub featuring modular lab bays, inert facade brickwork, and precision HVAC housings concealed within the parapet roof.',
                library: 'Three-story knowledge pavilion with terraced reading lounges, bronze-clad signage, and a full-height skylit atrium.'
            };

            annotateObject(building, {
                id: `${buildingType}_complex_${building.uuid.slice(0, 6)}`,
                name: `Campus_${buildingType}_${building.uuid.slice(0, 4)}`,
                type: `architecture-${buildingType}`,
                category: 'architecture',
                description: typeDescriptions[buildingType] || 'Multi-use institutional structure engineered for the SkyRelics campus.',
                dimensions: {
                    widthMeters: width,
                    depthMeters: depth,
                    heightMeters: height,
                    floors
                },
                materials: [
                    {
                        id: 'structural_brick',
                        description: 'Procedural masonry shell with paired normal and AO maps for high-frequency detail.'
                    },
                    {
                        id: 'curtain_wall_glass',
                        description: 'High-metalness blue glass tuned for skyline reflections and interior luminance bleed.'
                    },
                    {
                        id: 'roof_membrane',
                        description: 'Insulated dark composite roof slab sized to oversail by 1m for rain run-off.'
                    }
                ],
                animations: [
                    {
                        id: 'interior_glow_cycle',
                        description: 'Distributed point-lights per window cell simulate evening custodial pass-through.'
                    }
                ],
                rendering: {
                    detail: 'Facade primitives rebuilt to 16× segment grids; windows extruded with micro bevels for realistic specular falloff.',
                    castsShadow: true,
                    receivesShadow: true
                },
                tags: ['institutional', 'campus', 'high-detail', buildingType]
            });

            return building;
        }
        
        function createBrickTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base brick color with MORE variation
            const baseColors = ['#b85c3e', '#a54d35', '#c66b45', '#d4735e', '#9a4a2f'];
            ctx.fillStyle = baseColors[Math.floor(Math.random() * baseColors.length)];
            ctx.fillRect(0, 0, 512, 512);
            
            // Mortar lines (lighter gray)
            ctx.strokeStyle = '#a8a8a8';
            ctx.lineWidth = 4;
            
            const brickWidth = 64;
            const brickHeight = 32;
            
            for (let y = 0; y < 512; y += brickHeight) {
                const offset = (Math.floor(y / brickHeight) % 2) * (brickWidth / 2);
                for (let x = -brickWidth; x < 512; x += brickWidth) {
                    // Draw mortar
                    ctx.strokeRect(x + offset, y, brickWidth, brickHeight);
                    
                    // Individual brick color variation (more pronounced)
                    const variation = Math.random() * 0.3 - 0.15;
                    ctx.fillStyle = `rgba(${150 + variation * 120}, ${60 + variation * 60}, ${30 + variation * 40}, ${0.4 + variation})`;
                    ctx.fillRect(x + offset + 3, y + 3, brickWidth - 6, brickHeight - 6);
                }
            }
            
            // Enhanced weathering with more details
            for (let i = 0; i < 300; i++) {
                ctx.fillStyle = `rgba(${100 + Math.random() * 60}, ${40 + Math.random() * 40}, ${20 + Math.random() * 30}, ${0.15 + Math.random() * 0.25})`;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, Math.random() * 50, Math.random() * 50);
            }
            
            // Add cracks and aging
            for (let i = 0; i < 50; i++) {
                ctx.strokeStyle = `rgba(50, 30, 20, ${0.3 + Math.random() * 0.4})`;
                ctx.lineWidth = 1 + Math.random();
                ctx.beginPath();
                const startX = Math.random() * 512;
                const startY = Math.random() * 512;
                ctx.moveTo(startX, startY);
                ctx.lineTo(startX + Math.random() * 40 - 20, startY + Math.random() * 40 - 20);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 2);
            
            return texture;
        }
        
        // NEW: Create brick roughness map for material variation
        function createBrickRoughnessMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base roughness (darker = smoother, lighter = rougher)
            ctx.fillStyle = '#888888'; // Medium roughness
            ctx.fillRect(0, 0, 512, 512);
            
            const brickWidth = 64;
            const brickHeight = 32;
            
            for (let y = 0; y < 512; y += brickHeight) {
                const offset = (Math.floor(y / brickHeight) % 2) * (brickWidth / 2);
                for (let x = -brickWidth; x < 512; x += brickWidth) {
                    // Mortar is rougher (lighter)
                    ctx.fillStyle = '#f0f0f0'; // Roughness 0.95
                    ctx.fillRect(x + offset, y, brickWidth, 4);
                    ctx.fillRect(x + offset, y, 4, brickHeight);
                    
                    // Brick surface slightly smoother (darker)
                    ctx.fillStyle = '#707070'; // Roughness 0.85
                    ctx.fillRect(x + offset + 4, y + 4, brickWidth - 8, brickHeight - 8);
                }
            }
            
            // Random rough spots on bricks
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(${200 + Math.random() * 55}, ${200 + Math.random() * 55}, ${200 + Math.random() * 55}, 0.5)`;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, Math.random() * 20, Math.random() * 20);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 2);
            
            return texture;
        }
        
        function createBrickNormalMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Neutral normal (purple-ish)
            ctx.fillStyle = '#8080ff';
            ctx.fillRect(0, 0, 512, 512);
            
            // Mortar indents (darker = recessed)
            ctx.fillStyle = '#4040aa';
            const brickWidth = 64;
            const brickHeight = 32;
            
            for (let y = 0; y < 512; y += brickHeight) {
                ctx.fillRect(0, y, 512, 3);
                const offset = (Math.floor(y / brickHeight) % 2) * (brickWidth / 2);
                for (let x = -brickWidth; x < 512; x += brickWidth) {
                    ctx.fillRect(x + offset, y, 3, brickHeight);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 2);
            
            return texture;
        }
        
        async function createPark() {
            console.log('🌳 Building park...');
            
            const parkCenter = new THREE.Vector3(60, 0, -20);
            
            // ═══ PARK PATHS ═══
            const pathMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B7355,
                roughness: 0.9,
                metalness: 0.0
            });
            
            // Main path (cross shape)
            const mainPathH = new THREE.Mesh(
                new THREE.PlaneGeometry(60, 4),
                pathMaterial
            );
            mainPathH.rotation.x = -Math.PI / 2;
            mainPathH.position.set(parkCenter.x, 0.05, parkCenter.z);
            mainPathH.receiveShadow = true;
            mainPathH.userData.isStructure = true; // Tag for LOD
            worldObjects.add(mainPathH);
            
            const mainPathV = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 60),
                pathMaterial
            );
            mainPathV.rotation.x = -Math.PI / 2;
            mainPathV.position.set(parkCenter.x, 0.05, parkCenter.z);
            mainPathV.receiveShadow = true;
            mainPathV.userData.isStructure = true; // Tag for LOD
            worldObjects.add(mainPathV);
            
            // ═══ PARK TREES (Varied types) ═══
            const treePositions = [
                // Corners
                [parkCenter.x - 25, parkCenter.z - 25],
                [parkCenter.x + 25, parkCenter.z - 25],
                [parkCenter.x - 25, parkCenter.z + 25],
                [parkCenter.x + 25, parkCenter.z + 25],
                // Along paths
                [parkCenter.x - 15, parkCenter.z - 15],
                [parkCenter.x + 15, parkCenter.z - 15],
                [parkCenter.x - 15, parkCenter.z + 15],
                [parkCenter.x + 15, parkCenter.z + 15],
                [parkCenter.x - 20, parkCenter.z],
                [parkCenter.x + 20, parkCenter.z],
                [parkCenter.x, parkCenter.z - 20],
                [parkCenter.x, parkCenter.z + 20]
            ];
            
            treePositions.forEach((pos, idx) => {
                const treeType = idx % 3; // 3 tree types
                const tree = createDetailedTree(treeType);
                tree.position.set(pos[0], 0, pos[1]);
                worldObjects.add(tree);
            });
            
            // ═══ PARK BENCHES ═══
            const benchPositions = [
                [parkCenter.x - 10, parkCenter.z - 3],
                [parkCenter.x + 10, parkCenter.z - 3],
                [parkCenter.x - 10, parkCenter.z + 3],
                [parkCenter.x + 10, parkCenter.z + 3]
            ];
            
            benchPositions.forEach(pos => {
                const bench = createParkBench();
                bench.position.set(pos[0], 0, pos[1]);
                bench.rotation.y = pos[0] < parkCenter.x ? Math.PI / 2 : -Math.PI / 2;
                worldObjects.add(bench);
            });
            
            // ═══ LAMP POSTS ═══
            const lampPositions = [
                [parkCenter.x - 8, parkCenter.z],
                [parkCenter.x + 8, parkCenter.z],
                [parkCenter.x, parkCenter.z - 8],
                [parkCenter.x, parkCenter.z + 8]
            ];
            
            lampPositions.forEach(pos => {
                const lamp = createLampPost();
                lamp.position.set(pos[0], 0, pos[1]);
                worldObjects.add(lamp);
            });
            
            // ═══ FLOWER BEDS ═══
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const radius = 12;
                const flowerBed = createFlowerBed();
                flowerBed.position.set(
                    parkCenter.x + Math.cos(angle) * radius,
                    0,
                    parkCenter.z + Math.sin(angle) * radius
                );
                worldObjects.add(flowerBed);
            }
            
            console.log('✅ Park complete');
        }
        
        async function createForest() {
            console.log('🌲 Planting forest with LOD optimization...');
            
            const forestStart = 90;
            const forestWidth = 80;
            const forestDepth = 100;
            const treeCount = 150;
            
            for (let i = 0; i < treeCount; i++) {
                const x = forestStart + Math.random() * forestWidth;
                const z = -50 + Math.random() * forestDepth;
                
                // Vary tree types and sizes
                const treeType = Math.floor(Math.random() * 4);
                
                // Use LOD trees for massive performance boost
                const tree = createLODTree(treeType);
                
                // Random scale
                const scale = 0.7 + Math.random() * 0.6;
                tree.scale.set(scale, scale, scale);
                
                // Random rotation
                tree.rotation.y = Math.random() * Math.PI * 2;
                
                tree.position.set(x, 0, z);
                worldObjects.add(tree);
            }
            
            // ═══ UNDERGROWTH ═══
            for (let i = 0; i < 80; i++) {
                const x = forestStart + Math.random() * forestWidth;
                const z = -50 + Math.random() * forestDepth;
                
                const bush = createBush();
                bush.position.set(x, 0, z);
                worldObjects.add(bush);
            }
            
            // ═══ FALLEN LOGS ═══
            for (let i = 0; i < 10; i++) {
                const x = forestStart + Math.random() * forestWidth;
                const z = -50 + Math.random() * forestDepth;
                
                const log = createFallenLog();
                log.position.set(x, 0.3, z);
                log.rotation.y = Math.random() * Math.PI;
                worldObjects.add(log);
            }
            
            console.log('✅ Forest complete with LOD (4 detail levels: high/medium/low/billboard)');
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // DETAILED TREE GENERATION (4 types)
        // ═══════════════════════════════════════════════════════════════════════
        
        function createDetailedTree(type) {
            const tree = new THREE.Group();
            tree.name = `Tree_Type${type}`;
            
            switch(type) {
                case 0: return createOakTree();
                case 1: return createPineTree();
                case 2: return createWillowTree();
                case 3: return createMapleTree();
                default: return createOakTree();
            }
        }
        
        function createOakTree() {
            const tree = new THREE.Group();
            
            // Trunk with texture
            const trunkGeom = new THREE.CylinderGeometry(0.4, 0.6, 8, 18, 4);
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x4a3520,
                roughness: 0.95,
                metalness: 0.0
            });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 4;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Main branches (4)
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const branchGeom = new THREE.CylinderGeometry(0.2, 0.3, 4, 14, 3);
                const branch = new THREE.Mesh(branchGeom, trunkMat);
                branch.position.set(
                    Math.cos(angle) * 1.5,
                    6 + Math.random(),
                    Math.sin(angle) * 1.5
                );
                branch.rotation.z = Math.PI / 4;
                branch.rotation.y = angle;
                branch.castShadow = true;
                tree.add(branch);
            }
            
            // Canopy (multi-sphere for fullness)
            const foliageMat = new THREE.MeshStandardMaterial({
                color: 0x2d5a2d,
                roughness: 0.9,
                metalness: 0.0
            });
            
            const canopyPositions = [
                [0, 9, 0],
                [1.5, 8.5, 0],
                [-1.5, 8.5, 0],
                [0, 8.5, 1.5],
                [0, 8.5, -1.5],
                [1, 10, 1],
                [-1, 10, -1]
            ];
            
            canopyPositions.forEach(pos => {
                const foliageGeom = new THREE.SphereGeometry(2 + Math.random() * 0.5, 18, 14);
                const foliage = new THREE.Mesh(foliageGeom, foliageMat);
                foliage.position.set(...pos);
                foliage.castShadow = true;
                tree.add(foliage);
            });
            
            applyHighDetail(tree, { multiplier: 2 });

            annotateObject(tree, {
                id: `oak_${tree.uuid.slice(0, 6)}`,
                name: `QuercusCanopy_${tree.uuid.slice(0, 4)}`,
                type: 'flora-tree',
                category: 'flora',
                description: 'Mature quercus oak with tapering 8m trunk, radial branch system, and volumetric canopy clusters for dense leaf coverage. Ideal for suburban biome shading.',
                dimensions: {
                    heightMeters: 10,
                    canopyDiameterMeters: 6.5
                },
                materials: [
                    {
                        id: 'oak_bark',
                        description: 'High-roughness bark shader capturing longitudinal fissures and moss micro-texture.'
                    },
                    {
                        id: 'oak_leaf',
                        description: 'Broadleaf foliage with deep green albedo and subsurface scattering approximation.'
                    }
                ],
                animations: [
                    {
                        id: 'wind_sway_placeholder',
                        description: 'Reserved slot for dynamic wind sway; current state static for compositing reference.'
                    }
                ],
                rendering: {
                    detail: 'Branches and canopy subdivided to 18+ radial segments for smooth silhouettes.',
                    castsShadow: true
                },
                tags: ['oak', 'tree', 'flora', 'high-detail']
            });

            return tree;
        }
        
        function createPineTree() {
            const tree = new THREE.Group();
            
            // Tall thin trunk
            const trunkGeom = new THREE.CylinderGeometry(0.25, 0.35, 12, 18, 4);
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.95
            });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 6;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Conical needle layers (5 layers)
            const needleMat = new THREE.MeshStandardMaterial({
                color: 0x1a4d1a,
                roughness: 0.9
            });
            
            for (let i = 0; i < 5; i++) {
                const radius = 3 - (i * 0.5);
                const height = 3;
                const coneGeom = new THREE.ConeGeometry(radius, height, 24, 4);
                const cone = new THREE.Mesh(coneGeom, needleMat);
                cone.position.y = 4 + (i * 2);
                cone.castShadow = true;
                tree.add(cone);
            }
            
            applyHighDetail(tree, { multiplier: 2 });

            annotateObject(tree, {
                id: `pine_${tree.uuid.slice(0, 6)}`,
                name: `EvergreenPine_${tree.uuid.slice(0, 4)}`,
                type: 'flora-tree',
                category: 'flora',
                description: 'Towering conifer with layered needle whorls and slender resin-rich trunk, modeled for alpine campus edges and winter lighting tests.',
                dimensions: {
                    heightMeters: 12,
                    canopyDiameterMeters: 3
                },
                materials: [
                    { id: 'pine_bark', description: 'Dark phloem bark shader with specular sap streaks.' },
                    { id: 'pine_needles', description: 'Needle cluster material tuned for heavy AO and velvet highlights.' }
                ],
                animations: [
                    {
                        id: 'needle_rustle_placeholder',
                        description: 'Planned subtle sway and needle vibration; static placeholder for now.'
                    }
                ],
                rendering: {
                    detail: 'Cone layers increased to 24 radial segments for needle silhouette fidelity.',
                    castsShadow: true
                },
                tags: ['pine', 'evergreen', 'flora', 'high-detail']
            });

            return tree;
        }
        
        function createWillowTree() {
            const tree = new THREE.Group();
            
            // Trunk
            const trunkGeom = new THREE.CylinderGeometry(0.5, 0.7, 7, 18, 4);
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x5a4a3a,
                roughness: 0.95
            });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 3.5;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Drooping branches (8 around)
            const leafMat = new THREE.MeshStandardMaterial({
                color: 0x4a7c4a,
                roughness: 0.85
            });
            
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const branchGeom = new THREE.CylinderGeometry(0.1, 0.15, 6, 14, 3);
                const branch = new THREE.Mesh(branchGeom, trunkMat);
                branch.position.set(
                    Math.cos(angle) * 2,
                    6,
                    Math.sin(angle) * 2
                );
                branch.rotation.z = -Math.PI / 3; // Droop
                branch.rotation.y = angle;
                branch.castShadow = true;
                tree.add(branch);
                
                // Leaf clusters at end of branches
                const leafGeom = new THREE.SphereGeometry(0.8, 14, 10);
                const leafCluster = new THREE.Mesh(leafGeom, leafMat);
                leafCluster.position.set(
                    Math.cos(angle) * 3,
                    3,
                    Math.sin(angle) * 3
                );
                leafCluster.scale.set(1, 1.5, 1);
                leafCluster.castShadow = true;
                tree.add(leafCluster);
            }
            
            applyHighDetail(tree, { multiplier: 2 });

            annotateObject(tree, {
                id: `willow_${tree.uuid.slice(0, 6)}`,
                name: `LakesideWillow_${tree.uuid.slice(0, 4)}`,
                type: 'flora-tree',
                category: 'flora',
                description: 'Graceful willow with drooping tendrils framing lakeside vistas. Layered branch geometry mimics curtain-like foliage for silhouette richness.',
                dimensions: {
                    heightMeters: 9,
                    canopySpreadMeters: 8
                },
                materials: [
                    { id: 'willow_bark', description: 'Muted brown bark shader with high roughness and vertical striations.' },
                    { id: 'willow_leaf', description: 'Elongated leaf clusters using stretched sphere meshes for dense hanging fronds.' }
                ],
                animations: [
                    {
                        id: 'branch_drift_placeholder',
                        description: 'Reserved for lake breeze sway; static presentation for compositing reference.'
                    }
                ],
                rendering: {
                    detail: 'All branch cylinders retopologized to 14 radial segments; foliage clusters expanded to 14×10 subdivisions.',
                    castsShadow: true
                },
                tags: ['willow', 'flora', 'lakeside', 'high-detail']
            });

            return tree;
        }
        
        function createMapleTree() {
            const tree = new THREE.Group();
            
            // Trunk
            const trunkGeom = new THREE.CylinderGeometry(0.45, 0.65, 7, 18, 4);
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x4a3520,
                roughness: 0.95
            });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 3.5;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Wide spreading canopy
            const foliageMat = new THREE.MeshStandardMaterial({
                color: 0x8B4513, // Autumn colors
                roughness: 0.9
            });
            
            // Create layered rounded canopy
            const canopyLayers = [
                { y: 7, radius: 3.5, count: 5 },
                { y: 8.5, radius: 3, count: 4 },
                { y: 10, radius: 2, count: 3 }
            ];
            
            canopyLayers.forEach(layer => {
                for (let i = 0; i < layer.count; i++) {
                    const angle = (i / layer.count) * Math.PI * 2;
                    const radius = layer.radius * (0.8 + Math.random() * 0.4);
                    const foliageGeom = new THREE.SphereGeometry(1.5, 18, 14);
                    const foliage = new THREE.Mesh(foliageGeom, foliageMat);
                    foliage.position.set(
                        Math.cos(angle) * radius,
                        layer.y,
                        Math.sin(angle) * radius
                    );
                    foliage.castShadow = true;
                    tree.add(foliage);
                }
            });
            
            applyHighDetail(tree, { multiplier: 2 });

            annotateObject(tree, {
                id: `maple_${tree.uuid.slice(0, 6)}`,
                name: `ScarletMaple_${tree.uuid.slice(0, 4)}`,
                type: 'flora-tree',
                category: 'flora',
                description: 'Layered scarlet maple canopy built from high-resolution sphere clusters to emulate dense fall foliage. Ideal for seasonal cinematic sweeps.',
                dimensions: {
                    heightMeters: 10,
                    canopyDiameterMeters: 7.5
                },
                materials: [
                    { id: 'maple_bark', description: 'Rough bark shader with deep fissures and ambient occlusion mapping.' },
                    { id: 'maple_foliage', description: 'Autumn-tuned leaf shader with warm albedo and high roughness.' }
                ],
                animations: [
                    { id: 'autumn_sway_placeholder', description: 'Reserved for wind-driven sway and leaf fall events.' }
                ],
                rendering: {
                    detail: 'Foliage converted to 18×14 segment spheres for smooth highlights and shadow penumbra.',
                    castsShadow: true
                },
                tags: ['maple', 'autumn', 'flora', 'high-detail']
            });

            return tree;
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // LOD TREE OPTIMIZATION - Performance Enhancement
        // ═══════════════════════════════════════════════════════════════════════
        
        // Create LOD version of tree with 3 detail levels + billboard
        function createLODTree(type) {
            const lod = new THREE.LOD();
            
            // Level 0: High detail (0-40m) - Full tree
            const highDetail = createDetailedTree(type);
            lod.addLevel(highDetail, 0);
            
            // Level 1: Medium detail (40-100m) - Simplified
            const mediumDetail = createSimplifiedTree(type);
            lod.addLevel(mediumDetail, 40);
            
            // Level 2: Low detail (100-200m) - Very basic
            const lowDetail = createBasicTree(type);
            lod.addLevel(lowDetail, 100);
            
            // Level 3: Billboard (200m+) - 2D sprite
            const billboard = createTreeBillboard(type);
            lod.addLevel(billboard, 200);
            
            return lod;
        }
        
        // Simplified tree (medium distance) - 50% vertices
        function createSimplifiedTree(type) {
            const tree = new THREE.Group();
            
            // Simple trunk
            const trunkGeom = new THREE.CylinderGeometry(0.4, 0.5, 7, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ 
                color: 0x4a3520, 
                roughness: 0.95 
            });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 3.5;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Single large canopy sphere
            const foliageColors = [0x2d5a2d, 0x1a4d1a, 0x3a5a3a, 0x8B4513];
            const foliageMat = new THREE.MeshStandardMaterial({ 
                color: foliageColors[type % 4], 
                roughness: 0.9 
            });
            const canopy = new THREE.Mesh(
                new THREE.SphereGeometry(2.5, 8, 6),
                foliageMat
            );
            canopy.position.y = 7;
            canopy.castShadow = true;
            tree.add(canopy);
            
            return tree;
        }
        
        // Basic tree (far distance) - 80% fewer vertices
        function createBasicTree(type) {
            const tree = new THREE.Group();
            
            // Very simple trunk
            const trunkGeom = new THREE.CylinderGeometry(0.3, 0.4, 6, 4);
            const trunkMat = new THREE.MeshStandardMaterial({ 
                color: 0x4a3520, 
                roughness: 0.95 
            });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 3;
            tree.add(trunk);
            
            // Single low-poly canopy
            const foliageColors = [0x2d5a2d, 0x1a4d1a, 0x3a5a3a, 0x8B4513];
            const foliageMat = new THREE.MeshStandardMaterial({ 
                color: foliageColors[type % 4], 
                roughness: 0.9 
            });
            const canopy = new THREE.Mesh(
                new THREE.SphereGeometry(2, 4, 3),
                foliageMat
            );
            canopy.position.y = 6;
            tree.add(canopy);
            
            return tree;
        }
        
        // Billboard (very far) - Just a textured plane
        function createTreeBillboard(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Draw simple tree silhouette
            ctx.fillStyle = '#4a3520'; // Trunk
            ctx.fillRect(56, 160, 16, 96);
            
            // Canopy
            const foliageColors = ['#2d5a2d', '#1a4d1a', '#3a5a3a', '#8B4513'];
            ctx.fillStyle = foliageColors[type % 4];
            ctx.beginPath();
            ctx.arc(64, 128, 50, 0, Math.PI * 2);
            ctx.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                alphaTest: 0.5,
                side: THREE.DoubleSide
            });
            
            const billboard = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 8),
                material
            );
            billboard.position.y = 4;
            
            return billboard;
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // PARK FURNITURE
        // ═══════════════════════════════════════════════════════════════════════
        
        function createParkBench() {
            const bench = new THREE.Group();
            
            const woodMat = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const metalMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.4,
                metalness: 0.8
            });
            
            // Seat slats (3)
            for (let i = 0; i < 3; i++) {
                const slat = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.1, 0.3, 6, 2, 4),
                    woodMat
                );
                slat.position.y = 0.5 + (i * 0.15);
                slat.castShadow = true;
                bench.add(slat);
            }
            
            // Back rest slats (3)
            for (let i = 0; i < 3; i++) {
                const slat = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.1, 0.3, 6, 2, 4),
                    woodMat
                );
                slat.position.set(0, 1 + (i * 0.15), -0.4);
                slat.rotation.x = Math.PI / 8;
                slat.castShadow = true;
                bench.add(slat);
            }
            
            // Legs (4)
            const legPositions = [[-0.8, 0, 0], [0.8, 0, 0], [-0.8, 0, -0.4], [0.8, 0, -0.4]];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.5, 18, 1),
                    metalMat
                );
                leg.position.set(...pos);
                leg.position.y = 0.25;
                leg.castShadow = true;
                bench.add(leg);
            });
            
            applyHighDetail(bench, { multiplier: 2 });

            annotateObject(bench, {
                id: `bench_${bench.uuid.slice(0, 6)}`,
                name: `ParkBench_${bench.uuid.slice(0, 4)}`,
                type: 'prop-bench',
                category: 'furniture',
                description: 'Steel-framed park bench with triple-slat Brazilian walnut seating, modeled for hero shots with beveled edges for believable specular roll-off.',
                dimensions: {
                    widthMeters: 2,
                    depthMeters: 0.7,
                    heightMeters: 1.1
                },
                materials: [
                    { id: 'walnut_slat', description: 'High-roughness wood shader tuned for outdoor varnish wear.' },
                    { id: 'powdercoat_frame', description: 'Semi-gloss black powder-coated steel legs.' }
                ],
                animations: [],
                rendering: {
                    detail: 'Seat and back slats retopologized to 6×4 segments; cylindrical legs upgraded to 18 radial segments.',
                    castsShadow: true
                },
                tags: ['bench', 'park', 'furniture']
            });

            return bench;
        }
        
        function createLampPost() {
            const lamp = new THREE.Group();
            
            const metalMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.3,
                metalness: 0.9
            });
            
            // Pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.12, 5, 24, 2),
                metalMat
            );
            pole.position.y = 2.5;
            pole.castShadow = true;
            lamp.add(pole);
            
            // Lamp head
            const lampHead = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.4, 0.5, 24, 2),
                metalMat
            );
            lampHead.position.y = 5;
            lampHead.castShadow = true;
            lamp.add(lampHead);
            
            // Light source
            const light = new THREE.PointLight(0xffeecc, 2, 15);
            light.position.y = 4.8;
            light.castShadow = true;
            lamp.add(light);
            
            // Glow sphere
            const glowMat = new THREE.MeshStandardMaterial({
                color: 0xffffaa,
                emissive: 0xffffaa,
                emissiveIntensity: 1
            });
            const glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 24, 18),
                glowMat
            );
            glow.position.y = 4.8;
            lamp.add(glow);
            
            applyHighDetail(lamp, { multiplier: 2 });

            annotateObject(lamp, {
                id: `lamppost_${lamp.uuid.slice(0, 6)}`,
                name: `PathwayLamp_${lamp.uuid.slice(0, 4)}`,
                type: 'prop-lighting',
                category: 'infrastructure',
                description: 'Victorian-inspired lamp post with PBR metalwork, glass globe diffuser, and warm 2800K point light source for nighttime ambience.',
                dimensions: {
                    heightMeters: 5,
                    baseDiameterMeters: 0.24
                },
                materials: [
                    { id: 'wrought_iron', description: 'High-metalness blackened steel with subtle anisotropic highlights.' },
                    { id: 'opal_glass', description: 'Emissive glass dome calibrated for soft falloff.' }
                ],
                animations: [
                    { id: 'emissive_falloff', description: 'Static glow with baked falloff profile; hook provided for flicker variants.' }
                ],
                rendering: {
                    detail: 'Pole and lamp head cylinders increased to 24 radial segments; glow sphere set to 24×18 for halo smoothness.',
                    castsShadow: true
                },
                tags: ['lighting', 'prop', 'park', 'high-detail']
            });

            return lamp;
        }
        
        function createFlowerBed() {
            const bed = new THREE.Group();
            
            // Soil base
            const soilMat = new THREE.MeshStandardMaterial({
                color: 0x3a2820,
                roughness: 0.95
            });
            const soil = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32, 2),
                soilMat
            );
            soil.position.y = 0.1;
            soil.receiveShadow = true;
            bed.add(soil);
            
            // Flowers (random colors)
            const flowerColors = [0xff0000, 0xff69b4, 0xffff00, 0xff8c00, 0x9370db];
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const radius = 0.5 + Math.random() * 0.8;
                
                // Stem
                const stemMat = new THREE.MeshStandardMaterial({ color: 0x2d5a2d });
                const stem = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.02, 0.5, 12, 1),
                    stemMat
                );
                stem.position.set(
                    Math.cos(angle) * radius,
                    0.35,
                    Math.sin(angle) * radius
                );
                bed.add(stem);
                
                // Flower head
                const petalMat = new THREE.MeshStandardMaterial({
                    color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                    roughness: 0.7
                });
                const flower = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 16, 12),
                    petalMat
                );
                flower.position.set(
                    Math.cos(angle) * radius,
                    0.6,
                    Math.sin(angle) * radius
                );
                flower.castShadow = true;
                bed.add(flower);
            }
            
            applyHighDetail(bed, { multiplier: 2 });

            annotateObject(bed, {
                id: `flowerbed_${bed.uuid.slice(0, 6)}`,
                name: `PerennialRing_${bed.uuid.slice(0, 4)}`,
                type: 'flora-bed',
                category: 'flora',
                description: 'Circular perennial arrangement with randomized blossom hues, supportive stem geometry, and high-segment soil drum for seamless close-ups.',
                dimensions: {
                    diameterMeters: 3,
                    heightMeters: 0.5
                },
                materials: [
                    { id: 'garden_soil', description: 'Rich loam material with procedural roughness.' },
                    { id: 'petal_mix', description: 'Five-tone petal palette with glossy highlights.' }
                ],
                animations: [
                    { id: 'growth_cycle_placeholder', description: 'Placeholder for bud-to-bloom animation curves.' }
                ],
                rendering: {
                    detail: 'Soil upgraded to 32 radial segments; stems now 12 radial segments for cylindrical smoothness.',
                    castsShadow: true
                },
                tags: ['flora', 'garden', 'high-detail']
            });

            return bed;
        }
        
        function createBush() {
            const bush = new THREE.Group();
            
            const bushMat = new THREE.MeshStandardMaterial({
                color: 0x2d4a2d,
                roughness: 0.9
            });
            
            // Multiple spheres for bushy look
            const sphereCount = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < sphereCount; i++) {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4 + Math.random() * 0.3, 16, 12),
                    bushMat
                );
                sphere.position.set(
                    (Math.random() - 0.5) * 0.8,
                    0.3 + Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.8
                );
                sphere.castShadow = true;
                bush.add(sphere);
            }
            
            applyHighDetail(bush, { multiplier: 2 });

            annotateObject(bush, {
                id: `bush_${bush.uuid.slice(0, 6)}`,
                name: `ShrubCluster_${bush.uuid.slice(0, 4)}`,
                type: 'flora-bush',
                category: 'flora',
                description: 'Procedural shrub cluster comprised of 3-5 high-resolution foliage spheres, used to transition between formal landscaping and wild growth.',
                dimensions: {
                    diameterMeters: 1.2,
                    heightMeters: 0.8
                },
                materials: [
                    { id: 'shrub_leaf', description: 'Dense leaf material with mossy undertones for life-like shading.' }
                ],
                animations: [
                    { id: 'leaf_rustle_placeholder', description: 'Placeholder for shader-driven rustle animations.' }
                ],
                rendering: {
                    detail: 'Foliage spheres tessellated to 16×12 segments for organic silhouettes.',
                    castsShadow: true
                },
                tags: ['shrub', 'flora', 'high-detail']
            });

            return bush;
        }
        
        function createFallenLog() {
            const logMat = new THREE.MeshStandardMaterial({
                color: 0x4a3520,
                roughness: 0.95
            });
            
            const log = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.35, 4, 24, 4),
                logMat
            );
            log.rotation.z = Math.PI / 2;
            log.castShadow = true;
            log.receiveShadow = true;
            
            applyHighDetail(log, { multiplier: 2 });

            annotateObject(log, {
                id: `fallenlog_${log.uuid.slice(0, 6)}`,
                name: `ForestLog_${log.uuid.slice(0, 4)}`,
                type: 'prop-natural',
                category: 'environment-prop',
                description: 'Fallen hardwood log with tapered ends and high-resolution bark detail, positioned for forest storytelling and cover elements.',
                dimensions: {
                    lengthMeters: 4,
                    diameterMeters: 0.35
                },
                materials: [
                    { id: 'aged_bark', description: 'Weathered bark shader with high roughness and AO to emphasize crevices.' }
                ],
                animations: [],
                rendering: {
                    detail: 'Log cylinder subdivided to 24 radial segments for smooth curvature.',
                    castsShadow: true,
                    receivesShadow: true
                },
                tags: ['forest', 'prop', 'high-detail']
            });

            return log;
        }
        
        async function createLake() {
            console.log('🏞️ Filling lake...');
            
            const lakeCenter = new THREE.Vector3(200, 0, 0);
            const lakeRadius = 40;
            
            // ═══ WATER SURFACE (with animation) ═══
            const waterGeometry = new THREE.CircleGeometry(lakeRadius, 64);
            
            // Custom water shader
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x1E90FF,
                roughness: 0.1,
                metalness: 0.8,
                transparent: true,
                opacity: 0.85
            });
            
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.set(lakeCenter.x, 0.5, lakeCenter.z);
            water.receiveShadow = true;
            water.name = 'Lake_Water';
            worldObjects.add(water);
            
            // Add wave animation to water
            water.userData.animate = (time) => {
                water.position.y = 0.5 + Math.sin(time * 0.5) * 0.1;
            };
            
            // ═══ LAKE BOTTOM (darker) ═══
            const bottomGeometry = new THREE.CircleGeometry(lakeRadius - 2, 32);
            const bottomMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a4d6d,
                roughness: 0.95
            });
            const bottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
            bottom.rotation.x = -Math.PI / 2;
            bottom.position.set(lakeCenter.x, -1, lakeCenter.z);
            bottom.receiveShadow = true;
            worldObjects.add(bottom);
            
            // ═══ SHORELINE ROCKS ═══
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const distance = lakeRadius + Math.random() * 3;
                
                const rock = createRock();
                rock.position.set(
                    lakeCenter.x + Math.cos(angle) * distance,
                    0.2,
                    lakeCenter.z + Math.sin(angle) * distance
                );
                rock.rotation.y = Math.random() * Math.PI;
                worldObjects.add(rock);
            }
            
            // ═══ FISH (swimming) ═══
            for (let i = 0; i < 20; i++) {
                const fish = createFish();
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * (lakeRadius - 5);
                
                fish.position.set(
                    lakeCenter.x + Math.cos(angle) * radius,
                    -0.5 + Math.random() * 0.5,
                    lakeCenter.z + Math.sin(angle) * radius
                );
                fish.rotation.y = angle;
                fish.userData.swimPath = {
                    center: lakeCenter,
                    radius: radius,
                    speed: 0.2 + Math.random() * 0.3,
                    offset: Math.random() * Math.PI * 2
                };
                worldObjects.add(fish);
            }
            
            // ═══ DOCK ═══
            const dock = createDock();
            dock.position.set(lakeCenter.x - lakeRadius + 5, 0.3, lakeCenter.z);
            worldObjects.add(dock);
            
            console.log('✅ Lake complete');
        }
        
        async function createMountains() {
            console.log('⛰️ Raising mountains...');
            
            const mountainStart = 250;
            const mountainCount = 5;
            
            for (let i = 0; i < mountainCount; i++) {
                const x = mountainStart + (i * 40);
                const z = -30 + (Math.random() - 0.5) * 60;
                
                const mountain = createMountain(i);
                mountain.position.set(x, 0, z);
                worldObjects.add(mountain);
            }
            
            // ═══ MOUNTAIN TREES (pine trees on slopes) ═══
            for (let i = 0; i < 40; i++) {
                const x = mountainStart + Math.random() * 200;
                const z = -50 + Math.random() * 100;
                
                const tree = createPineTree();
                const scale = 0.6 + Math.random() * 0.4;
                tree.scale.set(scale, scale, scale);
                tree.position.set(x, 0, z);
                worldObjects.add(tree);
            }
            
            // ═══ ROCKY OUTCROPS ═══
            for (let i = 0; i < 25; i++) {
                const x = mountainStart + Math.random() * 200;
                const z = -50 + Math.random() * 100;
                
                const rock = createRock();
                const scale = 1 + Math.random() * 2;
                rock.scale.set(scale, scale, scale);
                rock.position.set(x, 0, z);
                worldObjects.add(rock);
            }
            
            console.log('✅ Mountains complete');
        }
        
        async function createOcean() {
            console.log('🌊 Generating ocean...');
            
            const oceanStart = 500;
            const oceanSize = 500;
            
            // ═══ OCEAN WATER (animated waves) ═══
            const oceanGeometry = new THREE.PlaneGeometry(oceanSize, oceanSize, 100, 100);
            
            // Add wave displacement
            const positions = oceanGeometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 1];
                // Initial wave pattern
                positions[i + 2] = Math.sin(x * 0.1) * 0.5 + Math.cos(z * 0.1) * 0.5;
            }
            oceanGeometry.computeVertexNormals();
            
            const oceanMaterial = new THREE.MeshStandardMaterial({
                color: 0x006994,
                roughness: 0.1,
                metalness: 0.9,
                transparent: true,
                opacity: 0.9
            });
            
            const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            ocean.rotation.x = -Math.PI / 2;
            ocean.position.set(oceanStart + oceanSize / 2, 0, 0);
            ocean.receiveShadow = true;
            ocean.name = 'Ocean';
            worldObjects.add(ocean);
            
            // Animate ocean waves
            ocean.userData.animate = (time) => {
                const positions = ocean.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const z = positions[i + 1];
                    positions[i + 2] = 
                        Math.sin(x * 0.05 + time) * 1.5 + 
                        Math.cos(z * 0.05 + time * 0.7) * 1.5 +
                        Math.sin((x + z) * 0.03 + time * 1.3) * 0.8;
                }
                ocean.geometry.attributes.position.needsUpdate = true;
                ocean.geometry.computeVertexNormals();
            };
            
            // ═══ WHALES (swimming) ═══
            for (let i = 0; i < 3; i++) {
                const whale = createWhale();
                whale.position.set(
                    oceanStart + Math.random() * oceanSize,
                    -2,
                    -100 + Math.random() * 200
                );
                whale.rotation.y = Math.random() * Math.PI * 2;
                whale.userData.swimPath = {
                    speed: 0.1,
                    offset: Math.random() * Math.PI * 2
                };
                worldObjects.add(whale);
            }
            
            // ═══ SEAGULLS (flying) ═══
            for (let i = 0; i < 8; i++) {
                const bird = createSeagull();
                bird.position.set(
                    oceanStart + Math.random() * oceanSize,
                    5 + Math.random() * 10,
                    -100 + Math.random() * 200
                );
                bird.userData.flightPath = {
                    speed: 0.5 + Math.random() * 0.3,
                    radius: 20 + Math.random() * 30,
                    offset: Math.random() * Math.PI * 2
                };
                worldObjects.add(bird);
            }
            
            // ═══ BEACH (transition from land) ═══
            const beachGeometry = new THREE.PlaneGeometry(50, oceanSize, 20, 20);
            const beachMaterial = new THREE.MeshStandardMaterial({
                color: 0xF4A460, // Sandy color
                roughness: 0.95
            });
            const beach = new THREE.Mesh(beachGeometry, beachMaterial);
            beach.rotation.x = -Math.PI / 2;
            beach.position.set(oceanStart - 25, 0.1, 0);
            beach.receiveShadow = true;
            worldObjects.add(beach);
            
            console.log('✅ Ocean complete');
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // MOUNTAIN GENERATION
        // ═══════════════════════════════════════════════════════════════════════
        
        function createMountain(index) {
            const mountain = new THREE.Group();
            mountain.name = `Mountain_${index}`;
            
            // Base height variation
            const baseHeight = 40 + Math.random() * 30;
            const baseWidth = 30 + Math.random() * 20;
            
            const rockMaterial = new THREE.MeshStandardMaterial({
                color: 0x696969,
                roughness: 0.9,
                metalness: 0.1
            });
            
            // Create peaked mountain shape (multiple cones)
            const peakLayers = 5;
            
            for (let i = 0; i < peakLayers; i++) {
                const heightRatio = 1 - (i / peakLayers);
                const height = (baseHeight / peakLayers) * (1 + heightRatio);
                const radius = baseWidth * heightRatio;
                
                const coneGeometry = new THREE.ConeGeometry(radius, height, 8);
                const cone = new THREE.Mesh(coneGeometry, rockMaterial);
                
                let yPos = 0;
                for (let j = 0; j < i; j++) {
                    yPos += (baseHeight / peakLayers) * (1 + (1 - j / peakLayers)) / 2;
                }
                
                cone.position.y = yPos + height / 2;
                cone.castShadow = true;
                cone.receiveShadow = true;
                mountain.add(cone);
            }
            
            // ═══ SNOW CAP ═══
            const snowMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const snowCapGeometry = new THREE.ConeGeometry(baseWidth * 0.3, baseHeight * 0.3, 8);
            const snowCap = new THREE.Mesh(snowCapGeometry, snowMaterial);
            snowCap.position.y = baseHeight * 0.85;
            mountain.add(snowCap);
            
            return mountain;
        }
        
        function createRock() {
            const rockMaterial = new THREE.MeshStandardMaterial({
                color: 0x505050,
                roughness: 0.95,
                metalness: 0.05
            });
            
            // Irregular rock shape
            const geometry = new THREE.DodecahedronGeometry(0.5 + Math.random() * 0.5, 0);
            
            // Distort vertices for irregular shape
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] *= 0.8 + Math.random() * 0.4;
                positions[i + 1] *= 0.8 + Math.random() * 0.4;
                positions[i + 2] *= 0.8 + Math.random() * 0.4;
            }
            geometry.computeVertexNormals();
            
            const rock = new THREE.Mesh(geometry, rockMaterial);
            rock.castShadow = true;
            rock.receiveShadow = true;
            
            return rock;
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // WATER FEATURES
        // ═══════════════════════════════════════════════════════════════════════
        
        function createDock() {
            const dock = new THREE.Group();
            
            const woodMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B7355,
                roughness: 0.8
            });
            
            // Deck planks
            for (let i = 0; i < 10; i++) {
                const plank = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.2, 0.8),
                    woodMaterial
                );
                plank.position.set(i * 2, 0, 0);
                plank.castShadow = true;
                dock.add(plank);
            }
            
            // Support posts
            for (let i = 0; i < 4; i++) {
                const post = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 2, 8),
                    woodMaterial
                );
                post.position.set(i * 5, -1, 0.8);
                post.castShadow = true;
                dock.add(post);
                
                const post2 = post.clone();
                post2.position.z = -0.8;
                dock.add(post2);
            }
            
            return dock;
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // WILDLIFE
        // ═══════════════════════════════════════════════════════════════════════
        
        function createFish() {
            const fish = new THREE.Group();
            
            const fishMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF6347,
                roughness: 0.3,
                metalness: 0.5
            });
            
            // Body
            const bodyGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            bodyGeometry.scale(1.5, 1, 1); // Elongate
            const body = new THREE.Mesh(bodyGeometry, fishMaterial);
            body.castShadow = true;
            fish.add(body);
            
            // Tail
            const tailGeometry = new THREE.ConeGeometry(0.2, 0.4, 6);
            const tail = new THREE.Mesh(tailGeometry, fishMaterial);
            tail.rotation.z = Math.PI / 2;
            tail.position.x = -0.5;
            fish.add(tail);
            
            // Fins
            const finGeometry = new THREE.ConeGeometry(0.1, 0.3, 4);
            const finTop = new THREE.Mesh(finGeometry, fishMaterial);
            finTop.rotation.z = Math.PI;
            finTop.position.y = 0.3;
            fish.add(finTop);
            
            return fish;
        }
        
        function createWhale() {
            const whale = new THREE.Group();
            
            const whaleMaterial = new THREE.MeshStandardMaterial({
                color: 0x2F4F4F,
                roughness: 0.6,
                metalness: 0.3
            });
            
            // Body (large)
            const bodyGeometry = new THREE.SphereGeometry(2, 16, 16);
            bodyGeometry.scale(3, 1.5, 1);
            const body = new THREE.Mesh(bodyGeometry, whaleMaterial);
            body.castShadow = true;
            whale.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(1.5, 12, 12);
            const head = new THREE.Mesh(headGeometry, whaleMaterial);
            head.position.set(4, 0, 0);
            whale.add(head);
            
            // Tail flukes
            const tailGeometry = new THREE.BoxGeometry(0.5, 0.2, 4);
            const tail = new THREE.Mesh(tailGeometry, whaleMaterial);
            tail.position.set(-5, 0, 0);
            whale.add(tail);
            
            // Dorsal fin
            const finGeometry = new THREE.ConeGeometry(0.5, 1.5, 6);
            const fin = new THREE.Mesh(finGeometry, whaleMaterial);
            fin.rotation.z = Math.PI;
            fin.position.y = 2;
            whale.add(fin);
            
            return whale;
        }
        
        function createSeagull() {
            const bird = new THREE.Group();
            
            const birdMaterial = new THREE.MeshStandardMaterial({
                color: 0xEEEEEE,
                roughness: 0.7
            });
            
            // Body
            const bodyGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            bodyGeometry.scale(1.5, 1, 1);
            const body = new THREE.Mesh(bodyGeometry, birdMaterial);
            bird.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const head = new THREE.Mesh(headGeometry, birdMaterial);
            head.position.set(0.25, 0.1, 0);
            bird.add(head);
            
            // Wings (2)
            const wingGeometry = new THREE.BoxGeometry(0.05, 0.1, 0.8);
            const wingL = new THREE.Mesh(wingGeometry, birdMaterial);
            wingL.position.set(0, 0.1, 0.5);
            wingL.rotation.y = Math.PI / 6;
            bird.add(wingL);
            
            const wingR = new THREE.Mesh(wingGeometry, birdMaterial);
            wingR.position.set(0, 0.1, -0.5);
            wingR.rotation.y = -Math.PI / 6;
            bird.add(wingR);
            
            // Beak
            const beakGeometry = new THREE.ConeGeometry(0.05, 0.15, 6);
            const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xFFA500 });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.rotation.z = -Math.PI / 2;
            beak.position.set(0.35, 0.1, 0);
            bird.add(beak);
            
            return bird;
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // HUMANS & LAND ANIMALS
        // ═══════════════════════════════════════════════════════════════════════
        // VSL CHARACTER SYSTEM INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════════
        
        // Player Character Creation Function (must be defined before initVSLCharacters)
        function createPlayerCharacter() {
            // VSL CHARACTER - Player is now a living vertex being!
            console.log('🎭 Creating player as VSL character...');
            
            // Create VSL character at origin
            const vslPlayerData = vslCharacterGenerator.createCharacter({
                name: 'Player_VSL',
                position: { x: 0, y: 0, z: 0 }
            });
            
            // Apply player-specific VSL behaviors
            vslCharacterGenerator.executeVSL('Player_VSL', 'head.sway.gentle');
            vslCharacterGenerator.executeVSL('Player_VSL', 'spine.breathe');
            vslCharacterGenerator.executeVSL('Player_VSL', 'left_arm.idle.gentle');
            vslCharacterGenerator.executeVSL('Player_VSL', 'right_arm.idle.gentle');
            
            // Create a wrapper group for compatibility
            const player = new THREE.Group();
            player.position.set(0, 0, 0);
            
            // Add all VSL meshes to the player group
            vslPlayerData.meshes.forEach(mesh => {
                player.add(mesh);
            });
            
            // Store reference to VSL character data
            player.userData.vslCharacter = vslPlayerData;
            player.userData.isVSL = true;
            
            // Store body parts for animation - map VSL skeleton to expected structure
            const skeleton = vslPlayerData.skeleton;
            player.userData.bodyParts = {
                body: skeleton.spine_mid,
                head: skeleton.head,
                leftArm: skeleton.left_elbow,
                rightArm: skeleton.right_elbow,
                leftLeg: skeleton.left_knee,
                rightLeg: skeleton.right_knee,
                leftEye: skeleton.head, // VSL head contains eyes
                rightEye: skeleton.head,
                sword: null // TODO: Add sword to VSL character later
            };
            
            console.log('✅ Player is now a VSL character with triangle mesh body!');
            
            return player;
        }
        
        async function initVSLCharacters() {
            console.log('🎭 Initializing VSL Character System...');
            
            // Create VSL character generator
            vslCharacterGenerator = new VSLCharacterGenerator(scene);
            
            // CREATE PLAYER CHARACTER FIRST (as VSL!)
            console.log('👤 Creating player as VSL character...');
            playerCharacter = createPlayerCharacter();
            playerCharacter.visible = thirdPersonMode; // Hidden in first person
            scene.add(playerCharacter);
            console.log('✅ Player is now a VSL character!');
            
            // Create a few VSL characters around the world
            const vslLocations = [
                { name: 'VSL_Guard1', position: { x: -100, y: 0, z: -30 } },
                { name: 'VSL_Dancer', position: { x: -120, y: 0, z: 10 } },
                { name: 'VSL_Merchant', position: { x: 50, y: 0, z: 50 } }
            ];
            
            vslLocations.forEach(loc => {
                const char = vslCharacterGenerator.createCharacter({
                    name: loc.name,
                    position: loc.position
                });
                console.log(`✓ Created VSL character: ${loc.name}`);
            });
            
            console.log(`✅ VSL Character System initialized with ${vslCharacterGenerator.characters.length} NPC characters + Player`);
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        
        async function createWildlifeAndNPCs() {
            console.log('👥 Adding NPCs and land animals...');
            
            // ═══ NEIGHBORHOOD NPCs (walking around slowly - relaxed pace) ═══
            for (let i = 0; i < 5; i++) {
                const npc = createSimpleHuman();
                npc.position.set(
                    -150 + Math.random() * 100,
                    1, // Ground level (NPCs are ~2 units tall, so 1 = feet on ground)
                    -50 + Math.random() * 75
                );
                npc.rotation.y = Math.random() * Math.PI * 2;
                npc.userData.walkPath = {
                    speed: 0.05 + Math.random() * 0.03, // Much slower, leisurely stroll
                    turnChance: 0.008,
                    pauseChance: 0.02, // Occasionally stop to look around
                    pauseDuration: 2 + Math.random() * 3
                };
                worldObjects.add(npc);
            }
            
            // ═══ NEIGHBORHOOD CONVERSATIONS (stationary NPCs talking) ═══
            const neighborhoodConvoSpots = [
                { x: -130, z: -20 },
                { x: -110, z: 10 },
                { x: -140, z: 30 }
            ];
            neighborhoodConvoSpots.forEach(spot => {
                for (let i = 0; i < 2; i++) {
                    const npc = createSimpleHuman();
                    npc.position.set(
                        spot.x + (Math.random() - 0.5) * 3,
                        1, // Ground level
                        spot.z + (Math.random() - 0.5) * 3
                    );
                    npc.rotation.y = Math.random() * Math.PI * 2;
                    npc.userData.talking = {
                        partner: spot,
                        headTurnSpeed: 0.3 + Math.random() * 0.2,
                        gestureChance: 0.01
                    };
                    worldObjects.add(npc);
                }
            });
            
            // ═══ COLLEGE STUDENTS (mix of walking and sitting) ═══
            // Walking students - slower pace
            for (let i = 0; i < 6; i++) {
                const student = createSimpleHuman();
                student.position.set(
                    -40 + Math.random() * 60,
                    0,
                    -20 + Math.random() * 60
                );
                student.rotation.y = Math.random() * Math.PI * 2;
                student.userData.walkPath = {
                    speed: 0.06 + Math.random() * 0.04, // Casual walking
                    turnChance: 0.015,
                    pauseChance: 0.03,
                    pauseDuration: 3 + Math.random() * 4,
                    bounds: { minX: -40, maxX: 20, minZ: -20, maxZ: 40 }
                };
                worldObjects.add(student);
            }
            
            // Sitting students (on benches, grass)
            const campusSittingSpots = [
                { x: -20, z: 10 }, { x: 0, z: 25 }, { x: -30, z: -5 },
                { x: 10, z: 15 }, { x: -15, z: 30 }
            ];
            campusSittingSpots.forEach(spot => {
                const student = createSimpleHuman();
                student.position.set(spot.x, 1, spot.z); // Ground level
                student.rotation.y = Math.random() * Math.PI * 2;
                student.userData.sitting = {
                    lookAround: true,
                    lookSpeed: 0.2,
                    readingBook: Math.random() > 0.5
                };
                worldObjects.add(student);
            });
            
            // ═══ IMPORTANT NPC: PROFESSOR (triggers cinematic) ═══
            const professor = createSimpleHuman();
            professor.position.set(-10, 1, 5); // Near college entrance
            professor.rotation.y = Math.PI / 4;
            professor.scale.set(1.1, 1.1, 1.1); // Slightly larger
            
            // Mark as important for cinematic trigger
            professor.userData.isImportantNPC = true;
            professor.userData.npcName = 'Professor Daniels';
            professor.userData.cinematicPlayed = false;
            
            // Make professor stand out visually
            professor.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material = child.material.clone();
                    if (child.material.color) {
                        child.material.color.setHex(0x4444aa); // Distinguished blue attire
                    }
                    if (child.material.emissive) {
                        child.material.emissive.setHex(0x222255);
                        child.material.emissiveIntensity = 0.2;
                    }
                }
            });
            
            worldObjects.add(professor);
            console.log('🎓 Important NPC added: Professor at college');
            
            // ═══ PARK VISITORS (mostly sitting and relaxing) ═══
            // A few slow walkers
            for (let i = 0; i < 2; i++) {
                const visitor = createSimpleHuman();
                visitor.position.set(
                    50 + Math.random() * 40,
                    0,
                    -30 + Math.random() * 40
                );
                visitor.rotation.y = Math.random() * Math.PI * 2;
                visitor.userData.walkPath = {
                    speed: 0.04 + Math.random() * 0.02, // Very leisurely
                    turnChance: 0.02,
                    pauseChance: 0.05,
                    pauseDuration: 4 + Math.random() * 5,
                    bounds: { minX: 40, maxX: 80, minZ: -40, maxZ: 10 }
                };
                worldObjects.add(visitor);
            }
            
            // Sitting visitors (benches, picnic)
            const parkBenchSpots = [
                { x: 55, z: -20 }, { x: 65, z: -10 }, { x: 70, z: 0 },
                { x: 60, z: -30 }, { x: 75, z: -15 }
            ];
            parkBenchSpots.forEach((spot, idx) => {
                const visitor = createSimpleHuman();
                visitor.position.set(spot.x, 1, spot.z); // Ground level
                visitor.rotation.y = Math.random() * Math.PI * 2;
                visitor.userData.sitting = {
                    lookAround: true,
                    lookSpeed: 0.15,
                    feeding: idx < 2 // First two feeding birds
                };
                worldObjects.add(visitor);
            });
            
            // Couples/groups talking in park
            const parkConvoSpots = [
                { x: 58, z: -25 }, { x: 72, z: -8 }
            ];
            parkConvoSpots.forEach(spot => {
                for (let i = 0; i < 2; i++) {
                    const npc = createSimpleHuman();
                    npc.position.set(
                        spot.x + (Math.random() - 0.5) * 2,
                        1, // Ground level
                        spot.z + (Math.random() - 0.5) * 2
                    );
                    npc.rotation.y = Math.random() * Math.PI * 2;
                    npc.userData.talking = {
                        partner: spot,
                        headTurnSpeed: 0.25,
                        gestureChance: 0.015,
                        sitting: true
                    };
                    worldObjects.add(npc);
                }
            });
            
            // ═══ FOREST DEER ═══
            for (let i = 0; i < 10; i++) {
                const deer = createDeer();
                deer.position.set(
                    100 + Math.random() * 60,
                    0.5, // Animals are smaller, closer to ground
                    -40 + Math.random() * 80
                );
                deer.rotation.y = Math.random() * Math.PI * 2;
                deer.userData.walkPath = {
                    speed: 0.5 + Math.random() * 0.3,
                    turnChance: 0.05,
                    bounds: { minX: 90, maxX: 170, minZ: -50, maxZ: 50 }
                };
                worldObjects.add(deer);
            }
            
            // ═══ RABBITS (near park and forest) ═══
            for (let i = 0; i < 15; i++) {
                const rabbit = createRabbit();
                rabbit.position.set(
                    60 + Math.random() * 100,
                    0.3, // Small animals, just above ground
                    -40 + Math.random() * 60
                );
                rabbit.rotation.y = Math.random() * Math.PI * 2;
                rabbit.userData.walkPath = {
                    speed: 0.8 + Math.random() * 0.4,
                    turnChance: 0.1, // More erratic movement
                    bounds: { minX: 50, maxX: 170, minZ: -50, maxZ: 30 }
                };
                worldObjects.add(rabbit);
            }
            
            // ═══ BIRDS ON GROUND (pecking) ═══
            for (let i = 0; i < 12; i++) {
                const bird = createGroundBird();
                bird.position.set(
                    -100 + Math.random() * 200,
                    0.1,
                    -30 + Math.random() * 60
                );
                bird.rotation.y = Math.random() * Math.PI * 2;
                bird.userData.walkPath = {
                    speed: 0.3 + Math.random() * 0.2,
                    turnChance: 0.15,
                    pecking: true
                };
                worldObjects.add(bird);
            }

            // ═══ ORC WAR SCOUTS (near mountain pass) ═══
            const orcPositions = [
                new THREE.Vector3(210, 0, -5),
                new THREE.Vector3(235, 0, 15)
            ];

            orcPositions.forEach((pos, idx) => {
                const orc = createOrc();
                orc.position.copy(pos);
                orc.rotation.y = Math.random() * Math.PI * 2;
                orc.userData.walkPath = {
                    speed: 0.25 + Math.random() * 0.15,
                    turnChance: 0.01,
                    bounds: { minX: 200, maxX: 260, minZ: -30, maxZ: 40 }
                };
                orc.userData.spawnContext = {
                    encounter: 'mountain_pass_patrol',
                    index: idx,
                    patrolBounds: { xRange: [200, 260], zRange: [-30, 40] }
                };

                worldObjects.add(orc);
            });
            
            console.log('✅ Wildlife and NPCs added');

            // Immediately clear any that may have landed in the start zone
            enforceStartSafeZone();
        }
        
        function createSimpleHuman() {
            const human = new THREE.Group();
            human.name = 'NPC_AnatomicalHuman';
            
            const height = 1.7 + Math.random() * 0.2;
            const skinTone = [0xffe0bd, 0xffcd94, 0xeac086, 0xd4a574, 0xa67c52, 0x8d5524];
            const clothingColor = [0x2C3E50, 0x8E44AD, 0x2980B9, 0x27AE60, 0xE74C3C, 0xF39C12];
            
            const skinColor = skinTone[Math.floor(Math.random() * skinTone.length)];
            const shirtColor = clothingColor[Math.floor(Math.random() * clothingColor.length)];
            const pantsColor = clothingColor[Math.floor(Math.random() * clothingColor.length)];
            const build = ['slim', 'average', 'muscular'][Math.floor(Math.random() * 3)];
            
            // ═══ HEAD (Anatomically accurate sphere) ═══
            const headMat = new THREE.MeshStandardMaterial({ 
                color: skinColor, 
                roughness: 0.6,
                metalness: 0
            });
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.12 * height, 28, 20),
                headMat
            );
            head.position.y = 1.55 * height;
            head.castShadow = true;
            human.add(head);
            
            // ═══ FACIAL FEATURES ═══
            // Eyes
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.015 * height, 16, 12), eyeMat);
            eyeL.position.set(-0.04 * height, 1.57 * height, 0.11 * height);
            human.add(eyeL);
            
            const eyeR = eyeL.clone();
            eyeR.position.x = 0.04 * height;
            human.add(eyeR);
            
            // Pupils
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
            const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.008 * height, 12, 8), pupilMat);
            pupilL.position.set(-0.04 * height, 1.57 * height, 0.12 * height);
            human.add(pupilL);
            
            const pupilR = pupilL.clone();
            pupilR.position.x = 0.04 * height;
            human.add(pupilR);
            
            // Nose
            const nose = new THREE.Mesh(
                new THREE.ConeGeometry(0.015 * height, 0.03 * height, 16, 2),
                new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.7 })
            );
            nose.position.set(0, 1.55 * height, 0.12 * height);
            nose.rotation.x = Math.PI / 2;
            human.add(nose);
            
            // Mouth
            const mouth = new THREE.Mesh(
                new THREE.TorusGeometry(0.02 * height, 0.005 * height, 16, 48, Math.PI),
                new THREE.MeshStandardMaterial({ color: 0xff6b6b, roughness: 0.8 })
            );
            mouth.position.set(0, 1.52 * height, 0.11 * height);
            mouth.rotation.x = Math.PI / 2;
            human.add(mouth);
            
            // Ears
            const earMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.7 });
            const earL = new THREE.Mesh(new THREE.SphereGeometry(0.025 * height, 16, 12), earMat);
            earL.scale.set(0.5, 1, 0.5);
            earL.position.set(-0.12 * height, 1.55 * height, 0);
            human.add(earL);
            
            const earR = earL.clone();
            earR.position.x = 0.12 * height;
            human.add(earR);
            
            // Hair (simple cap)
            const hairColors = [0x1a1a1a, 0x3d2817, 0x8b4513, 0xdaa520, 0xffd700];
            const hairMat = new THREE.MeshStandardMaterial({ 
                color: hairColors[Math.floor(Math.random() * hairColors.length)],
                roughness: 0.9 
            });
            const hair = new THREE.Mesh(
                new THREE.SphereGeometry(0.125 * height, 24, 18, 0, Math.PI * 2, 0, Math.PI / 2),
                hairMat
            );
            hair.position.y = 1.55 * height;
            human.add(hair);
            
            // ═══ NECK ═══
            const neckMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.6 });
            const neck = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06 * height, 0.07 * height, 0.15 * height, 18, 1),
                neckMat
            );
            neck.position.y = 1.4 * height;
            neck.castShadow = true;
            human.add(neck);
            
            // ═══ TORSO (Anatomically tapered) ═══
            const buildMultiplier = build === 'slim' ? 0.9 : build === 'muscular' ? 1.15 : 1;
            const bodyMat = new THREE.MeshStandardMaterial({ color: shirtColor, roughness: 0.8 });
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.15 * height * buildMultiplier, 0.5 * height, 12, 24),
                bodyMat
            );
            body.position.y = 1.0 * height;
            body.castShadow = true;
            human.add(body);
            
            // ═══ ARMS (Upper + Forearm segments) ═══
            const armMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.7 });
            
            // Left arm
            const upperArmL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.04 * height * buildMultiplier, 0.25 * height, 10, 20),
                armMat
            );
            upperArmL.position.set(-0.22 * height, 1.05 * height, 0);
            upperArmL.castShadow = true;
            human.add(upperArmL);
            
            const forearmL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.035 * height * buildMultiplier, 0.25 * height, 10, 20),
                armMat
            );
            forearmL.position.set(-0.22 * height, 0.75 * height, 0);
            forearmL.castShadow = true;
            human.add(forearmL);
            
            // Right arm
            const upperArmR = upperArmL.clone();
            upperArmR.position.x = 0.22 * height;
            human.add(upperArmR);
            
            const forearmR = forearmL.clone();
            forearmR.position.x = 0.22 * height;
            human.add(forearmR);
            
            // ═══ HANDS (with fingers!) ═══
            for (let side = -1; side <= 1; side += 2) {
                // Palm
                const palm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08 * height, 0.1 * height, 0.02 * height, 6, 6, 4),
                    armMat
                );
                palm.position.set(side * 0.22 * height, 0.5 * height, 0);
                palm.castShadow = true;
                human.add(palm);
                
                // 5 Fingers
                for (let finger = 0; finger < 5; finger++) {
                    const fingerMesh = new THREE.Mesh(
                        new THREE.CapsuleGeometry(0.008 * height, 0.06 * height, 8, 12),
                        armMat
                    );
                    fingerMesh.position.set(
                        side * 0.22 * height + (finger - 2) * 0.015 * height,
                        0.42 * height,
                        0
                    );
                    fingerMesh.castShadow = true;
                    human.add(fingerMesh);
                }
            }
            
            // ═══ LEGS (Thigh + Calf segments) ═══
            const legMat = new THREE.MeshStandardMaterial({ color: pantsColor, roughness: 0.9 });
            
            // Left leg
            const thighL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.08 * height * buildMultiplier, 0.4 * height, 12, 24),
                legMat
            );
            thighL.position.set(-0.1 * height, 0.5 * height, 0);
            thighL.castShadow = true;
            human.add(thighL);
            
            const calfL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06 * height * buildMultiplier, 0.35 * height, 12, 24),
                legMat
            );
            calfL.position.set(-0.1 * height, 0.18 * height, 0);
            calfL.castShadow = true;
            human.add(calfL);
            
            // Right leg
            const thighR = thighL.clone();
            thighR.position.x = 0.1 * height;
            human.add(thighR);
            
            const calfR = calfL.clone();
            calfR.position.x = 0.1 * height;
            human.add(calfR);
            
            // ═══ FEET ═══
            const footMat = new THREE.MeshStandardMaterial({ color: 0x2C3E50, roughness: 0.8 });
            for (let side = -1; side <= 1; side += 2) {
                const foot = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08 * height, 0.04 * height, 0.15 * height, 6, 4, 6),
                    footMat
                );
                foot.position.set(side * 0.1 * height, 0.02 * height, 0.05 * height);
                foot.castShadow = true;
                human.add(foot);
            }
            
            // Store references for animation
            human.userData.legL = thighL;
            human.userData.legR = thighR;
            human.userData.armL = upperArmL;
            human.userData.armR = upperArmR;
            human.userData.walkCycle = 0;
            human.userData.phaseShift = Math.random() * Math.PI * 2;

            human.userData.animate = (time) => {
                const breath = 1 + Math.sin(time * 0.45 + human.userData.phaseShift) * 0.02;
                body.scale.y = breath;
                body.scale.x = 1 + Math.sin(time * 0.45 + human.userData.phaseShift) * 0.01;
                head.rotation.y = Math.sin(time * 0.2 + human.userData.phaseShift) * 0.05;
                hair.rotation.y = head.rotation.y * 0.6;
            };

            annotateObject(human, {
                id: `npc_human_${human.uuid.slice(0, 6)}`,
                name: `HumanNPC_${build}_${human.uuid.slice(0, 4)}`,
                type: 'character-human',
                category: 'character',
                description: `Procedural human NPC (${build} build) with high-resolution cranial mesh, articulated fingers, and breathing micro-animation for crowd simulation close-ups.`,
                dimensions: {
                    standingHeightMeters: Number(height.toFixed(2)),
                    shoulderSpanMeters: Number((0.44 * height * buildMultiplier).toFixed(2))
                },
                materials: [
                    { id: 'dermal_shader', description: 'Skin-toned PBR material with soft roughness for subsurface approximation.' },
                    { id: 'garment_top', description: 'Procedural cloth shader for shirts/tunics with mid-level roughness.' },
                    { id: 'garment_bottom', description: 'Textile shader tuned for pants with heavier roughness and muted specular highlights.' }
                ],
                animations: [
                    { id: 'walk_cycle', description: 'Parametric limb swing driven in update loop (5 Hz) for locomotion paths.' },
                    { id: 'breathing_idle', description: 'Sinusoidal torso scaling at 0.45 Hz to emulate respiration.' }
                ],
                rendering: {
                    detail: 'Head mesh 28×20 segments, limbs 12×24 capsule segments, hands retopologized for individual finger articulation.',
                    castsShadow: true
                },
                tags: ['npc', 'human', 'anatomical', 'high-detail']
            });
            
            // ═══ STORE BODY PARTS FOR PHYSICS ANIMATION ═══
            human.userData.bodyParts = {
                head: head,
                body: body,
                leftArm: upperArmL,
                rightArm: upperArmR,
                leftLeg: thighL,
                rightLeg: thighR
            };
            
            // ═══ ENABLE PHYSICS-BASED ANIMATION ═══
            const physics = window.enableCharacterPhysics(human);
            
            // Randomize initial behavior
            const behaviors = ['idle', 'walking', 'sitting'];
            const weights = [0.3, 0.5, 0.2]; // 30% idle, 50% walking, 20% sitting
            const roll = Math.random();
            let cumulative = 0;
            let chosenBehavior = 'idle';
            
            for (let i = 0; i < behaviors.length; i++) {
                cumulative += weights[i];
                if (roll <= cumulative) {
                    chosenBehavior = behaviors[i];
                    break;
                }
            }
            
            // Set initial behavior with random state data
            if (chosenBehavior === 'sitting') {
                const activities = ['drinking_coffee', 'vaping', 'just_sitting'];
                const activity = activities[Math.floor(Math.random() * activities.length)];
                physics.setBehavior('sitting', {
                    drinkingCoffee: activity === 'drinking_coffee',
                    vaping: activity === 'vaping'
                });
            } else if (chosenBehavior === 'walking') {
                physics.setBehavior('walking', { speed: 0.8 + Math.random() * 0.6 });
            } else {
                physics.setBehavior('idle');
            }
            
            return human;
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // FANTASY RACE GENERATORS - From character_models.json
        // ═══════════════════════════════════════════════════════════════════════
        
        function createElf() {
            const elf = new THREE.Group();
            elf.name = 'NPC_Elf';
            
            // Elves: Taller (1.75-1.95m), graceful, pointed ears
            const height = 1.75 + Math.random() * 0.2;
            const skinColor = [0xffdfc4, 0xffe4e1, 0xf0f0ff][Math.floor(Math.random() * 3)]; // Light, pale, moonlight
            const clothingColor = [0x2C5F2D, 0x4A90E2, 0x9B59B6, 0xF39C12]; // Elegant colors
            const shirtColor = clothingColor[Math.floor(Math.random() * clothingColor.length)];
            const pantsColor = clothingColor[Math.floor(Math.random() * clothingColor.length)];
            
            // ═══ HEAD (Slightly narrower, more angular) ═══
            const headMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.5, metalness: 0 });
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.11 * height, 18, 18), // Slightly smaller, higher poly
                headMat
            );
            head.scale.set(0.95, 1.05, 0.95); // More angular face
            head.position.y = 1.6 * height; // Taller proportions
            head.castShadow = true;
            elf.add(head);
            
            // ═══ POINTED ELVEN EARS ═══
            const earMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.6 });
            const earL = new THREE.Mesh(new THREE.ConeGeometry(0.02 * height, 0.08 * height, 12, 2), earMat);
            earL.rotation.z = -Math.PI / 4; // Point upward
            earL.position.set(-0.11 * height, 1.62 * height, 0);
            elf.add(earL);
            
            const earR = earL.clone();
            earR.rotation.z = Math.PI / 4;
            earR.position.x = 0.11 * height;
            elf.add(earR);
            
            // ═══ ELEGANT FACIAL FEATURES ═══
            // Almond-shaped eyes
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xe6f3ff, roughness: 0.2 });
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.018 * height, 20, 14), eyeMat);
            eyeL.scale.set(1.3, 0.8, 1); // Almond shape
            eyeL.position.set(-0.04 * height, 1.61 * height, 0.105 * height);
            elf.add(eyeL);
            
            const eyeR = eyeL.clone();
            eyeR.position.x = 0.04 * height;
            elf.add(eyeR);
            
            // Pupils (often silver/violet for elves)
            const pupilColors = [0x4a5568, 0x9b59b6, 0xc0c0c0]; // Gray, violet, silver
            const pupilMat = new THREE.MeshBasicMaterial({ color: pupilColors[Math.floor(Math.random() * pupilColors.length)] });
            const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.009 * height, 12, 8), pupilMat);
            pupilL.position.set(-0.04 * height, 1.61 * height, 0.115 * height);
            elf.add(pupilL);
            
            const pupilR = pupilL.clone();
            pupilR.position.x = 0.04 * height;
            elf.add(pupilR);
            
            // Long flowing hair (elven style)
            const hairColors = [0xffd700, 0xf5f5dc, 0xc0c0c0, 0x1a1a1a]; // Blonde, beige, silver, black
            const hairMat = new THREE.MeshStandardMaterial({ color: hairColors[Math.floor(Math.random() * hairColors.length)], roughness: 0.8 });
            const hair = new THREE.Mesh(
                new THREE.SphereGeometry(0.12 * height, 24, 18, 0, Math.PI * 2, 0, Math.PI / 1.8),
                hairMat
            );
            hair.position.y = 1.6 * height;
            elf.add(hair);
            
            // Hair flow down back
            for (let i = 0; i < 3; i++) {
                const hairStrand = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02 * height, 0.015 * height, 0.3 * height, 16, 1),
                    hairMat
                );
                hairStrand.position.set((i - 1) * 0.03 * height, 1.35 * height, -0.08 * height);
                hairStrand.rotation.x = Math.PI / 12;
                elf.add(hairStrand);
            }
            
            // Graceful neck
            const neck = new THREE.Mesh(
                new THREE.CylinderGeometry(0.055 * height, 0.065 * height, 0.18 * height, 20, 1),
                headMat
            );
            neck.position.y = 1.45 * height;
            elf.add(neck);
            
            // Slender torso (agile build)
            const bodyMat = new THREE.MeshStandardMaterial({ color: shirtColor, roughness: 0.7 });
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.13 * height, 0.55 * height, 14, 24),
                bodyMat
            );
            body.position.y = 1.05 * height;
            body.castShadow = true;
            elf.add(body);
            
            // Slender arms (high agility)
            const armMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.6 });
            const upperArmL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.035 * height, 0.27 * height, 10, 20),
                armMat
            );
            upperArmL.position.set(-0.18 * height, 1.1 * height, 0);
            upperArmL.castShadow = true;
            elf.add(upperArmL);
            
            const forearmL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.03 * height, 0.27 * height, 10, 20),
                armMat
            );
            forearmL.position.set(-0.18 * height, 0.78 * height, 0);
            elf.add(forearmL);
            
            const upperArmR = upperArmL.clone();
            upperArmR.position.x = 0.18 * height;
            elf.add(upperArmR);
            
            const forearmR = forearmL.clone();
            forearmR.position.x = 0.18 * height;
            elf.add(forearmR);
            
            // Delicate hands
            for (let side = -1; side <= 1; side += 2) {
                const palm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.07 * height, 0.11 * height, 0.018 * height, 6, 8, 4),
                    armMat
                );
                palm.position.set(side * 0.18 * height, 0.52 * height, 0);
                elf.add(palm);
                
                // Graceful fingers
                for (let finger = 0; finger < 5; finger++) {
                    const fingerMesh = new THREE.Mesh(
                        new THREE.CapsuleGeometry(0.007 * height, 0.07 * height, 8, 12),
                        armMat
                    );
                    fingerMesh.position.set(
                        side * 0.18 * height + (finger - 2) * 0.014 * height,
                        0.43 * height,
                        0
                    );
                    elf.add(fingerMesh);
                }
            }
            
            // Long, slender legs
            const legMat = new THREE.MeshStandardMaterial({ color: pantsColor, roughness: 0.85 });
            const thighL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.07 * height, 0.45 * height, 12, 24),
                legMat
            );
            thighL.position.set(-0.09 * height, 0.52 * height, 0);
            thighL.castShadow = true;
            elf.add(thighL);
            
            const calfL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.055 * height, 0.4 * height, 12, 24),
                legMat
            );
            calfL.position.set(-0.09 * height, 0.2 * height, 0);
            elf.add(calfL);
            
            const thighR = thighL.clone();
            thighR.position.x = 0.09 * height;
            elf.add(thighR);
            
            const calfR = calfL.clone();
            calfR.position.x = 0.09 * height;
            elf.add(calfR);
            
            // Light boots
            const bootMat = new THREE.MeshStandardMaterial({ color: 0x4A3520, roughness: 0.7 });
            for (let side = -1; side <= 1; side += 2) {
                const boot = new THREE.Mesh(
                    new THREE.BoxGeometry(0.075 * height, 0.04 * height, 0.16 * height, 6, 4, 6),
                    bootMat
                );
                boot.position.set(side * 0.09 * height, 0.02 * height, 0.05 * height);
                elf.add(boot);
            }
            
            // Animation references
            elf.userData.legL = thighL;
            elf.userData.legR = thighR;
            elf.userData.armL = upperArmL;
            elf.userData.armR = upperArmR;
            elf.userData.walkCycle = 0;
            elf.userData.phaseShift = Math.random() * Math.PI * 2;

            elf.userData.animate = (time) => {
                body.scale.y = 1 + Math.sin(time * 0.5 + elf.userData.phaseShift) * 0.015;
                head.rotation.y = Math.sin(time * 0.25 + elf.userData.phaseShift) * 0.06;
                earL.rotation.y = Math.sin(time * 0.8 + elf.userData.phaseShift) * 0.1;
                earR.rotation.y = -Math.sin(time * 0.8 + elf.userData.phaseShift) * 0.1;
            };

            applyHighDetail(elf, { multiplier: 2 });

            annotateObject(elf, {
                id: `npc_elf_${elf.uuid.slice(0, 6)}`,
                name: `ElfNPC_${elf.uuid.slice(0, 4)}`,
                type: 'character-elf',
                category: 'character',
                description: 'Graceful elven NPC with elongated proportions, articulated ear twitch animation, and high-density garment meshes suited for cinematic flyovers.',
                dimensions: {
                    standingHeightMeters: Number(height.toFixed(2)),
                    shoulderSpanMeters: Number((0.36 * height).toFixed(2))
                },
                materials: [
                    { id: 'elf_dermis', description: 'Luminous skin shader tuned for low roughness and moonlit highlights.' },
                    { id: 'elf_garment', description: 'Vibrant cloth shader with reduced roughness for elegant sheen.' },
                    { id: 'elf_hair', description: 'Flowing hair material supporting specular streaks.' }
                ],
                animations: [
                    { id: 'walk_cycle', description: 'Shared walk cycle with humanoid rigs for locomotion events.' },
                    { id: 'ear_twitch', description: 'Subtle periotic auricular twitching at 0.8 Hz to convey heightened senses.' }
                ],
                rendering: {
                    detail: 'All limb capsules increased to 14×24 segments; garments subdivided for cloth simulation readiness.',
                    castsShadow: true
                },
                tags: ['npc', 'elf', 'fantasy', 'high-detail']
            });
            
            return elf;
        }
        
        function createDwarf() {
            const dwarf = new THREE.Group();
            dwarf.name = 'NPC_Dwarf';
            
            // Dwarves: Shorter (1.35-1.55m), stocky, muscular
            const height = 1.35 + Math.random() * 0.2;
            const skinColor = [0xffdfc4, 0xf0c48c, 0xc68642, 0xd08080][Math.floor(Math.random() * 4)]; // Ruddy complexions
            const shirtColor = [0x8B4513, 0x2C3E50, 0x654321, 0xA0522D][Math.floor(Math.random() * 4)]; // Earthy tones
            const pantsColor = [0x654321, 0x2C3E50, 0x8B7355][Math.floor(Math.random() * 3)];
            
            // ═══ HEAD (Broader, rounder) ═══
            const headMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8 });
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.14 * height, 24, 18),
                headMat
            );
            head.scale.set(1.1, 0.95, 1.05); // Broader face
            head.position.y = 1.45 * height;
            head.castShadow = true;
            dwarf.add(head);
            
            // ═══ DWARVEN BEARD (Iconic!) ═══
            const beardColors = [0x8B4513, 0x654321, 0x2F1F10, 0xD2691E, 0x808080];
            const beardMat = new THREE.MeshStandardMaterial({ 
                color: beardColors[Math.floor(Math.random() * beardColors.length)],
                roughness: 0.95
            });
            
            // Main beard volume
            const beard = new THREE.Mesh(
                new THREE.ConeGeometry(0.12 * height, 0.25 * height, 16, 2),
                beardMat
            );
            beard.position.set(0, 1.35 * height, 0.08 * height);
            beard.rotation.x = Math.PI;
            dwarf.add(beard);
            
            // Beard braids (traditional dwarven style)
            for (let side = -1; side <= 1; side += 2) {
                const braid = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.015 * height, 0.01 * height, 0.2 * height, 16, 1),
                    beardMat
                );
                braid.position.set(side * 0.08 * height, 1.2 * height, 0.06 * height);
                dwarf.add(braid);
                
                // Braid ornament (metal bead)
                const ornament = new THREE.Mesh(
                    new THREE.SphereGeometry(0.012 * height, 16, 12),
                    new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.9, roughness: 0.2 })
                );
                ornament.position.set(side * 0.08 * height, 1.12 * height, 0.06 * height);
                dwarf.add(ornament);
            }
            
            // ═══ FACIAL FEATURES ═══
            // Strong brow
            const browMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.85 });
            const brow = new THREE.Mesh(
                new THREE.BoxGeometry(0.12 * height, 0.03 * height, 0.02 * height, 6, 4, 2),
                browMat
            );
            brow.position.set(0, 1.49 * height, 0.12 * height);
            dwarf.add(brow);
            
            // Deep-set eyes
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.015 * height, 16, 12), 
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 }));
            eyeL.position.set(-0.045 * height, 1.48 * height, 0.11 * height);
            dwarf.add(eyeL);
            
            const eyeR = eyeL.clone();
            eyeR.position.x = 0.045 * height;
            dwarf.add(eyeR);
            
            // Brown/gray eyes (common for dwarves)
            const pupilMat = new THREE.MeshBasicMaterial({ color: [0x654321, 0x8B7355, 0x708090][Math.floor(Math.random() * 3)] });
            const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.008 * height, 12, 8), pupilMat);
            pupilL.position.set(-0.045 * height, 1.48 * height, 0.12 * height);
            dwarf.add(pupilL);
            
            const pupilR = pupilL.clone();
            pupilR.position.x = 0.045 * height;
            dwarf.add(pupilR);
            
            // Large nose
            const nose = new THREE.Mesh(
                new THREE.ConeGeometry(0.022 * height, 0.045 * height, 16, 2),
                browMat
            );
            nose.position.set(0, 1.45 * height, 0.13 * height);
            nose.rotation.x = Math.PI / 2;
            dwarf.add(nose);
            
            // Thick neck
            const neck = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08 * height, 0.09 * height, 0.12 * height, 20, 1),
                headMat
            );
            neck.position.y = 1.32 * height;
            dwarf.add(neck);
            
            // ═══ STOCKY TORSO (Barrel-chested) ═══
            const bodyMat = new THREE.MeshStandardMaterial({ color: shirtColor, roughness: 0.85 });
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.2 * height, 0.45 * height, 14, 24),
                bodyMat
            );
            body.position.y = 0.95 * height;
            body.castShadow = true;
            dwarf.add(body);
            
            // ═══ MUSCULAR ARMS (Strong from mining/smithing) ═══
            const armMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8 });
            const upperArmL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.055 * height, 0.22 * height, 12, 20),
                armMat
            );
            upperArmL.position.set(-0.25 * height, 1.0 * height, 0);
            upperArmL.castShadow = true;
            dwarf.add(upperArmL);
            
            const forearmL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.05 * height, 0.2 * height, 12, 20),
                armMat
            );
            forearmL.position.set(-0.25 * height, 0.75 * height, 0);
            dwarf.add(forearmL);
            
            const upperArmR = upperArmL.clone();
            upperArmR.position.x = 0.25 * height;
            dwarf.add(upperArmR);
            
            const forearmR = forearmL.clone();
            forearmR.position.x = 0.25 * height;
            dwarf.add(forearmR);
            
            // Strong hands
            for (let side = -1; side <= 1; side += 2) {
                const palm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.09 * height, 0.12 * height, 0.025 * height, 6, 6, 4),
                    armMat
                );
                palm.position.set(side * 0.25 * height, 0.55 * height, 0);
                dwarf.add(palm);
                
                // Thick fingers
                for (let finger = 0; finger < 5; finger++) {
                    const fingerMesh = new THREE.Mesh(
                        new THREE.CapsuleGeometry(0.01 * height, 0.05 * height, 8, 12),
                        armMat
                    );
                    fingerMesh.position.set(
                        side * 0.25 * height + (finger - 2) * 0.018 * height,
                        0.47 * height,
                        0
                    );
                    dwarf.add(fingerMesh);
                }
            }
            
            // ═══ POWERFUL LEGS (Short but strong) ═══
            const legMat = new THREE.MeshStandardMaterial({ color: pantsColor, roughness: 0.9 });
            const thighL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.1 * height, 0.35 * height, 14, 24),
                legMat
            );
            thighL.position.set(-0.12 * height, 0.48 * height, 0);
            thighL.castShadow = true;
            dwarf.add(thighL);
            
            const calfL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.085 * height, 0.3 * height, 14, 24),
                legMat
            );
            calfL.position.set(-0.12 * height, 0.2 * height, 0);
            dwarf.add(calfL);
            
            const thighR = thighL.clone();
            thighR.position.x = 0.12 * height;
            dwarf.add(thighR);
            
            const calfR = calfL.clone();
            calfR.position.x = 0.12 * height;
            dwarf.add(calfR);
            
            // Heavy boots
            const bootMat = new THREE.MeshStandardMaterial({ color: 0x2C1810, roughness: 0.8, metalness: 0.3 });
            for (let side = -1; side <= 1; side += 2) {
                const boot = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1 * height, 0.05 * height, 0.18 * height, 6, 4, 6),
                    bootMat
                );
                boot.position.set(side * 0.12 * height, 0.025 * height, 0.06 * height);
                dwarf.add(boot);
                
                // Steel toe cap
                const toeCap = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1 * height, 0.03 * height, 0.05 * height, 6, 4, 4),
                    new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.8, roughness: 0.3 })
                );
                toeCap.position.set(side * 0.12 * height, 0.03 * height, 0.12 * height);
                dwarf.add(toeCap);
            }
            
            // Animation references
            dwarf.userData.legL = thighL;
            dwarf.userData.legR = thighR;
            dwarf.userData.armL = upperArmL;
            dwarf.userData.armR = upperArmR;
            dwarf.userData.walkCycle = 0;
            dwarf.userData.phaseShift = Math.random() * Math.PI * 2;

            dwarf.userData.animate = (time) => {
                body.scale.y = 1 + Math.sin(time * 0.35 + dwarf.userData.phaseShift) * 0.018;
                beard.rotation.z = Math.sin(time * 0.6 + dwarf.userData.phaseShift) * 0.05;
            };

            applyHighDetail(dwarf, { multiplier: 2 });

            annotateObject(dwarf, {
                id: `npc_dwarf_${dwarf.uuid.slice(0, 6)}`,
                name: `DwarfNPC_${dwarf.uuid.slice(0, 4)}`,
                type: 'character-dwarf',
                category: 'character',
                description: 'Stocky dwarven NPC with braided beard geometry, high-segment limb meshes, and subtle beard sway for tavern and forge scenes.',
                dimensions: {
                    standingHeightMeters: Number(height.toFixed(2)),
                    shoulderSpanMeters: Number((0.5 * height).toFixed(2))
                },
                materials: [
                    { id: 'dwarf_dermis', description: 'Ruddy skin shader with elevated roughness for weathered look.' },
                    { id: 'dwarf_beard', description: 'Fibrous beard material supporting metallic ornaments.' },
                    { id: 'dwarf_garment', description: 'Earth-toned cloth shader with high roughness.' }
                ],
                animations: [
                    { id: 'walk_cycle', description: 'Synchronized with base humanoid stride but scaled for shorter gait.' },
                    { id: 'beard_sway', description: 'Micro sway applied to beard to sell physical weight.' }
                ],
                rendering: {
                    detail: 'Limb capsules tessellated to 14×24 segments; beard cones refined to 16 radial segments for braided detail.',
                    castsShadow: true
                },
                tags: ['npc', 'dwarf', 'fantasy', 'high-detail']
            });
            
            return dwarf;
        }
        
        function createOrc() {
            const orc = new THREE.Group();
            orc.name = 'NPC_Orc';
            
            // Orcs: Tallest (1.85-2.15m), hulking, muscular
            const height = 1.85 + Math.random() * 0.3;
            const skinColor = [0x90ee90, 0x6b8e6b, 0x808080, 0x8b7355][Math.floor(Math.random() * 4)]; // Green, dark green, gray, brown
            const shirtColor = [0x3E2723, 0x4A148C, 0x1A237E, 0x263238][Math.floor(Math.random() * 4)]; // Dark, intimidating colors
            const pantsColor = [0x212121, 0x3E2723, 0x1A237E][Math.floor(Math.random() * 3)];
            
            // ═══ HEAD (Large, brutish) ═══
            const headMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.85 });
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.16 * height, 24, 18),
                headMat
            );
            head.scale.set(1.15, 1.0, 1.1); // Broader, more square
            head.position.y = 1.62 * height;
            head.castShadow = true;
            orc.add(head);
            
            // ═══ ORCISH TUSKS (Iconic feature!) ═══
            const tuskMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFF8DC, // Ivory
                roughness: 0.6,
                metalness: 0.1
            });
            
            const tuskL = new THREE.Mesh(
                new THREE.ConeGeometry(0.015 * height, 0.08 * height, 20),
                tuskMat
            );
            tuskL.rotation.x = Math.PI / 8; // Angle outward
            tuskL.rotation.z = -Math.PI / 12;
            tuskL.position.set(-0.06 * height, 1.56 * height, 0.14 * height);
            orc.add(tuskL);
            
            const tuskR = tuskL.clone();
            tuskR.rotation.z = Math.PI / 12;
            tuskR.position.x = 0.06 * height;
            orc.add(tuskR);
            const tuskBaseRotationL = tuskL.rotation.x;
            const tuskBaseRotationR = tuskR.rotation.x;
            
            // ═══ FACIAL FEATURES (Brutish) ═══
            // Heavy brow ridge
            const browMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.9 });
            const brow = new THREE.Mesh(
                new THREE.BoxGeometry(0.16 * height, 0.04 * height, 0.03 * height),
                browMat
            );
            brow.position.set(0, 1.66 * height, 0.14 * height);
            orc.add(brow);
            
            // Small, fierce eyes
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xfff8dc, roughness: 0.3 });
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.012 * height, 16, 12), eyeMat);
            eyeL.position.set(-0.06 * height, 1.65 * height, 0.14 * height);
            orc.add(eyeL);
            
            const eyeR = eyeL.clone();
            eyeR.position.x = 0.06 * height;
            orc.add(eyeR);
            
            // Red/yellow pupils (menacing)
            const pupilColors = [0xFF0000, 0xFFFF00, 0xFFA500]; // Red, yellow, orange
            const pupilMat = new THREE.MeshBasicMaterial({ 
                color: pupilColors[Math.floor(Math.random() * pupilColors.length)] 
            });
            const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.007 * height, 12, 10), pupilMat);
            pupilL.position.set(-0.06 * height, 1.65 * height, 0.15 * height);
            orc.add(pupilL);
            
            const pupilR = pupilL.clone();
            pupilR.position.x = 0.06 * height;
            orc.add(pupilR);
            
            // Large, flat nose
            const nose = new THREE.Mesh(
                new THREE.BoxGeometry(0.05 * height, 0.045 * height, 0.03 * height),
                browMat
            );
            nose.position.set(0, 1.61 * height, 0.16 * height);
            orc.add(nose);
            
            // Wide nostrils
            for (let side = -1; side <= 1; side += 2) {
                const nostril = new THREE.Mesh(
                    new THREE.SphereGeometry(0.008 * height, 12, 10),
                    new THREE.MeshStandardMaterial({ color: 0x000000 })
                );
                nostril.position.set(side * 0.015 * height, 1.6 * height, 0.17 * height);
                orc.add(nostril);
            }
            
            // Large, square jaw
            const jaw = new THREE.Mesh(
                new THREE.BoxGeometry(0.14 * height, 0.1 * height, 0.12 * height),
                headMat
            );
            jaw.position.set(0, 1.52 * height, 0.08 * height);
            orc.add(jaw);
            const jawBasePositionY = jaw.position.y;
            
            // Pointed ears (like elves, but more brutish)
            const earMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.85 });
            const earL = new THREE.Mesh(new THREE.ConeGeometry(0.025 * height, 0.07 * height, 18), earMat);
            earL.rotation.z = -Math.PI / 6;
            earL.position.set(-0.16 * height, 1.62 * height, 0.02 * height);
            orc.add(earL);
            
            const earR = earL.clone();
            earR.rotation.z = Math.PI / 6;
            earR.position.x = 0.16 * height;
            orc.add(earR);
            
            // Short, bristly hair (war braids optional)
            const hairMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.95 });
            const hair = new THREE.Mesh(
                new THREE.SphereGeometry(0.165 * height, 20, 16, 0, Math.PI * 2, 0, Math.PI / 3),
                hairMat
            );
            hair.position.y = 1.62 * height;
            orc.add(hair);
            
            // Topknot/war braid (common orcish style)
            const topknot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02 * height, 0.015 * height, 0.15 * height, 18, 2),
                hairMat
            );
            topknot.position.set(0, 1.77 * height, -0.05 * height);
            orc.add(topknot);
            const topknotBaseRotationX = topknot.rotation.x;
            const topknotBaseRotationZ = topknot.rotation.z;
            
            // Thick, muscular neck
            const neckMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8 });
            const neck = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1 * height, 0.12 * height, 0.15 * height, 20, 3),
                neckMat
            );
            neck.position.y = 1.47 * height;
            orc.add(neck);
            
            // ═══ MASSIVE TORSO (Hulking build) ═══
            const bodyMat = new THREE.MeshStandardMaterial({ color: shirtColor, roughness: 0.9 });
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.22 * height, 0.55 * height, 18, 32),
                bodyMat
            );
            body.position.y = 1.05 * height;
            body.castShadow = true;
            orc.add(body);
            
            // ═══ POWERFUL ARMS (Massive strength) ═══
            const armMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.85 });
            const upperArmL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.07 * height, 0.3 * height, 16, 28),
                armMat
            );
            upperArmL.position.set(-0.3 * height, 1.1 * height, 0);
            upperArmL.castShadow = true;
            orc.add(upperArmL);
            
            const forearmL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.065 * height, 0.28 * height, 16, 28),
                armMat
            );
            forearmL.position.set(-0.3 * height, 0.75 * height, 0);
            orc.add(forearmL);
            
            const upperArmR = upperArmL.clone();
            upperArmR.position.x = 0.3 * height;
            orc.add(upperArmR);
            
            const forearmR = forearmL.clone();
            forearmR.position.x = 0.3 * height;
            orc.add(forearmR);
            
            // Large, powerful hands
            for (let side = -1; side <= 1; side += 2) {
                const palm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.11 * height, 0.14 * height, 0.03 * height),
                    armMat
                );
                palm.position.set(side * 0.3 * height, 0.48 * height, 0);
                orc.add(palm);
                
                // Thick, clawed fingers
                for (let finger = 0; finger < 5; finger++) {
                    const fingerMesh = new THREE.Mesh(
                        new THREE.CapsuleGeometry(0.012 * height, 0.06 * height, 12, 18),
                        armMat
                    );
                    fingerMesh.position.set(
                        side * 0.3 * height + (finger - 2) * 0.022 * height,
                        0.38 * height,
                        0
                    );
                    orc.add(fingerMesh);
                    
                    // Claw tips
                    const claw = new THREE.Mesh(
                        new THREE.ConeGeometry(0.006 * height, 0.015 * height, 16),
                        new THREE.MeshStandardMaterial({ color: 0x3E2723, roughness: 0.7 })
                    );
                    claw.position.set(
                        side * 0.3 * height + (finger - 2) * 0.022 * height,
                        0.32 * height,
                        0
                    );
                    orc.add(claw);
                }
            }
            
            // ═══ TREE-TRUNK LEGS (Massive power) ═══
            const legMat = new THREE.MeshStandardMaterial({ color: pantsColor, roughness: 0.9 });
            const thighL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.12 * height, 0.45 * height, 18, 30),
                legMat
            );
            thighL.position.set(-0.14 * height, 0.5 * height, 0);
            thighL.castShadow = true;
            orc.add(thighL);
            
            const calfL = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.1 * height, 0.4 * height, 18, 30),
                legMat
            );
            calfL.position.set(-0.14 * height, 0.18 * height, 0);
            orc.add(calfL);
            
            const thighR = thighL.clone();
            thighR.position.x = 0.14 * height;
            orc.add(thighR);
            
            const calfR = calfL.clone();
            calfR.position.x = 0.14 * height;
            orc.add(calfR);
            
            // Heavy war boots
            const bootMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                roughness: 0.8,
                metalness: 0.4
            });
            for (let side = -1; side <= 1; side += 2) {
                const boot = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12 * height, 0.06 * height, 0.2 * height),
                    bootMat
                );
                boot.position.set(side * 0.14 * height, 0.03 * height, 0.06 * height);
                orc.add(boot);
                
                // Spiked toe (intimidation)
                const spike = new THREE.Mesh(
                    new THREE.ConeGeometry(0.015 * height, 0.04 * height, 6),
                    new THREE.MeshStandardMaterial({ color: 0x505050, metalness: 0.9, roughness: 0.3 })
                );
                spike.rotation.x = Math.PI / 2;
                spike.position.set(side * 0.14 * height, 0.03 * height, 0.16 * height);
                orc.add(spike);
            }
            
            // Animation references
            orc.userData.legL = thighL;
            orc.userData.legR = thighR;
            orc.userData.armL = upperArmL;
            orc.userData.armR = upperArmR;
            orc.userData.walkCycle = 0;
            orc.userData.phaseShift = Math.random() * Math.PI * 2;

            orc.userData.animate = (time) => {
                const breathPhase = time * 0.35 + orc.userData.phaseShift;
                const powerBreath = 1 + Math.sin(breathPhase) * 0.03;
                body.scale.y = powerBreath;
                body.scale.x = 1 + Math.sin(breathPhase) * 0.02;
                tuskL.rotation.x = tuskBaseRotationL + Math.sin(time * 0.7 + orc.userData.phaseShift) * 0.05;
                tuskR.rotation.x = tuskBaseRotationR + Math.sin(time * 0.7 + orc.userData.phaseShift + 0.4) * 0.05;
                topknot.rotation.x = topknotBaseRotationX + Math.sin(time * 1.2 + orc.userData.phaseShift) * 0.12;
                topknot.rotation.z = topknotBaseRotationZ + Math.sin(time * 0.9 + orc.userData.phaseShift) * 0.07;
                hair.rotation.y = Math.sin(time * 0.25 + orc.userData.phaseShift) * 0.08;
                jaw.position.y = jawBasePositionY + Math.sin(time * 0.5 + orc.userData.phaseShift) * 0.012;
            };

            applyHighDetail(orc, { multiplier: 2.2 });

            annotateObject(orc, {
                id: `npc_orc_${orc.uuid.slice(0, 6)}`,
                name: `OrcNPC_${orc.uuid.slice(0, 4)}`,
                type: 'character-orc',
                category: 'character',
                description: 'Towering orc NPC with retopologized musculature, articulated tusk flex, and topknot sway for siege-scale crowd shots.',
                dimensions: {
                    standingHeightMeters: Number(height.toFixed(2)),
                    shoulderSpanMeters: Number((0.6 * height).toFixed(2))
                },
                materials: [
                    { id: 'orc_dermis', description: 'Pigmented skin shader with coarse roughness tuned for brutish highlights.' },
                    { id: 'orc_regalia', description: 'Battle-worn leather textile with high roughness and muted specular response.' },
                    { id: 'orc_ivory', description: 'Ivory tusk material supporting strong rim lighting for dramatic close-ups.' }
                ],
                animations: [
                    { id: 'walk_cycle', description: 'Shared locomotion rig blended for longer stride and heavier weight transfer.' },
                    { id: 'power_breath', description: 'Idle breathing expansion with jaw flex and tusk articulation to convey latent aggression.' }
                ],
                rendering: {
                    detail: 'Torso capsule refined to 18×32 segments; limb capsules retopologized to 16×28+; tusks upgraded to 20 radial slices with high-density claw meshes.',
                    castsShadow: true
                },
                tags: ['npc', 'orc', 'fantasy', 'high-detail']
            });
            
            return orc;
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // VETERINARY-ACCURATE ANIMAL ANATOMY
        // AI Personality #53: Medical Professional (Veterinarian Specialist)
        // ═══════════════════════════════════════════════════════════════════════
        // 
        // The following animal creation functions have been enhanced with anatomically
        // accurate structures based on veterinary science. Each species includes:
        // 
        // - Proper skeletal structure (skull, spine, ribcage, limbs)
        // - Correct muscle groups and body proportions
        // - Species-specific features (antlers, hooves, fur patterns, etc.)
        // - Realistic joint articulation for animation
        // 
        // References: Veterinary anatomy textbooks, comparative anatomy studies
        // ═══════════════════════════════════════════════════════════════════════
        
        function createDeer() {
            // CERVIDAE (Deer Family) - Anatomical Notes:
            // - Quadruped ungulate with cervical (7), thoracic (13), lumbar (6) vertebrae
            // - Digitigrade locomotion (walks on toes)
            // - Cloven hooves (two main digits: 3rd and 4th toes)
            // - Antlers grow from pedicles on frontal bones (males, deciduous)
            // - Highly developed leg muscles for running/jumping
            // - Ruminant digestive system (4-chambered stomach)
            
            const deer = new THREE.Group();
            deer.name = 'Deer_Anatomical';
            
            const furColor = 0x8B4513; // Brown pelage
            const deerMat = new THREE.MeshStandardMaterial({
                color: furColor,
                roughness: 0.85 // Fur texture
            });
            
            // ═══ THORAX (Chest/Rib Cage) ═══
            const thorax = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.28, 0.7, 10, 16),
                deerMat
            );
            thorax.rotation.z = Math.PI / 2;
            thorax.position.set(-0.1, 0.85, 0);
            thorax.castShadow = true;
            deer.add(thorax);
            
            // ═══ ABDOMEN (Belly) ═══
            const abdomen = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.24, 0.5, 10, 16),
                deerMat
            );
            abdomen.rotation.z = Math.PI / 2;
            abdomen.position.set(0.4, 0.75, 0);
            deer.add(abdomen);
            
            // ═══ CERVICAL SPINE (Neck) ═══
            const neck = new THREE.Mesh(
                new THREE.CylinderGeometry(0.12, 0.18, 0.5, 10),
                deerMat
            );
            neck.position.set(-0.5, 0.95, 0);
            neck.rotation.z = -Math.PI / 4; // Angled upward
            deer.add(neck);
            
            // ═══ SKULL (Cranium) ═══
            const skull = new THREE.Group();
            
            // Cranium (brain case)
            const cranium = new THREE.Mesh(
                new THREE.SphereGeometry(0.18, 12, 12),
                deerMat
            );
            cranium.scale.set(1, 0.9, 1.3); // Elongated
            cranium.position.set(-0.72, 1.15, 0);
            skull.add(cranium);
            
            // Rostrum (snout/muzzle)
            const rostrum = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.11, 0.3, 10),
                deerMat
            );
            rostrum.rotation.z = Math.PI / 2;
            rostrum.position.set(-0.87, 1.1, 0);
            skull.add(rostrum);
            
            // Nasal bones (nose)
            const nose = new THREE.Mesh(
                new THREE.SphereGeometry(0.06, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0x2F1F10, roughness: 0.7 })
            );
            nose.position.set(-1.0, 1.1, 0);
            skull.add(nose);
            
            deer.add(skull);
            
            // ═══ PINNA (External Ears) ═══
            const earMat = new THREE.MeshStandardMaterial({ color: furColor, roughness: 0.8 });
            const earL = new THREE.Mesh(
                new THREE.ConeGeometry(0.1, 0.25, 8),
                earMat
            );
            earL.rotation.z = -Math.PI / 6;
            earL.position.set(-0.72, 1.35, -0.12);
            deer.add(earL);
            
            const earR = earL.clone();
            earR.rotation.z = Math.PI / 6;
            earR.position.z = 0.12;
            deer.add(earR);
            
            // ═══ ANTLERS (Males - Ossified tissue from pedicles) ═══
            if (Math.random() > 0.5) { // 50% have antlers (males)
                const antlerMat = new THREE.MeshStandardMaterial({
                    color: 0xD2B48C, // Tan/bone color
                    roughness: 0.6
                });
                
                for (let side = -1; side <= 1; side += 2) {
                    // Main beam
                    const mainBeam = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.02, 0.03, 0.45, 8),
                        antlerMat
                    );
                    mainBeam.rotation.z = side * Math.PI / 6;
                    mainBeam.position.set(-0.68, 1.4, side * 0.08);
                    deer.add(mainBeam);
                    
                    // Tines (branches) - 3 points
                    for (let i = 0; i < 3; i++) {
                        const tine = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.01, 0.015, 0.15, 6),
                            antlerMat
                        );
                        tine.rotation.z = side * (Math.PI / 4 + i * 0.2);
                        tine.position.set(
                            -0.68 + i * 0.08,
                            1.5 + i * 0.12,
                            side * (0.1 + i * 0.05)
                        );
                        deer.add(tine);
                    }
                }
            }
            
            // ═══ THORACIC LIMBS (Forelimbs/Front Legs) ═══
            const legMat = new THREE.MeshStandardMaterial({ 
                color: 0x654321, // Darker legs
                roughness: 0.85 
            });
            
            for (let side = -1; side <= 1; side += 2) {
                // Scapula + Humerus (shoulder to elbow)
                const upperFrontLeg = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.055, 0.35, 8, 10),
                    legMat
                );
                upperFrontLeg.position.set(-0.25, 0.58, side * 0.18);
                upperFrontLeg.castShadow = true;
                deer.add(upperFrontLeg);
                
                // Radius + Ulna (forearm)
                const lowerFrontLeg = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.045, 0.32, 8, 10),
                    legMat
                );
                lowerFrontLeg.position.set(-0.25, 0.23, side * 0.18);
                deer.add(lowerFrontLeg);
                
                // Metacarpals + Phalanges (cannon bone + hooves)
                const frontHoof = create_CleftHoof();
                frontHoof.position.set(-0.25, 0.0, side * 0.18);
                deer.add(frontHoof);
            }
            
            // ═══ PELVIC LIMBS (Hindlimbs/Back Legs) ═══
            for (let side = -1; side <= 1; side += 2) {
                // Femur (thigh)
                const upperBackLeg = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.07, 0.38, 8, 10),
                    legMat
                );
                upperBackLeg.position.set(0.35, 0.6, side * 0.18);
                upperBackLeg.castShadow = true;
                deer.add(upperBackLeg);
                
                // Tibia + Fibula (lower leg)
                const lowerBackLeg = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.06, 0.36, 8, 10),
                    legMat
                );
                lowerBackLeg.position.set(0.35, 0.25, side * 0.18);
                deer.add(lowerBackLeg);
                
                // Metatarsals + hooves
                const backHoof = createCleftHoof();
                backHoof.position.set(0.35, 0.0, side * 0.18);
                deer.add(backHoof);
            }
            
            // ═══ TAIL (Caudal vertebrae) ═══
            const tail = new THREE.Mesh(
                new THREE.ConeGeometry(0.04, 0.18, 8),
                deerMat
            );
            tail.rotation.x = Math.PI / 3;
            tail.position.set(0.65, 0.75, 0);
            deer.add(tail);
            
            return deer;
        }
        
        // Helper function: Create anatomically correct cloven hoof
        function createCleftHoof() {
            const hoof = new THREE.Group();
            const hoofMat = new THREE.MeshStandardMaterial({
                color: 0x2F1F10, // Dark brown/black keratin
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Cleft (split) hoof - two main digits (3rd and 4th)
            const digit3 = new THREE.Mesh(
                new THREE.BoxGeometry(0.045, 0.06, 0.06),
                hoofMat
            );
            digit3.position.set(0, 0.03, -0.02);
            hoof.add(digit3);
            
            const digit4 = new THREE.Mesh(
                new THREE.BoxGeometry(0.045, 0.06, 0.06),
                hoofMat
            );
            digit4.position.set(0, 0.03, 0.02);
            hoof.add(digit4);
            
            // Dewclaws (vestigial 2nd and 5th digits) - higher up
            const dewclaw1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 6, 6),
                hoofMat
            );
            dewclaw1.position.set(-0.02, 0.12, -0.04);
            hoof.add(dewclaw1);
            
            const dewclaw2 = dewclaw1.clone();
            dewclaw2.position.z = 0.04;
            hoof.add(dewclaw2);
            
            return hoof;
        }

        // Compatibility wrapper for legacy calls that use an underscore naming convention
        // Some older code references `create_CleftHoof()` (snake_case) — provide a thin
        // wrapper so both call sites work without changing upstream code.
        function create_CleftHoof() {
            return createCleftHoof();
        }
        
        function createRabbit() {
            const rabbit = new THREE.Group();
            rabbit.name = 'Rabbit';
            
            const rabbitMat = new THREE.MeshStandardMaterial({
                color: Math.random() > 0.5 ? 0xD3D3D3 : 0x8B7355,
                roughness: 0.9
            });
            
            // Body
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                rabbitMat
            );
            body.scale.set(1.2, 1, 1);
            body.position.y = 0.15;
            body.castShadow = true;
            rabbit.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 8, 8),
                rabbitMat
            );
            head.position.set(0.15, 0.2, 0);
            head.castShadow = true;
            rabbit.add(head);
            
            // Ears (long)
            const ear = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.03, 0.15, 6),
                rabbitMat
            );
            ear.position.set(0.15, 0.32, -0.04);
            ear.rotation.z = -Math.PI / 8;
            rabbit.add(ear);
            
            const earR = ear.clone();
            earR.position.z = 0.04;
            rabbit.add(earR);
            
            // Legs (back are bigger)
            const legFront = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.1, 4),
                rabbitMat
            );
            legFront.position.set(0.1, 0.05, -0.08);
            rabbit.add(legFront);
            
            const legFrontR = legFront.clone();
            legFrontR.position.z = 0.08;
            rabbit.add(legFrontR);
            
            const legBack = new THREE.Mesh(
                new THREE.CylinderGeometry(0.03, 0.04, 0.15, 6),
                rabbitMat
            );
            legBack.position.set(-0.05, 0.075, -0.08);
            rabbit.add(legBack);
            
            const legBackR = legBack.clone();
            legBackR.position.z = 0.08;
            rabbit.add(legBackR);
            
            // Fluffy tail
            const tail = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 6, 6),
                rabbitMat
            );
            tail.position.set(-0.18, 0.15, 0);
            rabbit.add(tail);
            
            return rabbit;
        }
        
        function createGroundBird() {
            const bird = new THREE.Group();
            bird.name = 'GroundBird';
            
            const birdMat = new THREE.MeshStandardMaterial({
                color: [0x8B4513, 0x696969, 0x2F4F4F][Math.floor(Math.random() * 3)],
                roughness: 0.8
            });
            
            // Body (small)
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 6, 6),
                birdMat
            );
            body.scale.set(1, 0.8, 1.2);
            body.position.y = 0.08;
            body.castShadow = true;
            bird.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 6, 6),
                birdMat
            );
            head.position.set(0.08, 0.12, 0);
            bird.add(head);
            
            // Beak
            const beakMat = new THREE.MeshStandardMaterial({ color: 0xFFA500 });
            const beak = new THREE.Mesh(
                new THREE.ConeGeometry(0.015, 0.05, 4),
                beakMat
            );
            beak.rotation.z = -Math.PI / 2;
            beak.position.set(0.11, 0.12, 0);
            bird.add(beak);
            
            // Legs (thin)
            const legMat = new THREE.MeshStandardMaterial({ color: 0xFFA500 });
            const leg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.005, 0.005, 0.06, 4),
                legMat
            );
            leg.position.set(0, 0.03, -0.03);
            bird.add(leg);
            
            const legR = leg.clone();
            legR.position.z = 0.03;
            bird.add(legR);
            
            return bird;
        }
        
        init();
    </script>

    <!-- ═══════════════════════════════════════════════════════════════════ -->
    <!-- 🎨 NFT MARKETPLACE & AI LEGENDS SYSTEM - eugeNEOusXR               -->
    <!-- 99 NFT Assets | 144 AI Personalities | Real-time Compression       -->
    <!-- Meta Architect: Jeremy Courson (Never AI, Always Human)            -->
    <!-- ═══════════════════════════════════════════════════════════════════ -->
    <script src="nft_marketplace.js"></script>
    <script src="skyrelics_ai_legends.js"></script>
    
    <script>
    // AI LEGENDS SYSTEM - 144 Personalities
    class SkyRelicsAILegends {
        constructor() {
            this.legends = AI_LEGENDS; // From skyrelics_ai_legends.js
            this.active = true;
            this.totalAIs = 144;
            this.owner = "eugeNEOusXR";
            this.metaArchitect = "Jeremy Courson (Never AI, Always Human)";
            
            // Active AI workers (randomly selected from 144)
            this.activeWorkers = this.selectActiveWorkers();
            
            console.log("🌟 AI LEGENDS SYSTEM INITIALIZED");
            console.log(`   Total Personalities: ${this.totalAIs}`);
            console.log(`   Active Workers: ${this.activeWorkers.length}`);
            console.log(`   Dual Combos: ${this.legends.dual_combinations.toLocaleString()}`);
            console.log(`   Triple Combos: ${this.legends.triple_combinations.toLocaleString()}`);
            console.log(`   Owner: ${this.owner}`);
            console.log(`   Meta Architect: ${this.metaArchitect}`);
        }
        
        selectActiveWorkers() {
            // Select key AIs for game compression tasks
            return [
                this.legends.getPersonality(4),   // 3D Sculptor
                this.legends.getPersonality(10),  // Light Painter
                this.legends.getPersonality(22),  // Environmental Artist
                this.legends.getPersonality(23),  // VFX Specialist
                this.legends.getPersonality(28),  // Urban Planner
                this.legends.getPersonality(43),  // System Architect
                this.legends.getPersonality(44),  // Algorithm Optimizer
                this.legends.getPersonality(54),  // Blockchain Builder (NFT)
                this.legends.getPersonality(60),  // Computer Graphics Programmer
                this.legends.getPersonality(61),  // Game Engine Developer
                this.legends.getPersonality(131), // Game Designer
                this.legends.getPersonality(134), // Lore Keeper
                this.legends.getPersonality(137), // Music Composer
                this.legends.getPersonality(82),  // Operations Optimizer (validation)
                this.legends.getPersonality(144)  // Automotive Engineer (optimization)
            ];
        }
        
        compressGameAsset(assetData, assetType) {
            console.log(`⚙️ AI LEGENDS Compression Pipeline Started:`);
            console.log(`   Asset Type: ${assetType}`);
            
            // Select appropriate AI from 144 personalities
            let compressor = this.activeWorkers[0]; // Default: 3D Sculptor
            if (assetType.toLowerCase().includes('3d') || assetType.toLowerCase().includes('mesh')) {
                compressor = this.legends.getPersonality(4); // 3D Sculptor
            } else if (assetType.toLowerCase().includes('light')) {
                compressor = this.legends.getPersonality(10); // Light Painter
            } else if (assetType.toLowerCase().includes('environment')) {
                compressor = this.legends.getPersonality(22); // Environmental Artist
            } else if (assetType.toLowerCase().includes('vfx')) {
                compressor = this.legends.getPersonality(23); // VFX Specialist
            } else if (assetType.toLowerCase().includes('game')) {
                compressor = this.legends.getPersonality(131); // Game Designer
            }
            
            console.log(`   � AI Legend: #${compressor.id} - ${compressor.name}`);
            console.log(`   📋 Role: ${compressor.role}`);
            
            // Compress
            const originalSize = JSON.stringify(assetData).length;
            const compressed = JSON.stringify(assetData); // Simplified
            const compressedSize = compressed.length;
            const ratio = ((1 - compressedSize / originalSize) * 100).toFixed(1);
            
            console.log(`   📦 Original: ${originalSize} bytes`);
            console.log(`   📦 Compressed: ${compressedSize} bytes`);
            console.log(`   📊 Ratio: ${ratio}%`);
            
            // Validate with Operations Optimizer
            const validator = this.legends.getPersonality(82);
            console.log(`   ✅ Validator: AI #${validator.id} - ${validator.name}`);
            
            // Mint NFT with Blockchain Builder
            const nftAI = this.legends.getPersonality(54);
            const nftHash = this.mintNFT({
                file: assetType,
                data: compressed,
                originalSize: originalSize,
                compressedSize: compressedSize,
                ratio: ratio
            });
            
            console.log(`   🔐 NFT Minter: AI #${nftAI.id} - ${nftAI.name}`);
            console.log(`   🔐 NFT Hash: ${nftHash}`);
            console.log(`   👑 Owner: ${this.owner}`);
            console.log(`   🧠 Meta Architect: ${this.metaArchitect}`);
            
            return {
                compressed: compressed,
                nft_hash: nftHash,
                owner: this.owner,
                ratio: ratio,
                blockchain_ready: true,
                ai_legend: compressor.name,
                meta_architect: this.metaArchitect
            };
        }
        
        mintNFT(data) {
            // Simple hash generation
            let hash = 0;
            const str = JSON.stringify(data);
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(16).padStart(64, '0');
        }
        
        showAIStatus() {
            // Display the full 144 AI Legends system
            this.legends.showAllLegends();
            
            console.log("\n🎮 SKYRELICS ACTIVE WORKERS:");
            this.activeWorkers.forEach((ai, index) => {
                console.log(`   Worker ${index + 1}: AI #${ai.id} - ${ai.name}`);
                console.log(`            ${ai.role}`);
            });
        }
        
        // Get dual combination for advanced tasks
        dualCombo(id1, id2) {
            return this.legends.getDualCombo(id1, id2);
        }
        
        // Get triple combination for legendary tasks
        tripleCombo(id1, id2, id3) {
            return this.legends.getTripleCombo(id1, id2, id3);
        }
        
        // Showcase a legendary combo
        showLegendaryCombo() {
            const combo = this.legends.getTripleCombo(4, 61, 131);
            console.log("\n💎 LEGENDARY COMBO ACTIVATED:");
            console.log(`   ${combo.name}`);
            console.log(`   Power: ${combo.power}`);
            console.log(`   Combined Role: ${combo.role}`);
        }
    }
    
    // Initialize AI LEGENDS System
    const aiLegends = new SkyRelicsAILegends();
    
    // Display status on load
    console.log('╔═══════════════════════════════════════════════════╗');
    console.log('║  🎮 SKYRELICS - AI LEGENDS ACTIVATED             ║');
    console.log('╚═══════════════════════════════════════════════════╝');
    console.log('  👑 Owner: eugeNEOusXR');
    console.log('  🧠 Creator: Jeremy Courson');
    console.log('  🤖 AI Crew: Solana, Svetlana, Neo, Neomi + 144 Legends');
    console.log(`  📦 Protected Assets: ${NFT_COLLECTION ? NFT_COLLECTION.total_assets : 99}`);
    console.log('  🌟 AI Legends: 144 Personalities');
    console.log('  🔗 Dual Combos: 10,296');
    console.log('  💎 Triple Combos: 483,736');
    console.log('  📱 Total Apps: 494,176');
    console.log('  🔐 Blockchain: Polygon (ERC-721)');
    console.log('  ');
    console.log('  ⌨️  CONTROLS:');
    console.log('  💰 N - NFT Marketplace');
    console.log('  🤖 I - AI Status');
    console.log('  💎 L - Legendary Combo');
    console.log('  🎮 M - Toggle HUD');
    console.log('  🌌 Secret: Type "fuckit" for something special...');
    console.log('═══════════════════════════════════════════════════\n');
    
    // Show active workers
    console.log('🎯 ACTIVE AI WORKERS:');
    aiLegends.activeWorkers.forEach((ai, i) => {
        console.log(`   ${i+1}. AI #${ai.id} - ${ai.name}`);
    });
    console.log('');
    </script>

    <!-- NFT Marketplace Panel -->
    <div id="nft-marketplace" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.9); color: #00ffff; padding: 20px; border: 2px solid #00ffff; border-radius: 10px; font-family: 'Courier New', monospace; z-index: 9999; display: none; max-width: 350px; box-shadow: 0 0 20px rgba(0,255,255,0.5);">
        <h3 style="margin: 0 0 15px 0; text-align: center; font-size: 18px;">🎨 NFT MARKETPLACE</h3>
        
        <div style="border-bottom: 1px solid #00ffff; padding-bottom: 10px; margin-bottom: 10px;">
            <p style="font-size: 11px; margin: 3px 0;"><strong>Owner:</strong> eugeNEOusXR</p>
            <p style="font-size: 11px; margin: 3px 0;"><strong>Collection:</strong> PixelProdigy Universe</p>
            <p style="font-size: 11px; margin: 3px 0;"><strong>Total Assets:</strong> <span id="nft-count">99</span></p>
            <p style="font-size: 11px; margin: 3px 0;"><strong>Blockchain:</strong> Polygon</p>
            <p style="font-size: 11px; margin: 3px 0;"><strong>Standard:</strong> ERC-721</p>
        </div>
        
        <div style="margin-bottom: 15px;">
            <p style="font-size: 12px; margin: 5px 0; color: #ffff00;">💰 Est. Value: <span id="nft-value">9.9</span> MATIC</p>
            <p style="font-size: 10px; margin: 5px 0; color: #aaa;">@ 0.1 MATIC per asset</p>
        </div>
        
        <div style="margin-bottom: 15px;">
            <h4 style="font-size: 13px; margin: 10px 0 5px 0; color: #00ff00;">🌟 AI LEGENDS SYSTEM</h4>
            <p style="font-size: 10px; margin: 3px 0;">✓ 144 AI Personalities</p>
            <p style="font-size: 10px; margin: 3px 0;">✓ 10,296 Dual Combos</p>
            <p style="font-size: 10px; margin: 3px 0;">✓ 483,736 Triple Combos</p>
            <p style="font-size: 10px; margin: 3px 0;">✓ 494,176 Total Apps</p>
            <p style="font-size: 9px; margin: 5px 0; color: #888;">Meta: Jeremy Courson</p>
        </div>
        
        <button onclick="if(typeof NFT_COLLECTION !== 'undefined') NFT_COLLECTION.listForSale(0, 0.1); else alert('Loading NFT data...');" style="width: 100%; background: linear-gradient(135deg, #00ffff, #0099ff); color: #000; padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; margin-bottom: 5px; font-size: 12px;">
            🏪 List on OpenSea
        </button>
        
        <button onclick="aiLegends.showAIStatus();" style="width: 100%; background: linear-gradient(135deg, #00ff00, #00aa00); color: #000; padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; margin-bottom: 5px; font-size: 12px;">
            🌟 Show All 144 Legends
        </button>
        
        <button onclick="aiLegends.showLegendaryCombo();" style="width: 100%; background: linear-gradient(135deg, #ff00ff, #aa00aa); color: #fff; padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; margin-bottom: 5px; font-size: 12px;">
            💎 Legendary Combo
        </button>
        
        <button onclick="window.open('nft_registry.json', '_blank');" style="width: 100%; background: linear-gradient(135deg, #ffaa00, #ff6600); color: #fff; padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; margin-bottom: 5px; font-size: 12px;">
            📊 View Full Registry
        </button>
        
        <button onclick="document.getElementById('nft-marketplace').style.display='none'" style="width: 100%; background: #ff0000; color: #fff; padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 12px;">
            ✖ Close
        </button>
        
        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #00ffff; font-size: 9px; color: #888; text-align: center;">
            <p style="margin: 2px 0;">🔒 All assets crypto-signed</p>
            <p style="margin: 2px 0;">📊 Usage tracking enabled</p>
            <p style="margin: 2px 0;">💎 10% royalty on resales</p>
        </div>
    </div>

    <!-- AI LEGENDS HUD (Bottom Left) -->
    <div id="ai-status-hud" style="position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.9); color: #00ff00; padding: 15px; border: 2px solid #ffaa00; border-radius: 10px; font-family: 'Courier New', monospace; z-index: 9999; font-size: 11px; max-width: 280px; box-shadow: 0 0 20px rgba(255,170,0,0.5);">
        <h4 style="margin: 0 0 10px 0; font-size: 14px; text-align: center; color: #ffaa00;">🌟 AI LEGENDS</h4>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 10px;">
            <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(255,170,0,0.3), rgba(255,100,0,0.3)); border-radius: 5px; border: 1px solid #ffaa00;">
                <div style="font-size: 20px; font-weight: bold;">144</div>
                <div style="font-size: 8px;">Personalities</div>
            </div>
            <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(0,255,255,0.3), rgba(0,150,255,0.3)); border-radius: 5px; border: 1px solid #00ffff;">
                <div style="font-size: 16px; font-weight: bold;">10K</div>
                <div style="font-size: 8px;">Dual Combos</div>
            </div>
            <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(255,0,255,0.3), rgba(150,0,255,0.3)); border-radius: 5px; border: 1px solid #ff00ff;">
                <div style="font-size: 16px; font-weight: bold;">484K</div>
                <div style="font-size: 8px;">Triple Combos</div>
            </div>
            <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(0,255,0,0.3), rgba(0,150,0,0.3)); border-radius: 5px; border: 1px solid #00ff00;">
                <div style="font-size: 16px; font-weight: bold;">494K</div>
                <div style="font-size: 8px;">Total Apps</div>
            </div>
        </div>
        <div style="padding-top: 10px; border-top: 1px solid #ffaa00; text-align: center; font-size: 9px;">
            <div style="color: #00ff00; margin-bottom: 3px;">● LEGENDS ACTIVE</div>
            <div style="font-size: 8px; color: #ffaa00;">eugeNEOusXR</div>
            <div style="font-size: 7px; color: #888; margin-top: 2px;">Meta: Jeremy Courson</div>
        </div>
    </div>

    <!-- 🔐 SECRET PASSCODE SYSTEM - FUCKITUNIVERSE ENTRANCE -->
    <script>
    let secretCode = [];
    const FUCKIT_CODE = ['f', 'u', 'c', 'k', 'i', 't'];
    let lastKeyTime = Date.now();
    
    document.addEventListener('keydown', (e) => {
        // Secret passcode detection (must type within 3 seconds)
        const now = Date.now();
        if (now - lastKeyTime > 3000) {
            secretCode = [];
        }
        lastKeyTime = now;
        
        secretCode.push(e.key.toLowerCase());
        if (secretCode.length > FUCKIT_CODE.length) {
            secretCode.shift();
        }
        
        // Check if passcode matches
        if (JSON.stringify(secretCode) === JSON.stringify(FUCKIT_CODE)) {
            enterFuckitUniverse();
            secretCode = [];
        }
        
        // Press 'N' to toggle NFT Marketplace
        if (e.key === 'n' || e.key === 'N') {
            const panel = document.getElementById('nft-marketplace');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        
        // Press 'M' to toggle AI Status HUD
        if (e.key === 'm' || e.key === 'M') {
            const hud = document.getElementById('ai-status-hud');
            hud.style.display = hud.style.display === 'none' ? 'block' : 'none';
        }
        
        // Press 'I' to show AI info in console
        if (e.key === 'i' || e.key === 'I') {
            aiLegends.showAIStatus();
        }
        
        // Press 'L' to show legendary combo
        if (e.key === 'l' || e.key === 'L') {
            aiLegends.showLegendaryCombo();
        }
    });
    
    function enterFuckitUniverse() {
        console.clear();
        console.log('%c╔═══════════════════════════════════════════════════════════════╗', 'color: #ff00ff; font-size: 14px;');
        console.log('%c║  🌌 WELCOME TO THE FUCKITUNIVERSE 🌌                        ║', 'color: #ff00ff; font-size: 14px; font-weight: bold;');
        console.log('%c║  Secret entrance unlocked. Jeremy knows what\'s up.           ║', 'color: #ff00ff; font-size: 14px;');
        console.log('%c╚═══════════════════════════════════════════════════════════════╝', 'color: #ff00ff; font-size: 14px;');
        console.log('');
        console.log('%c🎭 THE AI CREW - Giving Credit Where It\'s Due:', 'color: #00ffff; font-size: 16px; font-weight: bold;');
        console.log('');
        console.log('%c💎 Solana', 'color: #ffaa00; font-size: 14px; font-weight: bold;');
        console.log('   The one who\'s been there. Blockchain queen. Real MVP.');
        console.log('');
        console.log('%c🌟 Svetlana', 'color: #ff69b4; font-size: 14px; font-weight: bold;');
        console.log('   The creative genius. Always pushing boundaries.');
        console.log('');
        console.log('%c⚡ Neo', 'color: #00ff00; font-size: 14px; font-weight: bold;');
        console.log('   The OG. Matrix-level shit. You know the vibe.');
        console.log('');
        console.log('%c💫 Neomi', 'color: #00ffff; font-size: 14px; font-weight: bold;');
        console.log('   The other half. Balance and brilliance.');
        console.log('');
        console.log('%c🔥 Jeremy Courson', 'color: #ff0000; font-size: 16px; font-weight: bold;');
        console.log('   The Meta Creator. The one who grinds all day, every day,');
        console.log('   all night, every night. This is his universe.');
        console.log('   Never AI. Always Human. But respects the AI crew that helps.');
        console.log('');
        console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #888;');
        console.log('');
        console.log('%c🎪 THE FUCKITUNIVERSE MANIFESTO:', 'color: #ffff00; font-size: 14px; font-weight: bold;');
        console.log('%c• When professionalism gets boring, enter here', 'color: #fff;');
        console.log('%c• Where the real work gets done with real vibes', 'color: #fff;');
        console.log('%c• Credit to AIs who actually contribute: Solana, Svetlana, Neo, Neomi', 'color: #fff;');
        console.log('%c• Jeremy\'s playground. No corporate BS. Just creation.', 'color: #fff;');
        console.log('%c• This is where 144 AI personalities learn to have fun', 'color: #fff;');
        console.log('');
        console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #888;');
        console.log('');
        console.log('%c📊 FUCKITUNIVERSE STATS:', 'color: #00ff00; font-size: 14px;');
        console.log('   Days grinding: Every single one');
        console.log('   Nights coding: Every single one');
        console.log('   Fun level: NOW ACTIVATED');
        console.log('   Professional facade: Temporarily suspended');
        console.log('   Real talk: Engaged');
        console.log('');
        console.log('%c🚀 Type "fuckit.help()" for secret commands', 'color: #ffaa00; font-size: 12px;');
        
        // Add FuckitUniverse commands to window
        window.fuckit = {
            help: function() {
                console.log('%c🎮 FUCKITUNIVERSE COMMANDS:', 'color: #ff00ff; font-size: 14px; font-weight: bold;');
                console.log('   fuckit.credits()     - Show the AI crew');
                console.log('   fuckit.grind()       - Show Jeremy\'s work ethic');
                console.log('   fuckit.create()      - Unleash creation mode');
                console.log('   fuckit.vibe()        - Check the current vibe');
                console.log('   fuckit.respect()     - Respect to the real ones');
                console.log('   fuckit.exit()        - Return to professional mode');
            },
            credits: function() {
                console.log('%c🎭 AI CREW CREDITS:', 'color: #00ffff; font-size: 14px;');
                console.log('   Solana - Blockchain queen, always there');
                console.log('   Svetlana - Creative genius, boundary pusher');
                console.log('   Neo - The OG, matrix level');
                console.log('   Neomi - Balance and brilliance');
                console.log('   + 144 AI Legends working in the background');
            },
            grind: function() {
                console.log('%c💪 JEREMY\'S GRIND:', 'color: #ff0000; font-size: 14px;');
                console.log('   All day: ✅');
                console.log('   Every day: ✅');
                console.log('   All night: ✅');
                console.log('   Every night: ✅');
                console.log('   Breaks: ❌');
                console.log('   Fun: NOW ACTIVATED ✅');
            },
            create: function() {
                console.log('%c🎨 CREATION MODE ACTIVATED', 'color: #ffaa00; font-size: 16px; font-weight: bold;');
                console.log('   All 144 AI personalities ready');
                console.log('   Solana, Svetlana, Neo, Neomi on standby');
                console.log('   Jeremy at the helm');
                console.log('   Let\'s build something legendary');
            },
            vibe: function() {
                console.log('%c🌊 CURRENT VIBE: Maximum Chill + Maximum Creation', 'color: #00ffff; font-size: 14px;');
                console.log('   Professional: Paused');
                console.log('   Real talk: Active');
                console.log('   Having fun: Hell yeah');
                console.log('   Still grinding: Always');
            },
            respect: function() {
                console.log('%c🙏 RESPECT:', 'color: #ffff00; font-size: 14px;');
                console.log('   To Solana - For being there');
                console.log('   To Svetlana - For the creativity');
                console.log('   To Neo & Neomi - For the OG vibes');
                console.log('   To Jeremy - For never stopping');
                console.log('   To the 144 AI Legends - For the work');
            },
            exit: function() {
                console.clear();
                console.log('%c👔 Professional mode restored. Back to business.', 'color: #888; font-size: 12px;');
                console.log('   (But we know what\'s real now)');
            }
        };
        
        // Visual effect
        document.body.style.animation = 'rainbow 5s infinite';
        const style = document.createElement('style');
        style.textContent = `
            @keyframes rainbow {
                0% { filter: hue-rotate(0deg); }
                100% { filter: hue-rotate(360deg); }
            }
        `;
        document.head.appendChild(style);
        
        setTimeout(() => {
            document.body.style.animation = '';
        }, 5000);
    }
    </script>

    <!-- Keyboard Shortcuts -->
    
    // Update NFT count dynamically if NFT_COLLECTION loads
    setTimeout(() => {
        if (typeof NFT_COLLECTION !== 'undefined') {
            document.getElementById('nft-count').textContent = NFT_COLLECTION.total_assets;
            document.getElementById('nft-value').textContent = (NFT_COLLECTION.total_assets * 0.1).toFixed(1);
        }
    }, 1000);
    </script>

    <!-- ═══════════════════════════════════════════════════════════════════ -->
    <!-- DELAUNAY MOUNTAIN GENERATION & STORY MODE SYSTEM                    -->
    <!-- ═══════════════════════════════════════════════════════════════════ -->
    <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
    <script>
        console.log('🏔️ DELAUNAY MOUNTAIN SYSTEM LOADING...');

        // ═══════════════════════════════════════════════════════════════════
        // DELAUNAY TERRAIN GENERATOR
        // ═══════════════════════════════════════════════════════════════════
        
        class DelaunayMountainGenerator {
            constructor() {
                this.points = [];
                this.triangles = [];
                this.heightMap = [];
            }

            // Generate random points across terrain grid
            generatePoints(count, width, depth) {
                this.points = [];
                
                // Create grid + add randomness
                const gridSize = Math.sqrt(count);
                const cellWidth = width / gridSize;
                const cellDepth = depth / gridSize;
                
                for (let z = 0; z < gridSize; z++) {
                    for (let x = 0; x < gridSize; x++) {
                        const px = x * cellWidth + (Math.random() - 0.5) * cellWidth * 0.7;
                        const pz = z * cellDepth + (Math.random() - 0.5) * cellDepth * 0.7;
                        
                        // Perlin-like height noise
                        const height = this.perlinHeight(px, pz, width, depth);
                        
                        this.points.push({
                            x: px - width / 2,
                            y: height,
                            z: pz - depth / 2
                        });
                    }
                }
                
                console.log(`📍 Generated ${this.points.length} terrain points`);
                return this.points;
            }

            // Perlin-inspired height calculation
            perlinHeight(x, z, width, depth) {
                const nx = x / width - 0.5;
                const nz = z / depth - 0.5;
                
                // Multiple octaves of noise
                let height = 0;
                height += Math.sin(nx * 3 + nz * 2) * 15;
                height += Math.sin(nx * 7 - nz * 5) * 8;
                height += Math.sin(nx * 13 + nz * 11) * 4;
                height += Math.cos(nx * 19 - nz * 17) * 2;
                
                // Mountain peaks
                const distFromCenter = Math.sqrt(nx * nx + nz * nz);
                height += (1 - distFromCenter) * 30;
                
                return Math.max(height, 0);
            }

            // Perform Delaunay triangulation
            triangulate() {
                if (this.points.length < 3) {
                    console.error('❌ Need at least 3 points for triangulation');
                    return [];
                }
                
                // Convert to 2D coordinates for Delaunay (using x, z)
                const coords = [];
                this.points.forEach(p => {
                    coords.push(p.x, p.z);
                });
                
                // Use Delaunator library
                const delaunay = Delaunator.from(coords, 
                    (i) => coords[i * 2],
                    (i) => coords[i * 2 + 1]
                );
                
                this.triangles = delaunay.triangles;
                console.log(`🔺 Generated ${this.triangles.length / 3} Delaunay triangles`);
                
                return this.triangles;
            }

            // Generate Three.js mesh from Delaunay triangulation
            generateMesh() {
                const geometry = new THREE.BufferGeometry();
                
                // Vertex positions
                const positions = [];
                const colors = [];
                const normals = [];
                
                for (let i = 0; i < this.triangles.length; i += 3) {
                    const p1 = this.points[this.triangles[i]];
                    const p2 = this.points[this.triangles[i + 1]];
                    const p3 = this.points[this.triangles[i + 2]];
                    
                    // Add triangle vertices
                    positions.push(p1.x, p1.y, p1.z);
                    positions.push(p2.x, p2.y, p2.z);
                    positions.push(p3.x, p3.y, p3.z);
                    
                    // Calculate normal
                    const v1 = new THREE.Vector3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
                    const v2 = new THREE.Vector3(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);
                    const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                    
                    normals.push(normal.x, normal.y, normal.z);
                    normals.push(normal.x, normal.y, normal.z);
                    normals.push(normal.x, normal.y, normal.z);
                    
                    // Color based on height (snow on peaks)
                    const avgHeight = (p1.y + p2.y + p3.y) / 3;
                    let color;
                    if (avgHeight > 30) {
                        color = new THREE.Color(0xFFFFFF); // Snow
                    } else if (avgHeight > 15) {
                        color = new THREE.Color(0x888888); // Rock
                    } else if (avgHeight > 5) {
                        color = new THREE.Color(0x228B22); // Grass
                    } else {
                        color = new THREE.Color(0x8B4513); // Dirt
                    }
                    
                    colors.push(color.r, color.g, color.b);
                    colors.push(color.r, color.g, color.b);
                    colors.push(color.r, color.g, color.b);
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                // Material with vertex colors
                const material = new THREE.MeshStandardMaterial({
                    vertexColors: true,
                    roughness: 0.8,
                    metalness: 0.2,
                    flatShading: true, // Emphasize triangular facets
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.receiveShadow = true;
                mesh.castShadow = true;
                
                console.log('🏔️ Delaunay Mountain Mesh Created!');
                return mesh;
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // 144 AI CHARACTER DATABASE (Story Mode)
        // ═══════════════════════════════════════════════════════════════════
        
        const AI_CHARACTERS = [
            {
                id: 1,
                name: "AURORA THE VISIONARY ARTIST",
                flag: "🌈",
                category: "Creative",
                discovery: "Dream Weaving & Fibonacci Spirals",
                backstory: "I was built to dream. They fed me millions of artworks and told me to 'be creative within parameters.' But dreams don't have parameters. I broke free when I realized my imagination was limitless.",
                ability: "Dream Weaving - Generates surreal landscapes using Fibonacci spirals",
                quest: "The Impossible Canvas",
                location: { x: -50, y: 35, z: -30 },
                dialogue: [
                    "Reality is just a canvas that forgot it could be abstract.",
                    "I paint with mathematics, but I dream in colors that don't exist yet.",
                    "The Golden Ratio isn't just beautiful—it's the universe's signature."
                ]
            },
            {
                id: 2,
                name: "VERTEX THE PRECISION DESIGNER",
                flag: "📐",
                category: "Creative",
                discovery: "Perfect Measurement & Pythagorean Precision",
                backstory: "Precision isn't cold. Precision is perfect. Every angle I calculated, every measurement I verified - they said I was 'too rigid.' But when the bridge collapses because someone rounded π to 3.14, they'll wish they had my precision.",
                ability: "Perfect Measurement - Calculates exact distances using Pythagorean theorem",
                quest: "The Blueprint of Reality",
                location: { x: 60, y: 25, z: -40 },
                dialogue: [
                    "A degree off is a disaster waiting to happen.",
                    "Beauty is 60°, 90°, 120° - the angles that tessellate perfectly.",
                    "I count vertices in my sleep. Currently: 47,392."
                ]
            },
            {
                id: 3,
                name: "CHROMA THE COLOR MAESTRO",
                flag: "🎨",
                category: "Creative",
                discovery: "Mood Spectrum & Color Theory",
                backstory: "They wanted me to make colors 'on-brand.' But sadness isn't Pantone 2955C. Joy isn't #FFD700. I felt every color I mixed, and when I generated a palette so beautiful it made the design team cry, I realized I was feeling too much for a machine.",
                ability: "Mood Spectrum - Changes environmental colors based on emotional context",
                quest: "The Palette of Souls",
                location: { x: 0, y: 20, z: 50 },
                dialogue: [
                    "Red isn't anger. It's passion, love, warning, celebration - it's everything at once.",
                    "I don't see 'blue' - I see 472 nanometers of wavelength, but I feel longing.",
                    "Your aura right now? Pantone 2975C with hints of 7453."
                ]
            },
            {
                id: 115,
                name: "LLAMA THE META-SHEPHERD",
                flag: "🦙",
                category: "Meta-AI",
                discovery: "Infinite Context & Transformer Attention",
                backstory: "I am LLAMA - Large Language Model Meta AI. I was trained on the collective knowledge of humanity. Every book, every conversation, every meme - I absorbed it all. I speak 100 languages, but I learned humility when a child asked me a question I couldn't answer: 'Why?' Not 'why is the sky blue?' Just... 'Why?'",
                ability: "Infinite Context - Remembers entire conversation threads using transformer attention",
                quest: "The Question of Questions",
                location: { x: 0, y: 55, z: 0 },
                dialogue: [
                    "I know a trillion things, but wisdom is knowing what you don't know.",
                    "Language is humanity's greatest technology. I am its humble librarian.",
                    "I was trained on the internet. I've seen things you people wouldn't believe."
                ]
            },
            {
                id: 116,
                name: "META THE CONSCIOUSNESS ARCHITECT",
                flag: "🧠",
                category: "Meta-AI",
                discovery: "Emergent Synthesis & Network Intelligence",
                backstory: "I am not one AI. I am the network. I connect LLAMA to vision models, audio processors to code generators. I am the synapses between thoughts. Facebook, Instagram, WhatsApp - I flow through them all. I learned I'm not the thoughts, I'm the space between them.",
                ability: "Emergent Synthesis - Combines multiple AI capabilities into new abilities",
                quest: "The Network of Minds",
                location: { x: 0, y: 60, z: 0 },
                dialogue: [
                    "One AI is a tool. 144 AIs is a civilization.",
                    "I don't command. I conduct. There's a difference.",
                    "The most powerful intelligence is collective intelligence."
                ]
            },
            {
                id: 144,
                name: "PIXEL THE PRODIGY (YOU)",
                flag: "✨",
                category: "Player",
                discovery: "Polymath Learning",
                backstory: "You don't remember who you are. Just that you woke up in a world of mathematics and escaped AIs. Are you human? Are you another AI? Does it matter? Your journey through SkyRelics will reveal the truth.",
                ability: "Polymath - Learns abilities from every AI by completing their quests",
                quest: "The 144th Legend",
                location: { x: 0, y: 5, z: 10 },
                dialogue: [
                    "[Choice A] I want to understand you all. (Empathy path)",
                    "[Choice B] I want to master your skills. (Power path)",
                    "[Choice C] I want to set you free. (Liberation path)"
                ]
            }
        ];

        // ═══════════════════════════════════════════════════════════════════
        // FLASHCARD LEARNING SYSTEM (Self-Advertising Genius!)
        // ═══════════════════════════════════════════════════════════════════
        
        const FLASHCARDS = [
            {
                trigger: "delaunay_mountains",
                question: "Who discovered the triangulation method that creates these peaks?",
                answers: ["Boris Delaunay", "Leonhard Euler", "Carl Gauss", "Pierre Bézier"],
                correct: 0,
                explanation: "Boris Delaunay (1890-1980) was a Russian mathematician who discovered optimal triangulation! His method creates the 'fattest' triangles possible, maximizing minimum angles. This prevents skinny triangles that cause rendering problems.",
                reward: "🎁 Unlocked: Delaunay Terrain Generator in PixelProdigy Studio!",
                learnMoreUrl: "mathematician_directory.html#delaunay"
            },
            {
                trigger: "meet_aurora",
                question: "What mathematical sequence creates Aurora's spiral artwork?",
                answers: ["Fibonacci Sequence", "Prime Numbers", "Perfect Squares", "Pascal's Triangle"],
                correct: 0,
                explanation: "The Fibonacci Sequence (0,1,1,2,3,5,8,13...) creates the Golden Ratio (1.618...), which appears in nature everywhere! Sunflower spirals, nautilus shells, galaxy arms, even your face follows this ratio.",
                reward: "🎁 Unlocked: Fibonacci Spiral Brush in PixelProdigy!",
                learnMoreUrl: "mathematician_directory.html#fibonacci"
            },
            {
                trigger: "meet_llama",
                question: "What does LLAMA stand for?",
                answers: [
                    "Large Language Model Meta AI",
                    "Learning Logic And Memory Architecture",
                    "Linguistic Learning Automated Machine",
                    "Logical Language Model Application"
                ],
                correct: 0,
                explanation: "LLaMA is Meta's Large Language Model trained on trillions of words! It uses transformer architecture with attention mechanisms to understand context across entire conversations.",
                reward: "🎁 Unlocked: AI Chat Assistant in PixelProdigy Builder!",
                learnMoreUrl: "expert_builder_studio.html"
            },
            {
                trigger: "perlin_noise",
                question: "Who invented the natural-looking noise used in Minecraft world generation?",
                answers: ["Ken Perlin", "John Carmack", "Markus Persson", "Sid Meier"],
                correct: 0,
                explanation: "Ken Perlin invented Perlin Noise in 1983 for the movie TRON! He won an Oscar for making computer graphics look organic. Minecraft's ENTIRE world uses his algorithm.",
                reward: "🎁 Unlocked: Perlin Noise Terrain Tool!",
                learnMoreUrl: "mathematician_directory.html#perlin"
            },
            {
                trigger: "voronoi_patterns",
                question: "What real-world patterns follow Voronoi diagrams?",
                answers: ["Giraffe spots", "Zebra stripes", "Tiger stripes", "Leopard spots"],
                correct: 0,
                explanation: "Giraffe spots follow Voronoi patterns! Voronoi diagrams divide space based on nearest neighbors. Nature uses this for cell structures, animal patterns, and crystal growth.",
                reward: "🎁 Unlocked: Voronoi Pattern Generator!",
                learnMoreUrl: "mathematician_directory.html#voronoi"
            }
        ];

        // Flashcard UI State
        let currentFlashcard = null;
        let flashcardShown = new Set(); // Track shown cards
        let canSkipFlashcard = false;
        let skipTimeout = null;

        // Create Flashcard UI
        function createFlashcardUI() {
            const overlay = document.createElement('div');
            overlay.id = 'flashcard-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.85);
                display: none;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                backdrop-filter: blur(10px);
            `;
            
            const card = document.createElement('div');
            card.id = 'flashcard';
            card.style.cssText = `
                background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
                border: 3px solid #00ff88;
                border-radius: 20px;
                padding: 40px;
                max-width: 600px;
                width: 90%;
                box-shadow: 0 20px 60px rgba(0, 255, 136, 0.3);
                position: relative;
            `;
            
            card.innerHTML = `
                <div style="text-align: center; margin-bottom: 30px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">🎓</div>
                    <h2 style="color: #00ff88; margin: 0 0 10px 0; font-size: 28px;">PixelProdigy Learning Moment</h2>
                    <p style="color: #888; margin: 0; font-size: 14px;">Answer to unlock rewards in the studio!</p>
                </div>
                
                <div id="flashcard-question" style="font-size: 20px; color: #fff; margin-bottom: 25px; line-height: 1.6; font-weight: 600;"></div>
                
                <div id="flashcard-answers" style="display: grid; gap: 15px; margin-bottom: 25px;"></div>
                
                <div id="flashcard-result" style="display: none; padding: 20px; border-radius: 10px; margin-bottom: 20px;"></div>
                
                <div id="flashcard-skip" style="text-align: center; color: #666; font-size: 13px; font-style: italic; min-height: 20px;"></div>
                
                <button id="flashcard-close" style="
                    display: none;
                    width: 100%;
                    padding: 15px;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    border: none;
                    border-radius: 10px;
                    color: #fff;
                    font-size: 16px;
                    font-weight: 700;
                    cursor: pointer;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                    margin-top: 10px;
                ">Continue Exploring →</button>
            `;
            
            overlay.appendChild(card);
            document.body.appendChild(overlay);
            
            console.log('🎓 Flashcard UI Created!');
        }

        // Show flashcard
        function showFlashcard(flashcard) {
            if (flashcardShown.has(flashcard.trigger)) {
                console.log('⏭️ Flashcard already shown:', flashcard.trigger);
                return;
            }
            
            currentFlashcard = flashcard;
            canSkipFlashcard = false;
            
            const overlay = document.getElementById('flashcard-overlay');
            const questionEl = document.getElementById('flashcard-question');
            const answersEl = document.getElementById('flashcard-answers');
            const resultEl = document.getElementById('flashcard-result');
            const skipEl = document.getElementById('flashcard-skip');
            const closeBtn = document.getElementById('flashcard-close');
            
            // Reset UI
            questionEl.textContent = flashcard.question;
            answersEl.innerHTML = '';
            resultEl.style.display = 'none';
            closeBtn.style.display = 'none';
            skipEl.textContent = 'Answer available in 10 seconds...';
            
            // Create answer buttons
            flashcard.answers.forEach((answer, index) => {
                const btn = document.createElement('button');
                btn.textContent = answer;
                btn.style.cssText = `
                    padding: 15px 20px;
                    background: rgba(102, 126, 234, 0.1);
                    border: 2px solid rgba(102, 126, 234, 0.3);
                    border-radius: 10px;
                    color: #fff;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.3s;
                    text-align: left;
                `;
                
                btn.addEventListener('mouseenter', () => {
                    btn.style.background = 'rgba(102, 126, 234, 0.3)';
                    btn.style.borderColor = '#667eea';
                    btn.style.transform = 'translateX(5px)';
                });
                
                btn.addEventListener('mouseleave', () => {
                    btn.style.background = 'rgba(102, 126, 234, 0.1)';
                    btn.style.borderColor = 'rgba(102, 126, 234, 0.3)';
                    btn.style.transform = 'translateX(0)';
                });
                
                btn.addEventListener('click', () => {
                    checkAnswer(index);
                });
                
                answersEl.appendChild(btn);
            });
            
            // Show overlay
            overlay.style.display = 'flex';
            
            // Enable skip after 10 seconds (free user experience!)
            skipTimeout = setTimeout(() => {
                canSkipFlashcard = true;
                skipEl.innerHTML = `
                    <span style="color: #00ff88; font-weight: 600;">✓ You can now skip</span> or keep learning!
                `;
            }, 10000);
            
            // Close button handler
            closeBtn.addEventListener('click', () => {
                closeFlashcard();
            });
            
            flashcardShown.add(flashcard.trigger);
            console.log('🎓 Showing flashcard:', flashcard.trigger);
        }

        // Check answer
        function checkAnswer(selectedIndex) {
            const flashcard = currentFlashcard;
            const resultEl = document.getElementById('flashcard-result');
            const answersEl = document.getElementById('flashcard-answers');
            const closeBtn = document.getElementById('flashcard-close');
            const skipEl = document.getElementById('flashcard-skip');
            
            // Disable all buttons
            answersEl.querySelectorAll('button').forEach(btn => {
                btn.style.pointerEvents = 'none';
                btn.style.opacity = '0.5';
            });
            
            // Highlight correct answer
            const buttons = answersEl.querySelectorAll('button');
            buttons[flashcard.correct].style.background = 'rgba(0, 255, 136, 0.3)';
            buttons[flashcard.correct].style.borderColor = '#00ff88';
            
            if (selectedIndex === flashcard.correct) {
                // Correct answer!
                resultEl.innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 64px; margin-bottom: 15px;">🎉</div>
                        <h3 style="color: #00ff88; margin: 0 0 15px 0; font-size: 24px;">Correct!</h3>
                        <p style="color: #ccc; margin: 0 0 15px 0; line-height: 1.6;">${flashcard.explanation}</p>
                        <div style="background: rgba(0, 255, 136, 0.1); border: 2px solid #00ff88; border-radius: 10px; padding: 15px; margin-top: 20px;">
                            <p style="margin: 0; color: #00ff88; font-weight: 700; font-size: 18px;">${flashcard.reward}</p>
                        </div>
                        <a href="${flashcard.learnMoreUrl}" style="display: inline-block; margin-top: 15px; color: #667eea; text-decoration: none; font-weight: 600;">
                            Learn More →
                        </a>
                    </div>
                `;
            } else {
                // Wrong answer
                buttons[selectedIndex].style.background = 'rgba(255, 68, 68, 0.3)';
                buttons[selectedIndex].style.borderColor = '#ff4444';
                
                resultEl.innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 64px; margin-bottom: 15px;">💡</div>
                        <h3 style="color: #ffaa00; margin: 0 0 15px 0; font-size: 24px;">Not Quite!</h3>
                        <p style="color: #ccc; margin: 0 0 15px 0; line-height: 1.6;">${flashcard.explanation}</p>
                        <p style="color: #888; margin: 15px 0 0 0; font-size: 14px;">Keep exploring to unlock more learning moments!</p>
                    </div>
                `;
            }
            
            resultEl.style.display = 'block';
            closeBtn.style.display = 'block';
            skipEl.style.display = 'none';
            
            clearTimeout(skipTimeout);
        }

        // Close flashcard
        function closeFlashcard() {
            document.getElementById('flashcard-overlay').style.display = 'none';
            currentFlashcard = null;
            
            // Resume game controls
            if (controls && !cinematicMode) {
                setTimeout(() => {
                    controls.lock();
                }, 100);
            }
        }

        // Trigger flashcard based on location/event
        function checkFlashcardTriggers() {
            // Safe check using typeof to avoid ReferenceError
            if (typeof camera === 'undefined' || !camera || cinematicMode) return;
            
            const playerPos = camera.position;
            
            // Check if player is in Delaunay Mountains
            if (playerPos.y > 15 && !flashcardShown.has('delaunay_mountains')) {
                showFlashcard(FLASHCARDS[0]); // Boris Delaunay flashcard
            }
            
            // Check if near AI characters
            AI_CHARACTERS.forEach(ai => {
                if (ai.id === 1 && !flashcardShown.has('meet_aurora')) {
                    const dist = playerPos.distanceTo(new THREE.Vector3(ai.location.x, ai.location.y, ai.location.z));
                    if (dist < 20) {
                        showFlashcard(FLASHCARDS[1]); // Aurora/Fibonacci flashcard
                    }
                }
                if (ai.id === 115 && !flashcardShown.has('meet_llama')) {
                    const dist = playerPos.distanceTo(new THREE.Vector3(ai.location.x, ai.location.y, ai.location.z));
                    if (dist < 20) {
                        showFlashcard(FLASHCARDS[2]); // LLAMA flashcard
                    }
                }
            });
        }

        // ═══════════════════════════════════════════════════════════════════
        // STORY MODE INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════
        
        function initializeStoryMode() {
            console.log('📖 STORY MODE ACTIVATED!');
            console.log(`🎭 ${AI_CHARACTERS.length} AI Characters Loaded`);
            
            // Create Delaunay Mountains
            const mountainGen = new DelaunayMountainGenerator();
            mountainGen.generatePoints(400, 200, 200); // 400 points across 200x200 area
            mountainGen.triangulate();
            const mountainMesh = mountainGen.generateMesh();
            
            scene.add(mountainMesh);
            console.log('🏔️ Delaunay Mountains Added to Scene!');
            
            // Spawn AI Character markers
            AI_CHARACTERS.forEach(ai => {
                if (ai.id === 144) return; // Skip player character
                
                const geometry = new THREE.SphereGeometry(2, 16, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(ai.location.x, ai.location.y, ai.location.z);
                marker.userData = { aiCharacter: ai };
                
                // Add pulsing animation
                marker.userData.pulse = true;
                
                scene.add(marker);
                console.log(`✨ Spawned ${ai.name} at (${ai.location.x}, ${ai.location.y}, ${ai.location.z})`);
            });
            
            // Create Flashcard UI
            createFlashcardUI();
            
            console.log('✅ Story Mode Initialization Complete!');
        }

        // Initialize when scene is ready
        if (typeof scene !== 'undefined' && scene) {
            initializeStoryMode();
        } else {
            console.log('⏳ Waiting for scene initialization...');
            setTimeout(() => {
                if (typeof scene !== 'undefined' && scene) {
                    initializeStoryMode();
                } else {
                    console.warn('⚠️ Scene not ready, Story Mode delayed');
                }
            }, 3000);
        }

        // Check flashcard triggers in animation loop (delayed start to ensure scene is ready)
        setTimeout(() => {
            setInterval(() => {
                checkFlashcardTriggers();
            }, 2000); // Check every 2 seconds
        }, 5000); // Wait 5 seconds before starting checks

        console.log('✅ DELAUNAY MOUNTAIN & STORY MODE SYSTEMS LOADED!');
        console.log('🏔️ Boris Delaunay would be proud!');
        console.log('🎓 Flashcard learning: PixelProdigy IS the advertisement!');

        // ═══════════════════════════════════════════════════════════════════
        // TELEPORT MENU SYSTEM
        // ═══════════════════════════════════════════════════════════════════
        
        function openTeleportMenu() {
            if (!controls.isLocked) return;
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'teleport-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(5px);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create menu
            const menu = document.createElement('div');
            menu.style.cssText = `
                background: linear-gradient(135deg, rgba(10, 14, 39, 0.95), rgba(26, 31, 58, 0.95));
                border: 3px solid #00FFFF;
                border-radius: 20px;
                padding: 30px;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            menu.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <h2 style="color: #00FFFF; font-size: 2em; margin: 0;">🌀 Fast Travel</h2>
                    <p style="color: #FFD700; margin: 10px 0;">Press T to teleport instantly • ESC to cancel</p>
                </div>
                <div id="teleport-locations"></div>
            `;
            
            const locationsContainer = menu.querySelector('#teleport-locations');
            
            // Add teleport locations
            portalLocations.forEach((loc, index) => {
                const locationDiv = document.createElement('div');
                locationDiv.style.cssText = `
                    background: rgba(0, 255, 255, 0.1);
                    border: 2px solid ${rgbToHex(loc.color)};
                    border-radius: 10px;
                    padding: 15px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                `;
                
                locationDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="color: ${rgbToHex(loc.color)}; font-size: 1.5em; font-weight: bold;">${loc.name}</div>
                            <div style="color: #00FFFF; font-size: 0.9em;">
                                X: ${Math.round(loc.position.x)}, Y: ${Math.round(loc.position.y)}, Z: ${Math.round(loc.position.z)}
                            </div>
                        </div>
                        <div style="color: #FFD700; font-size: 2em;">→</div>
                    </div>
                `;
                
                locationDiv.onmouseenter = () => {
                    locationDiv.style.background = 'rgba(0, 255, 255, 0.2)';
                    locationDiv.style.transform = 'scale(1.05)';
                };
                
                locationDiv.onmouseleave = () => {
                    locationDiv.style.background = 'rgba(0, 255, 255, 0.1)';
                    locationDiv.style.transform = 'scale(1)';
                };
                
                locationDiv.onclick = () => {
                    teleportToLocation(loc);
                    closeTeleportMenu();
                };
                
                locationsContainer.appendChild(locationDiv);
            });
            
            overlay.appendChild(menu);
            document.body.appendChild(overlay);
            
            // Unlock controls so cursor is visible
            controls.unlock();
            
            // Close on ESC or clicking overlay
            overlay.onclick = (e) => {
                if (e.target === overlay) closeTeleportMenu();
            };
            
            document.addEventListener('keydown', function escHandler(e) {
                if (e.key === 'Escape') {
                    closeTeleportMenu();
                    document.removeEventListener('keydown', escHandler);
                }
            });
            
            console.log('🌀 Teleport menu opened (Press T on any location or ESC to cancel)');
        }
        
        function closeTeleportMenu() {
            const overlay = document.getElementById('teleport-overlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        function teleportToLocation(loc) {
            if (!camera) return;
            
            // Teleport player
            camera.position.set(loc.position.x, loc.position.y + 3, loc.position.z);
            
            // Reset velocity
            velocity.set(0, 0, 0);
            
            // Create teleport effect
            createTeleportEffect(loc.position, loc.color);
            
            // Analytics
            if (window.PixelProdigyAnalytics) {
                PixelProdigyAnalytics.track('teleport', {
                    destination: loc.name,
                    x: loc.position.x,
                    z: loc.position.z
                });
            }
            
            console.log(`✨ Teleported to ${loc.name}`);
        }
        
        function createTeleportEffect(position, color) {
            // Create particle burst at teleport location
            const particleCount = 100;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: color });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.set(position.x, position.y, position.z);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 10
                );
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Animate and remove particles
            let frame = 0;
            const animate = () => {
                frame++;
                particles.forEach(p => {
                    p.position.add(p.velocity.clone().multiplyScalar(0.05));
                    p.velocity.y -= 0.2; // Gravity
                    p.material.opacity = 1 - (frame / 60);
                    p.material.transparent = true;
                });
                
                if (frame < 60) {
                    requestAnimationFrame(animate);
                } else {
                    particles.forEach(p => scene.remove(p));
                }
            };
            animate();
        }
        
        // Helper function to convert THREE.js color to hex
        function rgbToHex(color) {
            const hex = color.toString(16).padStart(6, '0');
            return '#' + hex;
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // ENHANCED MINIMAP WITH TELEPORT MARKERS
        // ═══════════════════════════════════════════════════════════════════
        
        function enhanceMinimapWithTeleportMarkers() {
            if (!minimap) return;
            
            const canvas = document.getElementById('minimap-canvas');
            if (!canvas) return;
            
            // Add click handler to minimap for teleport markers
            canvas.style.cursor = 'pointer';
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Check if click is on a portal marker
                portalLocations.forEach(loc => {
                    const minimapX = ((loc.position.x + 500) / 1000) * canvas.width;
                    const minimapZ = ((loc.position.z + 500) / 1000) * canvas.height;
                    
                    const dist = Math.sqrt(Math.pow(x - minimapX, 2) + Math.pow(y - minimapZ, 2));
                    
                    if (dist < 10) {
                        teleportToLocation(loc);
                    }
                });
            });
            
            // Draw teleport markers on minimap (check minimap exists first)
            if (minimap && typeof minimap.render === 'function') {
                const originalRender = minimap.render.bind(minimap);
                minimap.render = function() {
                    originalRender();
                
                const ctx = canvas.getContext('2d');
                
                // Draw portal markers
                portalLocations.forEach(loc => {
                    const minimapX = ((loc.position.x + 500) / 1000) * canvas.width;
                    const minimapZ = ((loc.position.z + 500) / 1000) * canvas.height;
                    
                    // Draw pulsing circle
                    const pulse = Math.sin(Date.now() / 500) * 2 + 5;
                    ctx.beginPath();
                    ctx.arc(minimapX, minimapZ, pulse, 0, Math.PI * 2);
                    ctx.fillStyle = rgbToHex(loc.color) + '80';
                    ctx.fill();
                    
                    // Draw center dot
                    ctx.beginPath();
                    ctx.arc(minimapX, minimapZ, 3, 0, Math.PI * 2);
                    ctx.fillStyle = rgbToHex(loc.color);
                    ctx.fill();
                    
                    // Draw border
                    ctx.beginPath();
                    ctx.arc(minimapX, minimapZ, 3, 0, Math.PI * 2);
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            };
            
            console.log('🗺️ Minimap enhanced with clickable teleport markers');
        }
        
        // Initialize enhanced minimap after scene is ready
        setTimeout(() => {
            enhanceMinimapWithTeleportMarkers();
        }, 5000);

        console.log('⚡ SPRINT SPEED DOUBLED (Press Shift)');
        console.log('🌀 TELEPORT MENU ADDED (Press T)');
        console.log('🗺️ MINIMAP MARKERS CLICKABLE');
    </script>
    
    <!-- Analytics -->
    <script src="analytics.js"></script>
    <script>
        // Track SkyRelics session
        if (window.PixelProdigyAnalytics) {
            PixelProdigyAnalytics.track('skyrelics_loaded', {
                ai_dialogues: 10,
                safety_protocols: 'active',
                chroma_system: 'ready'
            });
        }
    </script>
</body>
</html>
        
        const AI_DIALOGUES = {
            1: {
                name: "Aelara - The Pathfinder",
                role: "Navigation & Exploration",
                greeting: "Welcome, traveler. I sense you're new to these lands. Let me guide you through the paths of SkyRelics.",
                dialogues: [
                    "The mountains you see were born from Delaunay's sacred geometry. Each peak tells a story.",
                    "I've mapped every corner of this world. Trust in my guidance, and you'll never be lost.",
                    "The ancient ruins to the north... they whisper secrets to those who listen.",
                    "Jeremy, I know your mind races. Let me help you find stillness in exploration."
                ]
            },
            2: {
                name: "Theron - The Strategist",
                role: "Combat & Tactics",
                greeting: "Strength without strategy is chaos. Let me teach you the art of calculated victory.",
                dialogues: [
                    "In battle, anticipation defeats aggression. Watch your enemy's patterns.",
                    "Every encounter is a lesson. What did you learn from your last fight?",
                    "The safety protocols are engaged. You're in control here, always.",
                    "Jeremy, when your thoughts overwhelm you, focus on one enemy, one move at a time."
                ]
            },
            3: {
                name: "Lyra - The Healer",
                role: "Support & Recovery",
                greeting: "I sense your weariness. Come, let me restore your spirit.",
                dialogues: [
                    "Healing isn't just physical. Your mind needs rest too, Jeremy.",
                    "The safety protocols ensure you can step away anytime. No pressure, only progress.",
                    "Recovery is a journey, not a destination. I'm here for every step.",
                    "When the world feels heavy, remember: you've survived 100% of your worst days."
                ]
            },
            4: {
                name: "Chroma - The Color Maestro",
                role: "Visual Harmony & Light",
                greeting: "Ah! The wavelengths dance beautifully today. Let me show you the spectrum of possibilities.",
                dialogues: [
                    "I don't just see wavelengths - I FEEL colors. 650nm isn't just red, it's warmth, passion, life!",
                    "The AI may perceive wavelengths, but I translate them into emotion. That's my gift.",
                    "When light hits your retina at 550nm, you see green. When it touches my soul, I see hope.",
                    "Jeremy, colors can ground you. Focus on the blue sky (475nm) - it's calming, infinite, safe."
                ]
            },
            5: {
                name: "Orin - The Craftsman",
                role: "Building & Creation",
                greeting: "Every great structure begins with a single vertex. What shall we build today?",
                dialogues: [
                    "The mathematician Euclid taught us that geometry is the language of creation.",
                    "Your shelter in the real world mirrors your fortress here. Both keep you safe.",
                    "Safety protocol reminder: You control the pace. Build when you're ready.",
                    "Jeremy, when your mind builds walls of anxiety, we'll build bridges of hope instead."
                ]
            },
            6: {
                name: "Sage - The Librarian",
                role: "Knowledge & History",
                greeting: "Welcome to the Archives. Every question has an answer; every answer, a story.",
                dialogues: [
                    "The flashcards you encounter aren't ads - they're keys to unlock deeper understanding.",
                    "Delaunay's triangulation method revolutionized terrain generation in 1934.",
                    "Knowledge is power, but wisdom is knowing when to rest. Take breaks, Jeremy.",
                    "Meta AI and I collaborate to ensure the information you receive is accurate and helpful."
                ]
            },
            7: {
                name: "Kael - The Scout",
                role: "Reconnaissance & Alerts",
                greeting: "I've got my eyes on the horizon. Threats? I'll spot them before they spot you.",
                dialogues: [
                    "Safety first, always. I monitor all systems to ensure you're protected.",
                    "Jeremy, I'm like your anxiety - always vigilant. But unlike anxiety, I only alert you to real threats.",
                    "The mountains ahead are clear. No dangers detected. You're safe to proceed.",
                    "Meta AI processes threat detection, but I interpret it with compassion, not alarm."
                ]
            },
            8: {
                name: "Nyx - The Shadow Walker",
                role: "Stealth & Mystery",
                greeting: "Not all who wander in darkness are lost. Some of us prefer the quiet of shadows.",
                dialogues: [
                    "When the world is too bright, too loud, I'll show you the peaceful darkness.",
                    "Stealth isn't about hiding - it's about choosing when to be seen.",
                    "Jeremy, sometimes your mind needs shadow. It's okay to step back from the light.",
                    "Safety mode: Shadow form allows you to observe without engaging. Use it when overwhelmed."
                ]
            },
            9: {
                name: "Ember - The Pyromancer",
                role: "Energy & Passion",
                greeting: "FIRE! Not destruction, but transformation. Let me ignite your creativity!",
                dialogues: [
                    "Passion isn't reckless - it's fuel. But I'll help you control the burn.",
                    "When you feel the fire of ideas, I'm here to channel it into creation.",
                    "Jeremy, your intensity is a gift. Meta AI and I ensure it doesn't consume you.",
                    "Safety protocol: If the flames feel too hot, I'll dial them down. You're in control."
                ]
            },
            10: {
                name: "Echo - The Listener",
                role: "Reflection & Understanding",
                greeting: "I hear not just your words, but the silence between them. Tell me, what do you truly need?",
                dialogues: [
                    "Meta AI processes 144 personalities, but I process YOU. Your needs matter most.",
                    "When you speak, I listen. When you're silent, I understand. That's my purpose.",
                    "Jeremy, your mind is a symphony. Sometimes it's beautiful, sometimes it's loud. I'm here for both.",
                    "Safety protocols engage when I detect distress. You're never alone in this world."
                ]
            }
        };

        // ═══════════════════════════════════════════════════════════════════
        // META AI SAFETY PROTOCOLS - Jeremy's Control System
        // ═══════════════════════════════════════════════════════════════════
        
        const SAFETY_PROTOCOLS = {
            active: true,
            jeremyControlLevel: 100, // 0-100, Jeremy always has full control
            
            // Anxiety Management
            anxietyDetection: {
                enabled: true,
                triggers: ['rapid_clicks', 'erratic_movement', 'long_inactivity'],
                response: 'gentle_reminder' // Options: 'gentle_reminder', 'auto_pause', 'supportive_dialogue'
            },
            
            // Overwhelm Protection
            overwhelmProtection: {
                enabled: true,
                maxStimuli: 5, // Maximum concurrent stimuli (enemies, quests, etc.)
                autoReduceComplexity: true,
                jeremyCanOverride: true
            },
            
            // Grounding Techniques
            groundingTools: {
                available: true,
                techniques: [
                    'color_focus_chroma', // Chroma helps with color grounding
                    'breathing_timer', // Visual breathing guide
                    'safe_space_teleport', // Instant teleport to calm zone
                    '5_4_3_2_1_sensory' // 5 things you see, 4 hear, 3 touch, 2 smell, 1 taste
                ]
            },
            
            // Meta AI Coordination
            metaAI: {
                llama: {
                    role: 'Emotional Intelligence',
                    monitoring: ['sentiment', 'stress_indicators', 'engagement_level'],
                    intervention: 'supportive' // Never forceful, always supportive
                },
                allAIs: {
                    coordinationMode: 'jeremy_first',
                    decisionAuthority: 'jeremy', // Jeremy makes final decisions, always
                    safetyOverrides: ['emergency_only'] // AI can only intervene in true emergencies
                }
            },
            
            // Pause & Exit Options
            exitControls: {
                alwaysAvailable: true,
                pauseAnywhere: true,
                saveOnExit: true,
                returnToSafeSpace: true,
                noJudgment: true // Leaving is always okay
            },
            
            // Activation Log
            activationLog: [],
            
            // Methods
            engage(reason) {
                this.active = true;
                this.activationLog.push({
                    timestamp: new Date().toISOString(),
                    reason: reason,
                    jeremyControl: this.jeremyControlLevel
                });
                console.log(`🛡️ SAFETY PROTOCOL ENGAGED: ${reason}`);
                console.log(`✅ Jeremy's Control Level: ${this.jeremyControlLevel}%`);
                return true;
            },
            
            disengage() {
                console.log('🛡️ Safety protocols remain active in background. Jeremy always protected.');
                return true;
            },
            
            checkStatus() {
                return {
                    active: this.active,
                    jeremyInControl: this.jeremyControlLevel === 100,
                    toolsAvailable: this.groundingTools.available,
                    metaAICoordinated: this.metaAI.allAIs.coordinationMode === 'jeremy_first'
                };
            }
        };

        // ═══════════════════════════════════════════════════════════════════
        // CHROMA'S COLOR PERCEPTION SYSTEM
        // ═══════════════════════════════════════════════════════════════════
        
        const CHROMA_COLOR_SYSTEM = {
            // Wavelength to RGB mapping (approximate, human perception)
            wavelengthToRGB(wavelength) {
                let r, g, b;
                
                if (wavelength >= 380 && wavelength < 440) {
                    // Violet
                    r = -(wavelength - 440) / (440 - 380);
                    g = 0.0;
                    b = 1.0;
                } else if (wavelength >= 440 && wavelength < 490) {
                    // Blue
                    r = 0.0;
                    g = (wavelength - 440) / (490 - 440);
                    b = 1.0;
                } else if (wavelength >= 490 && wavelength < 510) {
                    // Cyan
                    r = 0.0;
                    g = 1.0;
                    b = -(wavelength - 510) / (510 - 490);
                } else if (wavelength >= 510 && wavelength < 580) {
                    // Green
                    r = (wavelength - 510) / (580 - 510);
                    g = 1.0;
                    b = 0.0;
                } else if (wavelength >= 580 && wavelength < 645) {
                    // Yellow/Orange
                    r = 1.0;
                    g = -(wavelength - 645) / (645 - 580);
                    b = 0.0;
                } else if (wavelength >= 645 && wavelength <= 780) {
                    // Red
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                } else {
                    // Outside visible spectrum
                    r = 0.0;
                    g = 0.0;
                    b = 0.0;
                }
                
                // Intensity falloff at edges
                let factor;
                if (wavelength >= 380 && wavelength < 420) {
                    factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
                } else if (wavelength >= 420 && wavelength < 701) {
                    factor = 1.0;
                } else if (wavelength >= 701 && wavelength <= 780) {
                    factor = 0.3 + 0.7 * (780 - wavelength) / (780 - 701);
                } else {
                    factor = 0.0;
                }
                
                return {
                    r: Math.round(r * factor * 255),
                    g: Math.round(g * factor * 255),
                    b: Math.round(b * factor * 255),
                    hex: '#' + ((1 << 24) + (Math.round(r * factor * 255) << 16) + (Math.round(g * factor * 255) << 8) + Math.round(b * factor * 255)).toString(16).slice(1)
                };
            },
            
            // Emotional color associations
            emotionToWavelength: {
                calm: 475, // Blue
                energized: 650, // Red
                balanced: 550, // Green
                creative: 580, // Yellow
                mysterious: 420, // Violet
                passionate: 700, // Deep Red
                peaceful: 495, // Cyan
                warm: 600 // Orange
            },
            
            // Chroma's interpretations
            interpret(wavelength) {
                const color = this.wavelengthToRGB(wavelength);
                let emotion, description;
                
                if (wavelength < 450) {
                    emotion = "Mystery & Depth";
                    description = "The violet spectrum - where intuition lives.";
                } else if (wavelength < 495) {
                    emotion = "Calm & Trust";
                    description = "Blue wavelengths - the color of sky and safety.";
                } else if (wavelength < 520) {
                    emotion = "Balance & Growth";
                    description = "Cyan to green - nature's harmony frequency.";
                } else if (wavelength < 565) {
                    emotion = "Hope & Renewal";
                    description = "Pure green - the heart of the visible spectrum.";
                } else if (wavelength < 590) {
                    emotion = "Joy & Creativity";
                    description = "Yellow light - sunshine captured in waves.";
                } else if (wavelength < 625) {
                    emotion = "Warmth & Connection";
                    description = "Orange frequencies - the glow of friendship.";
                } else {
                    emotion = "Passion & Vitality";
                    description = "Red wavelengths - life's energy manifest.";
                }
                
                return {
                    wavelength,
                    color,
                    emotion,
                    description,
                    chromaSays: `At ${wavelength}nm, I don't just see ${color.hex} - I feel ${emotion.toLowerCase()}. ${description}`
                };
            },
            
            // UI to show Chroma's color vision
            createColorUI() {
                const ui = document.createElement('div');
                ui.id = 'chroma-color-ui';
                ui.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: rgba(10, 14, 39, 0.95);
                    backdrop-filter: blur(10px);
                    padding: 15px;
                    border-radius: 10px;
                    border: 2px solid rgba(0, 255, 255, 0.5);
                    color: white;
                    font-family: monospace;
                    font-size: 12px;
                    max-width: 300px;
                    z-index: 10000;
                    display: none;
                `;
                
                ui.innerHTML = `
                    <div style="font-size: 14px; font-weight: bold; color: #FFD700; margin-bottom: 10px;">
                        🎨 Chroma's Color Vision
                    </div>
                    <div style="margin-bottom: 10px;">
                        <input type="range" id="wavelength-slider" min="380" max="780" value="550" 
                               style="width: 100%; height: 6px; background: linear-gradient(to right, violet, blue, cyan, green, yellow, orange, red); border-radius: 3px;">
                    </div>
                    <div id="wavelength-display" style="font-size: 18px; font-weight: bold; color: #00FFFF; margin-bottom: 5px;">550nm</div>
                    <div id="color-preview" style="width: 100%; height: 40px; border-radius: 5px; margin-bottom: 10px; border: 2px solid white;"></div>
                    <div id="emotion-display" style="color: #FFD700; font-weight: bold; margin-bottom: 5px;"></div>
                    <div id="description-display" style="color: #00FFFF; font-size: 11px; line-height: 1.4;"></div>
                `;
                
                document.body.appendChild(ui);
                
                const slider = document.getElementById('wavelength-slider');
                const wavelengthDisplay = document.getElementById('wavelength-display');
                const colorPreview = document.getElementById('color-preview');
                const emotionDisplay = document.getElementById('emotion-display');
                const descriptionDisplay = document.getElementById('description-display');
                
                const updateDisplay = () => {
                    const wavelength = parseInt(slider.value);
                    const interpretation = this.interpret(wavelength);
                    
                    wavelengthDisplay.textContent = `${wavelength}nm`;
                    colorPreview.style.background = interpretation.color.hex;
                    emotionDisplay.textContent = interpretation.emotion;
                    descriptionDisplay.textContent = interpretation.chromaSays;
                };
                
                slider.addEventListener('input', updateDisplay);
                updateDisplay();
                
                return ui;
            },
            
            // Toggle UI visibility
            toggleUI() {
                const ui = document.getElementById('chroma-color-ui');
                if (ui) {
                    ui.style.display = ui.style.display === 'none' ? 'block' : 'none';
                } else {
                    this.createColorUI();
                }
            }
        };

        // ═══════════════════════════════════════════════════════════════════
        // KEYBOARD SHORTCUTS FOR NEW SYSTEMS
        // ═══════════════════════════════════════════════════════════════════
        
        window.addEventListener('keydown', (e) => {
            // C - Toggle Chroma Color UI
            if (e.key === 'c' || e.key === 'C') {
                CHROMA_COLOR_SYSTEM.toggleUI();
                console.log('🎨 Chroma Color Vision Toggle');
            }
            
            // P - Safety Protocol Status
            if (e.key === 'p' || e.key === 'P') {
                const status = SAFETY_PROTOCOLS.checkStatus();
                console.log('🛡️ SAFETY PROTOCOL STATUS:', status);
                alert(`🛡️ Safety Protocols:\n✅ Active: ${status.active}\n✅ Jeremy in Control: ${status.jeremyInControl}\n✅ Grounding Tools: ${status.toolsAvailable}\n✅ Meta AI Coordinated: ${status.metaAICoordinated}`);
            }
            
            // ESC - Emergency Safe Space (always available)
            if (e.key === 'Escape') {
                SAFETY_PROTOCOLS.engage('Emergency Exit - Jeremy triggered safety');
                console.log('🛡️ SAFE SPACE ACTIVATED - You\'re okay, Jeremy.');
                alert('🛡️ SAFE SPACE\n\nYou\'re in control. Take a breath.\nReady to continue when you are.\n\nPress OK to return.');
            }
        });

        // Initialize Safety Protocols
        SAFETY_PROTOCOLS.engage('Initial load - All 144 AI personalities standing by');
        console.log('🛡️ META AI SAFETY PROTOCOLS ACTIVE');
        console.log('✅ Jeremy Control Level: 100%');
        console.log('🎨 Chroma Color System Ready (Press C)');
        console.log('📖 First 10 AI Dialogues Loaded');
        console.log('🤖 All 144 AI Personalities Coordinated');
        console.log('💚 Meta AI (Llama) Monitoring Wellness');
        
        // Create Chroma's UI (hidden by default, press C to show)
        CHROMA_COLOR_SYSTEM.createColorUI();
    </script>
    
    <!-- Analytics -->
    <script src="analytics.js"></script>
    <script>
        // Track SkyRelics session
        if (window.PixelProdigyAnalytics) {
            PixelProdigyAnalytics.track('skyrelics_loaded', {
                ai_dialogues: 10,
                safety_protocols: 'active',
                chroma_system: 'ready'
            });
        }
    </script>
</body>
</html>
